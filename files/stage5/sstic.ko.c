/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall sstic_vm_split(vm_area_struct *a1, __int64 addr); // idb
void sstic_pci_remove();
__int64 __fastcall sstic_vm_fault(vm_fault *a1); // idb
int __fastcall sstic_open(__int64 a1, file *a2);
sstic_phy_region *__fastcall alloc_phy_region(unsigned int a1);
__int64 __fastcall sstic_vm_open(vm_area_struct *newvm); // idb
int __fastcall sstic_mmap(file *a1, vm_area_struct *vm);
__int64 __fastcall free_phy_region(int *__shifted(sstic_phy_region,0x14) a1);
__int64 __fastcall sstic_vm_close(vm_area_struct *a1); // idb
sstic_region *__fastcall alloc_sstic_region(int a1, int a2, sstic_session *a3, sstic_phy_region *a4); // idb
__int64 __fastcall free_sstic_region(sstic_region *a1); // idb
sstic_session *alloc_sstic_session();
__int64 __fastcall free_sstic_session(sstic_session *a1); // idb
__int64 __fastcall sstic_release(__int64 a1, file *a2); // idb
sstic_region *__fastcall find_region(sstic_session *a1, int a2);
int __fastcall ioctl_alloc_region(sstic_session *a1, ioctl_alloc_req *arg);
int __fastcall get_debug_state();
int __fastcall ioctl_del_region(sstic_session *a1, _DWORD *a2);
int __fastcall ioctl_assoc_region(sstic_session *a1, _DWORD *a2);
int __fastcall ioctl_submit_command(sstic_session *a1, unsigned int *cmd);
int __fastcall ioctl_get_key(__int64 *a1);
int __fastcall sstic_ioctl(file *a1, unsigned int cmd, __int64 a3);
int __fastcall ioctl_get_debug_state(_DWORD *a1);
int __fastcall sstic_pci_probe(__int64 a1);
__int64 __fastcall init_module(); // weak
__int64 __fastcall cleanup_module(); // weak
// __int64 __fastcall ioread32(_DWORD *);
// __int64 __fastcall _put_page(void *);
// __int64 __fastcall alloc_chrdev_region(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall _class_create(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall copy_from_user(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall iowrite32(_DWORD, _DWORD *);
// __int64 __fastcall pci_iomap(_QWORD, _QWORD, _QWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// __int64 __fastcall class_destroy(_QWORD); weak
// __int64 __fastcall _pci_register_driver(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall kfree(_QWORD); weak
// __int64 __fastcall kmem_cache_create(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall raw_spin_lock(_QWORD); weak
// __int64 __fastcall refcount_warn_saturate(_QWORD, _QWORD); weak
// __int64 __fastcall kmem_cache_alloc(_QWORD, _QWORD); weak
// __int64 __fastcall split_page(_QWORD, _QWORD); weak
// __int64 __fastcall cdev_add(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall vm_insert_page(_QWORD, _QWORD, void *);
// __int64 __fastcall device_create(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall kmem_cache_free(_QWORD, _QWORD); weak
// __int64 printk(const char *, ...); weak
// __int64 __fastcall copy_to_user(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall unregister_chrdev_region(_QWORD, _QWORD); weak
// __int64 __fastcall device_destroy(_QWORD, _QWORD); weak
// __int64 __fastcall cdev_init(_QWORD, _QWORD); weak
// __int64 __fastcall _kmalloc(_QWORD, _QWORD); weak
// __int64 __fastcall kmem_cache_destroy(_QWORD); weak
// __int64 __fastcall alloc_pages_current(_QWORD, _QWORD); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN sstic_pci_driver; // weak
void *sstic_fops = &_this_module; // weak
__int64 (__fastcall *sstic_vm_ops[15])() =
{
  &sstic_vm_open,
  &sstic_vm_close,
  &sstic_vm_split,
  &sstic_vm_split,
  &sstic_vm_fault,
  &sstic_vm_split,
  &sstic_vm_split,
  &sstic_vm_split,
  &sstic_vm_split,
  &sstic_vm_split,
  &sstic_vm_split,
  &sstic_vm_split,
  &sstic_vm_split,
  &sstic_vm_split,
  &sstic_vm_split
}; // weak
int next_id = 1; // weak
__int64 sstic_session_cache_sz48; // weak
__int64 sstic_region_cache_sz32; // weak
char ssticlock; // weak
_UNKNOWN _sstic_key; // weak
_UNKNOWN sstic_cdev; // weak
__int64 sstic_class; // weak
unsigned int sstic_dev;
sstic_iomem *g_sstic_pci_iomem;


//----- (0000000000000000) ----------------------------------------------------
__int64 __fastcall sstic_vm_split(vm_area_struct *a1, __int64 addr)
{
  sstic_phy_region *v2; // rax

  v2 = a1->private_data;
  v2->splitend = (void *)addr;
  v2->splitstart = (void *)a1->vm_start;
  return 0LL;
}

//----- (0000000000000030) ----------------------------------------------------
__int64 __fastcall sstic_vm_fault(vm_fault *a1)
{
  __int64 v1; // rcx
  sstic_phy_region *v2; // rax
  unsigned __int64 v3; // rsi
  page *v4; // rdx
  int v5; // eax
  unsigned int v6; // er8

  v1 = a1->vma->vm_start;
  v2 = a1->vma->private_data;
  v3 = a1->address - v1;
  if ( (unsigned int)v2->npages <= v3 >> 12 )
    return 2;
  v4 = v2->pages[v3 >> 12];
  if ( !v4 )
    return 2;
  v5 = vm_insert_page(a1->vma, v1 + (v3 & 0xFFFFFFFFFFFFF000LL), v4);
  v6 = 1;
  if ( v5 == -12 )
    return v6;
  if ( v5 < 0 && v5 != -16 )
    return 2;
  return 256LL;
}

//----- (00000000000000A0) ----------------------------------------------------
int __fastcall sstic_open(__int64 a1, file *a2)
{
  sstic_session *v2; // rax

  v2 = (sstic_session *)kmem_cache_alloc(sstic_session_cache_sz48, 0xDC0LL);// GFP_KERNEL | GFP_ZERO
  if ( !v2 )
    return -12;
  a2->private_data = v2;
  v2->regions.next = &v2->regions;
  v2->regions.prev = &v2->regions;
  return 0;
}
// 1D80: using guessed type __int64 sstic_session_cache_sz48;
// 1E98: using guessed type __int64 __fastcall kmem_cache_alloc(_QWORD, _QWORD);

//----- (00000000000000E0) ----------------------------------------------------
sstic_phy_region *__fastcall alloc_phy_region(unsigned int a1)
{
  sstic_phy_region *result; // rax

  result = 0LL;
  if ( a1 <= 0x20 )
  {
    result = (sstic_phy_region *)_kmalloc(8LL * (a1 + 3), 3520LL);
    if ( result )
    {
      result->refcount = 1;
      result->npages = a1;
    }
  }
  return result;
}
// 1EF8: using guessed type __int64 __fastcall _kmalloc(_QWORD, _QWORD);

//----- (0000000000000110) ----------------------------------------------------
__int64 __fastcall sstic_vm_open(vm_area_struct *newvm)
{
  sstic_phy_region *phy; // rbx
  int v2; // eax
  __int64 v3; // rsi
  __int64 result; // rax
  unsigned __int64 newnpages; // r13
  sstic_phy_region *newphy; // rax MAPDST
  void *splitend; // rsi
  int v9; // esi
  int j; // edx
  __int64 v11; // rax
  unsigned int v12; // eax
  int i; // edx
  __int64 v14; // rcx
  unsigned __int64 oldsz; // rsi

  phy = newvm->private_data;
  if ( !phy->splitend )
  {
    v2 = _InterlockedExchangeAdd(&phy->refcount, 1u);
    v3 = 2LL;
    if ( v2 )
    {
      if ( v2 >= 0 )
      {
        result = (unsigned int)(v2 + 1);
        if ( (int)result >= 0 )
          return result;
      }
      v3 = 1LL;
    }
    return refcount_warn_saturate(&phy->refcount, v3);
  }
  newnpages = (newvm->vm_end - newvm->vm_start) >> 12;
  newphy = alloc_phy_region(newnpages);
  if ( !newphy )
    BUG();
  splitend = phy->splitend;
  if ( (unsigned __int64)splitend <= newvm->vm_start )// case: new vm is the second half of the split
  {
    i = 0;
    v14 = 0LL;
    result = 0LL;
    for ( oldsz = ((unsigned __int64)splitend - (unsigned __int64)phy->splitstart) >> 12; i < newnpages; v14 = i )
    {
      ++i;
      newphy->pages[result] = (page *)*((_QWORD *)&phy->pages[v14] + oldsz);
      result = i;
    }
    phy->npages = oldsz;
  }
  else                                          // case: new vm is the first half of the split
  {
    v9 = newphy->npages;
    if ( v9 )
    {
      for ( j = 0; j != v9; ++j )
      {
        v11 = j;
        newphy->pages[v11] = phy->pages[v11];
      }
    }
    v12 = phy->npages - v9;
    phy->npages = v12;
    result = (__int64)memmove(phy->pages, &phy->pages[newnpages], 8LL * v12);// BUG: Observed to copy -1 pages in one run
  }
  newvm->private_data = newphy;
  return result;
}
// 1E90: using guessed type __int64 __fastcall refcount_warn_saturate(_QWORD, _QWORD);

//----- (0000000000000220) ----------------------------------------------------
int __fastcall sstic_mmap(file *a1, vm_area_struct *vm)
{
  sstic_session *v3; // rbx
  sstic_region_list_node *__shifted(struct sstic_region,0x10) v4; // rax
  sstic_phy_region *v5; // rbx
  __int64 v6; // rcx
  unsigned __int64 vma_len; // rdx
  __int64 prot; // rcx
  sstic_phy_region *v9; // rax
  unsigned int v10; // ecx
  sstic_phy_region *i; // r8
  __int64 v12; // rax
  page *v13; // rdx
  __int64 v14; // rsi
  int result; // eax

  v3 = a1->private_data;
  raw_spin_lock(&ssticlock);
  v4 = &ADJ(v3->regions.next)->list;
  if ( v4 == &v3->regions )
    goto LABEL_23;
  while ( vm->vm_pgoff != ADJ(v4)->id )
  {
    v4 = &ADJ(ADJ(v4)->list.next)->list;
    if ( v4 == &v3->regions )
      goto LABEL_23;
  }
  if ( v4 == (sstic_region_list_node *__shifted(struct sstic_region,0x10))((char *)&loc_E + 2) )
    goto LABEL_23;
  v5 = ADJ(v4)->phy_region;
  if ( !v5 )
    goto LABEL_23;
  v6 = vm->vm_page_prot;
  vma_len = vm->vm_end - vm->vm_start;
  if ( (v6 & 1) == 0 )
  {
    v6 &= 0xFFFFFFFFFFFFFFEFLL;
    vm->vm_page_prot = v6;
  }
  if ( (v6 & 2) == 0 )
    vm->vm_page_prot = v6 & 0xFFFFFFFFFFFFFFDFLL;
  if ( vma_len
    && (prot = vm->vm_page_prot, (prot & 8) != 0)
    && vma_len >> 12 == v5->npages
    && ((prot & 1) == 0 || (ADJ(v4)->prot & 1) != 0)
    && ((prot & 2) == 0 || (ADJ(v4)->prot & 2) != 0) )
  {
    vm->vm_ops = sstic_vm_ops;
    vm->vm_page_prot = prot | 0x14044000;
    v9 = alloc_phy_region(v5->npages);
    v10 = 0;
    for ( i = v9; v5->npages > v10; *((_QWORD *)&i->splitend + v12) = *((_QWORD *)&v5->splitend + v12) )
    {
      v12 = (int)v10 + 2LL;
      v13 = (page *)*((_QWORD *)&v5->splitend + v12);
      v14 = v13->compound_head;
      if ( (v14 & 1) != 0 )
        v13 = (page *)(v14 - 1);
      _InterlockedIncrement(&v13->refcount);
      ++v10;
    }
    vm->private_data = i;
    result = 0;
    ssticlock = 0;
  }
  else
  {
LABEL_23:
    result = -EINVAL;
    ssticlock = 0;
  }
  return result;
}
// 1960: using guessed type __int64 (__fastcall *sstic_vm_ops[15])();
// 1D90: using guessed type char ssticlock;
// 1E80: using guessed type __int64 __fastcall raw_spin_lock(_QWORD);

//----- (0000000000000360) ----------------------------------------------------
__int64 __fastcall free_phy_region(int *__shifted(sstic_phy_region,0x14) a1)
{
  sstic_phy_region *v1; // r12
  unsigned int v3; // ebx
  page *page; // rdi
  __int64 v5; // rax

  v1 = ADJ(a1);
  if ( ADJ(a1)->npages )
  {
    v3 = 0;
    do
    {
      while ( 1 )
      {
        page = ADJ(a1)->pages[v3];
        if ( page )
        {
          v5 = page->compound_head;
          if ( (v5 & 1) != 0 )
            page = (page *)(v5 - 1);
          if ( !_InterlockedDecrement(&page->refcount) )
            break;
        }
        if ( ADJ(a1)->npages <= ++v3 )
          return kfree(v1);
      }
      _put_page(page);
      ++v3;
    }
    while ( ADJ(a1)->npages > v3 );
  }
  return kfree(v1);
}
// 1E70: using guessed type __int64 __fastcall kfree(_QWORD);

//----- (00000000000003C0) ----------------------------------------------------
__int64 __fastcall sstic_vm_close(vm_area_struct *a1)
{
  volatile signed __int32 *v1; // rdi
  __int64 result; // rax

  v1 = &a1->private_data->refcount;
  result = (unsigned int)_InterlockedExchangeAdd(v1, 0xFFFFFFFF);
  if ( (_DWORD)result == 1 )
    return free_phy_region((int *__shifted(sstic_phy_region,0x14))v1);
  if ( (int)result <= 0 )
    result = refcount_warn_saturate(v1, 3LL);
  return result;
}
// 1E90: using guessed type __int64 __fastcall refcount_warn_saturate(_QWORD, _QWORD);

//----- (00000000000003F0) ----------------------------------------------------
sstic_region *__fastcall alloc_sstic_region(int a1, int a2, sstic_session *a3, sstic_phy_region *a4)
{
  sstic_region *result; // rax
  sstic_region_list_node *v7; // rcx

  result = (sstic_region *)kmem_cache_alloc(sstic_region_cache_sz32, 3264LL);
  if ( result )
  {
    v7 = &ADJ(a3->regions.next)->list;
    result->prot = a2;
    result->id = a1;
    result->phy_region = a4;
    v7->prev = &result->list;
    result->list.next = v7;
    result->list.prev = &a3->regions;
    a3->regions.next = &result->list;
  }
  return result;
}
// 1D88: using guessed type __int64 sstic_region_cache_sz32;
// 1E98: using guessed type __int64 __fastcall kmem_cache_alloc(_QWORD, _QWORD);

//----- (0000000000000450) ----------------------------------------------------
__int64 __fastcall free_sstic_region(sstic_region *a1)
{
  sstic_phy_region *v1; // rax
  int *v3; // rdi
  int v4; // edx

  v1 = a1->phy_region;
  if ( !a1->phy_region )
    return kmem_cache_free(sstic_region_cache_sz32, a1);
  v3 = &v1->refcount;
  v4 = _InterlockedExchangeAdd(&v1->refcount, 0xFFFFFFFF);
  if ( v4 != 1 )
  {
    if ( v4 <= 0 )
      refcount_warn_saturate(v3, 3LL);
    return kmem_cache_free(sstic_region_cache_sz32, a1);
  }
  free_phy_region(v3);
  return kmem_cache_free(sstic_region_cache_sz32, a1);
}
// 1D88: using guessed type __int64 sstic_region_cache_sz32;
// 1E90: using guessed type __int64 __fastcall refcount_warn_saturate(_QWORD, _QWORD);
// 1EC0: using guessed type __int64 __fastcall kmem_cache_free(_QWORD, _QWORD);

//----- (00000000000004B0) ----------------------------------------------------
sstic_session *alloc_sstic_session()
{
  sstic_session *result; // rax

  result = (sstic_session *)kmem_cache_alloc(sstic_session_cache_sz48, 3520LL);
  if ( result )
  {
    result->regions.next = &result->regions;
    result->regions.prev = &result->regions;
  }
  return result;
}
// 1D80: using guessed type __int64 sstic_session_cache_sz48;
// 1E98: using guessed type __int64 __fastcall kmem_cache_alloc(_QWORD, _QWORD);

//----- (00000000000004E0) ----------------------------------------------------
__int64 __fastcall free_sstic_session(sstic_session *a1)
{
  sstic_region_list_node *__shifted(struct sstic_region,0x10) v2; // rdi
  sstic_region_list_node *v3; // rbx
  sstic_region_list_node *__shifted(struct sstic_region,0x10) i; // r14
  sstic_region_list_node *__shifted(struct sstic_region,0x10) v5; // rax
  struct sstic_region *v6; // rdi
  sstic_phy_region **v7; // rbp
  sstic_phy_region *v8; // rax
  int *v9; // rdi
  int v10; // edx

  v2 = &ADJ(a1->regions.next)->list;
  v3 = &a1->regions;
  for ( i = &ADJ(ADJ(v2)->list.next)->list; v3 != v2; i = &ADJ(ADJ(i)->list.next)->list )
  {
    v5 = &ADJ(ADJ(v2)->list.prev)->list;
    v6 = ADJ(v2);
    ADJ(i)->list.prev = v5;
    ADJ(v5)->list.next = i;
    v6->list.next = (sstic_region_list_node *__shifted(struct sstic_region,0x10))0xDEAD000000000100LL;
    v6->list.prev = (sstic_region_list_node *__shifted(struct sstic_region,0x10))0xDEAD000000000122LL;
    free_sstic_region(v6);
    v2 = i;
  }
  v7 = (sstic_phy_region **)a1;
  do
  {
    v8 = *v7;
    if ( *v7 )
    {
      v9 = &v8->refcount;
      v10 = _InterlockedExchangeAdd(&v8->refcount, 0xFFFFFFFF);
      if ( v10 == 1 )
      {
        free_phy_region(v9);
      }
      else if ( v10 <= 0 )
      {
        refcount_warn_saturate(v9, 3LL);
      }
      *v7 = 0LL;
    }
    ++v7;
  }
  while ( v3 != (sstic_region_list_node *)v7 );
  return kmem_cache_free(sstic_session_cache_sz48, a1);
}
// 1D80: using guessed type __int64 sstic_session_cache_sz48;
// 1E90: using guessed type __int64 __fastcall refcount_warn_saturate(_QWORD, _QWORD);
// 1EC0: using guessed type __int64 __fastcall kmem_cache_free(_QWORD, _QWORD);

//----- (00000000000005A0) ----------------------------------------------------
__int64 __fastcall sstic_release(__int64 a1, file *a2)
{
  free_sstic_session(a2->private_data);
  return 0LL;
}

//----- (00000000000005B0) ----------------------------------------------------
sstic_region *__fastcall find_region(sstic_session *a1, int a2)
{
  sstic_region_list_node *__shifted(struct sstic_region,0x10) v2; // rax
  sstic_region_list_node *__shifted(struct sstic_region,0x10) v3; // rdi

  v2 = &ADJ(a1->regions.next)->list;
  v3 = &a1->regions;
  if ( v2 == v3 )
    return 0LL;
  while ( ADJ(v2)->id != a2 )
  {
    v2 = &ADJ(ADJ(v2)->list.next)->list;
    if ( v2 == v3 )
      return 0LL;
  }
  return ADJ(v2);
}

//----- (00000000000005E0) ----------------------------------------------------
int __fastcall ioctl_alloc_region(sstic_session *a1, ioctl_alloc_req *arg)
{
  int v2; // ebp
  int v4; // edi
  sstic_phy_region *phy; // r13
  unsigned int v6; // er15
  __int64 pages; // rax
  __int64 v8; // r14
  int i; // eax
  __int64 v10; // rcx
  int prot; // er14
  sstic_region *region; // rax
  sstic_region_list_node *v13; // rcx

  v2 = next_id++;
  v4 = arg->npages;
  if ( !arg->npages || (v4 & (v4 - 1)) != 0 )
    return -22;
  phy = alloc_phy_region(v4);
  if ( !phy )
    return -12;
  _BitScanReverse(&v6, arg->npages);
  pages = alloc_pages_current(0xDC0LL, v6);
  v8 = pages;
  if ( !pages )
    return -12;
  split_page(pages, v6);
  if ( arg->npages )
  {
    i = 0;
    do
    {
      v10 = i++;
      phy->pages[v10] = (page *)(v8 + (v10 << 6));
    }
    while ( arg->npages > (unsigned int)i );
  }
  prot = arg->prot;
  region = (sstic_region *)kmem_cache_alloc(sstic_region_cache_sz32, 3264LL);
  if ( !region )
    return -12;
  v13 = &ADJ(a1->regions.next)->list;
  region->id = v2;
  region->prot = prot;
  region->phy_region = phy;
  v13->prev = &region->list;
  a1->regions.next = &region->list;
  arg->resp = v2 << 12;
  region->list.next = v13;
  region->list.prev = &a1->regions;
  return 0;
}
// 19D8: using guessed type int next_id;
// 1D88: using guessed type __int64 sstic_region_cache_sz32;
// 1E98: using guessed type __int64 __fastcall kmem_cache_alloc(_QWORD, _QWORD);
// 1EA0: using guessed type __int64 __fastcall split_page(_QWORD, _QWORD);
// 1F08: using guessed type __int64 __fastcall alloc_pages_current(_QWORD, _QWORD);

//----- (00000000000006F0) ----------------------------------------------------
int __fastcall get_debug_state()
{
  int result; // eax

  if ( g_sstic_pci_iomem )
    result = ioread32(&g_sstic_pci_iomem->debug_state);
  else
    result = -ENODEV;
  return result;
}

//----- (0000000000000710) ----------------------------------------------------
int __fastcall ioctl_del_region(sstic_session *a1, _DWORD *a2)
{
  sstic_region_list_node *__shifted(struct sstic_region,0x10) v2; // rax
  sstic_region_list_node *v3; // rdi
  sstic_region_list_node *v4; // rcx
  sstic_region_list_node *v5; // rdx

  v2 = &ADJ(a1->regions.next)->list;
  v3 = &a1->regions;
  if ( v2 == v3 )
    return -22;
  while ( *a2 >> 12 != ADJ(v2)->id )
  {
    v2 = &ADJ(ADJ(v2)->list.next)->list;
    if ( v2 == v3 )
      return -22;
  }
  if ( v2 == (sstic_region_list_node *__shifted(struct sstic_region,0x10))((char *)&loc_E + 2) )
    return -22;
  v4 = &ADJ(ADJ(v2)->list.next)->list;
  v5 = &ADJ(ADJ(v2)->list.prev)->list;
  v4->prev = v5;
  v5->next = v4;
  ADJ(v2)->list.next = (sstic_region_list_node *__shifted(struct sstic_region,0x10))0xDEAD000000000100LL;
  ADJ(v2)->list.prev = (sstic_region_list_node *__shifted(struct sstic_region,0x10))0xDEAD000000000122LL;
  free_sstic_region(ADJ(v2));
  return 0;
}

//----- (0000000000000780) ----------------------------------------------------
int __fastcall ioctl_assoc_region(sstic_session *a1, _DWORD *a2)
{
  sstic_region_list_node *__shifted(struct sstic_region,0x10) region; // rax
  sstic_phy_region *v4; // rbp
  unsigned int channel; // edx
  _DWORD *v6; // rdi
  int v7; // eax

  region = &ADJ(a1->regions.next)->list;
  if ( region == &a1->regions )
    return -22;
  while ( *a2 >> 12 != ADJ(region)->id )
  {
    region = &ADJ(ADJ(region)->list.next)->list;
    if ( region == &a1->regions )
      return -22;
  }
  if ( region == (sstic_region_list_node *__shifted(struct sstic_region,0x10))((char *)&loc_E + 2) )
    return -22;
  v4 = ADJ(region)->phy_region;
  if ( !v4 )
    return -22;
  channel = a2[1];
  if ( channel > 3 || a1->channels[channel] )
    return -22;
  if ( !channel || channel == 3 )
  {
    if ( (ADJ(region)->prot & 2) != 0 )
      goto LABEL_12;
    return -22;
  }
  if ( (ADJ(region)->prot & 2) != 0 )
    return -22;
LABEL_12:
  v6 = &v4->refcount;
  v7 = _InterlockedExchangeAdd(&v4->refcount, 1u);
  if ( v7 )
  {
    if ( v7 < 0 || v7 + 1 < 0 )
      refcount_warn_saturate(v6, 1LL);
  }
  else
  {
    refcount_warn_saturate(v6, 2LL);
  }
  a1->channels[a2[1]] = v4;
  return 0;
}
// 1E90: using guessed type __int64 __fastcall refcount_warn_saturate(_QWORD, _QWORD);

//----- (0000000000000840) ----------------------------------------------------
int __fastcall ioctl_submit_command(sstic_session *a1, unsigned int *cmd)
{
  unsigned int v3; // edi
  sstic_phy_region *v4; // rax

  if ( !g_sstic_pci_iomem )
    return -ENODEV;
  if ( *cmd - 1 <= 2 && a1->channels[0] && a1->channels[1] )
  {
    iowrite32((unsigned int)(((__int64)a1->channels[0]->pages[0] - vmemmap_base) >> 6) << 12, g_sstic_pci_iomem);
    iowrite32(
      (unsigned int)(((__int64)a1->channels[1]->pages[0] - vmemmap_base) >> 6) << 12,
      &g_sstic_pci_iomem->chanaddr[1]);
    iowrite32(a1->channels[0]->npages << 12, g_sstic_pci_iomem->chansize);
    iowrite32(a1->channels[1]->npages << 12, &g_sstic_pci_iomem->chansize[1]);
    v3 = *cmd;
    if ( *cmd != 2 )
    {
LABEL_9:
      iowrite32(v3, &g_sstic_pci_iomem->command_cmd);
      iowrite32(1, &g_sstic_pci_iomem->command_go);
      return ioread32(&g_sstic_pci_iomem->command_result);
    }
    if ( a1->channels[2] )
    {
      v4 = a1->channels[3];
      if ( v4 )
      {
        iowrite32((unsigned int)(((__int64)v4->pages[0] - vmemmap_base) >> 6) << 12, &g_sstic_pci_iomem->chanaddr[3]);
        iowrite32(
          (unsigned int)(((__int64)a1->channels[2]->pages[0] - vmemmap_base) >> 6) << 12,
          &g_sstic_pci_iomem->chanaddr[2]);
        iowrite32(a1->channels[3]->npages << 12, &g_sstic_pci_iomem->chansize[3]);
        iowrite32(a1->channels[2]->npages << 12, &g_sstic_pci_iomem->chansize[2]);
        v3 = *cmd;
        goto LABEL_9;
      }
    }
  }
  return -EINVAL;
}

//----- (00000000000009E0) ----------------------------------------------------
int __fastcall ioctl_get_key(__int64 *a1)
{
  int v2; // eax
  __int64 v3; // rdi

  if ( !g_sstic_pci_iomem )
    return -ENODEV;
  v2 = ioread32(&g_sstic_pci_iomem->debug_state);
  if ( v2 < 0 )
    return -EINVAL;
  v3 = *a1;
  if ( *a1 < 0 )
  {
    if ( v2 )
      return -EINVAL;
  }
  iowrite32(HIDWORD(v3), (_DWORD *)&g_sstic_pci_iomem->getkey_ident + 1);
  iowrite32(*(_DWORD *)a1, &g_sstic_pci_iomem->getkey_ident);
  *((_DWORD *)a1 + 2) = ioread32(g_sstic_pci_iomem->getkey_resp);
  *((_DWORD *)a1 + 3) = ioread32(&g_sstic_pci_iomem->getkey_resp[4]);
  *((_DWORD *)a1 + 4) = ioread32(&g_sstic_pci_iomem->getkey_resp[8]);
  *((_DWORD *)a1 + 5) = ioread32(&g_sstic_pci_iomem->getkey_resp[12]);
  return 0;
}

//----- (0000000000000AA0) ----------------------------------------------------
int __fastcall sstic_ioctl(file *a1, unsigned int cmd, __int64 a3)
{
  sstic_session *v4; // r12
  int v5; // eax
  __int64 v7[3]; // [rsp+0h] [rbp-38h] BYREF
  unsigned __int64 v8; // [rsp+18h] [rbp-20h]

  v4 = a1->private_data;
  v8 = __readgsqword(0x28u);
  raw_spin_lock(&ssticlock);
  printk("sstic ioctl cmd : %x", cmd);
  if ( copy_from_user(v7, a3, 24LL) )
    goto LABEL_13;
  if ( cmd == 0xC0185303 )
  {
    v5 = ioctl_submit_command(v4, (unsigned int *)v7);
LABEL_17:
    if ( v5 )
      goto LABEL_14;
    goto LABEL_12;
  }
  if ( cmd <= 0xC0185303 )
  {
    switch ( cmd )
    {
      case 0xC0185301:
        v5 = ioctl_del_region(v4, v7);
        break;
      case 0xC0185302:
        v5 = ioctl_assoc_region(v4, v7);
        break;
      case 0xC0185300:
        v5 = ioctl_alloc_region(v4, (ioctl_alloc_req *)v7);
        break;
      default:
        goto LABEL_12;
    }
    goto LABEL_17;
  }
  if ( cmd == 0xC0185304 )
  {
    v5 = ioctl_get_key(v7);
    goto LABEL_17;
  }
  if ( cmd == 0xC0185305 )
  {
    if ( !g_sstic_pci_iomem )
    {
      v5 = -ENODEV;
      goto LABEL_14;
    }
    v5 = ioread32(&g_sstic_pci_iomem->debug_state);
    if ( v5 < 0 )
      goto LABEL_14;
    LODWORD(v7[0]) = v5;
  }
LABEL_12:
  *(_QWORD *)&v5 = copy_to_user(a3, v7, 24LL);
  if ( *(_QWORD *)&v5 )
LABEL_13:
    v5 = -EFAULT;
LABEL_14:
  ssticlock = 0;
  return v5;
}
// 1D90: using guessed type char ssticlock;
// 1E40: using guessed type __int64 __fastcall copy_from_user(_QWORD, _QWORD, _QWORD);
// 1E80: using guessed type __int64 __fastcall raw_spin_lock(_QWORD);
// 1EC8: using guessed type __int64 printk(const char *, ...);
// 1ED0: using guessed type __int64 __fastcall copy_to_user(_QWORD, _QWORD, _QWORD);

//----- (0000000000000BE0) ----------------------------------------------------
int __fastcall ioctl_get_debug_state(_DWORD *a1)
{
  int result; // eax

  if ( !g_sstic_pci_iomem )
    return -ENODEV;
  result = ioread32(&g_sstic_pci_iomem->debug_state);
  if ( result >= 0 )
  {
    *a1 = result;
    result = 0;
  }
  return result;
}

//----- (0000000000000C0A) ----------------------------------------------------
int __fastcall sstic_pci_probe(__int64 a1)
{
  sstic_iomem *v1; // rax
  int result; // eax

  printk("probed pci dev, trying read.\n");
  v1 = (sstic_iomem *)pci_iomap(a1, 0LL, 0LL);
  if ( v1 )
  {
    g_sstic_pci_iomem = v1;
    printk("\x016Enabling debug mode");
    iowrite32(1, &g_sstic_pci_iomem->debug_state);
    result = 0;
  }
  else
  {
    printk("\x013device not connected !\n");
    result = -ENODEV;
    g_sstic_pci_iomem = 0LL;
  }
  return result;
}
// 1E50: using guessed type __int64 __fastcall pci_iomap(_QWORD, _QWORD, _QWORD);
// 1EC8: using guessed type __int64 printk(const char *, ...);

//----- (0000000000000C75) ----------------------------------------------------
__int64 init_module()
{
  unsigned int v0; // er12
  unsigned int v1; // eax

  v0 = -1;
  printk("\x016sstic registered");
  if ( (int)alloc_chrdev_region(&sstic_dev, 0LL, 1LL, "sstic") >= 0 )
  {
    sstic_class = _class_create(&_this_module, "chardrv", &_sstic_key);
    if ( sstic_class )
    {
      if ( !device_create(sstic_class, 0LL, sstic_dev, 0LL, "sstic") )
      {
        v0 = -1;
        printk("\x016sstic driver error");
        class_destroy(sstic_class);
        unregister_chrdev_region(sstic_dev, 1LL);
        return v0;
      }
      cdev_init(&sstic_cdev, &sstic_fops);
      v0 = cdev_add(&sstic_cdev, sstic_dev, 1LL);
      if ( v0 != -1 )
      {
        v0 = 0;
        v1 = _pci_register_driver(&sstic_pci_driver, &_this_module, "sstic");
        printk("ret %d\n", v1);
        printk("\x016<Major, Minor>: <%d, %d>\n", sstic_dev >> 20, sstic_dev & 0xFFFFF);
        sstic_region_cache_sz32 = kmem_cache_create("sstic_region_cache", 32LL, 0LL, 0LL, 0LL);
        sstic_session_cache_sz48 = kmem_cache_create("sstic_session_cache", 48LL, 0LL, 0LL, 0LL);
        return v0;
      }
      device_destroy(sstic_class, sstic_dev);
      class_destroy(sstic_class);
    }
    unregister_chrdev_region(sstic_dev, 1LL);
  }
  return v0;
}
// C75: using guessed type __int64 __fastcall init_module();
// 1860: using guessed type void *sstic_fops;
// 1D80: using guessed type __int64 sstic_session_cache_sz48;
// 1D88: using guessed type __int64 sstic_region_cache_sz32;
// 1E08: using guessed type __int64 sstic_class;
// 1E30: using guessed type __int64 __fastcall alloc_chrdev_region(_QWORD, _QWORD, _QWORD, _QWORD);
// 1E38: using guessed type __int64 __fastcall _class_create(_QWORD, _QWORD, _QWORD);
// 1E60: using guessed type __int64 __fastcall class_destroy(_QWORD);
// 1E68: using guessed type __int64 __fastcall _pci_register_driver(_QWORD, _QWORD, _QWORD);
// 1E78: using guessed type __int64 __fastcall kmem_cache_create(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1EA8: using guessed type __int64 __fastcall cdev_add(_QWORD, _QWORD, _QWORD);
// 1EB8: using guessed type __int64 __fastcall device_create(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1EC8: using guessed type __int64 printk(const char *, ...);
// 1EE0: using guessed type __int64 __fastcall unregister_chrdev_region(_QWORD, _QWORD);
// 1EE8: using guessed type __int64 __fastcall device_destroy(_QWORD, _QWORD);
// 1EF0: using guessed type __int64 __fastcall cdev_init(_QWORD, _QWORD);

//----- (0000000000000E13) ----------------------------------------------------
__int64 cleanup_module()
{
  unregister_chrdev_region(sstic_dev, 1LL);
  kmem_cache_destroy(sstic_region_cache_sz32);
  return kmem_cache_destroy(sstic_region_cache_sz32);
}
// E13: using guessed type __int64 __fastcall cleanup_module();
// 1D88: using guessed type __int64 sstic_region_cache_sz32;
// 1EE0: using guessed type __int64 __fastcall unregister_chrdev_region(_QWORD, _QWORD);
// 1F00: using guessed type __int64 __fastcall kmem_cache_destroy(_QWORD);

// nfuncs=55 queued=25 decompiled=25 lumina nreq=0 worse=0 better=0
// ALL OK, 25 function(s) have been successfully decompiled
