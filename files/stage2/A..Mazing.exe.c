/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *sub_140001000();
void *sub_140001010();
int __cdecl vfprintf(FILE *const Stream, const char *const Format, va_list ArgList);
int printf(const char *const Format, ...);
int __cdecl vfscanf_s(FILE *const Stream, const char *const Format, va_list ArgList);
int scanf_s(const char *const Format, ...);
__int64 __fastcall vsnprintf(char *a1, size_t a2, const char *a3, __crt_locale_pointers *a4, va_list ArgList);
int snprintf(char *const Buffer, const size_t BufferCount, const char *const Format, ...);
errno_t __cdecl static memcpy_s(void *const Destination, const rsize_t DestinationSize, const void *const Source, const rsize_t SourceSize);
time_t __cdecl static time(time_t *const Time);
int_stack *__fastcall int_stack_alloc(int capacity); // idb
_BOOL8 __fastcall int_stack_full(int_stack *a1); // idb
_BOOL8 __fastcall int_stack_empty(int_stack *a1); // idb
int_stack *__fastcall int_stack_resize(int_stack *a1, unsigned int a2);
__int64 __fastcall int_stack_push(int_stack *a1, int a2); // idb
int __fastcall int_stack_pop(int_stack *a1);
int eat_newline();
_BOOL8 __fastcall is_valid_filename(char *a1);
maze *__fastcall maze_delete(maze *a1);
__int64 __fastcall maze_check_trap(maze *a1, __int64 a2); // idb
unsigned __int64 __fastcall maze_classic_print(maze *a1, __int64 a2); // idb
unsigned __int64 __fastcall maze_multipass_print(maze *a1, __int64 pos, int a3); // idb
__int64 __fastcall maze_clear_ranks(maze *a1); // idb
int __fastcall maze_print(maze *a1, __int64 a2); // idb
int __fastcall read_string(char *a1, unsigned int a2);
_BOOL8 __fastcall get_int(int *a1); // idb
__int64 __fastcall read_motion(_BYTE *a1);
bool __fastcall do_register(user *a1);
void __fastcall mazeinit_fill_hash(char *a1, unsigned __int8 width, unsigned __int8 height);
void __fastcall shuffle(int *arr, int sz); // idb
__int64 __fastcall mazeinit_fill(char *a1, unsigned __int8 width, unsigned __int8 height, int_stack *xs, int_stack *ys); // idb
__int64 __fastcall mazeinit_multipass_init(char *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4); // idb
__int64 __fastcall mazeinit_traps_init(__int64 a1, maze_multipass *a2, unsigned __int8 a3, unsigned __int8 a4); // idb
__int64 __fastcall mazeinit_walls(maze *a1, int_stack *a2, int_stack *a3); // idb
__int64 __fastcall mazeinit(maze *a1); // idb
__int64 __fastcall maze_custom_size(maze *a1); // idb
__int64 __fastcall maze_custom_multipass(maze *a1); // idb
__int64 __fastcall maze_custom_traps(maze *a1); // idb
int __fastcall make_custom_maze(maze *a1);
void __fastcall do_motion(maze *a1, user *a2, char a3);
maze *__fastcall maze_random_size(maze *a1);
__int64 __fastcall maze_random_multipass(maze *a1); // idb
__int64 __fastcall maze_random_traps(maze *a1); // idb
int __fastcall make_random_maze(maze *a1);
__int64 __fastcall write_maze_common(maze *a1, void *a2); // idb
__int64 __fastcall write_maze_multipass(maze *a1, void *a2); // idb
int __fastcall write_ranks(maze *a1);
bool __fastcall write_maze(maze *a1); // idb
__int64 __fastcall load_maze_info(maze *a1, IStream *a2); // idb
_BOOL8 __fastcall load_maze_common(maze *a1, IStream *inf); // idb
__int64 __fastcall load_maze_traps(maze *a1, IStream *a2); // idb
maze *__fastcall load_maze(const CHAR *a1);
__int64 __fastcall get_maze_list(maze_paths *a1); // idb
__int64 __fastcall print_maze_list(maze_paths *a1, unsigned int a2); // idb
__int64 __fastcall read_ranks(maze *a1); // idb
_BOOL8 __fastcall do_load_ranks(maze *a1); // idb
maze *do_load_maze();
__int64 __fastcall read_char(char *a1); // idb
maze *__fastcall do_create_maze(user *a1); // idb
__int64 __fastcall add_rank(rank *a1, rank_data *a2); // idb
__int64 __fastcall write_ranks_0(maze *a1); // idb
int __fastcall maze_view_scoreboard(maze *a1); // idb
__int64 __fastcall maze_update_traps(maze *a1);
__int64 __fastcall do_upgrade_maze_traps(maze *a1); // idb
__int64 __fastcall do_upgrade_maze_multipass(maze *a1); // idb
__int64 __fastcall maze_remove_files(maze *a1); // idb
__int64 __fastcall do_save_maze(maze *rcx0);
__int64 __fastcall alarm_thread(LPVOID lpThreadParameter);
char __fastcall set_alarm(unsigned int a1);
int __cdecl main(int argc, const char **argv, const char **envp);
// __int64 __fastcall __scrt_common_main_seh();
// __int64 __fastcall _raise_securityfailure(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
__int64 __fastcall sub_140005F20(DWORD64 a1);
// __int64 __fastcall capture_previous_context(PCONTEXT ContextRecord); idb
// __int64 __fastcall _scrt_acquire_startup_lock(_QWORD); weak
// __int64 __fastcall _scrt_initialize_crt(_QWORD); weak
// __int64 __fastcall _scrt_is_nonwritable_in_current_image(_QWORD); weak
// __int64 __fastcall _scrt_release_startup_lock(_QWORD); weak
// __int64 __fastcall _scrt_uninitialize_crt(_QWORD, _QWORD); weak
__int64 __fastcall UserMathErrorFunction(struct _exception *a1);
void sub_140006384();
char sub_140006394();
void nullsub_1();
void *sub_1400063CC();
void *sub_1400063D4();
void sub_1400063DC();
void __fastcall sub_1400063E4(unsigned int a1);
// __int64 __fastcall _scrt_is_managed_app(_QWORD); weak
void sub_1400065FC();
void __fastcall sub_140006640();
// void *__cdecl memset(void *, int Val, size_t Size);
// void __cdecl __noreturn exit(int Code);
// char **__cdecl get_initial_narrow_environment();
// void __cdecl initterm(_PVFV *First, _PVFV *Last);
// int __cdecl initterm_e(_PIFV *First, _PIFV *Last);
// int *__cdecl _p___argc();
// char ***__cdecl _p___argv();
// void __cdecl cexit();
// void __cdecl register_thread_local_exe_atexit_callback(_tls_callback_type Callback);
// HANDLE __stdcall FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// HANDLE __stdcall GetCurrentProcess();
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// BOOL __stdcall FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
// BOOL __stdcall FindClose(HANDLE hFindFile);
// void __stdcall Sleep(DWORD dwMilliseconds);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// void __stdcall RtlCaptureContext(PCONTEXT ContextRecord);
// BOOL __stdcall IsDebuggerPresent();
// void __stdcall InitializeSListHead(PSLIST_HEADER ListHead);
// BOOL __stdcall IsProcessorFeaturePresent(DWORD ProcessorFeature);
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
// PEXCEPTION_ROUTINE __stdcall RtlVirtualUnwind(ULONG HandlerType, ULONG64 ImageBase, ULONG64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PULONG64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers);
// PRUNTIME_FUNCTION __stdcall RtlLookupFunctionEntry(ULONG64 ControlPc, PULONG64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable);
// HRESULT __stdcall SHCreateStreamOnFileA(LPCSTR pszFile, DWORD grfMode, IStream **ppstm);
// int __cdecl atoi(const char *String);
// int __cdecl remove(const char *FileName);
// void *__cdecl malloc(size_t Size);
// void *__cdecl calloc(size_t Count, size_t Size);
// void *__cdecl realloc(void *Block, size_t Size);
// void __cdecl free(void *Block);
// int *__cdecl errno();
// void __cdecl __noreturn exit(int Code);
// void __cdecl invalid_parameter_noinfo();
// int __cdecl getchar();
// int __cdecl _stdio_common_vfscanf(unsigned __int64 Options, FILE *Stream, const char *Format, _locale_t Locale, va_list Arglist);
// char *__cdecl getcwd(char *DstBuf, int SizeInBytes);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// FILE *__cdecl _acrt_iob_func(unsigned int Ix);
// int __cdecl _stdio_common_vfprintf(unsigned __int64 Options, FILE *Stream, const char *Format, _locale_t Locale, va_list ArgList);
// int __cdecl setvbuf(FILE *Stream, char *Buffer, int Mode, size_t Size);
// int __cdecl _stdio_common_vsprintf_s(unsigned __int64 Options, char *Buffer, size_t BufferCount, const char *Format, _locale_t Locale, va_list ArgList);
// errno_t __cdecl strcpy_s(char *Destination, rsize_t SizeInBytes, const char *Source);
// __time64_t __cdecl time64(__time64_t *Time);
// int __cdecl rand();
// void __cdecl srand(unsigned int Seed);

//-------------------------------------------------------------------------
// Data declarations

const struct _EXCEPTION_POINTERS ExceptionInfo = { &dword_14000A060, &ContextRecord }; // idb
void (*qword_140008308[2])(void) = { NULL, NULL }; // idb
void (*qword_140008318)(void) = NULL; // idb
int g_directions[4] = { 0, 1, 2, 3 };
int dword_14000A060 = 0; // weak
int dword_14000A064 = 0; // weak
__int64 qword_14000A070 = 0i64; // weak
int dword_14000A078 = 0; // weak
_UNKNOWN unk_14000A080; // weak
_CONTEXT ContextRecord =
{
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  0ui64,
  { {  } }
}; // idb
union _SLIST_HEADER stru_14000A620; // idb
int dword_14000A630; // weak
char cwd[264]; // idb
_UNKNOWN unk_14000A758; // weak
_UNKNOWN unk_14000A760; // weak
_UNKNOWN unk_14000A768; // weak
_UNKNOWN unk_14000A770; // weak


//----- (0000000140001000) ----------------------------------------------------
void *sub_140001000()
{
  return &unk_14000A760;
}

//----- (0000000140001010) ----------------------------------------------------
void *sub_140001010()
{
  return &unk_14000A758;
}

//----- (0000000140001020) ----------------------------------------------------
int __cdecl vfprintf(FILE *const Stream, const char *const Format, va_list ArgList)
{
  va_list v3; // r9
  unsigned __int64 *v4; // rax
  va_list v9; // [rsp+58h] [rbp+20h]

  v9 = v3;
  v4 = (unsigned __int64 *)sub_140001000();
  return _stdio_common_vfprintf(*v4, Stream, Format, (_locale_t)ArgList, v9);
}
// 140001020: variable 'v3' is possibly undefined

//----- (0000000140001070) ----------------------------------------------------
int printf(const char *const Format, ...)
{
  FILE *v1; // rax

  v1 = _acrt_iob_func(1u);
  return vfprintf(v1, Format, 0i64);
}

//----- (00000001400010F0) ----------------------------------------------------
int __cdecl vfscanf_s(FILE *const Stream, const char *const Format, va_list ArgList)
{
  va_list v3; // r9
  _QWORD *v4; // rax
  va_list Arglist; // [rsp+58h] [rbp+20h]

  Arglist = v3;
  v4 = sub_140001010();
  return _stdio_common_vfscanf(*v4 | 1i64, Stream, Format, (_locale_t)ArgList, Arglist);
}
// 1400010F0: variable 'v3' is possibly undefined

//----- (0000000140001140) ----------------------------------------------------
int scanf_s(const char *const Format, ...)
{
  FILE *v1; // rax

  v1 = _acrt_iob_func(0);
  return vfscanf_s(v1, Format, 0i64);
}

//----- (00000001400011C0) ----------------------------------------------------
__int64 __fastcall vsnprintf(char *a1, size_t a2, const char *a3, __crt_locale_pointers *a4, va_list ArgList)
{
  unsigned __int64 *v5; // rax
  int v7; // [rsp+30h] [rbp-18h]
  unsigned int v8; // [rsp+34h] [rbp-14h]

  v5 = (unsigned __int64 *)sub_140001000();
  v7 = _stdio_common_vsprintf_s(*v5, a1, a2, a3, a4, ArgList);
  if ( v7 >= 0 )
    v8 = v7;
  else
    v8 = -1;
  return v8;
}

//----- (0000000140001230) ----------------------------------------------------
int snprintf(char *const Buffer, const size_t BufferCount, const char *const Format, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  return vsnprintf(Buffer, BufferCount, Format, 0i64, va);
}

//----- (00000001400012B0) ----------------------------------------------------
errno_t __cdecl memcpy_s(void *const Destination, const rsize_t DestinationSize, const void *const Source, const rsize_t SourceSize)
{
  errno_t result; // eax

  if ( !SourceSize )
    return 0;
  if ( !Destination )
    goto LABEL_4;
  if ( Source && DestinationSize >= SourceSize )
  {
    qmemcpy(Destination, Source, SourceSize);
    result = 0;
  }
  else
  {
    memset(Destination, 0, DestinationSize);
    if ( !Source )
    {
LABEL_4:
      *errno() = 22;
      invalid_parameter_noinfo();
      return 22;
    }
    if ( DestinationSize >= SourceSize )
    {
      result = 22;
    }
    else
    {
      *errno() = 34;
      invalid_parameter_noinfo();
      result = 34;
    }
  }
  return result;
}

//----- (00000001400013F0) ----------------------------------------------------
time_t __cdecl time(time_t *const Time)
{
  return time64(Time);
}

//----- (0000000140001410) ----------------------------------------------------
int_stack *__fastcall int_stack_alloc(int capacity)
{
  int_stack *v2; // [rsp+20h] [rbp-18h]

  v2 = (int_stack *)malloc(0x10ui64);
  if ( !v2 )
    return 0i64;
  v2->capacity = capacity;
  v2->count = -1;
  v2->data = (int *)malloc(saturated_mul(v2->capacity, 4ui64));
  return v2;
}

//----- (0000000140001490) ----------------------------------------------------
_BOOL8 __fastcall int_stack_full(int_stack *a1)
{
  return a1->count == a1->capacity - 1;
}

//----- (00000001400014D0) ----------------------------------------------------
_BOOL8 __fastcall int_stack_empty(int_stack *a1)
{
  return a1->count == -1;
}

//----- (0000000140001500) ----------------------------------------------------
int_stack *__fastcall int_stack_resize(int_stack *a1, unsigned int a2)
{
  int_stack *result; // rax
  size_t v3; // rax
  int *v4; // [rsp+20h] [rbp-18h]

  result = a1;
  if ( a1->capacity < a2 )
  {
    v3 = 4i64 * a2;
    if ( !is_mul_ok(a2, 4ui64) )
      v3 = -1i64;
    v4 = (int *)realloc(a1->data, v3);
    if ( !v4 )
    {
      free(a1->data);
      exit(1);
    }
    a1->data = v4;
    result = a1;
    a1->capacity = a2;
  }
  return result;
}

//----- (00000001400015A0) ----------------------------------------------------
__int64 __fastcall int_stack_push(int_stack *a1, int a2)
{
  __int64 result; // rax
  int v3; // [rsp+20h] [rbp-18h]

  if ( int_stack_full(a1) )
    int_stack_resize(a1, 2 * a1->capacity);
  v3 = a1->count + 1;
  a1->count = v3;
  result = v3;
  a1->data[v3] = a2;
  return result;
}

//----- (0000000140001610) ----------------------------------------------------
int __fastcall int_stack_pop(int_stack *a1)
{
  if ( int_stack_empty(a1) )
    return 0x80000000;
  return a1->data[a1->count--];
}

//----- (0000000140001670) ----------------------------------------------------
int eat_newline()
{
  int result; // eax

  do
    result = getchar();
  while ( result != 10 && result != -1 );
  if ( result == -1 )
    exit(0);
  return result;
}

//----- (00000001400016B0) ----------------------------------------------------
_BOOL8 __fastcall is_valid_filename(char *a1)
{
  unsigned __int64 i; // [rsp+0h] [rbp-28h]
  unsigned __int64 v3; // [rsp+8h] [rbp-20h]

  for ( i = 0i64; ; ++i )
  {
    v3 = -1i64;
    do
      ++v3;
    while ( a1[v3] );
    if ( i >= v3 )
      break;
    if ( a1[i] == '*' || a1[i] == '/' || a1[i] == '\\' )
      return 0i64;
  }
  return *a1 != '.';
}

//----- (0000000140001790) ----------------------------------------------------
maze *__fastcall maze_delete(maze *a1)
{
  maze *result; // rax

  if ( a1->maze_type == MAZE_CLASSIC )
  {
    if ( a1->maze_data.classic.maze )
      free(a1->maze_data.classic.maze);
    result = a1;
    a1->maze_data.classic.maze = 0i64;
  }
  else
  {
    if ( a1->maze_data.multipass.maze )
      free(a1->maze_data.multipass.maze);
    result = a1;
    a1->maze_data.multipass.maze = 0i64;
  }
  return result;
}

//----- (0000000140001810) ----------------------------------------------------
__int64 __fastcall maze_check_trap(maze *a1, __int64 a2)
{
  unsigned __int8 i; // [rsp+20h] [rbp-18h]

  for ( i = 0; i < (int)a1->maze_data.multipass.num_traps; ++i )
  {
    if ( a1->maze_data.multipass.traps[i].position == a2 && a1->maze_data.multipass.traps[i].is_hit )
    {
      printf("%c", (unsigned int)a1->maze_data.multipass.traps[i].character);
      return 1i64;
    }
  }
  return 0i64;
}

//----- (00000001400018C0) ----------------------------------------------------
unsigned __int64 __fastcall maze_classic_print(maze *a1, __int64 a2)
{
  unsigned __int64 result; // rax
  unsigned __int64 i; // [rsp+20h] [rbp-28h]
  unsigned __int64 j; // [rsp+28h] [rbp-20h]
  unsigned __int64 v5; // [rsp+30h] [rbp-18h]

  for ( i = 0i64; ; ++i )
  {
    result = a1->height;
    if ( i >= result )
      break;
    for ( j = 0i64; j < a1->width; ++j )
    {
      v5 = j + a1->width * i;
      if ( v5 == a2 )
        printf("x");
      else
        printf("%c", (unsigned int)a1->maze_data.classic.maze[v5]);
    }
    printf("\n");
  }
  return result;
}

//----- (00000001400019A0) ----------------------------------------------------
unsigned __int64 __fastcall maze_multipass_print(maze *a1, __int64 pos, int a3)
{
  unsigned __int64 result; // rax
  unsigned __int64 i; // [rsp+20h] [rbp-28h]
  unsigned __int64 j; // [rsp+28h] [rbp-20h]
  __int64 v6; // [rsp+30h] [rbp-18h]

  for ( i = 0i64; ; ++i )
  {
    result = a1->height;
    if ( i >= result )
      break;
    for ( j = 0i64; j < a1->width; ++j )
    {
      v6 = j + a1->width * i;
      if ( v6 == pos && pos )
      {
        printf("x");
      }
      else if ( !(unsigned int)maze_check_trap(a1, v6) )
      {
        printf("%c", (unsigned int)a1->maze_data.multipass.maze[v6]);
      }
    }
    if ( a3 )
      printf("\n");
  }
  return result;
}

//----- (0000000140001AA0) ----------------------------------------------------
__int64 __fastcall maze_clear_ranks(maze *a1)
{
  __int64 result; // rax

  a1->rank_data.nr_ranks = 0;
  result = 0i64;
  memset(a1->rank_data.ranks, 0, sizeof(a1->rank_data.ranks));
  return result;
}

//----- (0000000140001AD0) ----------------------------------------------------
int __fastcall maze_print(maze *a1, __int64 a2)
{
  if ( a1->maze_type == MAZE_MULTIPASS_TRAPS || a1->maze_type == MAZE_MULTIPASS )
    maze_multipass_print(a1, a2, 1);
  else
    maze_classic_print(a1, a2);
  return printf("-*-*-*-*-*-*-*\n");
}

//----- (0000000140001B40) ----------------------------------------------------
int __fastcall read_string(char *a1, unsigned int a2)
{
  int v3; // [rsp+20h] [rbp-18h]

  v3 = scanf_s("%s", a1, a2);
  eat_newline();
  return v3;
}

//----- (0000000140001B80) ----------------------------------------------------
_BOOL8 __fastcall get_int(int *a1)
{
  int v2; // [rsp+24h] [rbp-14h]

  v2 = scanf_s("%d", a1);
  eat_newline();
  return v2 != 1;
}

//----- (0000000140001BD0) ----------------------------------------------------
__int64 __fastcall read_motion(_BYTE *a1)
{
  unsigned int v2; // [rsp+20h] [rbp-18h]

  v2 = scanf_s("%c", a1);
  eat_newline();
  if ( v2 != 1 )
    return v2;
  return *a1 != 122 && *a1 != 113 && *a1 != 115 && *a1 != 100 && *a1 != 120;
}

//----- (0000000140001C60) ----------------------------------------------------
bool __fastcall do_register(user *a1)
{
  printf("Pseudo :\n");
  if ( read_string(a1->name, 0x80u) == 1 )
    return 1;
  printf("Problem while getting pseudo, maximum size is %zd\n", 0x80ui64);
  return 0;
}

//----- (0000000140001CB0) ----------------------------------------------------
void __fastcall mazeinit_fill_hash(char *a1, unsigned __int8 width, unsigned __int8 height)
{
  unsigned __int64 i; // [rsp+0h] [rbp-18h]
  unsigned __int64 j; // [rsp+8h] [rbp-10h]

  for ( i = 0i64; i < height; ++i )
  {
    for ( j = 0i64; j < width; ++j )
      a1[j + width * i] = '#';
  }
}

//----- (0000000140001D30) ----------------------------------------------------
void __fastcall shuffle(int *arr, int sz)
{
  int v2; // eax
  int i; // [rsp+20h] [rbp-28h]
  int v4; // [rsp+30h] [rbp-18h]

  if ( sz > 1 )
  {
    for ( i = 0; i < sz - 1; ++i )
    {
      v2 = rand() / (0x7FFF / (sz - i) + 1);
      v4 = arr[v2 + i];
      arr[v2 + i] = arr[i];
      arr[i] = v4;
    }
  }
}

//----- (0000000140001DF0) ----------------------------------------------------
__int64 __fastcall mazeinit_fill(char *a1, unsigned __int8 width, unsigned __int8 height, int_stack *xs, int_stack *ys)
{
  __int64 result; // rax
  int x; // [rsp+20h] [rbp-18h]
  int y; // [rsp+24h] [rbp-14h]
  int i; // [rsp+28h] [rbp-10h]
  int v9; // [rsp+2Ch] [rbp-Ch]

  mazeinit_fill_hash(a1, width, height);
  a1[width + 1] = 32;
  a1[width * height] = 0;
  while ( !int_stack_empty(xs) )
  {
    shuffle(g_directions, 4);
    x = int_stack_pop(xs);
    y = int_stack_pop(ys);
    for ( i = 0; i < 4; ++i )
    {
      v9 = g_directions[i];
      if ( v9 )
      {
        if ( v9 == 1 )
        {
          if ( x + 2 < width - 1 && a1[width * y + 2 + x] != 32 )
          {
            a1[width * y + 2 + x] = 32;
            a1[width * y + 1 + x] = 32;
            int_stack_push(xs, x + 2);
            int_stack_push(ys, y);
          }
        }
        else if ( v9 == 2 )
        {
          if ( y + 2 < height - 1 && a1[x + width * (y + 2)] != 32 )
          {
            a1[x + width * (y + 2)] = 32;
            a1[x + width * (y + 1)] = 32;
            int_stack_push(xs, x);
            int_stack_push(ys, y + 2);
          }
        }
        else if ( v9 == 3 && x - 2 > 0 && a1[width * y - 2 + x] != 32 )
        {
          a1[width * y - 2 + x] = 32;
          a1[width * y - 1 + x] = 32;
          int_stack_push(xs, x - 2);
          int_stack_push(ys, y);
        }
      }
      else if ( y - 2 > 0 && a1[x + width * (y - 2)] != 32 )
      {
        a1[x + width * (y - 2)] = 32;
        a1[x + width * (y - 1)] = 32;
        int_stack_push(xs, x);
        int_stack_push(ys, y - 2);
      }
    }
  }
  result = width * (height - 2) + width - 1;
  a1[result] = 'o';
  return result;
}

//----- (0000000140002190) ----------------------------------------------------
__int64 __fastcall mazeinit_multipass_init(char *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  double v5; // xmm0_8
  unsigned __int64 v6; // rax
  double v7; // xmm0_8
  unsigned __int8 j; // [rsp+20h] [rbp-48h]
  unsigned __int8 i; // [rsp+21h] [rbp-47h]
  __int64 wallcount; // [rsp+28h] [rbp-40h]
  int *walls; // [rsp+30h] [rbp-38h]
  unsigned __int64 k; // [rsp+38h] [rbp-30h]
  unsigned __int64 v13; // [rsp+40h] [rbp-28h]
  unsigned __int64 v14; // [rsp+48h] [rbp-20h]

  wallcount = 0i64;
  walls = (int *)calloc(a2 * (unsigned __int64)a3, 4ui64);
  if ( !walls )
    return 0i64;
  for ( i = 0; i < (int)a2; ++i )
  {
    for ( j = 0; j < (int)a3; ++j )
    {
      if ( i && i != a2 - 1 && j && j != a3 - 1 && a1[i + a2 * j] == 35 )
        walls[wallcount++] = i + a2 * j;
    }
  }
  shuffle(walls, wallcount);
  if ( wallcount < 0 )
    v5 = (double)(int)(wallcount & 1 | ((unsigned __int64)wallcount >> 1))
       + (double)(int)(wallcount & 1 | ((unsigned __int64)wallcount >> 1));
  else
    v5 = (double)(int)wallcount;
  v6 = 0i64;
  v7 = v5 * ((double)a4 / 100.0);
  if ( v7 >= 9.223372036854776e18 )
  {
    v7 = v7 - 9.223372036854776e18;
    if ( v7 < 9.223372036854776e18 )
      v6 = 0x8000000000000000ui64;
  }
  v13 = v6 + (unsigned int)(int)v7;
  printf("Will destroy %ju walls\n", v13);
  for ( k = 0i64; ; ++k )
  {
    v14 = v13 >= wallcount ? wallcount : v13;
    if ( k >= v14 )
      break;
    a1[walls[k]] = 32;
  }
  free(walls);
  return 1i64;
}

//----- (0000000140002400) ----------------------------------------------------
__int64 __fastcall mazeinit_traps_init(__int64 a1, maze_multipass *a2, unsigned __int8 a3, unsigned __int8 a4)
{
  unsigned __int8 j; // [rsp+20h] [rbp-28h]
  unsigned __int8 i; // [rsp+21h] [rbp-27h]
  unsigned __int8 v7; // [rsp+22h] [rbp-26h]
  int v8; // [rsp+24h] [rbp-24h]
  int *walls; // [rsp+28h] [rbp-20h]
  unsigned __int64 k; // [rsp+30h] [rbp-18h]

  v8 = 0;
  walls = (int *)calloc(a3 * (unsigned __int64)a4, 4ui64);
  if ( !walls )
    return 0i64;
  for ( i = 0; i < (int)a3; ++i )
  {
    for ( j = 0; j < (int)a4; ++j )
    {
      if ( i && i != a3 - 1 && j && j != a4 - 1 && (j != 1 || i != 1) && *(_BYTE *)(a1 + i + a3 * j) == 32 )
        walls[v8++] = i + a3 * j;
    }
  }
  shuffle(walls, v8);
  v7 = 0;
  for ( k = 0i64; k < a2->num_traps; ++k )
  {
    a2->traps[k].position = walls[k];
    ++v7;
  }
  a2->num_traps = v7;
  free(walls);
  return 1i64;
}

//----- (00000001400025E0) ----------------------------------------------------
__int64 __fastcall mazeinit_walls(maze *a1, int_stack *a2, int_stack *a3)
{
  unsigned __int64 v3; // rax
  bool v4; // cf
  size_t v5; // rax
  char *data; // [rsp+30h] [rbp-18h]

  v3 = a1->height * (unsigned __int64)a1->width;
  v4 = __CFADD__(v3, 1i64);
  v5 = v3 + 1;
  if ( v4 )
    v5 = -1i64;
  data = (char *)calloc(v5, 1ui64);
  if ( !data )
    return 0i64;
  switch ( a1->maze_type )
  {
    case MAZE_CLASSIC:
      a1->maze_data.classic.maze = data;
      break;
    case MAZE_MULTIPASS:
      a1->maze_data.multipass.maze = data;
      break;
    case MAZE_MULTIPASS_TRAPS:
      a1->maze_data.multipass.maze = data;
      break;
  }
  mazeinit_fill(data, a1->width, a1->height, a2, a3);
  if ( (a1->maze_type < MAZE_MULTIPASS
     || (unsigned int)mazeinit_multipass_init(
                        data,
                        a1->width,
                        a1->height,
                        a1->maze_data.multipass.wall_percent_to_remove))
    && (a1->maze_type != MAZE_MULTIPASS_TRAPS
     || (unsigned int)mazeinit_traps_init((__int64)data, (maze_multipass *)&a1->maze_data, a1->width, a1->height)) )
  {
    return 1i64;
  }
  free(data);
  return 0i64;
}

//----- (0000000140002770) ----------------------------------------------------
__int64 __fastcall mazeinit(maze *a1)
{
  __int64 result; // rax
  unsigned int v2; // [rsp+20h] [rbp-28h]
  int_stack *s1; // [rsp+30h] [rbp-18h]
  int_stack *s2; // [rsp+38h] [rbp-10h]

  v2 = 1;
  s1 = int_stack_alloc(32);
  if ( !s1 )
    return 0i64;
  s2 = int_stack_alloc(32);
  if ( s2 )
  {
    int_stack_push(s1, 1);
    int_stack_push(s2, 1);
    if ( !(unsigned int)mazeinit_walls(a1, s1, s2) )
      v2 = 0;
    free(s1);
    free(s2);
    result = v2;
  }
  else
  {
    free(s1);
    result = 0i64;
  }
  return result;
}

//----- (0000000140002850) ----------------------------------------------------
__int64 __fastcall maze_custom_size(maze *a1)
{
  int v2; // [rsp+20h] [rbp-18h] BYREF
  int v3; // [rsp+24h] [rbp-14h] BYREF

  v2 = 0;
  v3 = 0;
  while ( !(v2 % 2) || v2 < 3 || v2 >= 255 )
  {
    printf("Width odd and greater than %d: ", 3i64);
    get_int(&v2);
  }
  a1->width = v2;
  while ( !(v3 % 2) || v3 < 3 || v3 >= 255 )
  {
    printf("Height odd and greater than %d: ", 3i64);
    get_int(&v3);
  }
  a1->height = v3;
  return 1i64;
}

//----- (0000000140002930) ----------------------------------------------------
__int64 __fastcall maze_custom_multipass(maze *a1)
{
  int i; // [rsp+20h] [rbp-18h] BYREF

  for ( i = -1; i < 0 || i > 100; get_int(&i) )
    printf("Enter the percentage of wall to remove, default is %d%%: ", 5i64);
  a1->maze_data.multipass.wall_percent_to_remove = i;
  return 1i64;
}

//----- (00000001400029B0) ----------------------------------------------------
__int64 __fastcall maze_custom_traps(maze *a1)
{
  int j; // [rsp+20h] [rbp-28h]
  int v3; // [rsp+24h] [rbp-24h]
  unsigned int v4; // [rsp+28h] [rbp-20h]
  int i; // [rsp+2Ch] [rbp-1Ch] BYREF
  int v6; // [rsp+30h] [rbp-18h] BYREF

  i = 0;
  v3 = a1->width + a1->height - 6;
  for ( i = a1->height * a1->width; i > v3 || i < 0 || i > 256; get_int(&i) )
  {
    if ( v3 >= 256 )
      v4 = 256;
    else
      v4 = v3;
    printf("Number of traps between %d and %d: ", 0i64, v4);
  }
  v6 = 0;
  a1->maze_data.multipass.num_traps = i;
  printf("Score value for traps: ");
  if ( get_int(&v6) )
    return 0i64;
  for ( j = 0; j < a1->maze_data.multipass.num_traps; ++j )
  {
    a1->maze_data.multipass.traps[j].character = 94;
    a1->maze_data.multipass.traps[j].position = 0;
    a1->maze_data.multipass.traps[j].is_hit = 1;
    a1->maze_data.multipass.traps[j].score = v6;
  }
  return 1i64;
}

//----- (0000000140002B40) ----------------------------------------------------
int __fastcall make_custom_maze(maze *a1)
{
  maze_custom_size(a1);
  if ( a1->maze_type >= MAZE_MULTIPASS )
    maze_custom_multipass(a1);
  if ( a1->maze_type == MAZE_MULTIPASS_TRAPS )
    maze_custom_traps(a1);
  return 1;
}

//----- (0000000140002B90) ----------------------------------------------------
void __fastcall do_motion(maze *a1, user *a2, char a3)
{
  unsigned __int8 x; // [rsp+0h] [rbp-38h]
  unsigned __int8 y; // [rsp+1h] [rbp-37h]
  unsigned __int64 i; // [rsp+8h] [rbp-30h]
  maze_data *v6; // [rsp+10h] [rbp-28h]
  char *v7; // [rsp+18h] [rbp-20h]
  unsigned __int64 v8; // [rsp+20h] [rbp-18h]

  ++a2->score;
  x = a2->x;
  y = a2->y;
  switch ( a3 )
  {
    case 'd':
      ++x;
      break;
    case 'q':
      --x;
      break;
    case 's':
      ++y;
      break;
    case 'z':
      --y;
      break;
  }
  if ( x < (int)a1->width && y < (int)a1->height )
  {
    v8 = x + a1->width * (unsigned __int64)y;
    switch ( a1->maze_type )
    {
      case MAZE_CLASSIC:
        v7 = a1->maze_data.classic.maze;
        break;
      case MAZE_MULTIPASS:
        v7 = a1->maze_data.multipass.maze;
        break;
      case MAZE_MULTIPASS_TRAPS:
        v7 = a1->maze_data.multipass.maze;
        break;
      default:
        return;
    }
    if ( a1->maze_type >= MAZE_MULTIPASS_TRAPS )
    {
      v6 = &a1->maze_data;
      for ( i = 0i64; i < v6->multipass.num_traps; ++i )
      {
        if ( v6->multipass.traps[i].position == v8 )
        {
          if ( v6->multipass.traps[i].is_hit )
          {
            a2->score += v6->multipass.traps[i].score;
            v6->multipass.traps[i].is_hit = 0;
          }
        }
      }
    }
    if ( v7[x + a1->width * y] != '#' )
    {
      a2->x = x;
      a2->y = y;
    }
  }
}

//----- (0000000140002DD0) ----------------------------------------------------
maze *__fastcall maze_random_size(maze *a1)
{
  maze *result; // rax
  unsigned __int64 v2; // [rsp+20h] [rbp-18h]
  unsigned __int64 v3; // [rsp+28h] [rbp-10h]

  v2 = (rand() + 11i64) % 0x100ui64;
  if ( !(v2 % 2) )
  {
    if ( v2 == 4 )
      LOBYTE(v2) = 5;
    else
      LOBYTE(v2) = v2 - 1;
  }
  v3 = (rand() + 11i64) % 0x100ui64;
  if ( !(v3 % 2) )
  {
    if ( v3 == 4 )
      LOBYTE(v3) = 5;
    else
      LOBYTE(v3) = v3 - 1;
  }
  a1->width = v2;
  result = a1;
  a1->height = v3;
  return result;
}

//----- (0000000140002EB0) ----------------------------------------------------
__int64 __fastcall maze_random_multipass(maze *a1)
{
  __int64 result; // rax

  do
  {
    a1->maze_data.multipass.wall_percent_to_remove = rand() % 10;
    result = (unsigned __int8)a1->maze_data.multipass.wall_percent_to_remove;
  }
  while ( !a1->maze_data.multipass.wall_percent_to_remove );
  return result;
}

//----- (0000000140002EF0) ----------------------------------------------------
__int64 __fastcall maze_random_traps(maze *a1)
{
  __int64 result; // rax
  int i; // [rsp+20h] [rbp-28h]
  int v3; // [rsp+28h] [rbp-20h]
  __int64 v4; // [rsp+38h] [rbp-10h]

  v4 = rand() % (a1->height * a1->width / 10);
  if ( (int)((double)(a1->height * a1->width / 4) * 0.3) >= 256 )
    v3 = 256;
  else
    v3 = (int)((double)(a1->height * a1->width / 4) * 0.3);
  a1->maze_data.multipass.num_traps = rand() % v3;
  for ( i = 0; ; ++i )
  {
    result = a1->maze_data.multipass.num_traps;
    if ( i >= (int)result )
      break;
    a1->maze_data.multipass.traps[i].character = '^';
    a1->maze_data.multipass.traps[i].position = 0;
    a1->maze_data.multipass.traps[i].is_hit = 1;
    a1->maze_data.multipass.traps[i].score = v4;
  }
  return result;
}

//----- (0000000140003030) ----------------------------------------------------
int __fastcall make_random_maze(maze *a1)
{
  maze_random_size(a1);
  if ( a1->maze_type >= MAZE_MULTIPASS )
    maze_random_multipass(a1);
  if ( a1->maze_type == MAZE_MULTIPASS_TRAPS )
    maze_random_traps(a1);
  return 1;
}

//----- (0000000140003080) ----------------------------------------------------
__int64 __fastcall write_maze_common(maze *a1, void *a2)
{
  BOOL v3; // [rsp+30h] [rbp-48h]
  int v4; // [rsp+30h] [rbp-48h]
  int v5; // [rsp+30h] [rbp-48h]
  int v6; // [rsp+30h] [rbp-48h]
  int v7; // [rsp+30h] [rbp-48h]
  __int64 v8; // [rsp+38h] [rbp-40h]
  char *v9; // [rsp+40h] [rbp-38h]
  char Buffer[4]; // [rsp+60h] [rbp-18h] BYREF
  DWORD NumberOfBytesWritten; // [rsp+64h] [rbp-14h] BYREF

  v8 = -1i64;
  do
    ++v8;
  while ( a1->creator_name[v8] );
  Buffer[0] = v8;
  v3 = WriteFile(a2, Buffer, 1u, &NumberOfBytesWritten, 0i64);
  v4 = WriteFile(a2, a1->creator_name, (unsigned __int8)Buffer[0], &NumberOfBytesWritten, 0i64) && v3;
  v5 = WriteFile(a2, &a1->maze_type, 1u, &NumberOfBytesWritten, 0i64) & v4;
  v6 = WriteFile(a2, a1, 1u, &NumberOfBytesWritten, 0i64) & v5;
  v7 = WriteFile(a2, &a1->height, 1u, &NumberOfBytesWritten, 0i64) & v6;
  v9 = 0i64;
  switch ( a1->maze_type )
  {
    case MAZE_CLASSIC:
      v9 = a1->maze_data.classic.maze;
      break;
    case MAZE_MULTIPASS:
      v9 = a1->maze_data.multipass.maze;
      break;
    case MAZE_MULTIPASS_TRAPS:
      v9 = a1->maze_data.multipass.maze;
      break;
  }
  return WriteFile(a2, v9, a1->width * a1->height, &NumberOfBytesWritten, 0i64) & (unsigned int)v7;
}

//----- (00000001400032F0) ----------------------------------------------------
__int64 __fastcall write_maze_multipass(maze *a1, void *a2)
{
  unsigned int v3; // [rsp+30h] [rbp-28h]
  int v4; // [rsp+30h] [rbp-28h]
  int v5; // [rsp+30h] [rbp-28h]
  int i; // [rsp+34h] [rbp-24h]
  DWORD NumberOfBytesWritten; // [rsp+38h] [rbp-20h] BYREF

  v3 = WriteFile(a2, &a1->maze_data, 1u, &NumberOfBytesWritten, 0i64);
  for ( i = 0; i < a1->maze_data.multipass.num_traps; ++i )
  {
    v4 = WriteFile(a2, (char *)&a1->maze_data.classic.maze + 15 * i + 1, 8u, &NumberOfBytesWritten, 0i64) & v3;
    v5 = WriteFile(a2, &a1->maze_data.multipass.traps[i].position, 2u, &NumberOfBytesWritten, 0i64) & v4;
    v3 = WriteFile(a2, &a1->maze_data.multipass.traps[i].character, 1u, &NumberOfBytesWritten, 0i64) & v5;
  }
  return v3;
}

//----- (0000000140003450) ----------------------------------------------------
int __fastcall write_ranks(maze *a1)
{
  int v2; // [rsp+40h] [rbp-138h]
  HANDLE hFile; // [rsp+48h] [rbp-130h]
  DWORD NumberOfBytesWritten; // [rsp+50h] [rbp-128h] BYREF
  CHAR FileName[256]; // [rsp+60h] [rbp-118h] BYREF

  memset(FileName, 0, sizeof(FileName));
  snprintf(FileName, 0x100ui64, "%s\\%s.rank", cwd, a1->maze_name);
  maze_clear_ranks(a1);
  hFile = CreateFileA(FileName, 0x40000000u, 0, 0i64, 1u, 0x80u, 0i64);
  if ( hFile == (HANDLE)-1i64 )
    return 0;
  v2 = WriteFile(hFile, &a1->rank_data, 1u, &NumberOfBytesWritten, 0i64);
  CloseHandle(hFile);
  return v2;
}

//----- (0000000140003560) ----------------------------------------------------
bool __fastcall write_maze(maze *a1)
{
  int v2; // [rsp+44h] [rbp-1B4h]
  HANDLE hObject; // [rsp+48h] [rbp-1B0h]
  CHAR FileName[400]; // [rsp+50h] [rbp-1A8h] BYREF

  memset(FileName, 0, sizeof(FileName));
  snprintf(FileName, 0x190ui64, "%s\\%s.maze", cwd, a1->maze_name);
  hObject = CreateFileA(FileName, 0x40000000u, 0, 0i64, 1u, 0x80u, 0i64);
  if ( hObject == (HANDLE)-1i64 )
    return 0;
  v2 = write_maze_common(a1, hObject);
  if ( a1->maze_type == MAZE_MULTIPASS_TRAPS )
    v2 &= write_maze_multipass(a1, hObject);
  CloseHandle(hObject);
  return v2 != 0;
}

//----- (0000000140003680) ----------------------------------------------------
__int64 __fastcall load_maze_info(maze *a1, IStream *a2)
{
  size_t v2; // rax
  char *data; // [rsp+30h] [rbp-38h]
  unsigned __int64 v5; // [rsp+38h] [rbp-30h]
  ULONG v6; // [rsp+48h] [rbp-20h] BYREF

  v6 = 0;
  v5 = a1->height * (unsigned __int64)a1->width;
  v2 = v5 + 1;
  if ( v5 == -1i64 )
    v2 = -1i64;
  data = (char *)calloc(v2, 1ui64);
  if ( !data )
    return 0i64;
  if ( a1->maze_type < MAZE_MULTIPASS )
    a1->maze_data.classic.maze = data;
  else
    a1->maze_data.multipass.maze = data;
  data[v5] = 0;
  if ( !a2->lpVtbl->Read(a2, data, v5, &v6) )
    return 1i64;
  free(data);
  return 0i64;
}

//----- (00000001400037A0) ----------------------------------------------------
_BOOL8 __fastcall load_maze_common(maze *a1, IStream *inf)
{
  char v3[4]; // [rsp+58h] [rbp-20h] BYREF
  ULONG v4; // [rsp+5Ch] [rbp-1Ch] BYREF

  v4 = 0;
  v3[0] = 0;
  if ( inf->lpVtbl->Read(inf, v3, 1u, &v4) )
    return 0i64;
  if ( inf->lpVtbl->Read(inf, a1->creator_name, (unsigned __int8)v3[0], &v4) )// bug: what if username length > 0x80?
    return 0i64;
  if ( inf->lpVtbl->Read(inf, &a1->maze_type, 1u, &v4) )
    return 0i64;
  if ( inf->lpVtbl->Read(inf, a1, 1u, &v4) )
    return 0i64;
  if ( inf->lpVtbl->Read(inf, &a1->height, 1u, &v4) )
    return 0i64;
  return (unsigned int)load_maze_info(a1, inf) != 0;
}

//----- (0000000140003970) ----------------------------------------------------
__int64 __fastcall load_maze_traps(maze *a1, IStream *a2)
{
  int i; // [rsp+30h] [rbp-48h]
  maze_data *v4; // [rsp+38h] [rbp-40h]
  ULONG v5; // [rsp+60h] [rbp-18h] BYREF

  v5 = 0;
  v4 = &a1->maze_data;
  if ( a2->lpVtbl->Read(a2, &a1->maze_data, 1u, &v5) )
    return 0i64;
  for ( i = 0; i < v4->multipass.num_traps; ++i )
  {
    if ( a2->lpVtbl->Read(a2, (char *)&v4->classic.maze + 15 * i + 1, 8u, &v5) )
      return 0i64;
    if ( a2->lpVtbl->Read(a2, &v4->multipass.traps[i].position, 2u, &v5) )
      return 0i64;
    if ( a2->lpVtbl->Read(a2, &v4->multipass.traps[i].character, 1u, &v5) )
      return 0i64;
  }
  return 1i64;
}

//----- (0000000140003B30) ----------------------------------------------------
maze *__fastcall load_maze(const CHAR *a1)
{
  maze *result; // rax
  maze *Block; // [rsp+20h] [rbp-38h]
  IStream *ppstm; // [rsp+38h] [rbp-20h] BYREF

  if ( SHCreateStreamOnFileA(a1, 0, &ppstm) )
    return 0i64;
  Block = (maze *)calloc(1ui64, 0x540Eui64);
  if ( !Block )
    return 0i64;
  if ( load_maze_common(Block, ppstm) )
  {
    if ( Block->maze_type == MAZE_MULTIPASS
      || Block->maze_type < MAZE_MULTIPASS_TRAPS
      || (unsigned int)load_maze_traps(Block, ppstm) )
    {
      ppstm->lpVtbl->Release(ppstm);
      result = Block;
    }
    else
    {
      maze_delete(Block);
      free(Block);
      result = 0i64;
    }
  }
  else
  {
    free(Block);
    ppstm->lpVtbl->Release(ppstm);
    result = 0i64;
  }
  return result;
}

//----- (0000000140003C60) ----------------------------------------------------
__int64 __fastcall get_maze_list(maze_paths *a1)
{
  int i; // [rsp+20h] [rbp-278h]
  HANDLE hFindFile; // [rsp+28h] [rbp-270h]
  struct _WIN32_FIND_DATAA FindFileData; // [rsp+30h] [rbp-268h] BYREF
  CHAR FileName[272]; // [rsp+170h] [rbp-128h] BYREF

  snprintf(FileName, 0x104ui64, "%s\\*.maze", cwd);
  hFindFile = FindFirstFileA(FileName, &FindFileData);
  if ( hFindFile == (HANDLE)-1i64 )
    return 0i64;
  i = 0;
  do
  {
    if ( (FindFileData.dwFileAttributes & 0x10) == 0 )
      strcpy_s(a1->paths[(__int64)i++].path, 0xFFui64, FindFileData.cFileName);
  }
  while ( FindNextFileA(hFindFile, &FindFileData) && i < 32 );
  FindClose(hFindFile);
  return (unsigned int)i;
}

//----- (0000000140003D50) ----------------------------------------------------
__int64 __fastcall print_maze_list(maze_paths *a1, unsigned int a2)
{
  __int64 result; // rax
  signed int i; // [rsp+20h] [rbp-18h]

  printf("List of existing mazes\n");
  for ( i = 0; ; ++i )
  {
    result = a2;
    if ( i >= (int)a2 )
      break;
    printf("%d -> %s\n", (unsigned int)(i + 1), a1->paths[(__int64)i].path);
  }
  return result;
}

//----- (0000000140003DC0) ----------------------------------------------------
__int64 __fastcall read_ranks(maze *a1)
{
  __int64 result; // rax
  int i; // [rsp+30h] [rbp-178h]
  IStream *ppstm; // [rsp+80h] [rbp-128h] BYREF
  char v4[4]; // [rsp+88h] [rbp-120h] BYREF
  ULONG v5; // [rsp+8Ch] [rbp-11Ch] BYREF
  CHAR pszFile[256]; // [rsp+90h] [rbp-118h] BYREF

  snprintf(pszFile, 0x100ui64, "%s\\%s.rank", cwd, a1->maze_name);
  if ( SHCreateStreamOnFileA(pszFile, 0, &ppstm) )
    return 0i64;
  if ( ppstm->lpVtbl->Read(ppstm, &a1->rank_data, 1u, &v5) )
  {
LABEL_10:
    ppstm->lpVtbl->Release(ppstm);
    result = 0i64;
  }
  else
  {
    for ( i = 0; i < a1->rank_data.nr_ranks; ++i )
    {
      if ( ppstm->lpVtbl->Read(ppstm, v4, 1u, &v5)
        || ppstm->lpVtbl->Read(ppstm, a1->rank_data.ranks[i].name, (unsigned __int8)v4[0], &v5)
        || ppstm->lpVtbl->Read(ppstm, &a1->rank_data.ranks[i], 8u, &v5) )
      {
        goto LABEL_10;
      }
    }
    ppstm->lpVtbl->Release(ppstm);
    result = 1i64;
  }
  return result;
}

//----- (00000001400040A0) ----------------------------------------------------
_BOOL8 __fastcall do_load_ranks(maze *a1)
{
  maze_clear_ranks(a1);
  return (unsigned int)read_ranks(a1) != 0;
}

//----- (00000001400040D0) ----------------------------------------------------
maze *do_load_maze()
{
  maze *result; // rax
  int v1; // [rsp+30h] [rbp-23C8h]
  HANDLE hFindFile; // [rsp+38h] [rbp-23C0h]
  HANDLE hFindFilea; // [rsp+38h] [rbp-23C0h]
  signed int a2; // [rsp+40h] [rbp-23B8h]
  __int64 pathlen; // [rsp+48h] [rbp-23B0h]
  unsigned __int64 pathlen_; // [rsp+50h] [rbp-23A8h]
  __int64 v7; // [rsp+58h] [rbp-23A0h]
  maze *v8; // [rsp+60h] [rbp-2398h]
  struct _WIN32_FIND_DATAA FindFileData; // [rsp+80h] [rbp-2378h] BYREF
  char inpath[128]; // [rsp+1C0h] [rbp-2238h] BYREF
  char Destination[129]; // [rsp+240h] [rbp-21B8h] BYREF
  char FileName[261]; // [rsp+2D0h] [rbp-2128h] BYREF
  maze_paths mazelist; // [rsp+3E0h] [rbp-2018h] BYREF

  memset(&mazelist, 0, sizeof(mazelist));
  a2 = get_maze_list(&mazelist);
  if ( a2 )
  {
    print_maze_list(&mazelist, a2);
    memset(inpath, 0, sizeof(inpath));
    memset(FileName, 0, sizeof(FileName));
    memset(Destination, 0, sizeof(Destination));
    while ( 1 )
    {
      while ( 1 )
      {
        printf(
          "Which maze do you want ? send its identifier or its name (w or wo extension).\n"
          " You can send -1 to come back to the main menu.\n");
        read_string(inpath, 0x80u);
        v1 = atoi(inpath);
        if ( v1 == -1 )
          return 0i64;
        if ( v1 > 0 && v1 <= a2 )
        {
          pathlen = -1i64;
          do
            ++pathlen;
          while ( mazelist.paths[(__int64)(v1 - 1)].path[pathlen] );
          memcpy_s(Destination, 0x80ui64, &mazelist.paths[(__int64)(v1 - 1)], pathlen - 5);// bug? what if pathlen < 5 (*unlikely, glob is on *.maze)
          snprintf(FileName, 0x104ui64, "%s\\%s", cwd, mazelist.paths[(__int64)(v1 - 1)].path);
          goto load;
        }
        if ( is_valid_filename(inpath) )
          break;
        printf("Name of maze contains forbidden characters\n");
      }
      snprintf(FileName, 0x104ui64, "%s\\%s", cwd, inpath);
      hFindFile = FindFirstFileA(FileName, &FindFileData);
      pathlen_ = -1i64;
      do
        ++pathlen_;
      while ( inpath[pathlen_] );
      if ( pathlen_ > 5 && hFindFile != (HANDLE)-1i64 )
        break;
      if ( hFindFile != (HANDLE)-1i64 )
        FindClose(hFindFile);
      snprintf(FileName, 0x104ui64, "%s\\%s.maze", cwd, inpath);
      hFindFilea = FindFirstFileA(FileName, &FindFileData);
      if ( hFindFilea != (HANDLE)-1i64 )
      {
        strcpy_s(Destination, 0x80ui64, inpath);
        FindClose(hFindFilea);
        goto load;
      }
    }
    v7 = -1i64;
    do
      ++v7;
    while ( inpath[v7] );
    memcpy_s(Destination, 0x80ui64, inpath, v7 - 5);
    FindClose(hFindFile);
load:
    v8 = load_maze(FileName);
    if ( v8 )
    {
      memset(v8->maze_name, 0, sizeof(v8->maze_name));
      strcpy_s(v8->maze_name, 0x80ui64, Destination);
      result = v8;
    }
    else
    {
      result = 0i64;
    }
  }
  else
  {
    printf("There is no maze to load. Please create one before.\n");
    result = 0i64;
  }
  return result;
}

//----- (00000001400044C0) ----------------------------------------------------
__int64 __fastcall read_char(char *a1)
{
  unsigned int v2; // [rsp+20h] [rbp-18h]

  v2 = scanf_s("%c", a1);
  eat_newline();
  return v2;
}

//----- (0000000140004500) ----------------------------------------------------
maze *__fastcall do_create_maze(user *a1)
{
  maze *result; // rax
  maze *maze; // [rsp+30h] [rbp-2308h]
  HANDLE hFindFile; // [rsp+40h] [rbp-22F8h]
  char v4; // [rsp+48h] [rbp-22F0h] BYREF
  char v5[3]; // [rsp+49h] [rbp-22EFh] BYREF
  int v6; // [rsp+4Ch] [rbp-22ECh] BYREF
  struct _WIN32_FIND_DATAA FindFileData; // [rsp+50h] [rbp-22E8h] BYREF
  CHAR FileName[400]; // [rsp+190h] [rbp-21A8h] BYREF
  maze_paths v9; // [rsp+320h] [rbp-2018h] BYREF

  memset(&v9, 0, sizeof(v9));
  if ( (int)get_maze_list(&v9) < 32 )
  {
    maze = (maze *)calloc(1ui64, 0x540Eui64);
    if ( maze )
    {
      do
      {
        do
          printf("Choose the level of your maze :\n\t1. Classic maze\n\t2. Maze multipass \n\t3. Maze multipass with traps\n");
        while ( get_int(&v6) );
      }
      while ( v6 < 1 || v6 > 3 );
      maze->maze_type = v6;
      printf("Random maze or custom maze ? r/c ");
      v4 = 0;
      do
      {
        read_char(&v4);
        if ( v4 == 'r' )
        {
          if ( make_random_maze(maze) )
            goto LABEL_17;
          goto LABEL_18;
        }
      }
      while ( v4 != 'c' );
      if ( !make_custom_maze(maze) )
        goto LABEL_18;
LABEL_17:
      if ( !(unsigned int)mazeinit(maze) )
      {
LABEL_18:
        free(maze);
        return 0i64;
      }
      maze->rank_data.nr_ranks = 0;
      maze_print(maze, maze->width + 1i64);
      printf("Do you want to save this maze ? y/n ");
      v5[0] = 0;
      read_char(v5);
      if ( v5[0] == 'y' )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            printf("What the name of the maze to save ?");
            if ( read_string(maze->maze_name, 0x80u) == 1 && is_valid_filename(maze->maze_name) )
              break;
            printf("Bad name, maybe too long or containing non alphabetical chars?\n");
          }
          memset(FileName, 0, sizeof(FileName));
          snprintf(FileName, 0x190ui64, "%s\\%s.maze", cwd, maze->maze_name);
          hFindFile = FindFirstFileA(FileName, &FindFileData);
          if ( hFindFile == (HANDLE)-1i64 )
            break;
          printf("A maze with this name already exists\n");
          FindClose(hFindFile);
        }
        strcpy_s(maze->creator_name, 0x80ui64, a1->name);
        if ( write_maze(maze) && write_ranks(maze) )
          printf("Maze saved as %s\n", maze->maze_name);
        else
          printf("Problem while saving maze\n");
        result = maze;
      }
      else
      {
        printf("I forgot the maze \n");
        maze_delete(maze);
        free(maze);
        result = 0i64;
      }
    }
    else
    {
      result = 0i64;
    }
  }
  else
  {
    printf("There is already too many mazes, please remove one before creating a new one.\n");
    result = 0i64;
  }
  return result;
}

//----- (0000000140004840) ----------------------------------------------------
__int64 __fastcall add_rank(rank *a1, rank_data *a2)
{
  unsigned __int64 i; // [rsp+0h] [rbp-28h]

  for ( i = 0i64; ; ++i )
  {
    if ( i >= 0x80 )
      return 0i64;
    if ( a2->nr_ranks <= i )
    {
      ++a2->nr_ranks;
      qmemcpy(&a2->ranks[i], a1, sizeof(a2->ranks[i]));
      return 1i64;
    }
    if ( a1->score < a2->ranks[i].score )
      break;
  }
  qmemcpy(&a2->ranks[i + 1], &a2->ranks[i], 136 * (128 - i - 1));
  qmemcpy(&a2->ranks[i], a1, sizeof(a2->ranks[i]));
  if ( a2->nr_ranks < 0x80u )
    ++a2->nr_ranks;
  return 1i64;
}

//----- (0000000140004980) ----------------------------------------------------
__int64 __fastcall write_ranks_0(maze *a1)
{
  unsigned __int8 i; // [rsp+40h] [rbp-148h]
  BOOL v3; // [rsp+44h] [rbp-144h]
  int v4; // [rsp+44h] [rbp-144h]
  int v5; // [rsp+44h] [rbp-144h]
  HANDLE hFile; // [rsp+48h] [rbp-140h]
  __int64 v7; // [rsp+50h] [rbp-138h]
  char Buffer[4]; // [rsp+60h] [rbp-128h] BYREF
  DWORD NumberOfBytesWritten; // [rsp+64h] [rbp-124h] BYREF
  CHAR FileName[256]; // [rsp+70h] [rbp-118h] BYREF

  snprintf(FileName, 0x100ui64, "%s\\%s.rank", cwd, a1->maze_name);
  hFile = CreateFileA(FileName, 0x40000000u, 0, 0i64, 2u, 0x80u, 0i64);
  if ( hFile == (HANDLE)-1i64 )
    return 0i64;
  v3 = WriteFile(hFile, &a1->rank_data, 1u, &NumberOfBytesWritten, 0i64);
  for ( i = 0; i < (int)a1->rank_data.nr_ranks; ++i )
  {
    v7 = -1i64;
    do
      ++v7;
    while ( a1->rank_data.ranks[i].name[v7] );
    Buffer[0] = v7;
    v4 = WriteFile(hFile, Buffer, 1u, &NumberOfBytesWritten, 0i64) && v3;
    v5 = WriteFile(hFile, a1->rank_data.ranks[i].name, (unsigned __int8)Buffer[0], &NumberOfBytesWritten, 0i64) & v4;
    v3 = WriteFile(hFile, &a1->rank_data.ranks[i], 8u, &NumberOfBytesWritten, 0i64) & v5;
  }
  CloseHandle(hFile);
  return 1i64;
}

//----- (0000000140004BB0) ----------------------------------------------------
int __fastcall maze_view_scoreboard(maze *a1)
{
  unsigned __int8 i; // [rsp+20h] [rbp-18h]

  if ( !a1->rank_data.nr_ranks )
    return printf("There is no Scoreboard for %s yet\n", a1->maze_name);
  printf("Scoreboard for %s (created by %s)\n", a1->maze_name, a1->creator_name);
  printf("Rank.\tScore\tpseudo\n");
  for ( i = 0; i < (int)a1->rank_data.nr_ranks; ++i )
    printf("%d.\t%ju\t%s\n", (unsigned int)i + 1, a1->rank_data.ranks[i].score, a1->rank_data.ranks[i].name);
  return printf("-*-*-*-*-*-*-*\n");
}

//----- (0000000140004CA0) ----------------------------------------------------
__int64 __fastcall maze_update_traps(maze *a1)
{
  FILE *v1; // rax
  __int64 result; // rax
  unsigned __int64 j; // [rsp+20h] [rbp-68h]
  __int64 v4; // [rsp+28h] [rbp-60h]
  __int64 v5; // [rsp+28h] [rbp-60h]
  unsigned __int64 k; // [rsp+30h] [rbp-58h]
  unsigned __int64 v7; // [rsp+38h] [rbp-50h]
  unsigned __int64 i; // [rsp+40h] [rbp-48h]
  __int64 v9; // [rsp+48h] [rbp-40h]
  __int64 v10; // [rsp+50h] [rbp-38h]
  char v11[8]; // [rsp+68h] [rbp-20h] BYREF

  v11[0] = 0;
  printf("Do you want to update traps positions y/n?");
  read_char(v11);
  if ( v11[0] != 121 )
    return 0i64;
  v7 = a1->height * (unsigned __int64)a1->width;
  printf("Please enter new data respecting the format, for example, current data maze is :\n");
  for ( i = 0i64; i < a1->maze_data.multipass.num_traps; ++i )
    a1->maze_data.multipass.traps[i].is_hit = 1;
  maze_multipass_print(a1, -1i64, 0);
  printf("\n-*-*-*-*-*-*-*\n");
  v1 = _acrt_iob_func(0);
  fgets(a1->maze_data.multipass.maze, v7 + 1, v1);
  eat_newline();
  v4 = 0i64;
  v9 = -1i64;
  do
    ++v9;
  while ( a1->maze_data.multipass.maze[v9] );
  if ( v9 == v7 )
  {
    for ( j = 0i64; j < v7; ++j )
    {
      if ( a1->maze_data.multipass.maze[j] != '#'
        && a1->maze_data.multipass.maze[j] != ' '
        && a1->maze_data.multipass.maze[j] != '^'
        && a1->maze_data.multipass.maze[j] != 'o' )
      {
        printf("Only #, SPACE, o,  and ^ are allowed.\n");
        return 0i64;
      }
      if ( a1->maze_data.multipass.maze[j] == '^' )
        ++v4;
    }
    if ( v4 == a1->maze_data.multipass.num_traps )
    {
      v5 = 0i64;
      for ( k = 0i64; k < v7; ++k )
      {
        if ( a1->maze_data.multipass.maze[k] == '^' )
        {
          a1->maze_data.multipass.maze[k] = ' ';
          a1->maze_data.multipass.traps[v5++].position = k;
        }
        if ( a1->maze_data.multipass.maze[k] == 'o' )
          a1->maze_data.multipass.maze[k] = ' ';
      }
      a1->maze_data.multipass.maze[a1->width * (a1->height - 2) - 1 + a1->width] = 'o';
      result = 1i64;
    }
    else
    {
      printf("Number of traps need to be %d, input = %ju\n", a1->maze_data.multipass.num_traps, v4);
      result = 0i64;
    }
  }
  else
  {
    v10 = -1i64;
    do
      ++v10;
    while ( a1->maze_data.multipass.maze[v10] );
    printf("size of input need to be %zd, given is %zd\n", v7, v10);
    result = 0i64;
  }
  return result;
}

//----- (0000000140005090) ----------------------------------------------------
__int64 __fastcall do_upgrade_maze_traps(maze *a1)
{
  char v2[8]; // [rsp+20h] [rbp-18h] BYREF

  v2[0] = 0;
  printf("Do you want to upgrade to level multipass with trap ? y/n: ");
  read_char(v2);
  if ( v2[0] != 121 )
    return 0i64;
  a1->maze_type = MAZE_MULTIPASS_TRAPS;
  maze_custom_traps(a1);
  mazeinit_traps_init((__int64)a1->maze_data.multipass.maze, (maze_multipass *)&a1->maze_data, a1->width, a1->height);
  maze_print(a1, a1->width + 1i64);
  return 1i64;
}

//----- (0000000140005150) ----------------------------------------------------
__int64 __fastcall do_upgrade_maze_multipass(maze *a1)
{
  char v2[8]; // [rsp+20h] [rbp-18h] BYREF

  v2[0] = 0;
  printf("Do you want to upgrade to level multipass ? y/n: ");
  read_char(v2);
  if ( v2[0] != 121 )
    return 0i64;
  a1->maze_type = MAZE_MULTIPASS;
  a1->maze_data.multipass.maze = a1->maze_data.classic.maze;
  memset(&a1->maze_data, 0, 0xF01ui64);
  a1->maze_data.multipass.num_traps = 0;
  maze_custom_multipass(a1);
  mazeinit_multipass_init(
    a1->maze_data.multipass.maze,
    a1->width,
    a1->height,
    a1->maze_data.multipass.wall_percent_to_remove);
  maze_print(a1, a1->width + 1i64);
  return 1i64;
}

//----- (0000000140005250) ----------------------------------------------------
__int64 __fastcall maze_remove_files(maze *a1)
{
  bool v2; // [rsp+30h] [rbp-348h]
  char FileName[400]; // [rsp+40h] [rbp-338h] BYREF
  char Buffer[400]; // [rsp+1D0h] [rbp-1A8h] BYREF

  memset(FileName, 0, sizeof(FileName));
  snprintf(FileName, 0x190ui64, "%s\\%s.maze", cwd, a1->maze_name);
  memset(Buffer, 0, sizeof(Buffer));
  snprintf(Buffer, 0x190ui64, "%s\\%s.rank", cwd, a1->maze_name);
  v2 = remove(FileName) == 0;
  return (remove(Buffer) == 0) & (unsigned __int8)v2;
}

//----- (0000000140005380) ----------------------------------------------------
__int64 __fastcall do_save_maze(maze *rcx0)
{
  __int64 result; // rax
  char v2[8]; // [rsp+20h] [rbp-18h] BYREF

  v2[0] = 0;
  printf("Do you want to save this maze ? y/n ");
  read_char(v2);
  if ( v2[0] != 121 )
    return 1i64;
  if ( (unsigned int)maze_remove_files(rcx0) )
  {
    if ( !write_maze(rcx0) || !write_ranks(rcx0) )
      printf("Problem while saving maze\n");
    printf("Maze upgraded !\n");
    result = 1i64;
  }
  else
  {
    printf("Problem while removing maze\n");
    result = 0i64;
  }
  return result;
}

//----- (0000000140005430) ----------------------------------------------------
__int64 __fastcall alarm_thread(LPVOID lpThreadParameter)
{
  HANDLE v1; // rax

  Sleep((DWORD)lpThreadParameter);
  v1 = GetCurrentProcess();
  TerminateProcess(v1, 1u);
  return 1i64;
}

//----- (0000000140005470) ----------------------------------------------------
char __fastcall set_alarm(unsigned int a1)
{
  FILE *v2; // rax

  if ( !CreateThread(0i64, 0i64, (LPTHREAD_START_ROUTINE)alarm_thread, (LPVOID)a1, 0, 0i64) )
    return 0;
  v2 = _acrt_iob_func(1u);
  setvbuf(v2, 0i64, 4, 0i64);
  return 1;
}

//----- (00000001400054E0) ----------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  FILE *v4; // rax
  int result; // eax
  unsigned int v6; // eax
  char is_registered; // [rsp+30h] [rbp-3B8h]
  char v8; // [rsp+31h] [rbp-3B7h]
  unsigned __int64 i; // [rsp+38h] [rbp-3B0h]
  rank v10; // [rsp+50h] [rbp-398h] BYREF
  user v11; // [rsp+E0h] [rbp-308h] BYREF
  user a1; // [rsp+170h] [rbp-278h] BYREF
  maze *maze; // [rsp+1FAh] [rbp-1EEh]
  char v14; // [rsp+210h] [rbp-1D8h] BYREF
  char v15[3]; // [rsp+211h] [rbp-1D7h] BYREF
  int input[3]; // [rsp+214h] [rbp-1D4h] BYREF
  rank v17; // [rsp+220h] [rbp-1C8h] BYREF
  char Buffer[272]; // [rsp+2B0h] [rbp-138h] BYREF

  is_registered = 0;
  v3 = _acrt_iob_func(1u);
  setvbuf(v3, 0i64, 4, 0i64);
  v4 = _acrt_iob_func(0);
  setvbuf(v4, 0i64, 4, 0i64);
  if ( getcwd(cwd, 260) )
  {
    if ( set_alarm(500000u) )
    {
      v6 = time(0i64);
      srand(v6);
      a1.score = 0i64;
      memset(&a1.x, 0, sizeof(user));
      while ( 1 )
      {
        printf(
          "Menu\n"
          "\n"
          "1. Register\n"
          "2. Create maze\n"
          "3. Load maze\n"
          "4. Play maze\n"
          "5. Remove maze\n"
          "6. View scoreboard\n"
          "7. Upgrade\n"
          "8. Exit\n");
        if ( get_int(input) )
          break;
        switch ( input[0] )
        {
          case 1:
            if ( do_register(&a1) )
            {
              is_registered = 1;
            }
            else
            {
              printf("Problem while registering. Please retry\n");
              is_registered = 0;
            }
            break;
          case 2:
            if ( is_registered )
            {
              if ( maze )
              {
                maze_delete(maze);
                free(maze);
                maze = 0i64;
              }
              qmemcpy(&v11, &a1, sizeof(v11));
              maze = do_create_maze(&v11);
            }
            else
            {
              printf("Need to register before playing\n");
            }
            break;
          case 3:
            if ( is_registered )
            {
              if ( maze )
              {
                maze_delete(maze);
                free(maze);
                maze = 0i64;
              }
              maze = do_load_maze();
              if ( maze )
              {
                if ( !do_load_ranks(maze) )
                  printf("Problem loading highscores\n");
              }
              else
              {
                printf("Problem loading maze\n");
              }
            }
            else
            {
              printf("Need to register before playing\n");
            }
            break;
          case 4:
            if ( is_registered )
            {
              if ( maze )
              {
                if ( maze->maze_type == MAZE_MULTIPASS_TRAPS )
                {
                  for ( i = 0i64; i < maze->maze_data.multipass.num_traps; ++i )
                    maze->maze_data.multipass.traps[i].is_hit = 1;
                }
                a1.x = 1;
                a1.y = 1;
                a1.score = -1i64;
                v8 = 1;
                while ( a1.x != maze->width - 1 || a1.y != maze->height - 2 )
                {
                  maze_print(maze, a1.x + maze->width * (unsigned __int64)a1.y);
                  if ( v8 )
                  {
                    printf("Use zqsd to move and x to exit\n");
                    v8 = 0;
                  }
                  while ( (unsigned int)read_motion(&v14) )
                    read_motion(&v14);
                  if ( v14 == 'x' )
                    goto LABEL_71;
                  do_motion(maze, &a1, v14);
                  printf("Current score %ju\n", a1.score);
                }
                printf("YOU WIN with a score of %zd\n", a1.score);
                v17.score = a1.score;
                qmemcpy(v17.name, a1.name, sizeof(v17.name));
                qmemcpy(&v10, &v17, sizeof(v10));
                if ( (unsigned int)add_rank(&v10, &maze->rank_data) )
                  write_ranks_0(maze);
              }
              else
              {
                printf("Need to load a maze before playing\n");
              }
            }
            else
            {
              printf("Need to register before playing\n");
            }
            break;
          case 5:
            if ( is_registered )
            {
              if ( !maze )
                maze = do_load_maze();
              if ( maze )
              {
                printf("Are you sure to remove %s y/n ?", maze->maze_name);
                v15[0] = 0;
                read_char(v15);
                if ( v15[0] == 'y' )
                {
                  maze_remove_files(maze);
                  free(maze);
                  maze = 0i64;
                }
              }
            }
            else
            {
              printf("Need to register before removing a maze\n");
            }
            break;
          case 6:
            if ( maze )
              maze_view_scoreboard(maze);
            else
              printf("Need to load a maze before show its scoreboard\n");
            break;
          case 7:
            if ( maze )
            {
              if ( maze->maze_type == MAZE_MULTIPASS_TRAPS )
              {
                if ( (unsigned int)maze_update_traps(maze) )
                {
                  printf("Trap positions have been updated\n");
                  do_save_maze(maze);
                  snprintf(Buffer, 0x104ui64, "%s\\%s.maze", cwd, maze->maze_name);
                  free(maze);
                  maze = 0i64;
                  maze = load_maze(Buffer);
                }
                else
                {
                  printf("Problem during the modification of trap positions. Please retry\n");
                }
              }
              else
              {
                maze_print(maze, maze->width + 1i64);
                if ( maze->maze_type == MAZE_MULTIPASS )
                {
                  if ( (unsigned int)do_upgrade_maze_traps(maze) )
                    do_save_maze(maze);
                }
                else if ( (unsigned int)do_upgrade_maze_multipass(maze) )
                {
                  do_upgrade_maze_traps(maze);
                  do_save_maze(maze);
                }
              }
            }
            else
            {
              printf("Need to load a maze before upgrading it\n");
            }
            break;
          case 8:
            printf("Goodbye\n");
            break;
          default:
            printf("Wrong Choice. Enter again\n");
            break;
        }
LABEL_71:
        if ( input[0] == 8 )
          goto LABEL_72;
      }
      printf("This is not a number !! GoodBye\n");
LABEL_72:
      result = 0;
    }
    else
    {
      result = -1;
    }
  }
  else
  {
    printf("Problem getting working dir\n");
    result = 0;
  }
  return result;
}

//----- (0000000140005F20) ----------------------------------------------------
__int64 __fastcall sub_140005F20(DWORD64 a1)
{
  DWORD64 retaddr; // [rsp+38h] [rbp+0h]
  DWORD64 v3; // [rsp+40h] [rbp+8h] BYREF

  v3 = a1;
  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  capture_previous_context(&ContextRecord);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&v3;
  qword_14000A070 = retaddr;
  ContextRecord.Rcx = v3;
  dword_14000A060 = -1073740791;
  dword_14000A064 = 1;
  dword_14000A078 = 1;
  unk_14000A080 = 2i64;
  return _raise_securityfailure((struct _EXCEPTION_POINTERS *)&ExceptionInfo);
}
// 14000A060: using guessed type int dword_14000A060;
// 14000A064: using guessed type int dword_14000A064;
// 14000A070: using guessed type __int64 qword_14000A070;
// 14000A078: using guessed type int dword_14000A078;

//----- (0000000140006370) ----------------------------------------------------
__int64 __fastcall UserMathErrorFunction(struct _exception *a1)
{
  return 0i64;
}

//----- (0000000140006384) ----------------------------------------------------
void sub_140006384()
{
  InitializeSListHead(&stru_14000A620);
}

//----- (0000000140006394) ----------------------------------------------------
char sub_140006394()
{
  return 1;
}

//----- (00000001400063CC) ----------------------------------------------------
void *sub_1400063CC()
{
  return &unk_14000A770;
}

//----- (00000001400063D4) ----------------------------------------------------
void *sub_1400063D4()
{
  return &unk_14000A768;
}

//----- (00000001400063DC) ----------------------------------------------------
void sub_1400063DC()
{
  dword_14000A630 = 0;
}
// 14000A630: using guessed type int dword_14000A630;

//----- (00000001400063E4) ----------------------------------------------------
void __fastcall sub_1400063E4(unsigned int a1)
{
  DWORD64 v2; // rbx
  struct _IMAGE_RUNTIME_FUNCTION_ENTRY *v3; // rax
  bool v4; // bl
  struct _EXCEPTION_POINTERS ExceptionInfo; // [rsp+40h] [rbp-C0h] BYREF
  _QWORD v6[20]; // [rsp+50h] [rbp-B0h] BYREF
  struct _CONTEXT ContextRecord; // [rsp+F0h] [rbp-10h] BYREF
  DWORD64 retaddr; // [rsp+5C8h] [rbp+4C8h]
  __int64 v9; // [rsp+5D0h] [rbp+4D0h] BYREF
  unsigned __int64 ImageBase; // [rsp+5D8h] [rbp+4D8h] BYREF
  unsigned __int64 EstablisherFrame; // [rsp+5E0h] [rbp+4E0h] BYREF
  PVOID HandlerData; // [rsp+5E8h] [rbp+4E8h] BYREF

  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(a1);
  sub_1400063DC();
  memset(&ContextRecord, 0, sizeof(ContextRecord));
  RtlCaptureContext(&ContextRecord);
  v2 = ContextRecord.Rip;
  v3 = RtlLookupFunctionEntry(ContextRecord.Rip, &ImageBase, 0i64);
  if ( v3 )
    RtlVirtualUnwind(0, ImageBase, v2, v3, &ContextRecord, &HandlerData, &EstablisherFrame, 0i64);
  ContextRecord.Rip = retaddr;
  ContextRecord.Rsp = (DWORD64)&v9;
  memset(v6, 0, 0x98ui64);
  v6[2] = retaddr;
  v6[0] = 0x140000015i64;
  ExceptionInfo.ExceptionRecord = (PEXCEPTION_RECORD)v6;
  v4 = IsDebuggerPresent();
  ExceptionInfo.ContextRecord = &ContextRecord;
  SetUnhandledExceptionFilter(0i64);
  if ( !UnhandledExceptionFilter(&ExceptionInfo) && !v4 )
    sub_1400063DC();
}

//----- (00000001400065FC) ----------------------------------------------------
void sub_1400065FC()
{
  void (**i)(void); // rbx

  for ( i = qword_140008308; i < qword_140008308; ++i )
  {
    if ( *i )
      (*i)();
  }
}

//----- (0000000140006640) ----------------------------------------------------
void __fastcall sub_140006640()
{
  void (**i)(void); // rbx

  for ( i = &qword_140008318; i < &qword_140008318; ++i )
  {
    if ( *i )
      (*i)();
  }
}

// nfuncs=140 queued=80 decompiled=80 lumina nreq=0 worse=0 better=0
// ALL OK, 80 function(s) have been successfully decompiled
