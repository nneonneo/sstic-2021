/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_2020();
// __int64 __fastcall vlc_stream_Delete(_QWORD); weak
// __int64 __fastcall vlc_mutex_unlock(_QWORD); weak
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// int unlink(const char *name);
// __int64 __fastcall var_Inherit(_QWORD, _QWORD, _QWORD, _QWORD); weak
// double strtod(const char *nptr, char **endptr);
// struct lconv *localeconv(void);
// __int64 __fastcall gcry_cipher_setkey(_QWORD, _QWORD, _QWORD); weak
// ssize_t write(int fd, const void *buf, size_t n);
// __int64 __fastcall gcry_cipher_setctr(_QWORD, _QWORD, _QWORD); weak
// __int64 vlc_Log(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, const char *, ...); weak
// __int64 vlc_dialog_display_error(_QWORD, _QWORD, const char *, ...); weak
// size_t strlen(const char *s);
// __int64 __fastcall vlc_mutex_destroy(_QWORD); weak
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// void *memset(void *s, int c, size_t n);
// char *strncat(char *dest, const char *src, size_t n);
// int close(int fd);
// __int64 __fastcall gcry_check_version(_QWORD); weak
// __int64 __fastcall vlc_UrlParse(__int64 a1, __int64 a2);
// __int64 __fastcall vlc_join(_QWORD, _QWORD); weak
// ssize_t read(int fd, void *buf, size_t nbytes);
// __int64 __fastcall vlc_readdir_helper_additem(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int mkstemp64(char *template);
// __int64 __fastcall gcry_cipher_ctl(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int mkstemps64(char *template, int suffixlen);
// unsigned __int64 strtoull(const char *nptr, char **endptr, int base);
// void *calloc(size_t nmemb, size_t size);
// __int64 __fastcall vlc_gettext(_QWORD); weak
// int strcmp(const char *s1, const char *s2);
// __int64 __fastcall gcry_cipher_open(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
// __int64 __fastcall input_item_Release(_QWORD); weak
// __int64 __fastcall var_GetChecked(_QWORD, _QWORD, _QWORD, _QWORD); weak
// void *memcpy(void *dest, const void *src, size_t n);
// __int64 __fastcall vlc_uri_encode(_QWORD); weak
// time_t time(time_t *timer);
// void *dlopen(const char *file, int mode);
// __int64 __fastcall vlc_readdir_helper_init(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall vlc_mutex_lock(_QWORD); weak
// __int64 __fastcall vlc_stream_Eof(_QWORD); weak
// __int64 __fastcall var_Create(_QWORD, _QWORD, _QWORD); weak
// int sscanf(const char *s, const char *format, ...);
// __int64 __fastcall vlc_mutex_init(_QWORD); weak
// int dlclose(void *handle);
// int asprintf(char **ptr, const char *fmt, ...);
// __int64 __fastcall input_item_NewExt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall vlc_sd_probe_Add(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
// __int64 __fastcall vlc_stream_ReadPartial(_QWORD, _QWORD, _QWORD); weak
// int chmod(const char *file, __mode_t mode);
// __int64 __fastcall vlc_clone(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall gcry_cipher_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall vlc_stream_NewURL(_QWORD, _QWORD); weak
// __int64 __fastcall input_item_AddOption(_QWORD, _QWORD, _QWORD); weak
// int sprintf(char *s, const char *format, ...);
// __int64 __fastcall vlc_global_mutex(_QWORD, _QWORD); weak
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// __off64_t lseek64(int fd, __off64_t offset, int whence);
// __int64 __fastcall vlc_stream_Read(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall vlc_readdir_helper_finish(_QWORD, _QWORD); weak
// __int64 __fastcall gcry_cipher_close(_QWORD); weak
// __int64 __fastcall vlc_UrlClean(_QWORD, _QWORD, _QWORD); weak
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// char *strdup(const char *s);
// void *dlsym(void *handle, const char *name);
// unsigned int sleep(unsigned int seconds);
// const __int32_t **__ctype_tolower_loc(void);
// int usleep(__useconds_t useconds);
// void freeaddrinfo(struct addrinfo *ai);
// int socket(int domain, int type, int protocol);
// void free(void *ptr);
// void *malloc(size_t size);
// void *realloc(void *ptr, size_t size);
// int __fastcall _cxa_finalize(void *);
void *deregister_tm_clones();
__int64 register_tm_clones();
void *_do_global_dtors_aux();
__int64 __fastcall frame_dummy(); // weak
__int64 __fastcall freeContext(__int64 a1);
void __fastcall setContext(context *ctx, const char *url, const char *keyhost, const char *keyport); // idb
void __fastcall initContext(context *a1, char *a2, char *a3, char *a4); // idb
__int64 __fastcall open_state_internal(context *a1); // idb
void *__fastcall remote_logout(_QWORD *a1);
__int64 __fastcall get_current_permission(context *a1); // idb
__int64 __fastcall open_state(context *a1); // idb
__int64 __fastcall remote_login(context *a1, const char *username, const char *password); // idb
__int64 __fastcall relogin(_QWORD *a1);
__int64 __fastcall hsign(context *a1, __int64 a2, __int64 a3); // idb
__int64 __fastcall send_recv__part_0_constprop_3(context *a1, emsg *a2, char *a3, __int64 *a4);
int __fastcall send_recv_constprop_1(context *a1, emsg *a2, void *a3, __int64 *a4);
int __fastcall check_hsign(context *a1, emsg *a2, __m128i *a3);
unsigned int __fastcall getkey(__int64 a1, const __m128i *a2, __m128i *a3);
__int64 __fastcall download_media_isra_1(__int64 a1, const char *a2, __int64 a3, int *a4, _BYTE *a5);
__int64 __fastcall get_dir_path_(__int64 a1, char **a2, __int64 a3);
__int64 __fastcall get_file_key_part_5(_QWORD *a1, __int64 a2, __int64 a3);
void __fastcall close_dir_part_6(__int64 a1);
void __fastcall erase_dir(__int64 a1);
__int64 __fastcall parse_json_index(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall get_file_key(_QWORD *a1, __int64 a2, __int64 a3);
__int64 __fastcall download_file_with_key(__int64 a1, const char *a2, __int64 a3, int *a4);
void __fastcall close_dir(__int64 a1);
void __fastcall close_index(__int64 a1);
__int64 __fastcall download_file(context *a1, _QWORD *a2, int *a3);
__int64 __fastcall open_index(context *a1, __int64 a2);
__int64 __fastcall open_dir(context *a1, __int64 a2);
__int64 __fastcall get_dir_path(__int64 a1, void **a2);
__int64 __fastcall get_file_path(__int64 a1, void **a2);
__int64 __fastcall get_dir(__int64 a1, const char **a2, char *a3, const char ***a4);
__int64 __fastcall get_file(__int64 a1, const char **a2, char *a3, const char ***a4);
__int64 __fastcall vlc_sd_probe_Open(__int64 a1);
void __fastcall CloseAccess(__int64 a1);
__int64 __fastcall error_Media(unsigned int a1, __int64 a2, const char *a3);
__int64 __fastcall AccessReadDir(__int64 a1, __int64 a2);
__int64 __fastcall AccessSeek(__int64 a1, __off64_t a2);
ssize_t __fastcall AccessRead(__int64 a1, void *a2, size_t a3);
__int64 __fastcall DownloadAccess(__int64 a1);
void __fastcall CloseSD(__int64 a1);
__int64 __fastcall AccessControl(__int64 a1, int a2, int *a3);
void global_init();
__int64 __fastcall OpenSD(__int64 a1);
__int64 __fastcall OpenAccess(__int64 a1);
int __fastcall vlc_entry__3_0_0f(unsigned int (*vlc_set)(void *, void *, vlc_module_properties, ...), void *vlc);
char *__fastcall ensure(_QWORD *a1, unsigned __int64 a2);
_QWORD *__fastcall get_object_item(__int64 a1, const char *a2, int a3);
__int64 __fastcall print_string_ptr_part_5(void *src, _QWORD *a2);
__int64 __fastcall print_value_part_8(__int64 a1, __m128i *a2);
void *__fastcall print_constprop_18(__int64 a1, int a2);
__int64 __fastcall parse_string_isra_0(_DWORD *a1, __int64 *a2, __int64 *a3);
__int64 __fastcall cJSON_GetErrorPtr(); // weak
__int64 __fastcall cJSON_GetStringValue(__int64 a1);
double __fastcall cJSON_GetNumberValue(__int64 a1);
char *cJSON_Version();
void *(**__fastcall cJSON_InitHooks(__int64 a1))(size_t size);
void __fastcall cJSON_Delete(_DWORD *a1);
__int64 __fastcall parse_value(__int64 a1, __int64 a2);
__int64 __fastcall cJSON_SetNumberHelper(__int64 a1, double a2);
void *__fastcall cJSON_SetValuestring(__int64 a1, const char *a2);
_DWORD *__fastcall cJSON_ParseWithLengthOpts(__int128 a1, _QWORD *a2, int a3);
_DWORD *__fastcall cJSON_ParseWithOpts(__int128 a1, int a2);
_DWORD *__fastcall cJSON_Parse(const char *a1);
_DWORD *__fastcall cJSON_ParseWithLength(__int128 a1);
void *__fastcall cJSON_Print(__int64 a1);
void *__fastcall cJSON_PrintUnformatted(__int64 a1);
__int64 __fastcall cJSON_PrintBuffered(__int64 a1, int a2, __int32 a3);
__int64 __fastcall cJSON_PrintPreallocated(__int64 a1, __int64 a2, int a3, __int32 a4);
__int64 __fastcall cJSON_GetArraySize(__int64 a1);
_QWORD *__fastcall cJSON_GetArrayItem(__int64 a1, __int64 a2);
_QWORD *__fastcall cJSON_GetObjectItem(__int64 a1, const char *a2);
_QWORD *__fastcall cJSON_GetObjectItemCaseSensitive(__int64 a1, const char *a2);
_BOOL8 __fastcall cJSON_HasObjectItem(__int64 a1, const char *a2);
__int64 __fastcall cJSON_AddItemToArray(_QWORD *a1, _QWORD *a2);
__int64 __fastcall cJSON_AddItemToObject(__int64 a1, const char *a2, __int64 a3);
__int64 __fastcall cJSON_AddItemToObjectCS(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall cJSON_AddItemReferenceToArray(__int64 a1, const __m128i *a2);
__int64 __fastcall cJSON_AddItemReferenceToObject(__int64 a1, const char *a2, const __m128i *a3);
__int64 __fastcall cJSON_AddNullToObject(__int64 a1, const char *a2);
__int64 __fastcall cJSON_AddTrueToObject(__int64 a1, const char *a2);
__int64 __fastcall cJSON_AddFalseToObject(__int64 a1, const char *a2);
__int64 __fastcall cJSON_AddBoolToObject(__int64 a1, const char *a2, int a3);
__int64 __fastcall cJSON_AddNumberToObject(__int64 a1, const char *a2, double a3);
__int64 __fastcall cJSON_AddStringToObject(__int64 a1, const char *a2, const char *a3);
__int64 __fastcall cJSON_AddRawToObject(__int64 a1, const char *a2, const char *a3);
__int64 __fastcall cJSON_AddObjectToObject(__int64 a1, const char *a2);
__int64 __fastcall cJSON_AddArrayToObject(__int64 a1, const char *a2);
_QWORD *__fastcall cJSON_DetachItemViaPointer(__int64 a1, _QWORD *a2);
_QWORD *__fastcall cJSON_DetachItemFromArray(__int64 a1, __int64 a2);
void __fastcall cJSON_DeleteItemFromArray(__int64 a1, __int64 a2);
_QWORD *__fastcall cJSON_DetachItemFromObject(__int64 a1, const char *a2);
_QWORD *__fastcall cJSON_DetachItemFromObjectCaseSensitive(__int64 a1, const char *a2);
void __fastcall cJSON_DeleteItemFromObject(__int64 a1, const char *a2);
void __fastcall cJSON_DeleteItemFromObjectCaseSensitive(__int64 a1, const char *a2);
__int64 __fastcall cJSON_InsertItemInArray(_QWORD *a1, __int64 a2, _QWORD *a3);
__int64 __fastcall cJSON_ReplaceItemViaPointer(__int64 a1, __m128i *a2, __m128i *a3);
__int64 __fastcall cJSON_ReplaceItemInArray(__int64 a1, __int64 a2, __m128i *a3);
__int64 __fastcall cJSON_ReplaceItemInObject(__int64 a1, const char *a2, __m128i *a3);
__int64 __fastcall cJSON_ReplaceItemInObjectCaseSensitive(__int64 a1, const char *a2, __m128i *a3);
__int64 __fastcall cJSON_CreateNull(); // weak
__int64 __fastcall cJSON_CreateTrue(); // weak
__int64 __fastcall cJSON_CreateFalse(); // weak
__int64 __fastcall cJSON_CreateBool(int a1);
__int64 __fastcall cJSON_CreateNumber(double a1);
__int64 __fastcall cJSON_CreateString(void *src); // idb
__int64 __fastcall cJSON_CreateStringReference(__int64 a1);
__int64 __fastcall cJSON_CreateObjectReference(__int64 a1);
__int64 __fastcall cJSON_CreateArrayReference(__int64 a1);
__int64 __fastcall cJSON_CreateRaw(void *src); // idb
__int64 __fastcall cJSON_CreateArray(); // weak
__int64 __fastcall cJSON_CreateObject(); // weak
__int64 __fastcall cJSON_CreateIntArray(__int64 a1, int a2);
__int64 __fastcall cJSON_CreateFloatArray(__int64 a1, int a2);
__int64 __fastcall cJSON_CreateDoubleArray(__int64 a1, int a2);
__int64 __fastcall cJSON_CreateStringArray(__int64 a1, int a2);
_OWORD *__fastcall cJSON_Duplicate(__int64 a1, int a2);
void __fastcall cJSON_Minify(_BYTE *a1);
_BOOL8 __fastcall cJSON_IsInvalid(__int64 a1);
_BOOL8 __fastcall cJSON_IsFalse(__int64 a1);
_BOOL8 __fastcall cJSON_IsTrue(__int64 a1);
_BOOL8 __fastcall cJSON_IsBool(__int64 a1);
_BOOL8 __fastcall cJSON_IsNull(__int64 a1);
_BOOL8 __fastcall cJSON_IsNumber(__int64 a1);
_BOOL8 __fastcall cJSON_IsString(__int64 a1);
_BOOL8 __fastcall cJSON_IsArray(__int64 a1);
_BOOL8 __fastcall cJSON_IsObject(__int64 a1);
_BOOL8 __fastcall cJSON_IsRaw(__int64 a1);
__int64 __fastcall cJSON_Compare(__int64 a1, __int64 a2, unsigned int a3);
void term_proc();
// void free(void *ptr);
// __int64 __fastcall vlc_UrlParse(_QWORD, _QWORD); weak
// __int64 __fastcall gcry_cipher_open(_QWORD, _QWORD, _QWORD, _QWORD); weak
// void *malloc(size_t size);
// void *realloc(void *ptr, size_t size);
// __int64 __fastcall vlc_sd_probe_Add(_QWORD, _QWORD, _QWORD, _QWORD); weak
// int __fastcall __cxa_finalize(void *);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
char byte_4 = '\x02'; // weak
__int64 (__fastcall **off_F8[2])() = { &_frame_dummy_init_array_entry, &_frame_dummy_init_array_entry }; // weak
__int64 qword_100 = 69040LL; // weak
_UNKNOWN unk_D5DA; // weak
__int128 xmmword_D740 = 0x10000000000000001LL; // weak
void *free_ptr = &free; // weak
void *_dso_handle = &_dso_handle; // idb
__int64 (__fastcall *global_hooks)(_QWORD) = &malloc; // weak
__int64 (__fastcall *off_11268)(_QWORD) = &free; // weak
__int64 (__fastcall *off_11270)(_QWORD, _QWORD) = &realloc; // weak
_UNKNOWN _TMC_END__; // weak
char completed_7325; // weak
char done_14258; // weak
char is_init; // weak
char need_init; // weak
char version_2420[16]; // idb
__int64 global_error; // weak
__int64 qword_112A8; // weak
context global_ctx;
__int64 a2; // idb
__int128 xmmword_11360; // weak
__int128 xmmword_11370; // weak
__int128 xmmword_11380; // weak
__int128 xmmword_11390; // weak
_UNKNOWN unk_113A0; // weak


//----- (0000000000002000) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    result = (__int64 (**)(void))_gmon_start__();
  return result;
}
// 11628: using guessed type __int64 _gmon_start__(void);

//----- (0000000000002020) ----------------------------------------------------
void sub_2020()
{
  JUMPOUT(0LL);
}
// 2026: control flows out of bounds to 0

//----- (00000000000024B0) ----------------------------------------------------
void *deregister_tm_clones()
{
  return &_TMC_END__;
}

//----- (00000000000024E0) ----------------------------------------------------
__int64 register_tm_clones()
{
  return 0LL;
}

//----- (0000000000002520) ----------------------------------------------------
void *_do_global_dtors_aux()
{
  void *result; // rax

  if ( !completed_7325 )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(_dso_handle);
    result = deregister_tm_clones();
    completed_7325 = 1;
  }
  return result;
}
// 11280: using guessed type char completed_7325;

//----- (0000000000002570) ----------------------------------------------------
__int64 __fastcall freeContext(__int64 a1)
{
  int v2; // edi
  __int64 result; // rax

  if ( a1 )
  {
    remote_logout((_QWORD *)a1);
    v2 = *(_DWORD *)(a1 + 16);
    if ( v2 >= 0 )
      close(v2);
    free(*(void **)a1);
    free(*(void **)(a1 + 8));
    free(*(void **)(a1 + 32));
    free(*(void **)(a1 + 40));
    free(*(void **)(a1 + 24));
    vlc_mutex_destroy(a1 + 96);
    result = 0LL;
    *(_QWORD *)a1 = 0LL;
    *(_QWORD *)(a1 + 136) = 0LL;
    memset(
      (void *)((a1 + 8) & 0xFFFFFFFFFFFFFFF8LL),
      0,
      8LL * (((unsigned int)a1 - (((_DWORD)a1 + 8) & 0xFFFFFFF8) + 144) >> 3));
    *(_DWORD *)(a1 + 16) = -1;
    *(_BYTE *)(a1 + 48) = 1;
    *(_BYTE *)(a1 + 136) = 0;
  }
  return result;
}
// 2110: using guessed type __int64 __fastcall vlc_mutex_destroy(_QWORD);

//----- (0000000000002620) ----------------------------------------------------
void __fastcall setContext(context *ctx, const char *url, const char *keyhost, const char *keyport)
{
  char *v7; // rdi
  void *v8; // rbp
  char v9; // r14
  char *v10; // rbp
  int v11; // edi

  if ( ctx )
  {
    v7 = ctx->url;
    if ( url )
    {
      if ( v7 )
        free(v7);
      ctx->url = strdup(url);
    }
    else if ( !v7 )
    {
      ctx->url = strdup("http://challenge2021.sstic.org:8080");
    }
    v8 = ctx->keyhost;
    if ( keyhost )
    {
      if ( !v8 || (v9 = 0, strcmp(keyhost, (const char *)ctx->keyhost)) )
      {
        v9 = 1;
        free(v8);
        ctx->keyhost = strdup(keyhost);
      }
    }
    else
    {
      v9 = 0;
      if ( !v8 )
      {
        v9 = 1;
        ctx->keyhost = strdup("62.210.125.243");
      }
    }
    v10 = ctx->keyport;
    if ( keyport )
    {
      if ( !v10 || strcmp(keyport, ctx->keyport) )
      {
        free(v10);
        ctx->keyport = strdup(keyport);
        goto LABEL_14;
      }
    }
    else if ( !v10 )
    {
      ctx->keyport = strdup("1337");
LABEL_14:
      v11 = ctx->fd;
      if ( v11 >= 0 )
      {
        close(v11);
        ctx->fd = -1;
      }
      return;
    }
    if ( !v9 )
      return;
    goto LABEL_14;
  }
}

//----- (0000000000002770) ----------------------------------------------------
void __fastcall initContext(context *a1, char *a2, char *a3, char *a4)
{
  char **v7; // rdi

  if ( a1 )
  {
    v7 = &a1->keyport;
    *(v7 - 1) = 0LL;
    v7[16] = 0LL;
    memset(
      (void *)((unsigned __int64)v7 & 0xFFFFFFFFFFFFFFF8LL),
      0,
      8LL * (((unsigned int)a1 - ((unsigned int)v7 & 0xFFFFFFF8) + 144) >> 3));
    a1->fd = -1;
    a1->permcheck = 1;
    a1->byte88 = 0;
    vlc_mutex_init(a1->mutex);
    setContext(a1, a2, a3, a4);
  }
}
// 22E0: using guessed type __int64 __fastcall vlc_mutex_init(_QWORD);

//----- (0000000000002810) ----------------------------------------------------
__int64 __fastcall open_state_internal(context *a1)
{
  char *v3; // rsi
  __int64 v4; // rdx
  char *v5; // rax
  int v6; // eax
  int v7; // er13
  __int64 v8; // r12
  size_t v9; // rbx
  void *v10; // rdi
  int (__fastcall *v11)(char *, char *); // rax
  void *v12; // rdi
  int (__fastcall *v13)(int64_t *); // rax
  void *v14; // rdi
  int (__fastcall *v15)(int *); // rax
  bool v16; // zf
  void *v17; // rdi
  __int64 v18; // [rsp-18h] [rbp-40078h]
  char *ptr; // [rsp+0h] [rbp-40060h] BYREF
  char templatea[16]; // [rsp+8h] [rbp-40058h] BYREF
  char v21[8]; // [rsp+18h] [rbp-40048h] BYREF
  __int64 s[3]; // [rsp+28h] [rbp-40038h] BYREF
  __int64 v23; // [rsp+40h] [rbp-40020h]
  unsigned int v24; // [rsp+48h] [rbp-40018h]
  char *v25; // [rsp+50h] [rbp-40010h]

  if ( a1->dlhandle )
    return 0LL;
  if ( a1->username && a1->password )
  {
    v3 = a1->url;
    if ( (unsigned int)vlc_UrlParse((__int64)s, (__int64)v3) == -1 )
      goto LABEL_30;
    v5 = v25;
    if ( v24 )
    {
      if ( !v25 )
        v5 = "";
      v3 = "%s://%s:%s@%s:%d/%s/api/auth.so";
      v6 = asprintf(&ptr, "%s://%s:%s@%s:%d/%s/api/auth.so", s[0], a1->username, a1->password, v23, v24, v5);
    }
    else
    {
      if ( !v25 )
        v5 = "";
      v3 = "%s://%s:%s@%s/%s/api/auth.so";
      v6 = asprintf(&ptr, "%s://%s:%s@%s/%s/api/auth.so", s[0], a1->username, a1->password, v23, v5);
    }
    v4 = v18;
    if ( v6 == -1 )
    {
LABEL_30:
      vlc_UrlClean(s, v3, v4);
      return 255LL;
    }
    vlc_UrlClean(s, v3, v18);
  }
  else if ( asprintf(&ptr, "%s/api/guest.so", a1->url) == -1 )
  {
    return 255LL;
  }
  strcpy(v21, ".so");
  *(__m128i *)templatea = _mm_load_si128((const __m128i *)"/tmp/libVMXXXXXXSTIC");
  v7 = mkstemps64(templatea, 3);
  if ( v7 == -1 )
  {
    free(ptr);
    return 255LL;
  }
  v8 = vlc_stream_NewURL(a1->access_ctx, ptr);
  if ( !v8 )
  {
    close(v7);
    free(ptr);
    unlink(templatea);
    return 254LL;
  }
  memset(s, 0, 0x40000uLL);
  do
  {
    do
    {
      v9 = vlc_stream_ReadPartial(v8, s, 0x40000LL);
      write(v7, s, v9);
    }
    while ( v9 == 0x40000 );
  }
  while ( !(unsigned __int8)vlc_stream_Eof(v8) );
  vlc_stream_Delete(v8);
  close(v7);
  free(ptr);
  chmod(templatea, 0700u);
  a1->dlhandle = dlopen(templatea, 1);
  unlink(templatea);
  v10 = a1->dlhandle;
  if ( !v10 )
    return 255LL;
  v11 = (int (__fastcall *)(char *, char *))dlsym(v10, "useVM");
  v12 = a1->dlhandle;
  a1->useVM = v11;
  v13 = (int (__fastcall *)(int64_t *))dlsym(v12, "getPerms");
  v14 = a1->dlhandle;
  a1->getPerms = v13;
  v15 = (int (__fastcall *)(int *))dlsym(v14, "getIdent");
  v16 = a1->useVM == 0LL;
  a1->getIdent = v15;
  if ( v16 || !a1->getPerms || !v15 )
  {
    v17 = a1->dlhandle;
    if ( v17 )
    {
      dlclose(v17);
      a1->dlhandle = 0LL;
      a1->useVM = 0LL;
      a1->getPerms = 0LL;
      a1->getIdent = 0LL;
    }
    return 255LL;
  }
  return 0LL;
}
// 28A8: variable 'v18' is possibly undefined
// 2A8D: variable 'v4' is possibly undefined
// 2030: using guessed type __int64 __fastcall vlc_stream_Delete(_QWORD);
// 22B0: using guessed type __int64 __fastcall vlc_stream_Eof(_QWORD);
// 2330: using guessed type __int64 __fastcall vlc_stream_ReadPartial(_QWORD, _QWORD, _QWORD);
// 2370: using guessed type __int64 __fastcall vlc_stream_NewURL(_QWORD, _QWORD);
// 2400: using guessed type __int64 __fastcall vlc_UrlClean(_QWORD, _QWORD, _QWORD);

//----- (0000000000002AE0) ----------------------------------------------------
void *__fastcall remote_logout(_QWORD *a1)
{
  void *v1; // rax
  void *v3; // rdi
  void *result; // rax

  if ( !a1 )
    return off_F8 + 7;
  v1 = (void *)a1[4];
  if ( v1 )
  {
    v3 = (void *)a1[7];
    if ( !v3 )
      goto LABEL_11;
    goto LABEL_4;
  }
  result = (void *)a1[5];
  if ( result )
  {
    v3 = (void *)a1[7];
    if ( !v3 )
      goto LABEL_10;
LABEL_4:
    dlclose(v3);
    v1 = (void *)a1[4];
    a1[7] = 0LL;
    a1[8] = 0LL;
    a1[9] = 0LL;
    a1[10] = 0LL;
    if ( !v1 )
    {
      result = (void *)a1[5];
      if ( !result )
      {
LABEL_6:
        a1[4] = 0LL;
        result = 0LL;
        a1[5] = 0LL;
        return result;
      }
LABEL_10:
      free(result);
      goto LABEL_6;
    }
LABEL_11:
    free(v1);
    result = (void *)a1[5];
    if ( !result )
      goto LABEL_6;
    goto LABEL_10;
  }
  return result;
}
// F8: using guessed type __int64 (__fastcall **[2])();

//----- (0000000000002BA0) ----------------------------------------------------
__int64 __fastcall get_current_permission(context *a1)
{
  int (__fastcall *v1)(int64_t *); // rax
  __int64 result; // rax
  int v3; // edx
  __int64 v4; // [rsp+8h] [rbp-10h] BYREF

  v1 = a1->getPerms;
  if ( v1 )
  {
    v1(&v4);
    return v4;
  }
  v3 = open_state(a1);
  result = -1LL;
  if ( !v3 )
  {
    a1->getPerms(&v4);
    return v4;
  }
  return result;
}

//----- (0000000000002BE0) ----------------------------------------------------
__int64 __fastcall open_state(context *a1)
{
  int v1; // ebp
  void *v3; // rdi
  unsigned int v4; // er12
  bool v5; // zf
  int (__fastcall *v6)(int *); // rax
  int v7; // eax
  void *v8; // rdi
  __int64 v10[3]; // [rsp+8h] [rbp-80h] BYREF
  __int64 v11; // [rsp+20h] [rbp-68h] BYREF
  __int64 perms; // [rsp+28h] [rbp-60h] BYREF
  emsg a2; // [rsp+30h] [rbp-58h] BYREF

  v1 = 10;
  while ( 1 )
  {
    v4 = open_state_internal(a1);
    if ( v4 )
      break;
    v5 = a1->getPerms == 0LL;
    a2.ident = 0;
    *(_OWORD *)a2.buf = 0LL;
    *(_OWORD *)&v10[1] = 0LL;
    if ( !v5 )
    {
      v6 = a1->getIdent;
      if ( v6 )
      {
        if ( a1->useVM )
        {
          v6(&a2.ident);
          v11 = 0LL;
          a1->getPerms(&perms);
          if ( !a1->useVM((char *)&v11, (char *)&a2) )
          {
            v10[0] = get_current_permission(a1);
            v7 = check_hsign(a1, &a2, (__m128i *)&v10[1]);
            switch ( v7 )
            {
              case 1:
                if ( !v10[1] && v10[2] == v10[0] )
                  return v4;
                break;
              case 0xFFFFFFFE:
                v8 = a1->dlhandle;
                v4 = 254;
                if ( !v8 )
                  return v4;
LABEL_18:
                dlclose(v8);
                a1->dlhandle = 0LL;
                a1->useVM = 0LL;
                a1->getPerms = 0LL;
                a1->getIdent = 0LL;
                return v4;
              case 0xFFFFFFFF:
                goto LABEL_17;
            }
          }
        }
      }
    }
    v3 = a1->dlhandle;
    if ( v3 )
    {
      dlclose(v3);
      a1->dlhandle = 0LL;
      a1->useVM = 0LL;
      a1->getPerms = 0LL;
      a1->getIdent = 0LL;
    }
    if ( !--v1 )
    {
LABEL_17:
      v8 = a1->dlhandle;
      v4 = 255;
      if ( !v8 )
        return v4;
      goto LABEL_18;
    }
    sleep(1u);
  }
  v8 = a1->dlhandle;
  if ( v8 )
    goto LABEL_18;
  return v4;
}

//----- (0000000000002D80) ----------------------------------------------------
__int64 __fastcall remote_login(context *a1, const char *username, const char *password)
{
  void *v5; // r13
  char *v6; // rdi
  char *v7; // rdi
  char *v9; // rdi

  if ( a1 )
  {
    v5 = a1->dlhandle;
    v6 = a1->username;
    if ( username && password )
    {
      if ( v5 )
      {
        if ( (v6 || a1->password) && !strcmp(v6, username) && !strcmp(a1->password, password) )
          return 0LL;
        dlclose(v5);
        a1->dlhandle = 0LL;
        v6 = a1->username;
        a1->useVM = 0LL;
        a1->getPerms = 0LL;
        a1->getIdent = 0LL;
      }
      if ( v6 )
        free(v6);
      v7 = a1->password;
      if ( v7 )
        free(v7);
      a1->username = strdup(username);
      a1->password = strdup(password);
      return open_state(a1);
    }
    if ( v6 )
    {
      if ( !v5 )
        goto LABEL_24;
    }
    else
    {
      v9 = a1->password;
      if ( !v9 )
      {
LABEL_19:
        if ( v5 )
          return 0LL;
        return open_state(a1);
      }
      if ( !v5 )
        goto LABEL_23;
    }
    dlclose(v5);
    v6 = a1->username;
    a1->dlhandle = 0LL;
    a1->useVM = 0LL;
    a1->getPerms = 0LL;
    a1->getIdent = 0LL;
    if ( !v6 )
    {
      v9 = a1->password;
      if ( !v9 )
      {
LABEL_18:
        a1->username = 0LL;
        v5 = a1->dlhandle;
        a1->password = 0LL;
        goto LABEL_19;
      }
LABEL_23:
      free(v9);
      goto LABEL_18;
    }
LABEL_24:
    free(v6);
    v9 = a1->password;
    if ( !v9 )
      goto LABEL_18;
    goto LABEL_23;
  }
  return 255LL;
}

//----- (0000000000002F30) ----------------------------------------------------
__int64 __fastcall relogin(_QWORD *a1)
{
  void *v2; // rdi

  v2 = (void *)a1[7];
  if ( v2 )
  {
    dlclose(v2);
    a1[7] = 0LL;
    a1[8] = 0LL;
    a1[9] = 0LL;
    a1[10] = 0LL;
  }
  return open_state((context *)a1);
}

//----- (0000000000002F70) ----------------------------------------------------
__int64 __fastcall hsign(context *a1, __int64 a2, __int64 a3)
{
  int (__fastcall *v5)(int *); // rax
  int v6; // edx
  __int64 result; // rax
  __int64 v8; // r15
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rdx
  void *v11; // rdi
  int (__fastcall *v12)(int *); // rax
  int v13; // ecx
  unsigned __int64 v14; // [rsp+0h] [rbp-50h]
  unsigned __int64 v15; // [rsp+0h] [rbp-50h]
  __int64 v16; // [rsp+8h] [rbp-48h] BYREF
  _BYTE v17[64]; // [rsp+10h] [rbp-40h] BYREF

  if ( !a1 )
    return 255LL;
  if ( !a1->getPerms || (v5 = a1->getIdent) == 0LL || !a1->useVM )
  {
    result = open_state(a1);
    if ( (_DWORD)result )
      return result;
    if ( !a1->getPerms )
      goto LABEL_11;
    v5 = a1->getIdent;
    if ( !v5 )
      goto LABEL_11;
  }
  if ( !a1->useVM )
    goto LABEL_11;
  v5((int *)(a3 + 16));
  v16 = a2;
  a1->getPerms((int64_t *)v17);
  v6 = a1->useVM((char *)&v16, (char *)a3);
  result = 1LL;
  if ( v6 )
    return result;
  v8 = *(unsigned int *)(a3 + 16);
  v9 = time(0LL);
  v10 = v9;
  if ( v8 + 3600 >= v9 )
    return 0LL;
  v11 = a1->dlhandle;
  if ( v11 )
  {
    v14 = v9;
    dlclose(v11);
    a1->dlhandle = 0LL;
    v10 = v14;
    a1->useVM = 0LL;
    a1->getPerms = 0LL;
    a1->getIdent = 0LL;
  }
  v15 = v10;
  result = open_state(a1);
  if ( !(_DWORD)result )
  {
    if ( a1->getPerms )
    {
      v12 = a1->getIdent;
      if ( v12 )
      {
        if ( a1->useVM )
        {
          v12((int *)(a3 + 16));
          v16 = a2;
          a1->getPerms((int64_t *)v17);
          v13 = a1->useVM((char *)&v16, (char *)a3);
          result = 1LL;
          if ( v13 )
            return result;
          if ( (unsigned __int64)*(unsigned int *)(a3 + 16) + 3600 >= v15 )
            return 0LL;
        }
      }
    }
LABEL_11:
    result = 255LL;
  }
  return result;
}

//----- (0000000000003120) ----------------------------------------------------
__int64 __fastcall send_recv__part_0_constprop_3(context *a1, emsg *a2, char *a3, __int64 *a4)
{
  int v8; // edi
  int v9; // eax
  int v10; // edi
  char v11; // al
  __int64 v12; // rdx
  int v14; // eax
  char *v15; // rsi
  const char *v16; // rdi
  struct addrinfo *v17; // rbx
  int v18; // eax
  int v19; // edi
  bool v20; // zf
  int buf; // [rsp+4h] [rbp-74h] BYREF
  struct addrinfo *pai; // [rsp+8h] [rbp-70h] BYREF
  struct addrinfo req; // [rsp+10h] [rbp-68h] BYREF

  v8 = a1->fd;
  if ( v8 >= 0 )
    goto LABEL_2;
  a1->fd = -1;
  v15 = a1->keyport;
  v16 = (const char *)a1->keyhost;
  *(_OWORD *)&req.ai_protocol = 0LL;
  *(_OWORD *)((char *)&req.ai_addr + 4) = 0LL;
  HIDWORD(req.ai_next) = 0;
  *(_QWORD *)&req.ai_flags = 0x200000001LL;
  req.ai_socktype = 1;
  if ( getaddrinfo(v16, v15, &req, &pai) )
    return 4294967294LL;
  v17 = pai;
  if ( !pai )
    goto LABEL_19;
  while ( 1 )
  {
    v18 = socket(v17->ai_family, v17->ai_socktype, v17->ai_protocol);
    a1->fd = v18;
    if ( v18 != -1 )
      break;
LABEL_17:
    v17 = v17->ai_next;
    if ( !v17 )
    {
      v17 = pai;
      goto LABEL_19;
    }
  }
  if ( connect(v18, v17->ai_addr, v17->ai_addrlen) == -1 )
  {
    close(a1->fd);
    a1->fd = -1;
    goto LABEL_17;
  }
  v17 = pai;
  if ( a1->fd == -1 )
  {
LABEL_19:
    freeaddrinfo(v17);
    return 4294967294LL;
  }
  freeaddrinfo(pai);
  v19 = a1->fd;
  buf = 0;
  if ( (unsigned int)recv(v19, &buf, 4uLL, 256) != 4 )
  {
    v8 = a1->fd;
LABEL_24:
    close(v8);
    a1->fd = -1;
    return 4294967294LL;
  }
  v20 = memcmp(&buf, "STIC", 4uLL) == 0;
  v8 = a1->fd;
  if ( !v20 )
    goto LABEL_24;
LABEL_2:
  v9 = send(v8, a2, 0x15uLL, 0);
  v10 = a1->fd;
  if ( v9 == 21 )
  {
    recv(v10, a3, 1uLL, 256);
    v11 = *a3;
    if ( *a3 <= 0 )
      goto LABEL_10;
    if ( v11 <= 3 )
    {
      v10 = a1->fd;
      if ( (unsigned __int64)*a4 > 0x10 )
      {
        v14 = recv(v10, a3 + 1, *a4 - 1, 256);
        v12 = 17LL;
        if ( v14 > 0 )
          goto LABEL_7;
        goto LABEL_10;
      }
    }
    else
    {
      if ( v11 <= 7 )
      {
        v12 = 1LL;
        if ( *a4 )
        {
LABEL_7:
          *a4 = v12;
          return (unsigned int)*a3;
        }
      }
LABEL_10:
      v10 = a1->fd;
    }
  }
  close(v10);
  a1->fd = -1;
  return 0xFFFFFFFFLL;
}

//----- (0000000000003340) ----------------------------------------------------
int __fastcall send_recv_constprop_1(context *a1, emsg *a2, void *a3, __int64 *a4)
{
  int v7; // edi
  __int64 v8; // rax
  int result; // eax

  if ( !a1 )
    return -1;
  v7 = a1->fd;
  v8 = *a4;
  if ( v7 >= 0 )
  {
    if ( !v8 )
      goto LABEL_6;
    result = send_recv__part_0_constprop_3(a1, a2, (char *)a3, a4);
    if ( result != -1 )
      return result;
    v7 = a1->fd;
    if ( v7 >= 0 )
LABEL_6:
      close(v7);
    a1->fd = -1;
    v8 = *a4;
  }
  if ( v8 )
    result = send_recv__part_0_constprop_3(a1, a2, (char *)a3, a4);
  else
    result = -1;
  return result;
}

//----- (00000000000033F0) ----------------------------------------------------
int __fastcall check_hsign(context *a1, emsg *a2, __m128i *a3)
{
  __m128i v4; // xmm0
  int v5; // eax
  int result; // eax
  __int64 a4; // [rsp+8h] [rbp-50h] BYREF
  char a3a; // [rsp+10h] [rbp-48h] BYREF
  __m128i v9; // [rsp+11h] [rbp-47h] BYREF
  char a2a; // [rsp+30h] [rbp-28h] BYREF
  emsg v11; // [rsp+31h] [rbp-27h]

  v4 = _mm_loadu_si128((const __m128i *)a2);
  v5 = a2->ident;
  a4 = 17LL;
  a2a = 0;
  *(__m128i *)v11.buf = v4;
  v11.ident = v5;
  result = send_recv_constprop_1(a1, (emsg *)&a2a, &a3a, &a4);
  if ( (unsigned int)(result - 1) <= 1 )
  {
    if ( a4 == 17 )
    {
      *a3 = _mm_loadu_si128(&v9);
      return result;
    }
    return -1;
  }
  if ( (unsigned int)result <= 0xEF )
    return -1;
  return result;
}

//----- (0000000000003470) ----------------------------------------------------
unsigned int __fastcall getkey(__int64 a1, const __m128i *a2, __m128i *a3)
{
  __m128i v4; // xmm1
  __int32 v5; // eax
  unsigned int result; // eax
  __int64 a4; // [rsp+0h] [rbp-50h] BYREF
  __int128 a3a; // [rsp+8h] [rbp-48h] BYREF
  char v9; // [rsp+18h] [rbp-38h]
  char a2a; // [rsp+28h] [rbp-28h] BYREF
  __m128i v11; // [rsp+29h] [rbp-27h]
  int v12; // [rsp+39h] [rbp-17h]

  v4 = _mm_loadu_si128(a2);
  v5 = a2[1].m128i_i32[0];
  a3a = 0LL;
  v9 = 0;
  a4 = 17LL;
  a2a = 1;
  v11 = v4;
  v12 = v5;
  result = send_recv_constprop_1((context *)a1, (emsg *)&a2a, &a3a, &a4);
  if ( result == 3 )
  {
    if ( a4 == 17 )
      *a3 = _mm_loadu_si128((const __m128i *)((char *)&a3a + 1));
    else
      result = -1;
  }
  else if ( result - 4 > 3 && result <= 0xEF )
  {
    result = -1;
  }
  return result;
}

//----- (0000000000003510) ----------------------------------------------------
__int64 __fastcall download_media_isra_1(__int64 a1, const char *a2, __int64 a3, int *a4, _BYTE *a5)
{
  _BYTE *v5; // r15
  __int64 v7; // r14
  char v8; // r12
  size_t v9; // rbp
  __int64 result; // rax
  __int64 v11; // r15
  __int64 v14; // [rsp+10h] [rbp-10048h] BYREF
  char *ptr; // [rsp+18h] [rbp-10040h] BYREF
  char s[65592]; // [rsp+20h] [rbp-10038h] BYREF

  if ( !a3 && *a5 )
    return 10LL;
  v5 = a5;
  if ( asprintf(&ptr, "%s/files/%s", *(const char **)(a1 + 24), a2) == -1 )
    goto LABEL_12;
  if ( !*v5 )
    goto LABEL_4;
  if ( (unsigned int)gcry_cipher_open(&v14, 7LL, 6LL, 0LL) )// AES-CTR
  {
LABEL_30:
    free(ptr);
    goto LABEL_12;
  }
  if ( (unsigned int)gcry_cipher_setkey(v14, a3, 16LL) )
  {
    gcry_cipher_close(v14);
    goto LABEL_30;
  }
  if ( (unsigned int)gcry_cipher_setctr(v14, &default_counter, 16LL) )
  {
    gcry_cipher_close(v14);
    free(ptr);
    return 10LL;
  }
LABEL_4:
  v7 = vlc_stream_NewURL(*(_QWORD *)(a1 + 88), ptr);
  if ( !v7 )
  {
    result = 9LL;
    if ( *a5 )
    {
      gcry_cipher_close(v14);
      result = 9LL;
    }
    return result;
  }
  memset(s, 0, 0x10000uLL);
  while ( 1 )
  {
    v8 = 0;
    v9 = vlc_stream_Read(v7, s, 0x10000LL);
    if ( v9 == 0x10000 )
      goto LABEL_14;
    if ( !(unsigned __int8)vlc_stream_Eof(v7) )
      goto LABEL_27;
    v8 = *a5;
    if ( !*a5 )
      break;
    if ( (unsigned int)gcry_cipher_ctl(v14, 5LL, 0LL, 0LL) )// finalize
      goto LABEL_10;
LABEL_14:
    if ( *a5 && (unsigned int)gcry_cipher_decrypt(v14, s, v9, 0LL, 0LL) )
    {
LABEL_10:
      vlc_stream_Delete(v7);
      goto LABEL_11;
    }
    v11 = a1 + 96;
    vlc_mutex_lock(a1 + 96);
    if ( *(_BYTE *)(a1 + 136) )
      goto LABEL_26;
    write(*a4, s, v9);
    vlc_mutex_unlock(a1 + 96);
    if ( v8 )
      goto LABEL_34;
  }
  v11 = a1 + 96;
  vlc_mutex_lock(a1 + 96);
  if ( *(_BYTE *)(a1 + 136) )
  {
LABEL_26:
    vlc_mutex_unlock(v11);
LABEL_27:
    vlc_stream_Delete(v7);
    if ( *a5 )
LABEL_11:
      gcry_cipher_close(v14);
LABEL_12:
    result = 10LL;
  }
  else
  {
    write(*a4, s, v9);
    vlc_mutex_unlock(a1 + 96);
LABEL_34:
    vlc_stream_Delete(v7);
    if ( *a5 )
      gcry_cipher_close(v14);
    result = lseek64(*a4, 0LL, 1) == 0;
  }
  return result;
}
// 2030: using guessed type __int64 __fastcall vlc_stream_Delete(_QWORD);
// 2040: using guessed type __int64 __fastcall vlc_mutex_unlock(_QWORD);
// 20A0: using guessed type __int64 __fastcall gcry_cipher_setkey(_QWORD, _QWORD, _QWORD);
// 20C0: using guessed type __int64 __fastcall gcry_cipher_setctr(_QWORD, _QWORD, _QWORD);
// 21C0: using guessed type __int64 __fastcall gcry_cipher_ctl(_QWORD, _QWORD, _QWORD, _QWORD);
// 2220: using guessed type __int64 __fastcall gcry_cipher_open(_QWORD, _QWORD, _QWORD, _QWORD);
// 22A0: using guessed type __int64 __fastcall vlc_mutex_lock(_QWORD);
// 22B0: using guessed type __int64 __fastcall vlc_stream_Eof(_QWORD);
// 2360: using guessed type __int64 __fastcall gcry_cipher_decrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 2370: using guessed type __int64 __fastcall vlc_stream_NewURL(_QWORD, _QWORD);
// 23D0: using guessed type __int64 __fastcall vlc_stream_Read(_QWORD, _QWORD, _QWORD);
// 23F0: using guessed type __int64 __fastcall gcry_cipher_close(_QWORD);

//----- (0000000000003800) ----------------------------------------------------
__int64 __fastcall get_dir_path_(__int64 a1, char **a2, __int64 a3)
{
  __int64 v3; // r13
  const char *v6; // rdi
  size_t v7; // r14
  unsigned int v8; // ebp
  char *v9; // rbx
  char *v11; // rax

  if ( !a1 || !a2 )
    return 10LL;
  v3 = *(_QWORD *)(a1 + 32);
  if ( v3 )
  {
    v6 = *(const char **)a1;
    if ( v6 )
    {
      v7 = strlen(v6);
      v8 = get_dir_path_(v3, a2, a3 + v7 + 1);
      if ( v8 )
        return v8;
      if ( *a2 )
      {
        strncat(*a2, *(const char **)a1, v7);
        v9 = *a2;
        *(_WORD *)&v9[strlen(*a2)] = 47;
        return v8;
      }
    }
    return 10LL;
  }
  if ( *a2 )
    free(*a2);
  v11 = (char *)calloc(a3 + 2, 1uLL);
  *a2 = v11;
  if ( !v11 )
    return 10LL;
  *(_WORD *)v11 = 47;
  return 0LL;
}

//----- (00000000000038E0) ----------------------------------------------------
__int64 __fastcall get_file_key_part_5(_QWORD *a1, __int64 a2, __int64 a3)
{
  int v4; // ebp
  unsigned int v5; // eax
  unsigned int v6; // er12
  unsigned int v7; // eax
  int v8; // eax
  __m128i v10[5]; // [rsp+0h] [rbp-58h] BYREF

  v4 = 3;
  while ( 1 )
  {
    v5 = hsign((context *)a1, a2, (__int64)v10);
    v6 = v5;
    if ( v5 )
    {
      if ( v5 != 2 )
      {
        if ( v5 == 254 )
          return 9;
        return 6;
      }
      return 5;
    }
    v7 = getkey((__int64)a1, v10, (__m128i *)a3);
    if ( v7 != 4 )
      break;
    v8 = relogin(a1);
    if ( v8 )
    {
      if ( v8 != 2 )
      {
        if ( v8 == 254 )
          return 9;
        return 6;
      }
      return 5;
    }
    if ( !--v4 )
      return 10;
  }
  if ( v7 != 3 )
  {
    v6 = 3;
    if ( v7 != 5 )
    {
      v6 = 2;
      if ( v7 != 6 )
      {
        v6 = 9;
        if ( v7 != -2 )
        {
          if ( v7 != 7 )
            return 10;
          v6 = 4;
        }
      }
    }
  }
  return v6;
}

//----- (00000000000039D0) ----------------------------------------------------
void __fastcall close_dir_part_6(__int64 a1)
{
  char *v2; // rdi
  unsigned __int64 v3; // r12
  char *v4; // rbx
  void *v5; // rdi
  void *v6; // rdi
  void *v7; // rdi
  unsigned __int64 v8; // rbx
  __int64 v9; // rax

  v2 = *(char **)(a1 + 64);
  if ( v2 )
  {
    if ( *(_QWORD *)(a1 + 72) )
    {
      v3 = 0LL;
      do
      {
        v4 = &v2[48 * v3];
        if ( v4 )
        {
          if ( *(_QWORD *)v4 )
            free(*(void **)v4);
          v5 = (void *)*((_QWORD *)v4 + 1);
          if ( v5 )
            free(v5);
          v6 = (void *)*((_QWORD *)v4 + 3);
          if ( v6 )
            free(v6);
          *(_QWORD *)v4 = 0LL;
          v2 = *(char **)(a1 + 64);
          *((_QWORD *)v4 + 1) = 0LL;
          *((_QWORD *)v4 + 3) = 0LL;
          *((_QWORD *)v4 + 5) = 0LL;
        }
        ++v3;
      }
      while ( *(_QWORD *)(a1 + 72) > v3 );
    }
    free(v2);
    *(_QWORD *)(a1 + 64) = 0LL;
    *(_QWORD *)(a1 + 72) = 0LL;
  }
  v7 = *(void **)(a1 + 48);
  if ( v7 )
  {
    if ( *(_QWORD *)(a1 + 56) )
    {
      v8 = 0LL;
      do
      {
        v9 = 5 * v8++;
        erase_dir((__int64)v7 + 16 * v9);
        v7 = *(void **)(a1 + 48);
      }
      while ( *(_QWORD *)(a1 + 56) > v8 );
    }
    free(v7);
    *(_QWORD *)(a1 + 48) = 0LL;
    *(_QWORD *)(a1 + 56) = 0LL;
  }
  *(_BYTE *)(a1 + 40) = 0;
}

//----- (0000000000003AC0) ----------------------------------------------------
void __fastcall erase_dir(__int64 a1)
{
  void *v2; // rdi
  void *v3; // rdi

  if ( a1 )
  {
    if ( *(_BYTE *)(a1 + 40) )
      close_dir_part_6(a1);
    v2 = *(void **)a1;
    if ( *(_QWORD *)a1 )
      free(v2);
    v3 = *(void **)(a1 + 8);
    if ( v3 )
      free(v3);
    *(_QWORD *)a1 = 0LL;
    *(_QWORD *)(a1 + 8) = 0LL;
    *(_QWORD *)(a1 + 32) = 0LL;
  }
}
// 39D0: using guessed type __int64 __fastcall close_dir_part_6(_QWORD);

//----- (0000000000003B20) ----------------------------------------------------
__int64 __fastcall parse_json_index(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 v4; // rbx
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  __int64 v7; // r14
  __int64 v8; // r15
  __int64 v9; // r12
  __int64 v10; // r13
  __int64 v11; // rbp
  __int64 v12; // r13
  __int64 v14; // rbp
  void *v15; // rax
  __int64 v16; // rcx
  _QWORD *v17; // rbx
  __int64 v18; // rbp
  char **v19; // rbp
  char *v20; // rax
  const char *v21; // rdi
  char *v22; // rax
  const char *v23; // rdi
  unsigned __int64 v24; // rax
  const char *v25; // rdi
  unsigned __int64 v26; // rax
  bool v27; // zf
  __int64 v28; // r13
  __int64 v29; // r12
  __int64 v30; // rbp
  __int64 v31; // r14
  __int64 v32; // r15
  __int64 v33; // rbp
  char **v34; // rbp
  char *v35; // rax
  const char *v36; // rdi
  char *v37; // rax
  const char *v38; // rdi
  unsigned __int64 v39; // rax
  const char *v40; // rdi
  unsigned __int64 v41; // rax
  char *v42; // rax
  _BYTE *v43; // rdx
  __int64 v44; // rax
  char **endptr; // [rsp+8h] [rbp-70h]
  __int64 v47; // [rsp+18h] [rbp-60h]
  __int64 v48; // [rsp+20h] [rbp-58h]
  __int64 v49; // [rsp+20h] [rbp-58h]
  char *s; // [rsp+28h] [rbp-50h]
  char *sa; // [rsp+28h] [rbp-50h]
  char *v52[8]; // [rsp+38h] [rbp-40h] BYREF

  v3 = cJSON_ParseWithLength(a1, a2);
  v47 = v3;
  v4 = v3;
  if ( !v3 )
    return 7LL;
  if ( !(unsigned int)cJSON_IsArray(v3) )
  {
LABEL_18:
    cJSON_Delete((_DWORD *)v47);
    return 7LL;
  }
  v5 = *(_QWORD **)(v4 + 16);
  v6 = v5;
  if ( !v5 )
  {
    *(_BYTE *)(a3 + 40) = 1;
    *(_QWORD *)(a3 + 56) = 0LL;
    *(_QWORD *)(a3 + 48) = 0LL;
    goto LABEL_45;
  }
  v48 = 0LL;
  s = 0LL;
  do
  {
    v7 = cJSON_GetObjectItemCaseSensitive(v5, "name");
    v8 = cJSON_GetObjectItemCaseSensitive(v5, "real_name");
    v9 = cJSON_GetObjectItemCaseSensitive(v5, "type");
    v10 = cJSON_GetObjectItemCaseSensitive(v5, "ident");
    v11 = cJSON_GetObjectItemCaseSensitive(v5, "perms");
    if ( !(unsigned int)cJSON_IsString(v10) )
      goto LABEL_18;
    if ( !(unsigned int)cJSON_IsString(v11) )
      goto LABEL_18;
    if ( !(unsigned int)cJSON_IsString(v9) )
      goto LABEL_18;
    if ( !(unsigned int)cJSON_IsString(v7) )
      goto LABEL_18;
    if ( !(unsigned int)cJSON_IsString(v8) )
      goto LABEL_18;
    v12 = *(_QWORD *)(v10 + 32);
    if ( !v12 )
      goto LABEL_18;
    if ( !*(_QWORD *)(v11 + 32) )
      goto LABEL_18;
    if ( !*(_QWORD *)(v9 + 32) )
      goto LABEL_18;
    if ( !*(_QWORD *)(v7 + 32) )
      goto LABEL_18;
    if ( !*(_QWORD *)(v8 + 32) )
      goto LABEL_18;
    v52[0] = 0LL;
    strtoull((const char *)v12, v52, 16);
    if ( !v52[0] )
      goto LABEL_18;
    if ( *v52[0] )
      goto LABEL_18;
    if ( v52[0] != (char *)(v12 + 16) )
      goto LABEL_18;
    v14 = *(_QWORD *)(v11 + 32);
    v52[0] = 0LL;
    strtoull((const char *)v14, v52, 16);
    if ( !v52[0] || *v52[0] || v52[0] != (char *)(v14 + 16) )
      goto LABEL_18;
    if ( !strcmp(*(const char **)(v9 + 32), "dir_index") )
      ++v48;
    else
      ++s;
    v5 = (_QWORD *)*v5;
  }
  while ( v5 );
  *(_BYTE *)(a3 + 40) = 1;
  if ( v48 )
  {
    v42 = (char *)calloc(80 * v48, 1uLL);
    v16 = a3;
    *(_QWORD *)(a3 + 48) = v42;
    if ( !v42 )
      goto LABEL_52;
    *(_QWORD *)(a3 + 56) = v48;
    v43 = v42 + 40;
    v44 = (__int64)&v42[80 * v48 + 40];
    do
    {
      *v43 = 0;
      v43 += 80;
    }
    while ( v43 != (_BYTE *)v44 );
  }
  else
  {
    *(_QWORD *)(a3 + 56) = 0LL;
    *(_QWORD *)(a3 + 48) = 0LL;
  }
  if ( !s )
  {
    v6 = *(_QWORD **)(v47 + 16);
LABEL_45:
    *(_QWORD *)(a3 + 72) = 0LL;
    *(_QWORD *)(a3 + 64) = 0LL;
    goto LABEL_30;
  }
  v15 = calloc(48LL * (_QWORD)s, 1uLL);
  v16 = a3;
  *(_QWORD *)(a3 + 64) = v15;
  if ( !v15 )
  {
LABEL_52:
    close_dir_part_6(v16);
    cJSON_Delete((_DWORD *)v47);
    return 10LL;
  }
  *(_QWORD *)(a3 + 72) = s;
  v6 = *(_QWORD **)(v47 + 16);
LABEL_30:
  v17 = v6;
  if ( !v6 )
  {
LABEL_50:
    cJSON_Delete((_DWORD *)v47);
    return 0LL;
  }
  v49 = 0LL;
  endptr = 0LL;
  while ( 1 )
  {
    v28 = cJSON_GetObjectItemCaseSensitive(v17, "name");
    v29 = cJSON_GetObjectItemCaseSensitive(v17, "real_name");
    v30 = cJSON_GetObjectItemCaseSensitive(v17, "type");
    v31 = cJSON_GetObjectItemCaseSensitive(v17, "ident");
    v32 = cJSON_GetObjectItemCaseSensitive(v17, "perms");
    if ( !strcmp(*(const char **)(v30 + 32), "dir_index") )
      break;
    sa = *(char **)(v30 + 32);
    v33 = 48LL * (_QWORD)endptr;
    endptr = (char **)((char *)endptr + 1);
    v34 = (char **)(*(_QWORD *)(a3 + 64) + v33);
    v35 = strdup(*(const char **)(v28 + 32));
    v36 = *(const char **)(v29 + 32);
    v34[1] = v35;
    *v34 = strdup(v36);
    v37 = strdup(sa);
    v38 = *(const char **)(v32 + 32);
    v34[3] = v37;
    v39 = strtoull(v38, 0LL, 16);
    v40 = *(const char **)(v31 + 32);
    v34[2] = (char *)v39;
    v41 = strtoull(v40, 0LL, 16);
    v27 = v34[1] == 0LL;
    v34[4] = (char *)v41;
    v34[5] = (char *)a3;
    if ( v27 || !*v34 || !v34[3] )
      goto LABEL_39;
LABEL_34:
    v17 = (_QWORD *)*v17;
    if ( !v17 )
      goto LABEL_50;
  }
  v18 = 80 * v49++;
  v19 = (char **)(*(_QWORD *)(a3 + 48) + v18);
  v20 = strdup(*(const char **)(v28 + 32));
  v21 = *(const char **)(v29 + 32);
  v19[1] = v20;
  v22 = strdup(v21);
  v23 = *(const char **)(v32 + 32);
  *v19 = v22;
  v24 = strtoull(v23, 0LL, 16);
  v25 = *(const char **)(v31 + 32);
  v19[2] = (char *)v24;
  v26 = strtoull(v25, 0LL, 16);
  v27 = v19[1] == 0LL;
  v19[3] = (char *)v26;
  v19[4] = (char *)a3;
  if ( !v27 && *v19 )
    goto LABEL_34;
LABEL_39:
  if ( *(_BYTE *)(a3 + 40) )
    close_dir_part_6(a3);
  cJSON_Delete((_DWORD *)v47);
  return 10LL;
}
// 39D0: using guessed type __int64 __fastcall close_dir_part_6(_QWORD);
// 9720: using guessed type __int64 __fastcall cJSON_ParseWithLength(_QWORD, _QWORD);
// 9B30: using guessed type __int64 __fastcall cJSON_GetObjectItemCaseSensitive(_QWORD, _QWORD);
// C1C0: using guessed type __int64 __fastcall cJSON_IsString(_QWORD);
// C1E0: using guessed type __int64 __fastcall cJSON_IsArray(_QWORD);

//----- (0000000000004070) ----------------------------------------------------
__int64 __fastcall download_file_with_key(__int64 a1, const char *a2, __int64 a3, int *a4)
{
  int v5; // eax
  int v7; // ebp
  unsigned int v8; // ebp
  __int64 v10; // [rsp+8h] [rbp-60h] BYREF
  char templatea[16]; // [rsp+10h] [rbp-58h] BYREF
  char v12[8]; // [rsp+20h] [rbp-48h] BYREF

  v5 = *a4;
  v10 = 0x100000000LL;
  if ( v5 > 0 )
  {
    LODWORD(v10) = v5;
    v8 = download_media_isra_1(a1, a2, a3, (int *)&v10, (_BYTE *)&v10 + 4);
  }
  else
  {
    strcpy(v12, "XXXX");
    *(__m128i *)templatea = _mm_load_si128((const __m128i *)"/tmp/MediaTmp-XXChall media services");
    v7 = mkstemp64(templatea);
    if ( v7 < 0 )
    {
      *a4 = -1;
      v8 = 10;
    }
    else
    {
      unlink(templatea);
      *a4 = v7;
      LODWORD(v10) = v7;
      v8 = download_media_isra_1(a1, a2, a3, (int *)&v10, (_BYTE *)&v10 + 4);
      if ( v8 )
      {
        close(*a4);
        *a4 = -1;
      }
    }
  }
  return v8;
}

//----- (0000000000004150) ----------------------------------------------------
void __fastcall close_dir(__int64 a1)
{
  if ( a1 )
  {
    if ( *(_BYTE *)(a1 + 40) )
      close_dir_part_6(a1);
  }
}

//----- (0000000000004170) ----------------------------------------------------
void __fastcall close_index(__int64 a1)
{
  if ( a1 )
    erase_dir(a1);
}

//----- (0000000000004190) ----------------------------------------------------
__int64 __fastcall download_file(context *a1, _QWORD *a2, int *a3)
{
  unsigned __int64 v5; // rdx
  __int64 result; // rax
  __int64 v7; // rsi
  const char *v8; // r13
  __int128 v9[3]; // [rsp+0h] [rbp-38h] BYREF

  if ( a1 == 0LL || a3 == 0LL || !a2 )
    return 10LL;
  if ( !a1->permcheck || (v5 = get_current_permission(a1), result = 3LL, a2[2] >= v5) )
  {
    v7 = a2[4];
    v8 = (const char *)a2[1];
    v9[0] = 0LL;
    result = get_file_key_part_5(a1, v7, (__int64)v9);
    if ( !(_DWORD)result )
      result = download_file_with_key((__int64)a1, v8, (__int64)v9, a3);
  }
  return result;
}

//----- (0000000000004230) ----------------------------------------------------
__int64 __fastcall open_index(context *a1, __int64 a2)
{
  unsigned int v2; // er12
  int v4; // er13
  __off64_t v5; // r12
  void *v6; // rbp
  char v7[24]; // [rsp+0h] [rbp-48h] BYREF

  v2 = 10;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( !*(_QWORD *)a2
        && !*(_QWORD *)(a2 + 8)
        && !*(_QWORD *)(a2 + 32)
        && !*(_QWORD *)(a2 + 48)
        && !*(_QWORD *)(a2 + 64) )
      {
        strcpy(&v7[16], "XXXX");
        *(__m128i *)v7 = _mm_load_si128((const __m128i *)"/tmp/MediaTmp-XXChall media services");
        v4 = mkstemp64(v7);
        if ( v4 >= 0 )
        {
          unlink(v7);
          *(_DWORD *)&v7[4] = 0;
          *(_DWORD *)v7 = v4;
          v2 = download_media_isra_1((__int64)a1, "index.json", 0LL, (int *)v7, &v7[4]);
          if ( v2 )
          {
            close(v4);
          }
          else
          {
            v5 = lseek64(v4, 0LL, 2);
            v6 = malloc(v5);
            if ( v6 )
            {
              lseek64(v4, 0LL, 0);
              if ( v5 == read(v4, v6, v5) )
              {
                close(v4);
                *(_BYTE *)(a2 + 40) = 0;
                *(_QWORD *)(a2 + 32) = 0LL;
                *(_QWORD *)(a2 + 16) = -1LL;
                *(_QWORD *)(a2 + 8) = 0LL;
                *(_QWORD *)a2 = 0LL;
                v2 = parse_json_index((__int64)v6, v5, a2);
                free(v6);
              }
              else
              {
                v2 = 10;
                free(v6);
                close(v4);
              }
            }
            else
            {
              v2 = 10;
              close(v4);
            }
          }
        }
      }
    }
  }
  return v2;
}

//----- (00000000000043C0) ----------------------------------------------------
__int64 __fastcall open_dir(context *a1, __int64 a2)
{
  __int64 result; // rax
  const char *v3; // r12
  unsigned __int64 v5; // rdx
  __int64 v6; // rsi
  int v7; // er13
  __off64_t v8; // r12
  void *v9; // rbp
  unsigned int v10; // [rsp+0h] [rbp-4Ch]
  int fd; // [rsp+10h] [rbp-3Ch] BYREF
  __int128 v12[3]; // [rsp+14h] [rbp-38h] BYREF

  if ( !a2 || !a1 )
    return 10LL;
  result = 0LL;
  if ( *(_BYTE *)(a2 + 40) )
    return result;
  if ( !*(_QWORD *)a2 )
    return 10LL;
  v3 = *(const char **)(a2 + 8);
  if ( !v3 || !*(_QWORD *)(a2 + 32) )
    return 10LL;
  if ( a1->permcheck )
  {
    v5 = get_current_permission(a1);
    result = 3LL;
    if ( *(_QWORD *)(a2 + 16) < v5 )
      return result;
    v3 = *(const char **)(a2 + 8);
  }
  v6 = *(_QWORD *)(a2 + 24);
  fd = 0;
  v12[0] = 0LL;
  result = get_file_key_part_5(a1, v6, (__int64)v12);
  if ( !(_DWORD)result )
  {
    result = download_file_with_key((__int64)a1, v3, (__int64)v12, &fd);
    if ( !(_DWORD)result )
    {
      v7 = fd;
      v8 = lseek64(fd, 0LL, 2);
      v9 = malloc(v8);
      if ( v9 )
      {
        lseek64(v7, 0LL, 0);
        if ( v8 == read(v7, v9, v8) )
        {
          close(fd);
          v10 = parse_json_index((__int64)v9, v8, a2);
          free(v9);
          return v10;
        }
        free(v9);
      }
      close(fd);
      result = 10LL;
    }
  }
  return result;
}

//----- (0000000000004540) ----------------------------------------------------
__int64 __fastcall get_dir_path(__int64 a1, void **a2)
{
  __int64 v3; // r14
  const char *v4; // rdi
  size_t v5; // rax
  __int64 v6; // r15
  size_t v7; // r12
  size_t v8; // rax
  size_t v9; // r13
  __int64 v10; // rdx
  size_t v11; // rax
  const char **v12; // r9
  __int64 v13; // rdx
  const char *v14; // rdi
  size_t v15; // rax
  const char **v16; // r10
  const char **v17; // r9
  __int64 v18; // rdx
  const char *v19; // rdi
  size_t v20; // rax
  const char **v21; // r11
  const char **v22; // r10
  const char **v23; // r9
  __int64 v24; // rdx
  const char *v25; // rdi
  size_t v26; // rax
  const char **v27; // r8
  const char **v28; // r11
  const char **v29; // r9
  __int64 v30; // rdx
  const char **v31; // r10
  const char *v32; // rdi
  __int64 result; // rax
  size_t v34; // rax
  const char **v35; // r9
  const char **v36; // r11
  char *v37; // rdi
  const char **v38; // r10
  size_t v39; // rax
  const char **v40; // r10
  char *v41; // rdi
  const char **v42; // r9
  size_t v43; // rax
  const char **v44; // r9
  char *v45; // rdi
  char *v46; // rdi
  char *v47; // r15
  char *v48; // rdi
  char *v49; // r13
  char *v50; // rdi
  _WORD *v51; // rax
  const char *v52; // rbx
  char *v53; // rax
  char *v54; // rax
  char *v55; // rax
  __int64 v56; // [rsp+0h] [rbp-90h]
  const char **v57; // [rsp+0h] [rbp-90h]
  const char **v58; // [rsp+0h] [rbp-90h]
  const char **v59; // [rsp+0h] [rbp-90h]
  const char **v60; // [rsp+0h] [rbp-90h]
  char *v61; // [rsp+0h] [rbp-90h]
  char *v62; // [rsp+0h] [rbp-90h]
  char *v63; // [rsp+0h] [rbp-90h]
  char *v64; // [rsp+0h] [rbp-90h]
  __int64 v65; // [rsp+0h] [rbp-90h]
  __int64 v66; // [rsp+0h] [rbp-90h]
  const char **v67; // [rsp+0h] [rbp-90h]
  const char **v68; // [rsp+0h] [rbp-90h]
  const char **v69; // [rsp+0h] [rbp-90h]
  const char **v70; // [rsp+0h] [rbp-90h]
  const char **v71; // [rsp+0h] [rbp-90h]
  const char **v72; // [rsp+8h] [rbp-88h]
  __int64 v73; // [rsp+8h] [rbp-88h]
  const char **v74; // [rsp+8h] [rbp-88h]
  const char **v75; // [rsp+8h] [rbp-88h]
  const char **v76; // [rsp+8h] [rbp-88h]
  __int64 v77; // [rsp+8h] [rbp-88h]
  const char **v78; // [rsp+8h] [rbp-88h]
  const char **v79; // [rsp+8h] [rbp-88h]
  const char **v80; // [rsp+8h] [rbp-88h]
  const char **v81; // [rsp+8h] [rbp-88h]
  size_t v82; // [rsp+10h] [rbp-80h]
  const char **v83; // [rsp+18h] [rbp-78h]
  __int64 v84; // [rsp+18h] [rbp-78h]
  const char **v85; // [rsp+18h] [rbp-78h]
  const char **v86; // [rsp+18h] [rbp-78h]
  __int64 v87; // [rsp+18h] [rbp-78h]
  const char **v88; // [rsp+18h] [rbp-78h]
  const char **v89; // [rsp+18h] [rbp-78h]
  size_t v90; // [rsp+20h] [rbp-70h]
  const char **v91; // [rsp+28h] [rbp-68h]
  __int64 v92; // [rsp+28h] [rbp-68h]
  const char **v93; // [rsp+28h] [rbp-68h]
  __int64 v94; // [rsp+28h] [rbp-68h]
  size_t v95; // [rsp+30h] [rbp-60h]
  char *v96; // [rsp+38h] [rbp-58h]
  __int64 v97; // [rsp+38h] [rbp-58h]
  size_t v98; // [rsp+40h] [rbp-50h]
  __int64 v99; // [rsp+48h] [rbp-48h]
  size_t n; // [rsp+50h] [rbp-40h]

  if ( !a1 || !a2 )
    return 10LL;
  v3 = *(_QWORD *)(a1 + 32);
  if ( !v3 )
  {
    if ( *a2 )
      free(*a2);
    v51 = malloc(2uLL);
    *a2 = v51;
    if ( v51 )
    {
      *v51 = 47;
      return 0LL;
    }
    return 10LL;
  }
  v4 = *(const char **)a1;
  if ( v4 )
  {
    v5 = strlen(v4);
    v6 = *(_QWORD *)(v3 + 32);
    v7 = v5;
    if ( !v6 )
    {
      if ( *a2 )
        free(*a2);
      v50 = (char *)calloc(v7 + 3, 1uLL);
      *a2 = v50;
      if ( !v50 )
        return 10LL;
      *(_WORD *)v50 = 47;
      goto LABEL_35;
    }
    if ( *(_QWORD *)v3 )
    {
      v8 = strlen(*(const char **)v3);
      v9 = v8;
      v10 = v7 + v8 + 1;
      if ( !*(_QWORD *)(v6 + 32) )
      {
        if ( *a2 )
        {
          v65 = v7 + v8 + 1;
          free(*a2);
          v10 = v65;
        }
        v48 = (char *)calloc(v10 + 3, 1uLL);
        *a2 = v48;
        if ( !v48 )
          return 10LL;
        *(_WORD *)v48 = 47;
LABEL_24:
        strncat(v48, *(const char **)v3, v9);
        v49 = (char *)*a2;
        *(_WORD *)&v49[strlen((const char *)*a2)] = 47;
        v50 = (char *)*a2;
        if ( !*a2 )
          return 10LL;
LABEL_35:
        strncat(v50, *(const char **)a1, v7);
        v52 = (const char *)*a2;
        *(_WORD *)&v52[strlen(v52)] = 47;
        return 0LL;
      }
      v72 = *(const char ***)(v6 + 32);
      v56 = v7 + v8 + 1;
      if ( *(_QWORD *)v6 )
      {
        v11 = strlen(*(const char **)v6);
        v12 = v72;
        v82 = v11;
        v13 = v56 + v11 + 1;
        if ( v72[4] )
        {
          v14 = *v72;
          v83 = (const char **)v72[4];
          v73 = v56 + v11 + 1;
          v57 = v12;
          if ( !v14 )
            return 10LL;
          v15 = strlen(v14);
          v16 = v83;
          v90 = v15;
          v17 = v57;
          v18 = v73 + v15 + 1;
          if ( v83[4] )
          {
            v19 = *v83;
            v91 = (const char **)v83[4];
            v84 = v73 + v15 + 1;
            v74 = v57;
            v58 = v16;
            if ( !v19 )
              return 10LL;
            v20 = strlen(v19);
            v21 = v91;
            v22 = v58;
            v23 = v74;
            v95 = v20;
            v24 = v84 + v20 + 1;
            if ( v91[4] )
            {
              v25 = *v91;
              v96 = (char *)v91[4];
              v92 = v84 + v20 + 1;
              v85 = v58;
              v59 = v21;
              if ( !v25 )
                return 10LL;
              v26 = strlen(v25);
              v27 = (const char **)v96;
              v28 = v59;
              v29 = v74;
              v98 = v26;
              v30 = v92 + v26 + 1;
              v31 = v85;
              if ( *((_QWORD *)v96 + 4) )
              {
                v32 = *(const char **)v96;
                v99 = *((_QWORD *)v96 + 4);
                v97 = v92 + v26 + 1;
                v93 = v59;
                v60 = v27;
                if ( !v32 )
                  return 10LL;
                n = strlen(v32);
                result = get_dir_path_(v99, (char **)a2, v97 + n + 2);
                if ( (_DWORD)result )
                  return result;
                if ( !*a2 )
                  return 10LL;
                strncat((char *)*a2, *v60, n);
                v61 = (char *)*a2;
                v34 = strlen((const char *)*a2);
                v35 = v74;
                v36 = v93;
                *(_WORD *)&v61[v34] = 47;
                v37 = (char *)*a2;
                v38 = v85;
                if ( !*a2 )
                  return 10LL;
              }
              else
              {
                if ( *a2 )
                {
                  v94 = v92 + v26 + 1;
                  v88 = v59;
                  v80 = v31;
                  v70 = v29;
                  free(*a2);
                  v29 = v70;
                  v31 = v80;
                  v28 = v88;
                  v30 = v94;
                }
                v89 = v28;
                v81 = v31;
                v71 = v29;
                v55 = (char *)calloc(v30 + 3, 1uLL);
                v35 = v71;
                v38 = v81;
                v37 = v55;
                *a2 = v55;
                v36 = v89;
                if ( !v55 )
                  return 10LL;
                *(_WORD *)v55 = 47;
              }
              v86 = v38;
              v75 = v35;
              strncat(v37, *v36, v98);
              v62 = (char *)*a2;
              v39 = strlen((const char *)*a2);
              v40 = v86;
              *(_WORD *)&v62[v39] = 47;
              v41 = (char *)*a2;
              v42 = v75;
              if ( !*a2 )
                return 10LL;
            }
            else
            {
              if ( *a2 )
              {
                v87 = v84 + v20 + 1;
                v78 = v58;
                v68 = v23;
                free(*a2);
                v23 = v68;
                v22 = v78;
                v24 = v87;
              }
              v79 = v22;
              v69 = v23;
              v54 = (char *)calloc(v24 + 3, 1uLL);
              v42 = v69;
              v40 = v79;
              v41 = v54;
              *a2 = v54;
              if ( !v54 )
                return 10LL;
              *(_WORD *)v54 = 47;
            }
            v76 = v42;
            strncat(v41, *v40, v95);
            v63 = (char *)*a2;
            v43 = strlen((const char *)*a2);
            v44 = v76;
            *(_WORD *)&v63[v43] = 47;
            v45 = (char *)*a2;
            if ( !*a2 )
              return 10LL;
          }
          else
          {
            if ( *a2 )
            {
              v77 = v73 + v15 + 1;
              free(*a2);
              v17 = v57;
              v18 = v77;
            }
            v67 = v17;
            v53 = (char *)calloc(v18 + 3, 1uLL);
            v44 = v67;
            v45 = v53;
            *a2 = v53;
            if ( !v53 )
              return 10LL;
            *(_WORD *)v53 = 47;
          }
          strncat(v45, *v44, v90);
          v64 = (char *)*a2;
          *(_WORD *)&v64[strlen((const char *)*a2)] = 47;
          v46 = (char *)*a2;
          if ( !*a2 )
            return 10LL;
        }
        else
        {
          if ( *a2 )
          {
            v66 = v56 + v11 + 1;
            free(*a2);
            v13 = v66;
          }
          v46 = (char *)calloc(v13 + 3, 1uLL);
          *a2 = v46;
          if ( !v46 )
            return 10LL;
          *(_WORD *)v46 = 47;
        }
        strncat(v46, *(const char **)v6, v82);
        v47 = (char *)*a2;
        *(_WORD *)&v47[strlen((const char *)*a2)] = 47;
        v48 = (char *)*a2;
        if ( *a2 )
          goto LABEL_24;
      }
    }
  }
  return 10LL;
}

//----- (0000000000004B40) ----------------------------------------------------
__int64 __fastcall get_file_path(__int64 a1, void **a2)
{
  __int64 v2; // r12
  size_t v4; // rax
  __int64 v5; // r15
  size_t v6; // r13
  size_t v7; // rax
  size_t v8; // r14
  size_t v9; // rdx
  size_t v10; // rax
  const char **v11; // r8
  __int64 v12; // rdx
  const char *v13; // rdi
  size_t v14; // rax
  const char **v15; // r9
  const char **v16; // r8
  __int64 v17; // rdx
  const char *v18; // rdi
  size_t v19; // rax
  const char **v20; // r10
  const char **v21; // r9
  const char **v22; // r8
  __int64 v23; // rdx
  const char *v24; // rdi
  size_t v25; // rax
  const char **v26; // r11
  const char **v27; // r10
  const char **v28; // r8
  __int64 v29; // rdx
  const char **v30; // r9
  const char *v31; // rdi
  size_t v32; // rax
  const char **v33; // rcx
  const char **v34; // r11
  const char **v35; // r8
  __int64 v36; // rdx
  const char **v37; // r9
  const char **v38; // r10
  const char *v39; // rdi
  __int64 result; // rax
  size_t v41; // rax
  const char **v42; // r8
  const char **v43; // r9
  const char **v44; // r11
  char *v45; // rdi
  const char **v46; // r10
  size_t v47; // rax
  const char **v48; // r8
  const char **v49; // r10
  char *v50; // rdi
  const char **v51; // r9
  size_t v52; // rax
  const char **v53; // r9
  char *v54; // rdi
  const char **v55; // r8
  size_t v56; // rax
  const char **v57; // r8
  char *v58; // rdi
  char *v59; // rdi
  char *v60; // r15
  char *v61; // rdi
  char *v62; // rax
  char *v63; // rdi
  char *v64; // r12
  char *v65; // rax
  char *v66; // rax
  char *v67; // rax
  char *v68; // rax
  size_t v69; // [rsp+0h] [rbp-A0h]
  const char **v70; // [rsp+0h] [rbp-A0h]
  const char **v71; // [rsp+0h] [rbp-A0h]
  const char **v72; // [rsp+0h] [rbp-A0h]
  const char **v73; // [rsp+0h] [rbp-A0h]
  const char **v74; // [rsp+0h] [rbp-A0h]
  char *v75; // [rsp+0h] [rbp-A0h]
  char *v76; // [rsp+0h] [rbp-A0h]
  char *v77; // [rsp+0h] [rbp-A0h]
  char *v78; // [rsp+0h] [rbp-A0h]
  char *v79; // [rsp+0h] [rbp-A0h]
  size_t v80; // [rsp+0h] [rbp-A0h]
  const char **v81; // [rsp+0h] [rbp-A0h]
  __int64 v82; // [rsp+0h] [rbp-A0h]
  const char **v83; // [rsp+0h] [rbp-A0h]
  const char **v84; // [rsp+0h] [rbp-A0h]
  const char **v85; // [rsp+0h] [rbp-A0h]
  const char **v86; // [rsp+0h] [rbp-A0h]
  const char **v87; // [rsp+0h] [rbp-A0h]
  const char **v88; // [rsp+0h] [rbp-A0h]
  const char **v89; // [rsp+8h] [rbp-98h]
  __int64 v90; // [rsp+8h] [rbp-98h]
  const char **v91; // [rsp+8h] [rbp-98h]
  const char **v92; // [rsp+8h] [rbp-98h]
  const char **v93; // [rsp+8h] [rbp-98h]
  const char **v94; // [rsp+8h] [rbp-98h]
  __int64 v95; // [rsp+8h] [rbp-98h]
  const char **v96; // [rsp+8h] [rbp-98h]
  const char **v97; // [rsp+8h] [rbp-98h]
  const char **v98; // [rsp+8h] [rbp-98h]
  const char **v99; // [rsp+8h] [rbp-98h]
  const char **v100; // [rsp+8h] [rbp-98h]
  const char **v101; // [rsp+8h] [rbp-98h]
  size_t v102; // [rsp+10h] [rbp-90h]
  const char **v103; // [rsp+18h] [rbp-88h]
  __int64 v104; // [rsp+18h] [rbp-88h]
  const char **v105; // [rsp+18h] [rbp-88h]
  const char **v106; // [rsp+18h] [rbp-88h]
  const char **v107; // [rsp+18h] [rbp-88h]
  __int64 v108; // [rsp+18h] [rbp-88h]
  const char **v109; // [rsp+18h] [rbp-88h]
  const char **v110; // [rsp+18h] [rbp-88h]
  const char **v111; // [rsp+18h] [rbp-88h]
  const char **v112; // [rsp+18h] [rbp-88h]
  size_t v113; // [rsp+20h] [rbp-80h]
  const char **v114; // [rsp+28h] [rbp-78h]
  __int64 v115; // [rsp+28h] [rbp-78h]
  const char **v116; // [rsp+28h] [rbp-78h]
  const char **v117; // [rsp+28h] [rbp-78h]
  __int64 v118; // [rsp+28h] [rbp-78h]
  const char **v119; // [rsp+28h] [rbp-78h]
  const char **v120; // [rsp+28h] [rbp-78h]
  size_t v121; // [rsp+30h] [rbp-70h]
  const char **v122; // [rsp+38h] [rbp-68h]
  __int64 v123; // [rsp+38h] [rbp-68h]
  __int64 v124; // [rsp+38h] [rbp-68h]
  __int64 v125; // [rsp+38h] [rbp-68h]
  size_t v126; // [rsp+40h] [rbp-60h]
  char *v127; // [rsp+48h] [rbp-58h]
  const char **v128; // [rsp+48h] [rbp-58h]
  size_t v129; // [rsp+50h] [rbp-50h]
  __int64 v130; // [rsp+58h] [rbp-48h]
  size_t n; // [rsp+60h] [rbp-40h]

  if ( !a1 )
    return 10LL;
  v2 = *(_QWORD *)(a1 + 40);
  if ( !v2 || !a2 )
    return 10LL;
  v4 = strlen(*(const char **)a1);
  v5 = *(_QWORD *)(v2 + 32);
  v6 = v4;
  if ( !v5 )
  {
    if ( *a2 )
      free(*a2);
    v62 = (char *)calloc(v6 + 2, 1uLL);
    v63 = v62;
    *a2 = v62;
    if ( !v62 )
      return 10LL;
    *(_WORD *)v62 = 47;
    goto LABEL_32;
  }
  if ( *(_QWORD *)v2 )
  {
    v7 = strlen(*(const char **)v2);
    v8 = v7;
    v9 = v6 + v7;
    if ( !*(_QWORD *)(v5 + 32) )
    {
      if ( *a2 )
      {
        v80 = v6 + v7;
        free(*a2);
        v9 = v80;
      }
      v61 = (char *)calloc(v9 + 3, 1uLL);
      *a2 = v61;
      if ( !v61 )
        return 10LL;
      *(_WORD *)v61 = 47;
LABEL_38:
      strncat(v61, *(const char **)v2, v8);
      v64 = (char *)*a2;
      *(_WORD *)&v64[strlen((const char *)*a2)] = 47;
      v63 = (char *)*a2;
      if ( !*a2 )
        return 10LL;
LABEL_32:
      strncat(v63, *(const char **)a1, v6);
      return 0LL;
    }
    v89 = *(const char ***)(v5 + 32);
    v69 = v6 + v7;
    if ( *(_QWORD *)v5 )
    {
      v10 = strlen(*(const char **)v5);
      v11 = v89;
      v102 = v10;
      v12 = v69 + v10 + 1;
      if ( !v89[4] )
      {
        if ( *a2 )
        {
          v82 = v69 + v10 + 1;
          free(*a2);
          v12 = v82;
        }
        v59 = (char *)calloc(v12 + 3, 1uLL);
        *a2 = v59;
        if ( !v59 )
          return 10LL;
        *(_WORD *)v59 = 47;
LABEL_25:
        strncat(v59, *(const char **)v5, v102);
        v60 = (char *)*a2;
        *(_WORD *)&v60[strlen((const char *)*a2)] = 47;
        v61 = (char *)*a2;
        if ( !*a2 )
          return 10LL;
        goto LABEL_38;
      }
      v13 = *v89;
      v103 = (const char **)v89[4];
      v90 = v69 + v10 + 1;
      v70 = v11;
      if ( v13 )
      {
        v14 = strlen(v13);
        v15 = v103;
        v113 = v14;
        v16 = v70;
        v17 = v90 + v14 + 1;
        if ( v103[4] )
        {
          v18 = *v103;
          v114 = (const char **)v103[4];
          v104 = v90 + v14 + 1;
          v91 = v70;
          v71 = v15;
          if ( !v18 )
            return 10LL;
          v19 = strlen(v18);
          v20 = v114;
          v21 = v71;
          v22 = v91;
          v121 = v19;
          v23 = v104 + v19 + 1;
          if ( v114[4] )
          {
            v24 = *v114;
            v122 = (const char **)v114[4];
            v115 = v104 + v19 + 1;
            v105 = v71;
            v72 = v20;
            if ( !v24 )
              return 10LL;
            v25 = strlen(v24);
            v26 = v122;
            v27 = v72;
            v28 = v91;
            v126 = v25;
            v29 = v115 + v25 + 1;
            v30 = v105;
            if ( v122[4] )
            {
              v31 = *v122;
              v127 = (char *)v122[4];
              v123 = v115 + v25 + 1;
              v116 = v72;
              v73 = v26;
              if ( !v31 )
                return 10LL;
              v32 = strlen(v31);
              v33 = (const char **)v127;
              v34 = v73;
              v35 = v91;
              v129 = v32;
              v36 = v123 + v32 + 1;
              v37 = v105;
              v38 = v116;
              v124 = *((_QWORD *)v127 + 4);
              if ( v124 )
              {
                v39 = *(const char **)v127;
                v130 = v36;
                v128 = v73;
                v74 = v33;
                if ( !v39 )
                  return 10LL;
                n = strlen(v39);
                result = get_dir_path_(v124, (char **)a2, v130 + n + 2);
                if ( (_DWORD)result )
                  return result;
                if ( !*a2 )
                  return 10LL;
                strncat((char *)*a2, *v74, n);
                v75 = (char *)*a2;
                v41 = strlen((const char *)*a2);
                v42 = v91;
                v43 = v105;
                v44 = v128;
                *(_WORD *)&v75[v41] = 47;
                v45 = (char *)*a2;
                v46 = v116;
                if ( !*a2 )
                  return 10LL;
              }
              else
              {
                if ( *a2 )
                {
                  v125 = v36;
                  v119 = v73;
                  v111 = v38;
                  v100 = v37;
                  v87 = v35;
                  free(*a2);
                  v35 = v87;
                  v37 = v100;
                  v38 = v111;
                  v34 = v119;
                  v36 = v125;
                }
                v120 = v34;
                v112 = v38;
                v101 = v37;
                v88 = v35;
                v68 = (char *)calloc(v36 + 3, 1uLL);
                v42 = v88;
                v43 = v101;
                v45 = v68;
                *a2 = v68;
                v46 = v112;
                v44 = v120;
                if ( !v68 )
                  return 10LL;
                *(_WORD *)v68 = 47;
              }
              v117 = v46;
              v106 = v43;
              v92 = v42;
              strncat(v45, *v44, v129);
              v76 = (char *)*a2;
              v47 = strlen((const char *)*a2);
              v48 = v92;
              v49 = v117;
              *(_WORD *)&v76[v47] = 47;
              v50 = (char *)*a2;
              v51 = v106;
              if ( !*a2 )
                return 10LL;
            }
            else
            {
              if ( *a2 )
              {
                v118 = v115 + v25 + 1;
                v109 = v72;
                v98 = v30;
                v85 = v28;
                free(*a2);
                v28 = v85;
                v30 = v98;
                v27 = v109;
                v29 = v118;
              }
              v110 = v27;
              v99 = v30;
              v86 = v28;
              v67 = (char *)calloc(v29 + 3, 1uLL);
              v48 = v86;
              v51 = v99;
              v50 = v67;
              *a2 = v67;
              v49 = v110;
              if ( !v67 )
                return 10LL;
              *(_WORD *)v67 = 47;
            }
            v107 = v51;
            v93 = v48;
            strncat(v50, *v49, v126);
            v77 = (char *)*a2;
            v52 = strlen((const char *)*a2);
            v53 = v107;
            *(_WORD *)&v77[v52] = 47;
            v54 = (char *)*a2;
            v55 = v93;
            if ( !*a2 )
              return 10LL;
          }
          else
          {
            if ( *a2 )
            {
              v108 = v104 + v19 + 1;
              v96 = v71;
              v83 = v22;
              free(*a2);
              v22 = v83;
              v21 = v96;
              v23 = v108;
            }
            v97 = v21;
            v84 = v22;
            v66 = (char *)calloc(v23 + 3, 1uLL);
            v55 = v84;
            v53 = v97;
            v54 = v66;
            *a2 = v66;
            if ( !v66 )
              return 10LL;
            *(_WORD *)v66 = 47;
          }
          v94 = v55;
          strncat(v54, *v53, v121);
          v78 = (char *)*a2;
          v56 = strlen((const char *)*a2);
          v57 = v94;
          *(_WORD *)&v78[v56] = 47;
          v58 = (char *)*a2;
          if ( !*a2 )
            return 10LL;
        }
        else
        {
          if ( *a2 )
          {
            v95 = v90 + v14 + 1;
            free(*a2);
            v16 = v70;
            v17 = v95;
          }
          v81 = v16;
          v65 = (char *)calloc(v17 + 3, 1uLL);
          v57 = v81;
          v58 = v65;
          *a2 = v65;
          if ( !v65 )
            return 10LL;
          *(_WORD *)v65 = 47;
        }
        strncat(v58, *v57, v113);
        v79 = (char *)*a2;
        *(_WORD *)&v79[strlen((const char *)*a2)] = 47;
        v59 = (char *)*a2;
        if ( *a2 )
          goto LABEL_25;
      }
    }
  }
  return 10LL;
}

//----- (0000000000005250) ----------------------------------------------------
__int64 __fastcall get_dir(__int64 a1, const char **a2, char *a3, const char ***a4)
{
  char *v4; // rbx
  const char **v5; // rax
  const char **v6; // r15
  char v7; // r13
  size_t v8; // rsi
  _BYTE *v9; // rax
  __int64 v10; // r14
  unsigned __int64 v11; // rbp
  unsigned __int64 v12; // rcx
  unsigned int v13; // er13
  __int64 v15; // r9
  _BOOL4 v16; // edx
  void **v17; // r12
  const char **v18; // r14
  const char *v19; // rbx
  const char **v20; // rbp
  unsigned int v21; // eax
  const char *v22; // r12
  const char **v23; // r13
  const char *v24; // r15
  void *v25; // rdi
  void **v26; // rbx
  void *v27; // rdi
  void **v28; // rbx
  void *v29; // rdi
  void **v30; // rbx
  char *v31; // rax
  void *v32; // rdi
  void **v33; // rbx
  char *s1; // [rsp+0h] [rbp-68h]
  char *s1a; // [rsp+0h] [rbp-68h]
  char *ptr; // [rsp+10h] [rbp-58h]
  void **ptra; // [rsp+10h] [rbp-58h]
  unsigned __int64 v40; // [rsp+28h] [rbp-40h]
  unsigned __int64 v41; // [rsp+28h] [rbp-40h]

  v4 = a3;
  if ( a1 == 0 || a2 == 0LL )
    return 10;
  if ( !a3 )
    return 10;
  v5 = (const char **)malloc(0x20uLL);
  v6 = v5;
  if ( !v5 )
    return 10;
  v7 = *v4;
  s1 = 0LL;
  if ( *v4 == 47 )
  {
    v31 = (char *)malloc(2uLL);
    *v6 = v31;
    if ( v31 )
    {
      s1 = (_BYTE *)(&dword_0 + 1);
      *(_WORD *)v31 = 47;
      v5 = v6 + 1;
      goto LABEL_5;
    }
    free(v6);
    return 10;
  }
LABEL_5:
  *v5 = 0LL;
  ptr = &byte_4;
  while ( v7 && v7 != 63 )
  {
    if ( s1 + 1 >= ptr )
    {
      v8 = 8LL * (_QWORD)(ptr + 4);
      ptr += 4;
      v6 = (const char **)realloc(v6, v8);
      if ( !v6 )
        return 10;
    }
    v9 = malloc(0x10uLL);
    if ( !v9 )
      return 10;
    v10 = 0LL;
    v11 = 0LL;
    v12 = 16LL;
    while ( (unsigned __int8)(v7 + 1) > 1u && v7 != 63 )
    {
      ++v10;
      if ( v7 == 47 )
      {
        if ( v11 >= v12 )
        {
          v40 = v12 + 16;
          v9 = realloc(v9, v12 + 16);
          v12 = v40;
          if ( !v9 )
            return 10;
        }
        if ( v11 )
          goto LABEL_23;
      }
      else
      {
        v9[v11++] = v7;
        if ( v11 >= v12 )
        {
          v41 = v12 + 16;
          v9 = realloc(v9, v12 + 16);
          v12 = v41;
          if ( !v9 )
            return 10;
        }
      }
      v7 = v4[v10];
    }
    if ( v11 >= v12 )
    {
      v9 = realloc(v9, v12 + 16);
      if ( !v9 )
        return 10;
LABEL_23:
      v4 += v10;
      v7 = *v4;
      goto LABEL_25;
    }
    v4 += v10;
LABEL_25:
    v9[v11] = 0;
    if ( !*v9 || !strcmp(v9, ".") )
    {
LABEL_32:
      free(v9);
    }
    else
    {
      v15 = (__int64)s1;
      v16 = strcmp(v9, "..") != 0;
      if ( !s1 || v16 || !strcmp(v6[v15 - 1], "..") )
      {
        v6[(_QWORD)s1] = v9;
        v6[v15 + 1] = 0LL;
        ++s1;
      }
      else
      {
        if ( !strcmp(v6[v15 - 1], "/") )
          goto LABEL_32;
        --s1;
        free(v9);
        v17 = (void **)&v6[(_QWORD)s1];
        free(*v17);
        *v17 = 0LL;
      }
    }
  }
  v18 = a2;
  s1a = (char *)*v6;
  if ( !*v6 )
  {
    v13 = open_dir((context *)a1, (__int64)a2);
    if ( v13 )
      goto LABEL_57;
    if ( !a4 )
      goto LABEL_64;
LABEL_61:
    *a4 = v18;
    if ( !s1a )
    {
LABEL_64:
      v13 = 0;
      free(v6);
      return v13;
    }
LABEL_62:
    v29 = s1a;
    v30 = (void **)v6;
    do
    {
      free(v29);
      *v30++ = 0LL;
      v29 = *v30;
    }
    while ( *v30 );
    goto LABEL_64;
  }
  if ( !strcmp(*v6, "/") )
  {
    while ( v18[4] )
      v18 = (const char **)v18[4];
    v19 = v6[1];
    v20 = v6 + 1;
    if ( v19 )
      goto LABEL_37;
LABEL_59:
    v13 = open_dir((context *)a1, (__int64)v18);
    if ( v13 )
    {
      v32 = s1a;
      v33 = (void **)v6;
      do
      {
        free(v32);
        *v33++ = 0LL;
        v32 = *v33;
      }
      while ( *v33 );
      goto LABEL_57;
    }
    if ( !a4 )
      goto LABEL_62;
    goto LABEL_61;
  }
  v19 = *v6;
  v20 = v6;
LABEL_37:
  ptra = (void **)v6;
  while ( 1 )
  {
    v21 = open_dir((context *)a1, (__int64)v18);
    if ( v21 )
      break;
    if ( strcmp(v19, ".") )
    {
      if ( !strcmp(v19, "..") )
      {
        if ( v18[4] )
          v18 = (const char **)v18[4];
      }
      else
      {
        v22 = v18[7];
        if ( !v22 )
        {
LABEL_48:
          v25 = s1a;
          v26 = ptra;
          do
          {
            free(v25);
            *v26++ = 0LL;
            v25 = *v26;
          }
          while ( *v26 );
          v13 = 8;
          free(ptra);
          return v13;
        }
        v23 = (const char **)v18[6];
        v24 = 0LL;
        while ( 1 )
        {
          v18 = v23;
          if ( !strcmp(v19, *v23) )
            break;
          ++v24;
          v23 += 10;
          if ( v24 == v22 )
            goto LABEL_48;
        }
      }
    }
    v19 = *++v20;
    if ( !*v20 )
    {
      v6 = (const char **)ptra;
      goto LABEL_59;
    }
  }
  v6 = (const char **)ptra;
  v27 = s1a;
  v13 = v21;
  v28 = ptra;
  do
  {
    free(v27);
    *v28++ = 0LL;
    v27 = *v28;
  }
  while ( *v28 );
LABEL_57:
  free(v6);
  return v13;
}
// 0: using guessed type int dword_0;
// 4: using guessed type char byte_4;

//----- (0000000000005770) ----------------------------------------------------
__int64 __fastcall get_file(__int64 a1, const char **a2, char *a3, const char ***a4)
{
  char *v4; // rbx
  const char **v5; // rax
  char v6; // r13
  unsigned __int64 v7; // rbp
  _BYTE *v8; // rax
  __int64 v9; // r15
  unsigned __int64 v10; // r14
  unsigned __int64 v11; // rcx
  unsigned int v12; // er13
  __int64 v14; // r9
  void **v15; // r12
  const char **v16; // r14
  const char **v17; // rbp
  const char *v18; // rbx
  unsigned int v19; // eax
  const char *v20; // r15
  const char **v21; // r12
  const char *v22; // r13
  void **v23; // rbx
  void *v24; // rdi
  void **v25; // rbx
  void *v26; // rdi
  void **v27; // rbx
  void *v28; // rdi
  char *v29; // rax
  const char *v30; // r12
  const char **v31; // r14
  const char *v32; // rbp
  void **v33; // rbx
  void *v34; // rdi
  void **v35; // rbx
  void *v36; // rdi
  __int64 v37; // [rsp+0h] [rbp-68h]
  const char *v38; // [rsp+0h] [rbp-68h]
  const char **ptr; // [rsp+8h] [rbp-60h]
  char *s1; // [rsp+18h] [rbp-50h]
  unsigned __int64 v42; // [rsp+28h] [rbp-40h]
  unsigned __int64 v43; // [rsp+28h] [rbp-40h]

  v4 = a3;
  if ( a1 == 0 || a2 == 0LL )
    return 10;
  if ( !a3 )
    return 10;
  v5 = (const char **)malloc(0x20uLL);
  ptr = v5;
  if ( !v5 )
    return 10;
  v6 = *v4;
  v37 = 0LL;
  if ( *v4 == 47 )
  {
    v29 = (char *)malloc(2uLL);
    *ptr = v29;
    if ( v29 )
    {
      v37 = 1LL;
      *(_WORD *)v29 = 47;
      v5 = ptr + 1;
      goto LABEL_5;
    }
    free(ptr);
    return 10;
  }
LABEL_5:
  *v5 = 0LL;
  v7 = 4LL;
  while ( v6 && v6 != 63 )
  {
    if ( v37 + 1 >= v7 )
    {
      v7 += 4LL;
      ptr = (const char **)realloc(ptr, 8 * v7);
      if ( !ptr )
        return 10;
    }
    v8 = malloc(0x10uLL);
    if ( !v8 )
      return 10;
    v9 = 0LL;
    v10 = 0LL;
    v11 = 16LL;
    while ( (unsigned __int8)(v6 + 1) > 1u && v6 != 63 )
    {
      ++v9;
      if ( v6 == 47 )
      {
        if ( v10 >= v11 )
        {
          v42 = v11 + 16;
          v8 = realloc(v8, v11 + 16);
          v11 = v42;
          if ( !v8 )
            return 10;
        }
        if ( v10 )
          goto LABEL_23;
      }
      else
      {
        v8[v10++] = v6;
        if ( v10 >= v11 )
        {
          v43 = v11 + 16;
          v8 = realloc(v8, v11 + 16);
          v11 = v43;
          if ( !v8 )
            return 10;
        }
      }
      v6 = v4[v9];
    }
    if ( v10 >= v11 )
    {
      v8 = realloc(v8, v11 + 16);
      if ( !v8 )
        return 10;
LABEL_23:
      v4 += v9;
      v6 = *v4;
      goto LABEL_25;
    }
    v4 += v9;
LABEL_25:
    v8[v10] = 0;
    if ( !*v8 || !strcmp(v8, ".") )
    {
LABEL_32:
      free(v8);
    }
    else
    {
      v14 = v37;
      if ( !strcmp(v8, "..") && v37 && strcmp(ptr[v14 - 1], "..") )
      {
        if ( !strcmp(ptr[v14 - 1], "/") )
          goto LABEL_32;
        --v37;
        free(v8);
        v15 = (void **)&ptr[v37];
        free(*v15);
        *v15 = 0LL;
      }
      else
      {
        ++v37;
        ptr[v14] = v8;
        ptr[v14 + 1] = 0LL;
      }
    }
  }
  v16 = a2;
  s1 = (char *)*ptr;
  if ( !*ptr )
    goto LABEL_55;
  if ( strcmp(*ptr, "/") )
  {
    v17 = ptr;
    v18 = *ptr;
    goto LABEL_41;
  }
  while ( v16[4] )
    v16 = (const char **)v16[4];
  v18 = ptr[1];
  v17 = ptr + 1;
  if ( !v18 )
  {
LABEL_53:
    v23 = (void **)ptr;
    v24 = s1;
    do
    {
      free(v24);
      *v23++ = 0LL;
      v24 = *v23;
    }
    while ( *v23 );
    goto LABEL_55;
  }
LABEL_41:
  while ( 2 )
  {
    v19 = open_dir((context *)a1, (__int64)v16);
    if ( v19 )
    {
      v27 = (void **)ptr;
      v28 = s1;
      v12 = v19;
      do
      {
        free(v28);
        *v27++ = 0LL;
        v28 = *v27;
      }
      while ( *v27 );
LABEL_61:
      free(ptr);
      return v12;
    }
    v20 = v17[1];
    if ( !strcmp(v18, ".") )
    {
LABEL_39:
      ++v17;
      if ( !v20 )
        goto LABEL_53;
LABEL_40:
      v18 = v20;
      continue;
    }
    break;
  }
  if ( !strcmp(v18, "..") )
  {
    if ( v16[4] )
      v16 = (const char **)v16[4];
    goto LABEL_39;
  }
  if ( v20 )
  {
    v38 = v16[7];
    if ( !v38 )
    {
LABEL_56:
      v25 = (void **)ptr;
      v26 = s1;
      do
      {
        free(v26);
        *v25++ = 0LL;
        v26 = *v25;
      }
      while ( *v25 );
      goto LABEL_55;
    }
    v21 = (const char **)v16[6];
    v22 = 0LL;
    while ( 1 )
    {
      v16 = v21;
      if ( !strcmp(v18, *v21) )
        break;
      ++v22;
      v21 += 10;
      if ( v22 == v38 )
        goto LABEL_56;
    }
    ++v17;
    goto LABEL_40;
  }
  v30 = v16[9];
  v12 = 0;
  if ( v30 )
  {
    v31 = (const char **)v16[8];
    v32 = 0LL;
    while ( strcmp(v18, *v31) )
    {
      ++v32;
      v31 += 6;
      if ( v32 == v30 )
        goto LABEL_73;
    }
    if ( a4 )
      *a4 = v31;
    v33 = (void **)ptr;
    v34 = s1;
    do
    {
      free(v34);
      *v33++ = 0LL;
      v34 = *v33;
    }
    while ( *v33 );
    goto LABEL_61;
  }
LABEL_73:
  v35 = (void **)ptr;
  v36 = s1;
  do
  {
    free(v36);
    *v35++ = 0LL;
    v36 = *v35;
  }
  while ( *v35 );
LABEL_55:
  v12 = 8;
  free(ptr);
  return v12;
}

//----- (0000000000005CE0) ----------------------------------------------------
__int64 __fastcall vlc_sd_probe_Open(__int64 a1)
{
  vlc_sd_probe_Add(a1, (__int64)"chall_SD", (__int64)"Chall media services", 3LL);
  return 0xFFFFFFFFLL;
}

//----- (0000000000005D10) ----------------------------------------------------
void __fastcall CloseAccess(__int64 a1)
{
  __int64 v2; // rbx
  int v3; // edi

  v2 = *(_QWORD *)(a1 + 136);
  if ( !*(_BYTE *)(v2 + 8) )
  {
    vlc_mutex_lock(v2 + 176);
    *(_BYTE *)(v2 + 216) = 1;
    vlc_mutex_unlock(v2 + 176);
    vlc_join(*(_QWORD *)(v2 + 72), 0LL);
    v3 = *(_DWORD *)(v2 + 32);
    if ( v3 > 0 )
      close(v3);
    freeContext(v2 + 80);
    v2 = *(_QWORD *)(a1 + 136);
  }
  free((void *)v2);
  *(_QWORD *)(a1 + 136) = 0LL;
}
// 2040: using guessed type __int64 __fastcall vlc_mutex_unlock(_QWORD);
// 2180: using guessed type __int64 __fastcall vlc_join(_QWORD, _QWORD);
// 22A0: using guessed type __int64 __fastcall vlc_mutex_lock(_QWORD);

//----- (0000000000005DA0) ----------------------------------------------------
__int64 __fastcall error_Media(unsigned int a1, __int64 a2, const char *a3)
{
  __int64 result; // rax

  switch ( a1 )
  {
    case 1u:
      vlc_Log(
        a2,
        1LL,
        "chall",
        "/root/wb/client/src/vlc_lib/lib_interface.c",
        87LL,
        "error_Media",
        "Empty file: %s",
        a3);
      result = vlc_dialog_display_error(a2, "Empty file", "Empty file: %s", a3);
      break;
    case 3u:
      vlc_Log(
        a2,
        1LL,
        "chall",
        "/root/wb/client/src/vlc_lib/lib_interface.c",
        95LL,
        "error_Media",
        "Permission denied: %s",
        a3);
      result = vlc_dialog_display_error(a2, "Permission denied", "Permission denied: %s", a3);
      break;
    case 4u:
      vlc_Log(
        a2,
        1LL,
        "chall",
        "/root/wb/client/src/vlc_lib/lib_interface.c",
        99LL,
        "error_Media",
        "Prod device needed");
      result = vlc_dialog_display_error(a2, "Prod device needed", "The key server is in debug mode.");
      break;
    case 8u:
      vlc_Log(
        a2,
        1LL,
        "chall",
        "/root/wb/client/src/vlc_lib/lib_interface.c",
        91LL,
        "error_Media",
        "Path invalid: %s",
        a3);
      result = vlc_dialog_display_error(a2, "Path invalid", "Path invalid: %s", a3);
      break;
    case 9u:
      vlc_Log(a2, 1LL, "chall", "/root/wb/client/src/vlc_lib/lib_interface.c", 103LL, "error_Media", "Connection error");
      result = vlc_dialog_display_error(a2, "Connection error", "Fail to connect to the server.");
      break;
    default:
      vlc_Log(
        a2,
        1LL,
        "chall",
        "/root/wb/client/src/vlc_lib/lib_interface.c",
        107LL,
        "error_Media",
        "Unexpected error when loaded '%s': %d",
        a3,
        a1);
      result = vlc_dialog_display_error(a2, "Unknown error", "Unexpected error when loaded '%s': %d", a3, a1);
      break;
  }
  return result;
}
// 20D0: using guessed type __int64 vlc_Log(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);
// 20E0: using guessed type __int64 vlc_dialog_display_error(_QWORD, _QWORD, const char *, ...);

//----- (0000000000005FC0) ----------------------------------------------------
__int64 __fastcall AccessReadDir(__int64 a1, __int64 a2)
{
  __int64 v3; // rbp
  _QWORD *v4; // rax
  unsigned __int64 v5; // r12
  const char *v6; // rax
  char *v7; // r13
  __int64 v8; // rdi
  __int64 v9; // rbx
  unsigned __int64 v11; // r12
  const char *v12; // rax
  __int64 v13; // rdi
  __int64 v14; // rbx
  void *v15; // [rsp+20h] [rbp-88h] BYREF
  void *v16; // [rsp+28h] [rbp-80h] BYREF
  char v17[120]; // [rsp+30h] [rbp-78h] BYREF

  v3 = *(_QWORD *)(a1 + 136);
  vlc_readdir_helper_init(v17, a1, a2);
  v4 = *(_QWORD **)(v3 + 16);
  if ( v4[9] )
  {
    v5 = 0LL;
    while ( 1 )
    {
      v8 = v4[8];
      v15 = 0LL;
      v9 = 48 * v5;
      if ( (unsigned int)get_file_path(48 * v5 + v8, &v15) )
        break;
      v6 = (const char *)vlc_uri_encode(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 16) + 64LL) + v9 + 8));
      v7 = (char *)v6;
      if ( !v6 )
      {
LABEL_9:
        free(v15);
        break;
      }
      if ( asprintf(
             (char **)&v16,
             "chall://%s?id=%lu&remote_name=%s",
             (const char *)v15,
             *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 16) + 64LL) + v9 + 32),
             v6) == -1 )
      {
LABEL_10:
        free(v15);
        free(v7);
        vlc_readdir_helper_finish(v17, 0LL);
        return 4294967294LL;
      }
      ++v5;
      vlc_Log(
        a1,
        3LL,
        "chall",
        "/root/wb/client/src/vlc_lib/lib_interface.c",
        484LL,
        "AccessReadDir",
        "Add File %s",
        (const char *)v16);
      vlc_readdir_helper_additem(v17, v16, 0LL, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 16) + 64LL) + v9), 1LL, 0LL);
      free(v15);
      free(v7);
      free(v16);
      v4 = *(_QWORD **)(v3 + 16);
      if ( v4[9] <= v5 )
        goto LABEL_11;
    }
  }
  else
  {
LABEL_11:
    if ( !v4[7] )
    {
LABEL_18:
      vlc_readdir_helper_finish(v17, 1LL);
      return 0LL;
    }
    v11 = 0LL;
    while ( 1 )
    {
      v13 = v4[6];
      v15 = 0LL;
      v14 = 80 * v11;
      if ( (unsigned int)get_dir_path(80 * v11 + v13, &v15) )
        break;
      v12 = (const char *)vlc_uri_encode(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 16) + 48LL) + v14 + 8));
      v7 = (char *)v12;
      if ( !v12 )
        goto LABEL_9;
      if ( asprintf(
             (char **)&v16,
             "chall://%s?id=%lu&remote_name=%s",
             (const char *)v15,
             *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 16) + 48LL) + v14 + 24),
             v12) == -1 )
        goto LABEL_10;
      ++v11;
      vlc_Log(
        a1,
        3LL,
        "chall",
        "/root/wb/client/src/vlc_lib/lib_interface.c",
        512LL,
        "AccessReadDir",
        "Add directory %s",
        (const char *)v16);
      vlc_readdir_helper_additem(v17, v16, 0LL, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 16) + 48LL) + v14), 2LL, 0LL);
      free(v15);
      free(v7);
      free(v16);
      v4 = *(_QWORD **)(v3 + 16);
      if ( v4[7] <= v11 )
        goto LABEL_18;
    }
  }
  vlc_readdir_helper_finish(v17, 0LL);
  return 4294967294LL;
}
// 20D0: using guessed type __int64 vlc_Log(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);
// 21A0: using guessed type __int64 __fastcall vlc_readdir_helper_additem(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 2260: using guessed type __int64 __fastcall vlc_uri_encode(_QWORD);
// 2290: using guessed type __int64 __fastcall vlc_readdir_helper_init(_QWORD, _QWORD, _QWORD);
// 23E0: using guessed type __int64 __fastcall vlc_readdir_helper_finish(_QWORD, _QWORD);
// 4540: using guessed type __int64 __fastcall get_dir_path(_QWORD, _QWORD);
// 4B40: using guessed type __int64 __fastcall get_file_path(_QWORD, _QWORD);

//----- (00000000000062D0) ----------------------------------------------------
__int64 __fastcall AccessSeek(__int64 a1, __off64_t a2)
{
  __int64 v2; // rbx
  __int64 v3; // rdi
  __int64 result; // rax

  v2 = *(_QWORD *)(a1 + 136);
  vlc_mutex_lock(v2 + 176);
  if ( *(_BYTE *)(v2 + 216) )
  {
    vlc_mutex_unlock(v2 + 176);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    if ( !*(_BYTE *)(v2 + 64) )
    {
      *(_QWORD *)(v2 + 56) = a2;
      v3 = v2 + 176;
      goto LABEL_4;
    }
    v3 = v2 + 176;
    if ( a2 == lseek64(*(_DWORD *)(v2 + 32), a2, 0) )
    {
LABEL_4:
      vlc_mutex_unlock(v3);
      return 0LL;
    }
    vlc_mutex_unlock(v3);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 2040: using guessed type __int64 __fastcall vlc_mutex_unlock(_QWORD);
// 22A0: using guessed type __int64 __fastcall vlc_mutex_lock(_QWORD);

//----- (0000000000006350) ----------------------------------------------------
ssize_t __fastcall AccessRead(__int64 a1, void *a2, size_t a3)
{
  __int64 v5; // rbx
  int v6; // edi
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rsi
  __off64_t v9; // r14
  ssize_t v10; // rbp
  ssize_t result; // rax
  ssize_t v12; // rbp

  v5 = *(_QWORD *)(a1 + 136);
  vlc_mutex_lock(v5 + 176);
  if ( *(_BYTE *)(v5 + 216) )
  {
    vlc_mutex_unlock(v5 + 176);
    result = 0LL;
  }
  else
  {
    v6 = *(_DWORD *)(v5 + 32);
    if ( *(_BYTE *)(v5 + 64) )
    {
      v12 = read(v6, a2, a3);
      vlc_mutex_unlock(v5 + 176);
      result = 0LL;
      if ( v12 >= 0 )
        result = v12;
    }
    else if ( v6 == -1 || (v7 = lseek64(v6, 0LL, 1), v8 = *(_QWORD *)(v5 + 56), v9 = v7, v8 >= v7) )
    {
      vlc_mutex_unlock(v5 + 176);
      result = -1LL;
    }
    else
    {
      lseek64(*(_DWORD *)(v5 + 32), v8, 0);
      v10 = read(*(_DWORD *)(v5 + 32), a2, a3);
      lseek64(*(_DWORD *)(v5 + 32), v9, 0);
      *(_QWORD *)(v5 + 56) += v10;
      vlc_mutex_unlock(v5 + 176);
      if ( v10 )
      {
        result = 0LL;
        if ( v10 >= 0 )
          result = v10;
      }
      else
      {
        result = -1LL;
      }
    }
  }
  return result;
}
// 2040: using guessed type __int64 __fastcall vlc_mutex_unlock(_QWORD);
// 22A0: using guessed type __int64 __fastcall vlc_mutex_lock(_QWORD);

//----- (0000000000006460) ----------------------------------------------------
__int64 __fastcall DownloadAccess(__int64 a1)
{
  *(_DWORD *)(a1 + 12) = download_file_with_key(
                           a1 + 80,
                           *(const char **)(*(_QWORD *)(a1 + 24) + 8LL),
                           a1 + 36,
                           (int *)(a1 + 32));
  vlc_mutex_lock(a1 + 176);
  if ( !*(_BYTE *)(a1 + 216) )
  {
    lseek64(*(_DWORD *)(a1 + 32), *(_QWORD *)(a1 + 56), 0);
    *(_BYTE *)(a1 + 64) = 1;
  }
  vlc_mutex_unlock(a1 + 176);
  return 0LL;
}
// 2040: using guessed type __int64 __fastcall vlc_mutex_unlock(_QWORD);
// 22A0: using guessed type __int64 __fastcall vlc_mutex_lock(_QWORD);

//----- (00000000000064C0) ----------------------------------------------------
void __fastcall CloseSD(__int64 a1)
{
  _QWORD *v1; // rbp

  v1 = *(_QWORD **)(a1 + 80);
  (*(void (__fastcall **)(__int64, _QWORD))(a1 + 104))(a1, *v1);
  input_item_Release(*v1);
  free(v1);
  *(_QWORD *)(a1 + 80) = 0LL;
}
// 2230: using guessed type __int64 __fastcall input_item_Release(_QWORD);

//----- (0000000000006500) ----------------------------------------------------
__int64 __fastcall AccessControl(__int64 a1, int a2, int *a3)
{
  __int64 result; // rax
  unsigned int v4; // eax
  _BYTE **v5; // rcx
  unsigned int v6; // eax
  _BYTE **v7; // rcx
  int v9; // eax
  __int64 v10; // rcx
  unsigned int v11; // eax
  __int64 **v12; // rdx
  __int64 **v13; // rdx
  __int64 v14; // [rsp+0h] [rbp-10h] BYREF

  if ( a2 <= 3 )
  {
    if ( a2 < 2 && a2 )
    {
      if ( a2 == 1 )
      {
        v4 = *a3;
        if ( (unsigned int)*a3 <= 0x2F )
        {
          v5 = (_BYTE **)(*((_QWORD *)a3 + 2) + v4);
          *a3 = v4 + 8;
        }
        else
        {
          v5 = (_BYTE **)*((_QWORD *)a3 + 1);
          *((_QWORD *)a3 + 1) = v5 + 1;
        }
        **v5 = 0;
        result = 0LL;
      }
      else
      {
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      v6 = *a3;
      if ( (unsigned int)*a3 > 0x2F )
      {
        v7 = (_BYTE **)*((_QWORD *)a3 + 1);
        *((_QWORD *)a3 + 1) = v7 + 1;
      }
      else
      {
        v7 = (_BYTE **)(*((_QWORD *)a3 + 2) + v6);
        *a3 = v6 + 8;
      }
      **v7 = 1;
      result = 0LL;
    }
  }
  else
  {
    if ( a2 != 257 )
      return (unsigned int)(a2 == 512) - 1;
    v9 = var_Inherit(a1, "network-caching", 48LL, &v14);
    v10 = 0LL;
    if ( v9 )
    {
      v11 = *a3;
      if ( (unsigned int)*a3 <= 0x2F )
      {
LABEL_16:
        v12 = (__int64 **)(*((_QWORD *)a3 + 2) + v11);
        *a3 = v11 + 8;
        **v12 = v10;
        return 0LL;
      }
    }
    else
    {
      v10 = 1000 * v14;
      v11 = *a3;
      if ( (unsigned int)*a3 <= 0x2F )
        goto LABEL_16;
    }
    v13 = (__int64 **)*((_QWORD *)a3 + 1);
    *((_QWORD *)a3 + 1) = v13 + 1;
    **v13 = v10;
    result = 0LL;
  }
  return result;
}
// 2070: using guessed type __int64 __fastcall var_Inherit(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000006630) ----------------------------------------------------
void global_init()
{
  char v0; // al

  vlc_global_mutex(1LL, 1LL);
  if ( !done_14258 )
  {
    gcry_check_version(0LL);
    done_14258 = 1;
  }
  vlc_global_mutex(1LL, 0LL);
  if ( !is_init )
  {
    v0 = need_init;
    need_init = 1;
    if ( v0 )
    {
      do
      {
        usleep(0x64u);
        _mm_mfence();
      }
      while ( !is_init );
    }
    else
    {
      vlc_mutex_init(&unk_113A0);
      initContext(&global_ctx, 0LL, 0LL, 0LL);
      is_init = 1;
      *(_OWORD *)&a2 = 0LL;
      xmmword_11360 = 0LL;
      xmmword_11370 = 0LL;
      xmmword_11380 = 0LL;
      xmmword_11390 = 0LL;
    }
  }
}
// 2160: using guessed type __int64 __fastcall gcry_check_version(_QWORD);
// 22E0: using guessed type __int64 __fastcall vlc_mutex_init(_QWORD);
// 23A0: using guessed type __int64 __fastcall vlc_global_mutex(_QWORD, _QWORD);
// 11281: using guessed type char done_14258;
// 11282: using guessed type char is_init;
// 11283: using guessed type char need_init;
// 11360: using guessed type __int128 xmmword_11360;
// 11370: using guessed type __int128 xmmword_11370;
// 11380: using guessed type __int128 xmmword_11380;
// 11390: using guessed type __int128 xmmword_11390;

//----- (0000000000006710) ----------------------------------------------------
__int64 __fastcall OpenSD(__int64 a1)
{
  __int64 *v1; // rax
  __int64 *v2; // rbx
  __int64 v3; // rax
  __int64 result; // rax

  v1 = (__int64 *)malloc(0x18uLL);
  if ( !v1 )
    return 0xFFFFFFFELL;
  v1[1] = a1;
  v2 = v1;
  *(_QWORD *)(a1 + 80) = v1;
  *(_QWORD *)(a1 + 64) = vlc_gettext("Chall media services");
  global_init();
  v3 = input_item_NewExt("chall:///", "/", -1LL, 2LL, 1LL);
  *v2 = v3;
  if ( v3 )
  {
    input_item_AddOption(v3, "recursive=collapse", 258LL);
    (*(void (__fastcall **)(__int64, _QWORD, __int64, _QWORD))(a1 + 96))(a1, 0LL, *v2, 0LL);
    result = 0LL;
  }
  else
  {
    free(v2);
    result = 4294967294LL;
  }
  return result;
}
// 2200: using guessed type __int64 __fastcall vlc_gettext(_QWORD);
// 2310: using guessed type __int64 __fastcall input_item_NewExt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 2380: using guessed type __int64 __fastcall input_item_AddOption(_QWORD, _QWORD, _QWORD);

//----- (00000000000067C0) ----------------------------------------------------
__int64 __fastcall OpenAccess(__int64 a1)
{
  access_state *v1; // rax
  access_state *v2; // rbp
  int v3; // eax
  char v4; // dl
  int v5; // eax
  __int64 v6; // rdx
  char *url; // r13
  char *keyhost; // r14
  char *v9; // r13
  char *v10; // r12
  __int64 v11; // r14
  char *v12; // r12
  unsigned int v13; // eax
  __int64 result; // rax
  unsigned int v15; // eax
  __int64 v16; // r12
  __int64 v17; // rdx
  unsigned int v18; // [rsp+Ch] [rbp-3Ch]
  char *keyport; // [rsp+10h] [rbp-38h] BYREF
  void *v20; // [rsp+18h] [rbp-30h] BYREF

  v1 = (access_state *)malloc(0xE0uLL);
  if ( !v1 )
    return 4294967294LL;
  *(_QWORD *)(a1 + 136) = v1;
  v2 = v1;
  v1->access_obj = (void *)a1;
  v1->c32 = -1;
  v1->c64 = 0;
  v1->c56 = 0LL;
  global_init();
  var_Create(a1, "media-server-permcheck", 32800LL);
  LOBYTE(v20) = 0;
  v3 = var_GetChecked(a1, "media-server-permcheck", 32LL, &v20);
  v4 = 0;
  if ( !v3 )
    v4 = (char)v20;
  global_ctx.permcheck = v4;
  var_Create(a1, "key-server-port", 0x8030LL);
  v5 = var_GetChecked(a1, "key-server-port", 48LL, &v20);
  v6 = 0LL;
  if ( !v5 )
    v6 = (unsigned int)v20;
  if ( asprintf(&keyport, "%d", v6) == -1 )
  {
    free(v2);
    return 0xFFFFFFFELL;
  }
  url = 0LL;
  var_Create(a1, "media-server", 32832LL);
  v20 = 0LL;
  if ( !(unsigned int)var_GetChecked(a1, "media-server", 64LL, &v20) )
    url = (char *)v20;
  keyhost = 0LL;
  var_Create(a1, "key-server-addr", 32832LL);
  v20 = 0LL;
  if ( !(unsigned int)var_GetChecked(a1, "key-server-addr", 64LL, &v20) )
    keyhost = (char *)v20;
  vlc_mutex_lock(&unk_113A0);
  global_ctx.access_ctx = (void *)a1;
  setContext(&global_ctx, url, keyhost, keyport);
  free(keyhost);
  free(keyport);
  free(url);
  var_Create(a1, "media-server-login", 32832LL);
  v20 = 0LL;
  if ( (unsigned int)var_GetChecked(a1, "media-server-login", 64LL, &v20) )
  {
    v9 = 0LL;
    var_Create(a1, "media-server-pass", 32832LL);
    v20 = 0LL;
    if ( !(unsigned int)var_GetChecked(a1, "media-server-pass", 64LL, &v20) )
    {
      v10 = (char *)v20;
      goto LABEL_16;
    }
LABEL_35:
    v10 = 0LL;
LABEL_16:
    vlc_Log(a1, 3LL, "chall", "/root/wb/client/src/vlc_lib/lib_interface.c", 257LL, "OpenAccess", "Log as guest");
    v11 = (unsigned int)remote_login(&global_ctx, 0LL, 0LL);
    goto LABEL_17;
  }
  v9 = (char *)v20;
  var_Create(a1, "media-server-pass", 32832LL);
  v20 = 0LL;
  if ( (unsigned int)var_GetChecked(a1, "media-server-pass", 64LL, &v20) )
    goto LABEL_35;
  v10 = (char *)v20;
  if ( !v9 || !v20 || !*v9 || !*(_BYTE *)v20 )
    goto LABEL_16;
  vlc_Log(a1, 3LL, "chall", "/root/wb/client/src/vlc_lib/lib_interface.c", 260LL, "OpenAccess", "Log as %s", v9);
  v11 = (unsigned int)remote_login(&global_ctx, v9, v10);
LABEL_17:
  free(v9);
  free(v10);
  if ( (_DWORD)v11 )
  {
    if ( (_DWORD)v11 == 2 )
    {
      vlc_Log(
        a1,
        1LL,
        "chall",
        "/root/wb/client/src/vlc_lib/lib_interface.c",
        74LL,
        "error_VM",
        "Authentification fail");
      vlc_dialog_display_error(a1, "Server authentification failed", "Wrong login/password");
    }
    else if ( (_DWORD)v11 == 254 )
    {
      vlc_Log(a1, 1LL, "chall", "/root/wb/client/src/vlc_lib/lib_interface.c", 77LL, "error_VM", "Connection error");
      vlc_dialog_display_error(a1, "Connection error", "Fail to connect to the server.");
    }
    else
    {
      vlc_Log(
        a1,
        1LL,
        "chall",
        "/root/wb/client/src/vlc_lib/lib_interface.c",
        80LL,
        "error_VM",
        "Unexpected error when loaded library: %d",
        v11);
      vlc_dialog_display_error(a1, "Unknown error", "Unexpected error: %d", (unsigned int)v11);
    }
    vlc_mutex_unlock(&unk_113A0);
    free(v2);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    vlc_Log(
      a1,
      3LL,
      "chall",
      "/root/wb/client/src/vlc_lib/lib_interface.c",
      273LL,
      "OpenAccess",
      "Success load library");
    if ( !BYTE8(xmmword_11370) )
    {
      v15 = open_index((context *)(&a2 - 18), (__int64)&a2);
      v16 = v15;
      if ( v15 )
      {
        vlc_mutex_unlock(&unk_113A0);
        vlc_Log(
          a1,
          1LL,
          "chall",
          "/root/wb/client/src/vlc_lib/lib_interface.c",
          279LL,
          "OpenAccess",
          "Fail to load index: %d",
          v16);
        vlc_dialog_display_error(
          a1,
          "Server authentification failed",
          "Fail to load server index: %d",
          (unsigned int)v16);
        free(v2);
        return 0xFFFFFFFFLL;
      }
    }
    v2->c16 = 0LL;
    v2->c24 = 0LL;
    vlc_Log(
      a1,
      3LL,
      "chall",
      "/root/wb/client/src/vlc_lib/lib_interface.c",
      289LL,
      "OpenAccess",
      "Look for %s",
      *(const char **)(a1 + 64));
    v12 = *(char **)(a1 + 64);
    if ( *v12 && v12[strlen(*(const char **)(a1 + 64)) - 1] != 47 )
    {
      v2->c8 = 0;
      v13 = get_file((__int64)(&a2 - 18), (const char **)&a2, v12, (const char ***)&v2->c24);
      if ( v13 == 8 )
      {
        v2->c8 = 1;
        v13 = get_dir((__int64)(&a2 - 18), (const char **)&a2, *(char **)(a1 + 64), (const char ***)&v2->c16);
      }
    }
    else
    {
      v2->c8 = 1;
      v13 = get_dir((__int64)(&a2 - 18), (const char **)&a2, v12, (const char ***)&v2->c16);
    }
    if ( v13 )
      goto LABEL_41;
    if ( v2->c8 )
    {
      vlc_mutex_unlock(&unk_113A0);
      *(_QWORD *)(a1 + 96) = 0LL;
      *(_QWORD *)(a1 + 112) = AccessReadDir;
      *(_QWORD *)(a1 + 104) = 0LL;
      *(_QWORD *)(a1 + 120) = 0LL;
      *(_QWORD *)(a1 + 128) = &access_vaDirectoryControlHelper;
      return 0LL;
    }
    v13 = get_file_key(&global_ctx, *((_QWORD *)v2->c24 + 4), (__int64)&v2->c36);
    if ( v13 )
    {
LABEL_41:
      v18 = v13;
      vlc_mutex_unlock(&unk_113A0);
      v17 = *(_QWORD *)(a1 + 56);
      if ( !v17 )
        v17 = *(_QWORD *)(a1 + 64);
      error_Media(v18, a1, v17);
      free(v2);
      result = 0xFFFFFFFFLL;
    }
    else
    {
      initContext((context *)&v2->c80, global_ctx.url, 0LL, 0LL);
      *(_QWORD *)&v2->c168 = a1;
      vlc_mutex_unlock(&unk_113A0);
      result = vlc_clone(&v2->c72, DownloadAccess, v2, 10LL);
      if ( (_DWORD)result )
      {
        freeContext(&v2->c80);
        free(v2);
        result = 0xFFFFFFFFLL;
      }
      else
      {
        *(_QWORD *)(a1 + 104) = 0LL;
        *(_QWORD *)(a1 + 96) = AccessRead;
        *(_QWORD *)(a1 + 128) = AccessControl;
        *(_QWORD *)(a1 + 120) = &AccessSeek;
        *(_QWORD *)(a1 + 112) = 0LL;
      }
    }
  }
  return result;
}
// 2040: using guessed type __int64 __fastcall vlc_mutex_unlock(_QWORD);
// 20D0: using guessed type __int64 vlc_Log(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, const char *, ...);
// 20E0: using guessed type __int64 vlc_dialog_display_error(_QWORD, _QWORD, const char *, ...);
// 2240: using guessed type __int64 __fastcall var_GetChecked(_QWORD, _QWORD, _QWORD, _QWORD);
// 22A0: using guessed type __int64 __fastcall vlc_mutex_lock(_QWORD);
// 22C0: using guessed type __int64 __fastcall var_Create(_QWORD, _QWORD, _QWORD);
// 2350: using guessed type __int64 __fastcall vlc_clone(_QWORD, _QWORD, _QWORD, _QWORD);
// 2570: using guessed type __int64 __fastcall freeContext(_QWORD);
// 5DA0: using guessed type __int64 __fastcall error_Media(_QWORD, _QWORD, _QWORD);
// 6460: using guessed type __int64 __fastcall DownloadAccess();
// 6500: using guessed type __int64 __fastcall AccessControl();
// 11370: using guessed type __int128 xmmword_11370;

//----- (0000000000006F90) ----------------------------------------------------
int __fastcall vlc_entry__3_0_0f(unsigned int (*vlc_set)(void *, void *, vlc_module_properties, ...), void *vlc)
{
  int result; // eax
  void *module; // [rsp+8h] [rbp-40h] BYREF
  void *category; // [rsp+10h] [rbp-38h] BYREF
  char *shortcut; // [rsp+18h] [rbp-30h] BYREF

  category = 0LL;
  if ( vlc_set(vlc, 0LL, VLC_MODULE_CREATE, &module) )
    goto LABEL_21;
  if ( vlc_set(vlc, module, VLC_MODULE_NAME, "chall") )
    goto LABEL_21;
  vlc_set(vlc, 0LL, VLC_CONFIG_CREATE, CONFIG_CATEGORY, &category);
  vlc_set(vlc, category, VLC_CONFIG_VALUE, 7LL);// CAT_PLAYLIST
  vlc_set(vlc, 0LL, VLC_CONFIG_CREATE, CONFIG_SUBCATEGORY, &category);
  vlc_set(vlc, category, VLC_CONFIG_VALUE, 702LL);// SUBCAT_PLAYLIST_SD
  if ( vlc_set(vlc, module, VLC_MODULE_SHORTNAME, "Chall") )
    goto LABEL_21;
  if ( vlc_set(vlc, module, VLC_MODULE_DESCRIPTION, "Chall media services") )
    goto LABEL_21;
  if ( vlc_set(vlc, module, VLC_MODULE_CAPABILITY, "services_discovery") )
    goto LABEL_21;
  if ( vlc_set(vlc, module, VLC_MODULE_SCORE, 0LL) )
    goto LABEL_21;
  if ( vlc_set(vlc, module, VLC_MODULE_CB_OPEN, "OpenSD", OpenSD) )
    goto LABEL_21;
  if ( vlc_set(vlc, module, VLC_MODULE_CB_CLOSE, "CloseSD", CloseSD) )
    goto LABEL_21;
  shortcut = "chall_SD";
  if ( vlc_set(vlc, module, VLC_MODULE_SHORTCUT, 1LL, &shortcut) )
    goto LABEL_21;
  if ( vlc_set(vlc, 0LL, VLC_MODULE_CREATE, &module) )
    goto LABEL_21;
  vlc_set(vlc, 0LL, VLC_CONFIG_CREATE, CONFIG_CATEGORY, &category);
  vlc_set(vlc, category, VLC_CONFIG_VALUE, 4LL);// CAT_INPUT
  vlc_set(vlc, 0LL, VLC_CONFIG_CREATE, CONFIG_SUBCATEGORY, &category);
  vlc_set(vlc, category, VLC_CONFIG_VALUE, 402LL);// SUBCAT_INPUT_ACCESS
  if ( vlc_set(vlc, module, VLC_MODULE_CB_OPEN, "OpenAccess", OpenAccess) )
    goto LABEL_21;
  if ( vlc_set(vlc, module, VLC_MODULE_CB_CLOSE, "CloseAccess", CloseAccess) )
    goto LABEL_21;
  if ( vlc_set(vlc, module, VLC_MODULE_CAPABILITY, "access") )
    goto LABEL_21;
  if ( vlc_set(vlc, module, VLC_MODULE_SCORE, 10LL) )
    goto LABEL_21;
  shortcut = "chall";
  if ( vlc_set(vlc, module, VLC_MODULE_SHORTCUT, 1LL, &shortcut) )
    goto LABEL_21;
  vlc_set(vlc, 0LL, VLC_CONFIG_CREATE, CONFIG_ITEM_STRING, &category);
  vlc_set(vlc, category, VLC_CONFIG_DESC, "media server URL", "Change the media server to retrived the media");
  vlc_set(vlc, category, VLC_CONFIG_NAME, "media-server");
  vlc_set(vlc, category, VLC_CONFIG_VALUE, "http://challenge2021.sstic.org:8080");
  vlc_set(vlc, 0LL, VLC_CONFIG_CREATE, CONFIG_ITEM_STRING, &category);
  vlc_set(vlc, category, VLC_CONFIG_DESC, "key server address", "Change the key server address");
  vlc_set(vlc, category, VLC_CONFIG_NAME, "key-server-addr");
  vlc_set(vlc, category, VLC_CONFIG_VALUE, "62.210.125.243");
  vlc_set(vlc, 0LL, VLC_CONFIG_CREATE, CONFIG_ITEM_INTEGER, &category);
  vlc_set(vlc, category, VLC_CONFIG_DESC, "key server port", "Change the key server port");
  vlc_set(vlc, category, VLC_CONFIG_NAME, "key-server-port");
  vlc_set(vlc, category, VLC_CONFIG_VALUE, 1337LL);
  vlc_set(vlc, category, VLC_CONFIG_RANGE, 1LL, 0xFFFFLL);
  vlc_set(vlc, 0LL, VLC_CONFIG_CREATE, CONFIG_ITEM_STRING, &category);
  vlc_set(vlc, category, VLC_CONFIG_DESC, "Login");
  vlc_set(vlc, category, VLC_CONFIG_NAME, "media-server-login");
  vlc_set(vlc, category, VLC_CONFIG_VALUE, 0LL);
  vlc_set(vlc, 0LL, VLC_CONFIG_CREATE, CONFIG_ITEM_PASSWORD, &category);
  vlc_set(vlc, category, VLC_CONFIG_DESC, "Password");
  vlc_set(vlc, category, VLC_CONFIG_NAME, "media-server-pass");
  vlc_set(vlc, category, VLC_CONFIG_VALUE, 0LL);
  vlc_set(vlc, 0LL, VLC_CONFIG_CREATE, CONFIG_ITEM_BOOL, &category);
  vlc_set(vlc, category, VLC_CONFIG_DESC, "");
  vlc_set(vlc, category, VLC_CONFIG_ADVANCED);
  vlc_set(vlc, category, VLC_CONFIG_NAME, "media-server-permcheck");
  vlc_set(vlc, category, VLC_CONFIG_VALUE, 1LL);
  vlc_set(vlc, category, VLC_CONFIG_PRIVATE);
  if ( vlc_set(vlc, 0LL, VLC_MODULE_CREATE, &module)
    || vlc_set(vlc, module, VLC_MODULE_CAPABILITY, "services probe")
    || vlc_set(vlc, module, VLC_MODULE_SCORE, 100LL)
    || vlc_set(vlc, module, VLC_MODULE_CB_OPEN, "vlc_sd_probe_Open", vlc_sd_probe_Open) )
  {
LABEL_21:
    result = -1;
  }
  else
  {
    result = -(vlc_set(vlc, module, VLC_MODULE_CB_CLOSE, "NULL", 0LL) != 0);
  }
  return result;
}

//----- (0000000000007590) ----------------------------------------------------
char *__fastcall ensure(_QWORD *a1, unsigned __int64 a2)
{
  char *v2; // rbp
  unsigned __int64 v3; // rax
  __int64 v4; // rcx
  unsigned __int64 v5; // rdx
  __int64 v6; // r12
  __int64 (__fastcall *v7)(_QWORD, __int64); // rax

  if ( !a1 )
    return 0LL;
  v2 = (char *)*a1;
  if ( !*a1 )
    return v2;
  v3 = a1[1];
  if ( v3 )
  {
    if ( v3 <= a1[2] )
      return 0LL;
  }
  if ( a2 > 0x7FFFFFFF )
    return 0LL;
  v4 = a1[2];
  v5 = v4 + a2 + 1;
  if ( v3 < v5 )
  {
    if ( !*((_DWORD *)a1 + 8) )
    {
      if ( v5 <= 0x3FFFFFFF )
      {
        v6 = 2 * v5;
        goto LABEL_9;
      }
      v6 = 0x7FFFFFFFLL;
      if ( v5 <= 0x7FFFFFFF )
      {
LABEL_9:
        v7 = (__int64 (__fastcall *)(_QWORD, __int64))a1[7];
        if ( v7 )
        {
          v2 = (char *)v7(*a1, v6);
          if ( v2 )
          {
LABEL_11:
            a1[1] = v6;
            *a1 = v2;
            v2 += a1[2];
            return v2;
          }
        }
        else
        {
          v2 = (char *)((__int64 (__fastcall *)(__int64))a1[5])(v6);
          if ( v2 )
          {
            memcpy(v2, (const void *)*a1, a1[2] + 1LL);
            ((void (__fastcall *)(_QWORD))a1[6])(*a1);
            goto LABEL_11;
          }
        }
        ((void (__fastcall *)(_QWORD))a1[6])(*a1);
        a1[1] = 0LL;
        *a1 = 0LL;
        return v2;
      }
    }
    return 0LL;
  }
  return &v2[v4];
}

//----- (00000000000076A0) ----------------------------------------------------
_QWORD *__fastcall get_object_item(__int64 a1, const char *a2, int a3)
{
  _QWORD *v4; // rbx
  const char *v5; // rbp
  const __int32_t *v6; // rdx
  __int64 v7; // rax
  __int64 i; // rax
  __int64 v9; // rdi
  const char *v11; // rsi

  if ( !a1 || !a2 )
    return 0LL;
  v4 = *(_QWORD **)(a1 + 16);
  if ( a3 )
  {
    while ( v4 )
    {
      v11 = (const char *)v4[7];
      if ( !v11 )
        return 0LL;
      if ( !strcmp(a2, v11) )
        break;
      v4 = (_QWORD *)*v4;
    }
  }
  else
  {
    for ( ; v4; v4 = (_QWORD *)*v4 )
    {
      v5 = (const char *)v4[7];
      if ( v5 )
      {
        if ( v5 == a2 )
          return v4;
        v6 = *__ctype_tolower_loc();
        v7 = *(unsigned __int8 *)a2;
        if ( v6[*(unsigned __int8 *)v5] == v6[v7] )
        {
          if ( !(_BYTE)v7 )
            return v4;
          for ( i = 1LL; ; ++i )
          {
            v9 = (unsigned __int8)a2[i];
            if ( v6[v9] != v6[(unsigned __int8)v5[i]] )
              break;
            if ( !(_BYTE)v9 )
              return v4;
          }
        }
      }
    }
  }
  return v4;
}

//----- (0000000000007770) ----------------------------------------------------
__int64 __fastcall print_string_ptr_part_5(void *src, _QWORD *a2)
{
  char *v2; // rbp
  unsigned __int8 v3; // al
  _BYTE *v4; // rdx
  __int64 v5; // r13
  size_t v6; // rbx
  char *v7; // rax
  char *v8; // r14
  char *v9; // r12
  char *v10; // rcx
  __int64 v11; // r15
  char v12; // al
  __int64 v13; // rdx
  __int64 result; // rax
  char *v15; // rax
  char *v16; // [rsp+8h] [rbp-40h]
  char *v17; // [rsp+8h] [rbp-40h]

  v2 = (char *)src;
  v3 = *(_BYTE *)src;
  if ( !*(_BYTE *)src )
  {
    v15 = ensure(a2, 3uLL);
    v8 = v15;
    if ( v15 )
    {
      v9 = v15 + 1;
      v11 = 2LL;
      v6 = 0LL;
      v10 = v15 + 1;
      goto LABEL_40;
    }
    return 0LL;
  }
  v4 = src;
  v5 = 0LL;
  do
  {
    while ( v3 > 0xDu )
    {
      if ( v3 != 34 && v3 != 92 )
        goto LABEL_5;
LABEL_11:
      v3 = *++v4;
      ++v5;
      if ( !*v4 )
        goto LABEL_12;
    }
    if ( v3 >= 0xCu || (unsigned __int8)(v3 - 8) <= 2u )
      goto LABEL_11;
LABEL_5:
    if ( v3 < 0x20u )
      v5 += 5LL;
    v3 = *++v4;
  }
  while ( *v4 );
LABEL_12:
  v6 = v4 - (_BYTE *)src + v5;
  v7 = ensure(a2, v6 + 3);
  v8 = v7;
  if ( !v7 )
    return 0LL;
  v9 = v7 + 1;
  v10 = &v7[v6 + 1];
  v11 = v6 + 2;
  if ( v5 )
  {
    *v7 = 34;
    v12 = *(_BYTE *)src;
    if ( !*(_BYTE *)src )
    {
LABEL_26:
      *v10 = 34;
      result = 1LL;
      v8[v11] = 0;
      return result;
    }
    while ( 1 )
    {
      if ( v12 != 34 && (unsigned __int8)v12 > 0x1Fu && v12 != 92 )
      {
        *v9++ = v12;
        goto LABEL_18;
      }
      *v9 = 92;
      v13 = (unsigned __int8)*v2;
      if ( (_BYTE)v13 == 12 )
      {
        v9[1] = 102;
        v9 += 2;
        goto LABEL_18;
      }
      if ( (unsigned __int8)v13 > 0xCu )
      {
        switch ( (_BYTE)v13 )
        {
          case 0x22:
            v9[1] = 34;
            v9 += 2;
            goto LABEL_18;
          case 0x5C:
            v9[1] = 92;
            v9 += 2;
            goto LABEL_18;
          case 0xD:
            v9[1] = 114;
            v9 += 2;
            goto LABEL_18;
        }
      }
      else
      {
        switch ( (_BYTE)v13 )
        {
          case 9:
            v9[1] = 116;
            v9 += 2;
LABEL_18:
            v12 = *++v2;
            if ( !*v2 )
              goto LABEL_26;
            continue;
          case 0xA:
            v9[1] = 110;
            v9 += 2;
            goto LABEL_18;
          case 8:
            v9[1] = 98;
            v9 += 2;
            goto LABEL_18;
        }
      }
      ++v2;
      v16 = v10;
      sprintf(v9 + 1, "u%04x", v13);
      v12 = *v2;
      v9 += 6;
      v10 = v16;
      if ( !*v2 )
        goto LABEL_26;
    }
  }
LABEL_40:
  *v8 = 34;
  v17 = v10;
  memcpy(v9, src, v6);
  result = 1LL;
  *v17 = 34;
  v8[v11] = 0;
  return result;
}

//----- (00000000000079C0) ----------------------------------------------------
__int64 __fastcall print_value_part_8(__int64 a1, __m128i *a2)
{
  unsigned int v4; // ebp
  const char *v5; // rdi
  unsigned __int64 v6; // rbp
  char *v7; // rax
  size_t v8; // rdx
  void *v10; // rdi
  char *v11; // rax
  char *v12; // rax
  char *v13; // rax
  double v14; // xmm1_8
  char v15; // r13
  char v16; // cl
  __int64 j; // rdx
  char *v18; // rax
  _QWORD *v19; // rbp
  char *v20; // rax
  __int64 v21; // r12
  __int64 v22; // r12
  char *v23; // rax
  char *v24; // rax
  _QWORD *v25; // rbp
  __int64 v26; // r13
  char *v27; // rax
  __int32 v28; // edx
  void *v29; // rdi
  __int64 v30; // r12
  unsigned __int64 v31; // r12
  char *v32; // rax
  __int64 v33; // r12
  unsigned __int64 v34; // r12
  char *v35; // rax
  char *v36; // rdx
  char *v37; // rax
  unsigned __int64 v38; // rcx
  int v39; // er14
  char *v40; // rax
  unsigned __int64 v41; // rcx
  unsigned __int64 i; // rdx
  char *v43; // rax
  char *v44; // rax
  unsigned __int64 v45; // rsi
  double v46; // [rsp+18h] [rbp-60h] BYREF
  char s[16]; // [rsp+20h] [rbp-58h] BYREF
  __int64 v48; // [rsp+30h] [rbp-48h]
  __int16 v49; // [rsp+38h] [rbp-40h]
  unsigned __int64 v50; // [rsp+48h] [rbp-30h]

  v4 = *(unsigned __int8 *)(a1 + 24);
  v50 = __readfsqword(0x28u);
  if ( v4 != 8 )
  {
    if ( (int)v4 <= 8 )
    {
      switch ( v4 )
      {
        case 2u:
          v12 = ensure(a2, 5uLL);
          if ( v12 )
          {
            strcpy(v12, "true");
            return 1;
          }
          break;
        case 4u:
          v13 = ensure(a2, 5uLL);
          if ( v13 )
          {
            strcpy(v13, "null");
            return 1;
          }
          break;
        case 1u:
          v11 = ensure(a2, 6uLL);
          if ( v11 )
          {
            strcpy(v11, "false");
            return v4;
          }
          break;
      }
      return 0;
    }
    if ( v4 == 32 )
    {
      if ( !a2 )
        return 0;
      v19 = *(_QWORD **)(a1 + 16);
      v20 = ensure(a2, 1uLL);
      if ( !v20 )
        return 0;
      *v20 = 91;
      a2[1] = _mm_add_epi64(_mm_load_si128((const __m128i *)&xmmword_D740), a2[1]);
      if ( v19 )
      {
        while ( 1 )
        {
          if ( !(unsigned int)print_value_part_8(v19, a2) )
            return 0;
          if ( a2->m128i_i64[0] )
          {
            v21 = a2[1].m128i_i64[0];
            a2[1].m128i_i64[0] = strlen((const char *)(v21 + a2->m128i_i64[0])) + v21;
          }
          if ( !*v19 )
            break;
          v22 = 2LL - (a2[2].m128i_i32[1] == 0);
          v23 = ensure(a2, 3LL - (a2[2].m128i_i32[1] == 0));
          if ( !v23 )
            return 0;
          *v23 = 44;
          if ( a2[2].m128i_i32[1] )
          {
            *(_WORD *)(v23 + 1) = 32;
            v19 = (_QWORD *)*v19;
            a2[1].m128i_i64[0] += v22;
            if ( !v19 )
              break;
          }
          else
          {
            v23[1] = 0;
            v19 = (_QWORD *)*v19;
            a2[1].m128i_i64[0] += v22;
            if ( !v19 )
              break;
          }
        }
      }
      v24 = ensure(a2, 2uLL);
      if ( v24 )
      {
        *(_WORD *)v24 = 93;
        v4 = 1;
        --a2[1].m128i_i64[1];
        return v4;
      }
      return 0;
    }
    if ( (int)v4 <= 32 )
    {
      if ( v4 == 16 && a2 )
      {
        v10 = *(void **)(a1 + 32);
        if ( v10 )
          return (unsigned int)print_string_ptr_part_5(v10, a2);
        v44 = ensure(a2, 3uLL);
        if ( v44 )
        {
          v4 = 1;
          strcpy(v44, "\"\"");
          return v4;
        }
      }
      return 0;
    }
    if ( v4 != 64 )
    {
      if ( v4 == 128 )
      {
        v5 = *(const char **)(a1 + 32);
        if ( v5 )
        {
          v6 = strlen(v5) + 1;
          v7 = ensure(a2, v6);
          if ( v7 )
          {
            v8 = v6;
            v4 = 1;
            memcpy(v7, *(const void **)(a1 + 32), v8);
            return v4;
          }
        }
      }
      return 0;
    }
    if ( !a2 )
      return 0;
    v25 = *(_QWORD **)(a1 + 16);
    v26 = 2LL - (a2[2].m128i_i32[1] == 0);
    v27 = ensure(a2, 3LL - (a2[2].m128i_i32[1] == 0));
    if ( !v27 )
      return 0;
    *v27 = 123;
    v28 = a2[2].m128i_i32[1];
    ++a2[1].m128i_i64[1];
    if ( !v28 )
    {
      a2[1].m128i_i64[0] += v26;
      if ( v25 )
        goto LABEL_53;
      v45 = 2LL;
      goto LABEL_72;
    }
    v27[1] = 10;
    v28 = a2[2].m128i_i32[1];
    a2[1].m128i_i64[0] += v26;
    if ( !v25 )
      goto LABEL_70;
    while ( 1 )
    {
LABEL_53:
      if ( v28 )
      {
        v40 = ensure(a2, a2[1].m128i_u64[1]);
        if ( !v40 )
          return 0;
        v41 = a2[1].m128i_u64[1];
        if ( v41 )
        {
          for ( i = 0LL; i < v41; ++i )
          {
            v40[i] = 9;
            v41 = a2[1].m128i_u64[1];
          }
        }
        v29 = (void *)v25[7];
        a2[1].m128i_i64[0] += v41;
        if ( v29 )
        {
LABEL_55:
          if ( !(unsigned int)print_string_ptr_part_5(v29, a2) )
            return 0;
          goto LABEL_56;
        }
      }
      else
      {
        v29 = (void *)v25[7];
        if ( v29 )
          goto LABEL_55;
      }
      v43 = ensure(a2, 3uLL);
      if ( !v43 )
        return 0;
      strcpy(v43, "\"\"");
LABEL_56:
      if ( a2->m128i_i64[0] )
      {
        v30 = a2[1].m128i_i64[0];
        a2[1].m128i_i64[0] = strlen((const char *)(v30 + a2->m128i_i64[0])) + v30;
      }
      v31 = (a2[2].m128i_i32[1] != 0) + 1LL;
      v32 = ensure(a2, v31);
      if ( !v32 )
        return 0;
      *v32 = 58;
      if ( a2[2].m128i_i32[1] )
        v32[1] = 9;
      a2[1].m128i_i64[0] += v31;
      if ( !(unsigned int)print_value_part_8(v25, a2) )
        return 0;
      if ( a2->m128i_i64[0] )
      {
        v33 = a2[1].m128i_i64[0];
        a2[1].m128i_i64[0] = strlen((const char *)(v33 + a2->m128i_i64[0])) + v33;
      }
      v34 = (a2[2].m128i_i32[1] != 0) + (unsigned __int64)(*v25 != 0LL);
      v35 = ensure(a2, v34 + 1);
      if ( !v35 )
        return 0;
      v36 = v35;
      if ( *v25 )
      {
        *v35 = 44;
        v36 = v35 + 1;
      }
      if ( a2[2].m128i_i32[1] )
      {
        *(_WORD *)v36 = 10;
        v25 = (_QWORD *)*v25;
        a2[1].m128i_i64[0] += v34;
        if ( !v25 )
          goto LABEL_69;
      }
      else
      {
        *v36 = 0;
        v25 = (_QWORD *)*v25;
        a2[1].m128i_i64[0] += v34;
        if ( !v25 )
        {
LABEL_69:
          v28 = a2[2].m128i_i32[1];
LABEL_70:
          v45 = 2LL;
          if ( v28 )
            v45 = a2[1].m128i_i64[1] + 1;
LABEL_72:
          v37 = ensure(a2, v45);
          if ( v37 )
          {
            if ( a2[2].m128i_i32[1] && a2[1].m128i_i64[1] != 1 )
            {
              v38 = 0LL;
              do
              {
                *v37++ = 9;
                ++v38;
              }
              while ( v38 < a2[1].m128i_i64[1] - 1 );
            }
            v4 = 1;
            *(_WORD *)v37 = 125;
            --a2[1].m128i_i64[1];
            return v4;
          }
          return 0;
        }
      }
      v28 = a2[2].m128i_i32[1];
    }
  }
  v14 = *(double *)(a1 + 48);
  v48 = 0LL;
  *(_OWORD *)s = 0LL;
  v49 = 0;
  v15 = *localeconv()->decimal_point;
  v46 = 0.0;
  if ( !a2 )
    return 0;
  v39 = sprintf(s, "%1.15g", v14);
  if ( sscanf(s, "%lg", &v46) != 1 || fmax(fabs(v46), fabs(v14)) * 2.220446049250313e-16 < fabs(v46 - v14) )
    v39 = sprintf(s, "%1.17g", v14);
  if ( (unsigned int)v39 > 0x19 )
    return 0;
  v18 = ensure(a2, v39 + 1LL);
  if ( !v18 )
    return 0;
  if ( v39 )
  {
    for ( j = 0LL; j != v39; v18[j++] = v16 )
    {
      v16 = s[j];
      if ( v15 == v16 )
        v16 = 46;
    }
    v18 += v39;
  }
  *v18 = 0;
  v4 = 1;
  a2[1].m128i_i64[0] += v39;
  return v4;
}
// D740: using guessed type __int128 xmmword_D740;

//----- (00000000000080B0) ----------------------------------------------------
void *__fastcall print_constprop_18(__int64 a1, int a2)
{
  void *v2; // rbx
  void *v3; // rbp
  __int64 v4; // rbx
  void *v5; // rdi
  void *v7; // rax
  void *v8; // rdx
  void *ptr[2]; // [rsp+0h] [rbp-78h] BYREF
  __int128 v10; // [rsp+10h] [rbp-68h]
  int v11; // [rsp+20h] [rbp-58h]
  int v12; // [rsp+24h] [rbp-54h]
  __m128i v13; // [rsp+28h] [rbp-50h]
  __int64 (__fastcall *v14)(_QWORD, _QWORD); // [rsp+38h] [rbp-40h]
  unsigned __int64 v15; // [rsp+48h] [rbp-30h]

  v15 = __readfsqword(0x28u);
  v10 = 0LL;
  v11 = 0;
  v12 = a2;
  v2 = (void *)global_hooks(256LL);
  ptr[0] = v2;
  ptr[1] = &qword_100;
  v13 = _mm_load_si128((const __m128i *)&global_hooks);
  v14 = off_11270;
  if ( !v2 || !a1 )
  {
LABEL_9:
    if ( v2 )
    {
      v5 = v2;
      v2 = 0LL;
      off_11268(v5);
    }
    return v2;
  }
  if ( !(unsigned int)print_value_part_8(a1, (__m128i *)ptr) )
    goto LABEL_8;
  v3 = ptr[0];
  v4 = v10;
  if ( ptr[0] )
  {
    v4 += strlen((const char *)ptr[0] + v10);
    *(_QWORD *)&v10 = v4;
  }
  if ( off_11270 )
  {
    v2 = (void *)off_11270(v3, v4 + 1);
    if ( v2 )
      return v2;
    goto LABEL_8;
  }
  v7 = (void *)global_hooks(v4 + 1);
  v2 = v7;
  if ( !v7 )
  {
LABEL_8:
    v2 = ptr[0];
    goto LABEL_9;
  }
  v8 = (void *)(v10 + 1);
  if ( (void *)(v10 + 1) > ptr[1] )
    v8 = ptr[1];
  memcpy(v7, ptr[0], (size_t)v8);
  *((_BYTE *)v2 + v10) = 0;
  off_11268(ptr[0]);
  return v2;
}
// 11270: invalid function type has been ignored
// 100: using guessed type __int64;
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11268: using guessed type __int64 (__fastcall *off_11268)(_QWORD);
// 11270: using guessed type __int64 (__fastcall *off_11270)(_QWORD, _QWORD);

//----- (0000000000008210) ----------------------------------------------------
__int64 __fastcall parse_string_isra_0(_DWORD *a1, __int64 *a2, __int64 *a3)
{
  __int64 v4; // r8
  __int64 v5; // rax
  _BYTE *v6; // rdx
  _BYTE *v7; // rbp
  unsigned __int64 v8; // r9
  char v9; // cl
  _BYTE *v11; // rax
  __int64 v12; // r10
  _BYTE *v13; // rbx
  unsigned __int64 v14; // rdi
  _BYTE *v15; // rcx
  __int64 result; // rax
  __int64 v17; // rax
  _BYTE *v18; // rdx
  char v19; // r14
  int v20; // ecx
  int v21; // ecx
  int v22; // er8
  int v23; // ecx
  unsigned __int8 v24; // r14
  int v25; // er8
  int v26; // ecx
  int v27; // er8
  int v28; // er8
  int v29; // ecx
  int v30; // er8
  unsigned __int8 v31; // r14
  unsigned int v32; // ecx
  _BYTE *v33; // r8
  int v34; // er8
  int v35; // er8
  int v36; // er14
  int v37; // er8
  int v38; // er14
  int v39; // er8
  int v40; // er14
  int v41; // er14
  int v42; // er8
  int v43; // er14
  int v44; // er14
  unsigned int v45; // er8
  __int16 v46; // cx
  __int64 v47; // r14
  unsigned __int64 v48; // rcx
  unsigned __int64 v49; // r8
  unsigned __int64 v50; // rcx
  char v51; // r8
  char v52; // cl
  _BYTE *v53; // rbx
  unsigned __int64 v54; // rbp
  char v55; // cl
  unsigned __int64 v56; // rcx
  unsigned __int64 v57; // rcx

  v4 = *a3;
  v5 = a3[2];
  v6 = (_BYTE *)(*a3 + v5);
  v7 = (_BYTE *)(v4 + v5 + 1);
  if ( *v6 == 34 && (v8 = a3[1], v5 + 1 < v8) )
  {
    v9 = *v7;
    if ( *v7 == 34 )
    {
      v18 = (_BYTE *)((__int64 (__fastcall *)(__int64))a3[4])(2LL);
      if ( !v18 )
      {
LABEL_10:
        result = 0LL;
        a3[2] = (__int64)&v7[-*a3];
        return result;
      }
    }
    else
    {
      v11 = (_BYTE *)(v4 + v5 + 1);
      v12 = 0LL;
      do
      {
        v13 = v11 + 1;
        v14 = (unsigned __int64)&v11[-v4 + 1];
        if ( v9 == 92 )
        {
          if ( v8 <= v14 )
            goto LABEL_10;
          v15 = v11 + 2;
          ++v12;
          ++v11;
          v13 = v15;
          if ( v8 <= (unsigned __int64)&v15[-v4] )
            goto LABEL_10;
        }
        else if ( v8 <= v14 )
        {
          goto LABEL_10;
        }
        v9 = v11[1];
        v11 = v13;
      }
      while ( v9 != 34 );
      v17 = ((__int64 (__fastcall *)(signed __int64))a3[4])(v13 - v6 - v12 + 1);
      if ( !v17 )
        goto LABEL_10;
      if ( v7 < v13 )
      {
        v18 = (_BYTE *)v17;
        while ( *v7 != 92 )
        {
          *v18++ = *v7++;
LABEL_17:
          if ( v13 <= v7 )
            goto LABEL_69;
        }
        if ( v13 - v7 <= 0 )
          goto LABEL_66;
        v19 = v7[1];
        switch ( v19 )
        {
          case '"':
          case '/':
          case '\\':
            *v18 = v19;
            v7 += 2;
            ++v18;
            goto LABEL_17;
          case 'b':
            *v18 = 8;
            v7 += 2;
            ++v18;
            goto LABEL_17;
          case 'f':
            *v18 = 12;
            v7 += 2;
            ++v18;
            goto LABEL_17;
          case 'n':
            *v18 = 10;
            v7 += 2;
            ++v18;
            goto LABEL_17;
          case 'r':
            *v18 = 13;
            v7 += 2;
            ++v18;
            goto LABEL_17;
          case 't':
            *v18 = 9;
            v7 += 2;
            ++v18;
            goto LABEL_17;
          case 'u':
            if ( v13 - v7 <= 5 )
              goto LABEL_66;
            v20 = (unsigned __int8)v7[2];
            if ( (unsigned __int8)(v20 - 48) <= 9u )
            {
              v21 = v20 - 48;
            }
            else if ( (unsigned __int8)(v20 - 65) <= 5u )
            {
              v21 = v20 - 55;
            }
            else
            {
              if ( (unsigned __int8)(v20 - 97) > 5u )
                goto LABEL_81;
              v21 = v20 - 87;
            }
            v22 = (unsigned __int8)v7[3];
            v23 = 16 * v21;
            if ( (unsigned __int8)(v22 - 48) <= 9u )
            {
              v25 = v23 + v22 - 48;
            }
            else if ( (unsigned __int8)(v22 - 65) <= 5u )
            {
              v25 = v23 + v22 - 55;
            }
            else
            {
              v24 = v22 - 97;
              v25 = v23 + v22 - 87;
              if ( v24 > 5u )
                goto LABEL_81;
            }
            v26 = (unsigned __int8)v7[4];
            v27 = 16 * v25;
            if ( (unsigned __int8)(v26 - 48) <= 9u )
            {
              v28 = v27 + v26 - 48;
            }
            else if ( (unsigned __int8)(v26 - 65) <= 5u )
            {
              v28 = v27 + v26 - 55;
            }
            else
            {
              v28 = v27 + v26 - 87;
              if ( (unsigned __int8)(v26 - 97) > 5u )
                goto LABEL_81;
            }
            v29 = (unsigned __int8)v7[5];
            v30 = 16 * v28;
            if ( (unsigned __int8)(v29 - 48) <= 9u )
            {
              v32 = v30 + v29 - 48;
              goto LABEL_35;
            }
            if ( (unsigned __int8)(v29 - 65) <= 5u )
            {
              v32 = v30 + v29 - 55;
              goto LABEL_35;
            }
            v31 = v29 - 97;
            v32 = v30 + v29 - 87;
            if ( v31 <= 5u )
            {
LABEL_35:
              if ( v32 - 56320 <= 0x3FF )
                goto LABEL_66;
              v33 = v7 + 6;
              if ( v32 - 55296 <= 0x3FF )
              {
                if ( v13 - v33 <= 5 || v7[6] != 92 || v7[7] != 117 )
                  goto LABEL_66;
                v34 = (unsigned __int8)v7[8];
                if ( (unsigned __int8)(v34 - 48) <= 9u )
                {
                  v35 = v34 - 48;
                }
                else if ( (unsigned __int8)(v34 - 65) <= 5u )
                {
                  v35 = v34 - 55;
                }
                else
                {
                  if ( (unsigned __int8)(v34 - 97) > 5u )
                    goto LABEL_66;
                  v35 = v34 - 87;
                }
                v36 = (unsigned __int8)v7[9];
                v37 = 16 * v35;
                if ( (unsigned __int8)(v36 - 48) <= 9u )
                {
                  v38 = v37 + v36 - 48;
                }
                else if ( (unsigned __int8)(v36 - 65) <= 5u )
                {
                  v38 = v37 + v36 - 55;
                }
                else
                {
                  if ( (unsigned __int8)(v36 - 97) > 5u )
                    goto LABEL_66;
                  v38 = v37 + v36 - 87;
                }
                v39 = (unsigned __int8)v7[10];
                v40 = 16 * v38;
                if ( (unsigned __int8)(v39 - 48) <= 9u )
                {
                  v41 = v40 + v39 - 48;
                }
                else if ( (unsigned __int8)(v39 - 65) <= 5u )
                {
                  v41 = v40 + v39 - 55;
                }
                else
                {
                  if ( (unsigned __int8)(v39 - 97) > 5u )
                    goto LABEL_66;
                  v41 = v40 + v39 - 87;
                }
                v42 = (unsigned __int8)v7[11];
                v43 = 16 * v41;
                if ( (unsigned __int8)(v42 - 48) <= 9u )
                {
                  v44 = v43 + v42 - 48;
                }
                else if ( (unsigned __int8)(v42 - 65) <= 5u )
                {
                  v44 = v43 + v42 - 55;
                }
                else
                {
                  if ( (unsigned __int8)(v42 - 97) > 5u )
                    goto LABEL_66;
                  v44 = v43 + v42 - 87;
                }
                if ( (unsigned int)(v44 - 56320) > 0x3FF )
                {
LABEL_66:
                  ((void (__fastcall *)(__int64, __int64 *, _BYTE *))a3[5])(v17, a2, v18);
                  goto LABEL_10;
                }
                v7 += 12;
                v45 = v32 << 10;
                v46 = v44;
                v47 = 4LL;
                v48 = (v46 & 0x3FF | v45 & 0xFFC00) + 0x10000;
                v18[3] = v48 & 0x3F | 0x80;
                v18[2] = (v48 >> 6) & 0x3F | 0x80;
                v49 = v48;
                v50 = v48 >> 18;
                v18[1] = (v49 >> 12) & 0x3F | 0x80;
                v51 = -16;
                goto LABEL_58;
              }
              v54 = v32;
              if ( v32 > 0x7F )
              {
                v55 = v32 & 0x3F | 0x80;
                if ( v54 > 0x7FF )
                {
                  v18[2] = v55;
                  v47 = 3LL;
                  v18[1] = (v54 >> 6) & 0x3F | 0x80;
                  v57 = v54;
                  v7 = v33;
                  v51 = -32;
                  v50 = v57 >> 12;
                }
                else
                {
                  v18[1] = v55;
                  v56 = v54;
                  v47 = 2LL;
                  v7 = v33;
                  v50 = v56 >> 6;
                  v51 = -64;
                }
LABEL_58:
                v52 = v51 | v50;
LABEL_59:
                *v18 = v52;
                v18 += v47;
                goto LABEL_17;
              }
LABEL_82:
              v52 = v32 & 0x7F;
              v7 = v33;
              v47 = 1LL;
              goto LABEL_59;
            }
LABEL_81:
            v33 = v7 + 6;
            LOBYTE(v32) = 0;
            goto LABEL_82;
          default:
            goto LABEL_66;
        }
      }
      v7 = v13;
      v18 = (_BYTE *)v17;
    }
    v13 = v7;
    v17 = (__int64)v18;
LABEL_69:
    *v18 = 0;
    v53 = &v13[-*a3];
    *a1 = 16;
    *a2 = v17;
    a3[2] = (__int64)(v53 + 1);
    result = 1LL;
  }
  else
  {
    result = 0LL;
    if ( v7 )
      goto LABEL_10;
  }
  return result;
}

//----- (00000000000087E0) ----------------------------------------------------
__int64 cJSON_GetErrorPtr()
{
  return global_error + qword_112A8;
}
// 87E0: using guessed type __int64 __fastcall cJSON_GetErrorPtr();
// 112A0: using guessed type __int64 global_error;
// 112A8: using guessed type __int64 qword_112A8;

//----- (00000000000087F0) ----------------------------------------------------
__int64 __fastcall cJSON_GetStringValue(__int64 a1)
{
  __int64 result; // rax

  if ( a1 && *(_BYTE *)(a1 + 24) == 16 )
    result = *(_QWORD *)(a1 + 32);
  else
    result = 0LL;
  return result;
}

//----- (0000000000008810) ----------------------------------------------------
double __fastcall cJSON_GetNumberValue(__int64 a1)
{
  double result; // xmm0_8

  if ( a1 && *(_BYTE *)(a1 + 24) == 8 )
    result = *(double *)(a1 + 48);
  else
    result = 0.0 / 0.0;
  return result;
}

//----- (0000000000008840) ----------------------------------------------------
char *cJSON_Version()
{
  sprintf(version_2420, "%i.%i.%i", 1LL, 7LL, 14LL);
  return version_2420;
}

//----- (0000000000008880) ----------------------------------------------------
void *(**__fastcall cJSON_InitHooks(__int64 a1))(size_t size)
{
  void *(**result)(size_t); // rax
  __int64 (*v2)(void); // rdx

  if ( !a1 )
  {
    result = (void *(**)(size_t))&realloc;
    off_11270 = &realloc;
    *(__m128 *)&global_hooks = _mm_loadh_ps((const double *)&free_ptr);
    return result;
  }
  result = *(void *(***)(size_t))a1;
  global_hooks = &malloc;
  if ( !result )
  {
    v2 = *(__int64 (**)(void))(a1 + 8);
    result = &malloc;
    off_11268 = (__int64 (*)(void))&free;
    if ( v2 )
    {
      off_11268 = v2;
      off_11270 = 0LL;
      goto LABEL_10;
    }
LABEL_7:
    off_11270 = 0LL;
    if ( result != &malloc )
      return result;
LABEL_8:
    result = (void *(**)(size_t))&realloc;
    off_11270 = &realloc;
    return result;
  }
  v2 = *(__int64 (**)(void))(a1 + 8);
  global_hooks = result;
  off_11268 = (__int64 (*)(void))&free;
  if ( !v2 )
    goto LABEL_7;
  off_11268 = v2;
  off_11270 = 0LL;
  if ( result != &malloc )
    return result;
LABEL_10:
  if ( (char *)v2 == (char *)&free )
    goto LABEL_8;
  return result;
}
// 10FC0: using guessed type void *free_ptr;
// 11260: using guessed type void *global_hooks;
// 11268: using guessed type __int64 (*off_11268)(void);
// 11270: using guessed type void *off_11270;

//----- (0000000000008960) ----------------------------------------------------
void __fastcall cJSON_Delete(_DWORD *a1)
{
  _DWORD *v1; // rbx
  int v2; // eax
  _DWORD *v3; // rbp
  _DWORD *v4; // rdi
  void (__fastcall *v5)(void *); // rdx
  void *v6; // rdi
  void *v7; // rdi

  if ( a1 )
  {
    v1 = a1;
    while ( 1 )
    {
      v2 = v1[6];
      v3 = *(_DWORD **)v1;
      if ( (v2 & 0x100) != 0 )
        goto LABEL_8;
      v4 = (_DWORD *)*((_QWORD *)v1 + 2);
      if ( v4 )
      {
        cJSON_Delete(v4);
        v2 = v1[6];
        if ( (v2 & 0x100) != 0 )
          goto LABEL_8;
      }
      v5 = (void (__fastcall *)(void *))off_11268;
      if ( *((_QWORD *)v1 + 4) )
        break;
LABEL_9:
      if ( (v2 & 0x200) == 0 )
      {
        v6 = (void *)*((_QWORD *)v1 + 7);
        if ( v6 )
        {
          v5(v6);
          v5 = (void (__fastcall *)(void *))off_11268;
        }
      }
      v7 = v1;
      v1 = v3;
      v5(v7);
      if ( !v3 )
        return;
    }
    off_11268();
    v2 = v1[6];
LABEL_8:
    v5 = (void (__fastcall *)(void *))off_11268;
    goto LABEL_9;
  }
}
// 11268: using guessed type __int64 (*off_11268)(void);

//----- (00000000000089F0) ----------------------------------------------------
__int64 __fastcall parse_value(__int64 a1, __int64 a2)
{
  __int64 v2; // rdx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // r8
  unsigned __int64 v7; // r9
  unsigned __int64 v8; // r11
  _BYTE *v9; // rsi
  char v10; // cl
  __int64 result; // rax
  unsigned __int64 v12; // rdi
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rax
  __int64 *v15; // r14
  __int64 v16; // r12
  __int64 v17; // rax
  __int64 v18; // r13
  __int64 v19; // rax
  __int64 v20; // rcx
  unsigned __int64 v21; // rdx
  unsigned __int64 v22; // rsi
  unsigned __int64 v23; // rax
  __int64 v24; // rcx
  unsigned __int64 v25; // rdx
  unsigned __int64 v26; // rsi
  __int64 v27; // rsi
  unsigned __int64 v28; // rax
  __int64 v29; // rcx
  unsigned __int64 v30; // rdx
  unsigned __int64 v31; // rsi
  char v32; // al
  char v33; // r11
  unsigned __int64 v34; // rax
  unsigned __int64 v35; // rdi
  __int64 v36; // rdx
  char *v37; // r10
  char v38; // si
  char v39; // cl
  double v40; // xmm0_8
  char *v41; // rax
  unsigned __int64 v42; // rdi
  __int64 *v43; // r14
  __int64 v44; // rax
  __int64 *v45; // r13
  __int64 v46; // rax
  __int64 v47; // rcx
  unsigned __int64 v48; // rdx
  unsigned __int64 v49; // rsi
  unsigned __int64 v50; // rax
  __int64 v51; // rcx
  unsigned __int64 v52; // rdx
  unsigned __int64 v53; // rsi
  char v54; // al
  __int64 v55; // rax
  unsigned __int64 v56; // rax
  __int64 v57; // rax
  unsigned __int64 v58; // rax
  unsigned __int64 v59; // rax
  char *endptr; // [rsp+8h] [rbp-80h] BYREF
  char nptr[72]; // [rsp+10h] [rbp-78h] BYREF
  unsigned __int64 v62; // [rsp+58h] [rbp-30h]

  v62 = __readfsqword(0x28u);
  if ( !a2 )
    return 0LL;
  v2 = *(_QWORD *)a2;
  if ( !*(_QWORD *)a2 )
    return 0LL;
  v4 = *(_QWORD *)(a2 + 16);
  v5 = *(_QWORD *)(a2 + 8);
  v7 = v4 + 4;
  if ( v4 + 4 <= v5 )
  {
    if ( !memcmp((const void *)(v2 + v4), "null", 4uLL) )
    {
      *(_DWORD *)(a1 + 24) = 4;
      result = 1LL;
      *(_QWORD *)(a2 + 16) = v7;
      return result;
    }
    v8 = v4 + 5;
    if ( v5 < v4 + 5 || memcmp((const void *)(v2 + v4), "false", 5uLL) )
    {
      if ( !memcmp((const void *)(v2 + v4), "true", 4uLL) )
      {
        *(_DWORD *)(a1 + 24) = 2;
        result = 1LL;
        *(_DWORD *)(a1 + 40) = 1;
        *(_QWORD *)(a2 + 16) = v7;
        return result;
      }
      goto LABEL_8;
    }
LABEL_17:
    *(_DWORD *)(a1 + 24) = 1;
    result = 1LL;
    *(_QWORD *)(a2 + 16) = v8;
    return result;
  }
  v8 = v4 + 5;
  if ( v5 >= v4 + 5 && !memcmp((const void *)(v2 + v4), "false", 5uLL) )
    goto LABEL_17;
LABEL_8:
  if ( v4 >= v5 )
    return 0LL;
  v9 = (_BYTE *)(v2 + v4);
  v10 = *(_BYTE *)(v2 + v4);
  if ( v10 == 34 )
    return parse_string_isra_0((_DWORD *)(a1 + 24), (__int64 *)(a1 + 32), (__int64 *)a2);
  if ( (unsigned __int8)(v10 - 48) <= 9u || v10 == 45 )
  {
    endptr = 0LL;
    v33 = *localeconv()->decimal_point;
    if ( !*(_QWORD *)a2 )
      return 0LL;
    v34 = *(_QWORD *)(a2 + 16);
    v35 = *(_QWORD *)(a2 + 8);
    v36 = 0LL;
    v37 = &nptr[-v34];
    do
    {
      if ( v35 <= v34 )
        break;
      v38 = *(_BYTE *)(*(_QWORD *)a2 + v34);
      v39 = v38 - 43;
      if ( (unsigned __int8)(v38 - 43) > 0x3Au )
        break;
      if ( ((1LL << v39) & 0x400000004007FE5LL) != 0 )
      {
        v37[v34] = v38;
      }
      else
      {
        if ( ((1LL << v39) & 8) == 0 )
          break;
        v37[v34] = v33;
      }
      ++v36;
      ++v34;
    }
    while ( v36 != 63 );
    nptr[v36] = 0;
    v40 = strtod(nptr, &endptr);
    v41 = endptr;
    if ( endptr == nptr )
      return 0LL;
    *(double *)(a1 + 48) = v40;
    if ( v40 < 2147483647.0 )
    {
      if ( v40 > -2147483648.0 )
        *(_DWORD *)(a1 + 40) = (int)v40;
      else
        *(_DWORD *)(a1 + 40) = 0x80000000;
    }
    else
    {
      *(_DWORD *)(a1 + 40) = 0x7FFFFFFF;
    }
    *(_DWORD *)(a1 + 24) = 8;
    *(_QWORD *)(a2 + 16) += v41 - nptr;
    return 1LL;
  }
  if ( v10 != 91 )
  {
    if ( v10 != 123 )
      return 0LL;
    v12 = *(_QWORD *)(a2 + 24);
    if ( v12 > 0x3E7 )
      return 0LL;
    *(_QWORD *)(a2 + 24) = v12 + 1;
    if ( *v9 != 123 )
      return 0LL;
    v13 = v4 + 1;
    *(_QWORD *)(a2 + 16) = v4 + 1;
    if ( v5 > v4 + 1 )
    {
      if ( *(_BYTE *)(v2 + v4 + 1) > 0x20u )
      {
LABEL_136:
        v13 = *(_QWORD *)(a2 + 16);
        goto LABEL_29;
      }
      while ( 1 )
      {
        v14 = v13 + 1;
        *(_QWORD *)(a2 + 16) = v13 + 1;
        if ( v5 <= v13 + 1 )
          break;
        ++v13;
        if ( *(_BYTE *)(v2 + v14) > 0x20u )
          goto LABEL_136;
      }
      if ( v5 == v13 + 1 )
      {
        *(_QWORD *)(a2 + 16) = v13;
LABEL_29:
        if ( *(_BYTE *)(v2 + v13) == 125 )
        {
          *(_QWORD *)(a2 + 24) = v12;
          v16 = 0LL;
LABEL_69:
          *(_DWORD *)(a1 + 24) = 64;
          result = 1LL;
          *(_QWORD *)(a1 + 16) = v16;
          ++*(_QWORD *)(a2 + 16);
          return result;
        }
        v15 = 0LL;
        v16 = 0LL;
        *(_QWORD *)(a2 + 16) = v13 - 1;
        while ( 1 )
        {
          v17 = (*(__int64 (__fastcall **)(__int64))(a2 + 32))(64LL);
          v18 = v17;
          if ( !v17 )
            goto LABEL_132;
          *(_OWORD *)v17 = 0LL;
          *(_OWORD *)(v17 + 16) = 0LL;
          *(_OWORD *)(v17 + 32) = 0LL;
          *(_OWORD *)(v17 + 48) = 0LL;
          if ( v16 )
          {
            *v15 = v17;
            *(_QWORD *)(v17 + 8) = v15;
          }
          else
          {
            v16 = v17;
          }
          v19 = *(_QWORD *)(a2 + 16);
          v20 = *(_QWORD *)a2;
          v21 = v19 + 1;
          *(_QWORD *)(a2 + 16) = v19 + 1;
          if ( v20 )
          {
            v22 = *(_QWORD *)(a2 + 8);
            if ( v21 < v22 && *(_BYTE *)(v20 + v19 + 1) <= 0x20u )
            {
              while ( 1 )
              {
                v23 = v21 + 1;
                *(_QWORD *)(a2 + 16) = v21 + 1;
                if ( v22 <= v21 + 1 )
                  break;
                ++v21;
                if ( *(_BYTE *)(v20 + v23) > 0x20u )
                  goto LABEL_42;
              }
              if ( v22 == v21 + 1 )
                *(_QWORD *)(a2 + 16) = v21;
            }
          }
LABEL_42:
          if ( !(unsigned int)parse_string_isra_0((_DWORD *)(v18 + 24), (__int64 *)(v18 + 32), (__int64 *)a2) )
            goto LABEL_129;
          v24 = *(_QWORD *)a2;
          v25 = *(_QWORD *)(a2 + 8);
          v26 = *(_QWORD *)(a2 + 16);
          if ( *(_QWORD *)a2 )
          {
            if ( v25 <= v26 )
            {
              v55 = *(_QWORD *)(v18 + 32);
              *(_QWORD *)(v18 + 32) = 0LL;
              *(_QWORD *)(v18 + 56) = v55;
              goto LABEL_129;
            }
            if ( *(_BYTE *)(v24 + v26) > 0x20u )
            {
              v57 = *(_QWORD *)(v18 + 32);
              *(_QWORD *)(v18 + 32) = 0LL;
              *(_QWORD *)(v18 + 56) = v57;
              v58 = v26;
              goto LABEL_51;
            }
            while ( 1 )
            {
              v58 = v26 + 1;
              *(_QWORD *)(a2 + 16) = v26 + 1;
              if ( v25 == v26 + 1 )
                break;
              ++v26;
              if ( *(_BYTE *)(v24 + v58) > 0x20u )
                goto LABEL_50;
            }
            *(_QWORD *)(a2 + 16) = v26;
            v58 = v26;
          }
          else
          {
            v58 = *(_QWORD *)(a2 + 16);
          }
LABEL_50:
          v27 = *(_QWORD *)(v18 + 32);
          *(_QWORD *)(v18 + 32) = 0LL;
          *(_QWORD *)(v18 + 56) = v27;
          if ( v25 <= v58 )
            goto LABEL_129;
LABEL_51:
          if ( *(_BYTE *)(v24 + v58) != 58 )
            goto LABEL_129;
          v28 = v58 + 1;
          *(_QWORD *)(a2 + 16) = v28;
          if ( v25 > v28 && v24 )
          {
            while ( *(_BYTE *)(v24 + v28) <= 0x20u )
            {
              *(_QWORD *)(a2 + 16) = ++v28;
              if ( v25 <= v28 )
              {
                if ( v25 == v28 )
                  *(_QWORD *)(a2 + 16) = v25 - 1;
                break;
              }
            }
          }
          if ( !(unsigned int)parse_value(v18, a2) )
            goto LABEL_129;
          v29 = *(_QWORD *)a2;
          v30 = *(_QWORD *)(a2 + 16);
          v31 = *(_QWORD *)(a2 + 8);
          if ( !*(_QWORD *)a2 )
          {
            v59 = *(_QWORD *)(a2 + 16);
            goto LABEL_65;
          }
          if ( v30 >= v31 )
            goto LABEL_129;
          if ( *(_BYTE *)(v29 + v30) <= 0x20u )
          {
            while ( 1 )
            {
              v59 = v30 + 1;
              *(_QWORD *)(a2 + 16) = v30 + 1;
              if ( v30 + 1 == v31 )
                break;
              ++v30;
              if ( *(_BYTE *)(v29 + v59) > 0x20u )
                goto LABEL_65;
            }
            *(_QWORD *)(a2 + 16) = v30;
            v59 = v30;
LABEL_65:
            if ( v31 <= v59 )
              goto LABEL_129;
            goto LABEL_66;
          }
          v59 = *(_QWORD *)(a2 + 16);
LABEL_66:
          v32 = *(_BYTE *)(v29 + v59);
          v15 = (__int64 *)v18;
          if ( v32 != 44 )
          {
            if ( v32 != 125 )
              goto LABEL_129;
            --*(_QWORD *)(a2 + 24);
            *(_QWORD *)(v16 + 8) = v18;
            goto LABEL_69;
          }
        }
      }
      goto LABEL_126;
    }
LABEL_127:
    *(_QWORD *)(a2 + 16) = v13 - 1;
    return 0LL;
  }
  v42 = *(_QWORD *)(a2 + 24);
  if ( v42 > 0x3E7 )
    return 0LL;
  *(_QWORD *)(a2 + 24) = v42 + 1;
  if ( *v9 != 91 )
    return 0LL;
  v13 = v4 + 1;
  *(_QWORD *)(a2 + 16) = v4 + 1;
  if ( v5 <= v4 + 1 )
    goto LABEL_127;
  if ( *(_BYTE *)(v2 + v4 + 1) <= 0x20u )
  {
    while ( 1 )
    {
      v14 = v13 + 1;
      *(_QWORD *)(a2 + 16) = v13 + 1;
      if ( v5 <= v13 + 1 )
        break;
      ++v13;
      if ( *(_BYTE *)(v2 + v14) > 0x20u )
        goto LABEL_131;
    }
    if ( v5 != v13 + 1 )
    {
LABEL_126:
      v13 = v14;
      goto LABEL_127;
    }
    *(_QWORD *)(a2 + 16) = v13;
  }
  else
  {
LABEL_131:
    v13 = *(_QWORD *)(a2 + 16);
  }
  if ( *(_BYTE *)(v2 + v13) == 93 )
  {
    *(_QWORD *)(a2 + 24) = v42;
    v16 = 0LL;
LABEL_118:
    *(_DWORD *)(a1 + 24) = 32;
    result = 1LL;
    *(_QWORD *)(a1 + 16) = v16;
    ++*(_QWORD *)(a2 + 16);
    return result;
  }
  v43 = 0LL;
  v16 = 0LL;
  *(_QWORD *)(a2 + 16) = v13 - 1;
  while ( 1 )
  {
    v44 = (*(__int64 (__fastcall **)(__int64))(a2 + 32))(64LL);
    v45 = (__int64 *)v44;
    if ( !v44 )
      break;
    *(_OWORD *)v44 = 0LL;
    *(_OWORD *)(v44 + 16) = 0LL;
    *(_OWORD *)(v44 + 32) = 0LL;
    *(_OWORD *)(v44 + 48) = 0LL;
    if ( v16 )
    {
      *v43 = v44;
      *(_QWORD *)(v44 + 8) = v43;
    }
    else
    {
      v16 = v44;
    }
    v46 = *(_QWORD *)(a2 + 16);
    v47 = *(_QWORD *)a2;
    v48 = v46 + 1;
    *(_QWORD *)(a2 + 16) = v46 + 1;
    if ( v47 )
    {
      v49 = *(_QWORD *)(a2 + 8);
      if ( v48 < v49 && *(_BYTE *)(v47 + v46 + 1) <= 0x20u )
      {
        while ( 1 )
        {
          v50 = v48 + 1;
          *(_QWORD *)(a2 + 16) = v48 + 1;
          if ( v49 <= v48 + 1 )
            break;
          ++v48;
          if ( *(_BYTE *)(v47 + v50) > 0x20u )
            goto LABEL_106;
        }
        if ( v49 == v48 + 1 )
          *(_QWORD *)(a2 + 16) = v48;
      }
    }
LABEL_106:
    if ( !(unsigned int)parse_value(v45, a2) )
      goto LABEL_129;
    v51 = *(_QWORD *)a2;
    v52 = *(_QWORD *)(a2 + 16);
    v53 = *(_QWORD *)(a2 + 8);
    if ( !*(_QWORD *)a2 )
    {
      v56 = *(_QWORD *)(a2 + 16);
      goto LABEL_114;
    }
    if ( v52 >= v53 )
      goto LABEL_129;
    if ( *(_BYTE *)(v51 + v52) <= 0x20u )
    {
      while ( 1 )
      {
        v56 = v52 + 1;
        *(_QWORD *)(a2 + 16) = v52 + 1;
        if ( v53 == v52 + 1 )
          break;
        ++v52;
        if ( *(_BYTE *)(v51 + v56) > 0x20u )
          goto LABEL_114;
      }
      *(_QWORD *)(a2 + 16) = v52;
      v56 = v52;
LABEL_114:
      if ( v53 <= v56 )
        goto LABEL_129;
      goto LABEL_115;
    }
    v56 = *(_QWORD *)(a2 + 16);
LABEL_115:
    v54 = *(_BYTE *)(v51 + v56);
    v43 = v45;
    if ( v54 != 44 )
    {
      if ( v54 == 93 )
      {
        --*(_QWORD *)(a2 + 24);
        *(_QWORD *)(v16 + 8) = v45;
        goto LABEL_118;
      }
      goto LABEL_129;
    }
  }
LABEL_132:
  if ( v16 )
  {
LABEL_129:
    cJSON_Delete((_DWORD *)v16);
    return 0LL;
  }
  return 0LL;
}

//----- (0000000000009190) ----------------------------------------------------
__int64 __fastcall cJSON_SetNumberHelper(__int64 a1, double a2)
{
  __int64 result; // rax

  if ( a2 < 2147483647.0 )
  {
    if ( a2 > -2147483648.0 )
    {
      result = (unsigned int)(int)a2;
      *(double *)(a1 + 48) = a2;
      *(_DWORD *)(a1 + 40) = result;
    }
    else
    {
      *(_DWORD *)(a1 + 40) = 0x80000000;
      *(double *)(a1 + 48) = a2;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 40) = 0x7FFFFFFF;
    *(double *)(a1 + 48) = a2;
  }
  return result;
}

//----- (00000000000091E0) ----------------------------------------------------
void *__fastcall cJSON_SetValuestring(__int64 a1, const char *a2)
{
  size_t v2; // rax
  void *v3; // rbp
  size_t v4; // rbx
  size_t v5; // rbx
  void *v6; // rax
  void *v7; // rbp

  if ( (*(_DWORD *)(a1 + 24) & 0x110) != 16 )
    return 0LL;
  v2 = strlen(a2);
  v3 = *(void **)(a1 + 32);
  v4 = v2;
  if ( v2 <= strlen((const char *)v3) )
  {
    memcpy(v3, a2, v4 + 1);
    return *(void **)(a1 + 32);
  }
  v5 = v4 + 1;
  v6 = (void *)global_hooks(v5);
  v7 = v6;
  if ( !v6 )
    return 0LL;
  memcpy(v6, a2, v5);
  if ( *(_QWORD *)(a1 + 32) )
    off_11268();
  *(_QWORD *)(a1 + 32) = v7;
  return v7;
}
// 11260: invalid function type has been ignored
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11268: using guessed type __int64 (*off_11268)(void);

//----- (00000000000092A0) ----------------------------------------------------
_DWORD *__fastcall cJSON_ParseWithLengthOpts(__int128 a1, _QWORD *a2, int a3)
{
  __int64 v4; // rbp
  _OWORD *v6; // rax
  _DWORD *v7; // rbx
  __int128 *v8; // r9
  __int64 v9; // r8
  __int64 v10; // rax
  __int64 v11; // rax
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // rax
  __int128 v15; // [rsp+0h] [rbp-68h] BYREF
  __int128 v16; // [rsp+10h] [rbp-58h]
  __m128i v17; // [rsp+20h] [rbp-48h]
  void *v18; // [rsp+30h] [rbp-38h]
  unsigned __int64 v19; // [rsp+38h] [rbp-30h]

  v4 = a1;
  v19 = __readfsqword(0x28u);
  v15 = 0LL;
  v16 = 0LL;
  v17 = 0LL;
  v18 = 0LL;
  global_error = 0LL;
  qword_112A8 = 0LL;
  if ( !(_QWORD)a1 || !*((_QWORD *)&a1 + 1) )
  {
    v11 = 0LL;
    if ( !(_QWORD)a1 )
      return 0LL;
    goto LABEL_19;
  }
  v15 = a1;
  v17 = _mm_load_si128((const __m128i *)&global_hooks);
  v18 = off_11270;
  v6 = (_OWORD *)global_hooks(64LL);
  v7 = v6;
  if ( !v6 )
  {
LABEL_34:
    v11 = v16;
    if ( *((_QWORD *)&v15 + 1) <= (unsigned __int64)v16 )
    {
      v11 = *((_QWORD *)&v15 + 1) - 1LL;
      if ( !*((_QWORD *)&v15 + 1) )
        v11 = 0LL;
      if ( !a2 )
        goto LABEL_21;
      goto LABEL_20;
    }
LABEL_19:
    if ( !a2 )
    {
LABEL_21:
      global_error = v4;
      qword_112A8 = v11;
      return 0LL;
    }
LABEL_20:
    *a2 = v4 + v11;
    goto LABEL_21;
  }
  *v6 = 0LL;
  v8 = (__int128 *)v15;
  v6[1] = 0LL;
  v6[2] = 0LL;
  v6[3] = 0LL;
  if ( !v8 )
    goto LABEL_14;
  v9 = v16;
  if ( (_QWORD)v16 )
  {
    v8 = 0LL;
    goto LABEL_14;
  }
  if ( *((_QWORD *)&v15 + 1) > 4uLL )
  {
    if ( !memcmp(v8, &unk_D5DA, 3uLL) )
    {
      *(_QWORD *)&v16 = 3LL;
      v9 = 3LL;
    }
LABEL_9:
    if ( *((_BYTE *)v8 + v9) <= 0x20u )
    {
      while ( 1 )
      {
        v10 = v9 + 1;
        *(_QWORD *)&v16 = v9 + 1;
        if ( v9 + 1 == *((_QWORD *)&v15 + 1) )
          break;
        ++v9;
        if ( *((_BYTE *)v8 + v10) > 0x20u )
          goto LABEL_40;
      }
      *(_QWORD *)&v16 = v9;
      v8 = &v15;
      goto LABEL_14;
    }
    goto LABEL_40;
  }
  if ( *((_QWORD *)&v15 + 1) )
    goto LABEL_9;
LABEL_40:
  v8 = &v15;
LABEL_14:
  if ( !(unsigned int)parse_value((__int64)v7, (__int64)v8) )
    goto LABEL_33;
  if ( !a3 )
    goto LABEL_16;
  v13 = v16;
  if ( !(_QWORD)v15 )
  {
    v14 = v16;
    goto LABEL_31;
  }
  if ( (unsigned __int64)v16 >= *((_QWORD *)&v15 + 1) )
  {
LABEL_33:
    cJSON_Delete(v7);
    goto LABEL_34;
  }
  if ( *(_BYTE *)(v15 + v16) > 0x20u )
  {
    v14 = v16;
    goto LABEL_32;
  }
  while ( 1 )
  {
    v14 = v13 + 1;
    *(_QWORD *)&v16 = v13 + 1;
    if ( v13 + 1 == *((_QWORD *)&v15 + 1) )
      break;
    ++v13;
    if ( *(_BYTE *)(v15 + v14) > 0x20u )
      goto LABEL_31;
  }
  *(_QWORD *)&v16 = v13;
  v14 = v13;
LABEL_31:
  if ( *((_QWORD *)&v15 + 1) <= v14 )
    goto LABEL_33;
LABEL_32:
  if ( *(_BYTE *)(v15 + v14) )
    goto LABEL_33;
LABEL_16:
  if ( a2 )
    *a2 = v15 + v16;
  return v7;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11270: using guessed type void *off_11270;
// 112A0: using guessed type __int64 global_error;
// 112A8: using guessed type __int64 qword_112A8;

//----- (0000000000009520) ----------------------------------------------------
_DWORD *__fastcall cJSON_ParseWithOpts(__int128 a1, int a2)
{
  size_t v3; // rax
  _QWORD *v4; // rdx

  if ( !(_QWORD)a1 )
    return 0LL;
  v3 = strlen((const char *)a1);
  v4 = (_QWORD *)*((_QWORD *)&a1 + 1);
  *((_QWORD *)&a1 + 1) = v3 + 1;
  return cJSON_ParseWithLengthOpts(a1, v4, a2);
}

//----- (0000000000009560) ----------------------------------------------------
_DWORD *__fastcall cJSON_Parse(const char *a1)
{
  _OWORD *v2; // rax
  _DWORD *v3; // rbx
  __int64 *v4; // r8
  __int64 v5; // rdx
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 *v9; // [rsp+0h] [rbp-58h] BYREF
  size_t v10; // [rsp+8h] [rbp-50h]
  __int128 v11; // [rsp+10h] [rbp-48h]
  __m128i v12; // [rsp+20h] [rbp-38h]
  void *v13; // [rsp+30h] [rbp-28h]
  unsigned __int64 v14; // [rsp+38h] [rbp-20h]

  v14 = __readfsqword(0x28u);
  if ( !a1 )
    return 0LL;
  v9 = (__int64 *)a1;
  v11 = 0LL;
  v10 = strlen(a1) + 1;
  global_error = 0LL;
  qword_112A8 = 0LL;
  v12 = _mm_load_si128((const __m128i *)&global_hooks);
  v13 = off_11270;
  v2 = (_OWORD *)global_hooks(64LL);
  v3 = v2;
  if ( !v2 )
    goto LABEL_15;
  *v2 = 0LL;
  v4 = v9;
  v2[1] = 0LL;
  v2[2] = 0LL;
  v2[3] = 0LL;
  if ( !v4 )
    goto LABEL_13;
  v5 = v11;
  if ( (_QWORD)v11 )
  {
    v4 = 0LL;
    goto LABEL_13;
  }
  if ( v10 <= 4 )
  {
    if ( !v10 )
      goto LABEL_22;
  }
  else if ( !memcmp(v4, &unk_D5DA, 3uLL) )
  {
    *(_QWORD *)&v11 = 3LL;
    v5 = 3LL;
  }
  if ( *((_BYTE *)v4 + v5) <= 0x20u )
  {
    while ( 1 )
    {
      v6 = v5 + 1;
      *(_QWORD *)&v11 = v5 + 1;
      if ( v5 + 1 == v10 )
        break;
      ++v5;
      if ( *((_BYTE *)v4 + v6) > 0x20u )
        goto LABEL_22;
    }
    *(_QWORD *)&v11 = v5;
    v4 = (__int64 *)&v9;
LABEL_13:
    if ( (unsigned int)parse_value((__int64)v3, (__int64)v4) )
      return v3;
    goto LABEL_14;
  }
LABEL_22:
  if ( (unsigned int)parse_value((__int64)v3, (__int64)&v9) )
    return v3;
LABEL_14:
  cJSON_Delete(v3);
LABEL_15:
  v7 = v11;
  if ( (unsigned __int64)v11 >= v10 )
  {
    v7 = v10 - 1;
    if ( !v10 )
      v7 = 0LL;
  }
  global_error = (__int64)a1;
  v3 = 0LL;
  qword_112A8 = v7;
  return v3;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11270: using guessed type void *off_11270;
// 112A0: using guessed type __int64 global_error;
// 112A8: using guessed type __int64 qword_112A8;

//----- (0000000000009720) ----------------------------------------------------
_DWORD *__fastcall cJSON_ParseWithLength(__int128 a1)
{
  __int64 v1; // rbp
  _OWORD *v2; // rax
  _DWORD *v3; // rbx
  __int128 *v4; // r8
  __int64 v5; // rdx
  __int64 v6; // rax
  __int64 v8; // rax
  __int128 v9; // [rsp+0h] [rbp-58h] BYREF
  __int128 v10; // [rsp+10h] [rbp-48h]
  __m128i v11; // [rsp+20h] [rbp-38h]
  void *v12; // [rsp+30h] [rbp-28h]
  unsigned __int64 v13; // [rsp+38h] [rbp-20h]

  v1 = a1;
  v13 = __readfsqword(0x28u);
  v9 = 0LL;
  v10 = 0LL;
  v11 = 0LL;
  v12 = 0LL;
  global_error = 0LL;
  qword_112A8 = 0LL;
  if ( !(_QWORD)a1 || !*((_QWORD *)&a1 + 1) )
  {
    if ( (_QWORD)a1 )
    {
      global_error = a1;
      qword_112A8 = 0LL;
    }
    return 0LL;
  }
  v9 = a1;
  v11 = _mm_load_si128((const __m128i *)&global_hooks);
  v12 = off_11270;
  v2 = (_OWORD *)global_hooks(64LL);
  v3 = v2;
  if ( !v2 )
  {
LABEL_16:
    if ( (unsigned __int64)v10 >= *((_QWORD *)&v9 + 1) )
    {
      v8 = *((_QWORD *)&v9 + 1) - 1LL;
      global_error = v1;
      if ( !*((_QWORD *)&v9 + 1) )
        v8 = 0LL;
      qword_112A8 = v8;
    }
    else
    {
      global_error = v1;
      qword_112A8 = v10;
    }
    return 0LL;
  }
  *v2 = 0LL;
  v4 = (__int128 *)v9;
  v2[1] = 0LL;
  v2[2] = 0LL;
  v2[3] = 0LL;
  if ( v4 )
  {
    v5 = v10;
    if ( (_QWORD)v10 )
    {
      v4 = 0LL;
    }
    else
    {
      if ( *((_QWORD *)&v9 + 1) <= 4uLL )
      {
        if ( !*((_QWORD *)&v9 + 1) )
          goto LABEL_26;
      }
      else if ( !memcmp(v4, &unk_D5DA, 3uLL) )
      {
        *(_QWORD *)&v10 = 3LL;
        v5 = 3LL;
      }
      if ( *((_BYTE *)v4 + v5) > 0x20u )
      {
LABEL_26:
        if ( (unsigned int)parse_value((__int64)v3, (__int64)&v9) )
          return v3;
        goto LABEL_15;
      }
      while ( 1 )
      {
        v6 = v5 + 1;
        *(_QWORD *)&v10 = v5 + 1;
        if ( v5 + 1 == *((_QWORD *)&v9 + 1) )
          break;
        ++v5;
        if ( *((_BYTE *)v4 + v6) > 0x20u )
          goto LABEL_26;
      }
      *(_QWORD *)&v10 = v5;
      v4 = &v9;
    }
  }
  if ( !(unsigned int)parse_value((__int64)v3, (__int64)v4) )
  {
LABEL_15:
    cJSON_Delete(v3);
    goto LABEL_16;
  }
  return v3;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11270: using guessed type void *off_11270;
// 112A0: using guessed type __int64 global_error;
// 112A8: using guessed type __int64 qword_112A8;

//----- (0000000000009910) ----------------------------------------------------
void *__fastcall cJSON_Print(__int64 a1)
{
  return print_constprop_18(a1, 1);
}

//----- (0000000000009920) ----------------------------------------------------
void *__fastcall cJSON_PrintUnformatted(__int64 a1)
{
  return print_constprop_18(a1, 0);
}

//----- (0000000000009930) ----------------------------------------------------
__int64 __fastcall cJSON_PrintBuffered(__int64 a1, int a2, __int32 a3)
{
  __int64 result; // rax
  int v5; // edx
  __m128i v6; // [rsp+0h] [rbp-68h] BYREF
  __int128 v7; // [rsp+10h] [rbp-58h]
  __m256i v8; // [rsp+20h] [rbp-48h]
  unsigned __int64 v9; // [rsp+48h] [rbp-20h]

  v9 = __readfsqword(0x28u);
  v6 = 0LL;
  v7 = 0LL;
  *(_OWORD *)v8.m256i_i8 = 0LL;
  *(_OWORD *)&v8.m256i_u64[2] = 0LL;
  if ( a2 < 0 )
    goto LABEL_6;
  result = global_hooks(a2);
  v6.m128i_i64[0] = result;
  if ( !result )
    goto LABEL_6;
  v6.m128i_i64[1] = a2;
  *(_QWORD *)&v7 = 0LL;
  v8.m256i_i32[0] = 0;
  v8.m256i_i32[1] = a3;
  *(__m128i *)&v8.m256i_u64[1] = _mm_load_si128((const __m128i *)&global_hooks);
  v8.m256i_i64[3] = (__int64)off_11270;
  if ( !a1 || (v5 = print_value_part_8(a1, &v6), result = v6.m128i_i64[0], !v5) )
  {
    off_11268(result);
LABEL_6:
    result = 0LL;
  }
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11268: using guessed type __int64 (__fastcall *off_11268)(_QWORD);
// 11270: using guessed type __int64 (__fastcall *off_11270)(_QWORD, _QWORD);

//----- (0000000000009A10) ----------------------------------------------------
__int64 __fastcall cJSON_PrintPreallocated(__int64 a1, __int64 a2, int a3, __int32 a4)
{
  __int64 result; // rax
  __m128i v5[2]; // [rsp+0h] [rbp-58h] BYREF
  __m256i v6; // [rsp+20h] [rbp-38h]
  unsigned __int64 v7; // [rsp+48h] [rbp-10h]

  v7 = __readfsqword(0x28u);
  v5[0] = 0LL;
  v5[1] = 0LL;
  *(_OWORD *)v6.m256i_i8 = 0LL;
  *(_OWORD *)&v6.m256i_u64[2] = 0LL;
  if ( a3 >= 0
    && a2
    && (v5[0].m128i_i64[0] = a2,
        v5[0].m128i_i64[1] = a3,
        v6.m256i_i32[0] = 1,
        v6.m256i_i32[1] = a4,
        *(__m128i *)&v6.m256i_u64[1] = _mm_load_si128((const __m128i *)&global_hooks),
        v6.m256i_i64[3] = (__int64)off_11270,
        a1) )
  {
    result = print_value_part_8(a1, v5);
  }
  else
  {
    result = 0LL;
  }
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11270: using guessed type __int64 (__fastcall *off_11270)(_QWORD, _QWORD);

//----- (0000000000009AB0) ----------------------------------------------------
__int64 __fastcall cJSON_GetArraySize(__int64 a1)
{
  _QWORD *v1; // rdx
  __int64 result; // rax

  if ( !a1 )
    return 0LL;
  v1 = *(_QWORD **)(a1 + 16);
  if ( !v1 )
    return 0LL;
  result = 0LL;
  do
  {
    v1 = (_QWORD *)*v1;
    ++result;
  }
  while ( v1 );
  return result;
}

//----- (0000000000009AE0) ----------------------------------------------------
_QWORD *__fastcall cJSON_GetArrayItem(__int64 a1, __int64 a2)
{
  _QWORD *result; // rax

  if ( (int)a2 < 0 )
    return 0LL;
  a2 = (int)a2;
  if ( !a1 )
    return 0LL;
  result = *(_QWORD **)(a1 + 16);
  if ( (_DWORD)a2 && result )
  {
    do
    {
      result = (_QWORD *)*result;
      --a2;
    }
    while ( result && a2 );
  }
  return result;
}

//----- (0000000000009B20) ----------------------------------------------------
_QWORD *__fastcall cJSON_GetObjectItem(__int64 a1, const char *a2)
{
  return get_object_item(a1, a2, 0);
}

//----- (0000000000009B30) ----------------------------------------------------
_QWORD *__fastcall cJSON_GetObjectItemCaseSensitive(__int64 a1, const char *a2)
{
  _QWORD *v2; // rbx
  const char *v4; // rsi

  if ( !a1 || !a2 )
    return 0LL;
  v2 = *(_QWORD **)(a1 + 16);
  if ( !v2 )
    return v2;
  v4 = (const char *)v2[7];
  if ( v4 )
  {
    while ( strcmp(a2, v4) )
    {
      v2 = (_QWORD *)*v2;
      if ( !v2 )
        break;
      v4 = (const char *)v2[7];
      if ( !v4 )
        return 0LL;
    }
    return v2;
  }
  return 0LL;
}

//----- (0000000000009BA0) ----------------------------------------------------
_BOOL8 __fastcall cJSON_HasObjectItem(__int64 a1, const char *a2)
{
  return get_object_item(a1, a2, 0) != 0LL;
}

//----- (0000000000009BC0) ----------------------------------------------------
__int64 __fastcall cJSON_AddItemToArray(_QWORD *a1, _QWORD *a2)
{
  __int64 v2; // rdx
  _QWORD *v3; // rcx
  __int64 result; // rax

  if ( a1 == a2 || a1 == 0LL || !a2 )
    return 0LL;
  v2 = a1[2];
  if ( v2 )
  {
    v3 = *(_QWORD **)(v2 + 8);
    result = 1LL;
    if ( v3 )
    {
      *v3 = a2;
      a2[1] = v3;
      *(_QWORD *)(v2 + 8) = a2;
    }
  }
  else
  {
    a1[2] = a2;
    result = 1LL;
    a2[1] = a2;
    *a2 = 0LL;
  }
  return result;
}

//----- (0000000000009C20) ----------------------------------------------------
__int64 __fastcall cJSON_AddItemToObject(__int64 a1, const char *a2, __int64 a3)
{
  size_t v4; // r13
  void *v5; // rax
  void *v6; // r14
  int v7; // ebx
  __int64 v8; // rdx
  _QWORD *v9; // rcx
  __int64 result; // rax

  if ( !a1 || !a2 || !a3 || a1 == a3 )
    return 0LL;
  v4 = strlen(a2) + 1;
  v5 = (void *)global_hooks(v4);
  v6 = v5;
  if ( !v5 )
    return 0LL;
  memcpy(v5, a2, v4);
  v7 = *(_DWORD *)(a3 + 24);
  BYTE1(v7) &= 0xFDu;
  if ( (*(_DWORD *)(a3 + 24) & 0x200) == 0 && *(_QWORD *)(a3 + 56) )
    off_11268();
  v8 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a3 + 56) = v6;
  *(_DWORD *)(a3 + 24) = v7;
  if ( v8 )
  {
    v9 = *(_QWORD **)(v8 + 8);
    result = 1LL;
    if ( v9 )
    {
      *v9 = a3;
      *(_QWORD *)(a3 + 8) = v9;
      *(_QWORD *)(v8 + 8) = a3;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 16) = a3;
    result = 1LL;
    *(_QWORD *)(a3 + 8) = a3;
    *(_QWORD *)a3 = 0LL;
  }
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11268: using guessed type __int64 (*off_11268)(void);

//----- (0000000000009D10) ----------------------------------------------------
__int64 __fastcall cJSON_AddItemToObjectCS(__int64 a1, __int64 a2, __int64 a3)
{
  int v4; // er13
  __int64 v5; // rdx
  _QWORD *v6; // rcx
  __int64 result; // rax

  if ( !a1 || !a2 || !a3 || a1 == a3 )
    return 0LL;
  v4 = *(_DWORD *)(a3 + 24) | 0x200;
  if ( (*(_DWORD *)(a3 + 24) & 0x200) == 0 && *(_QWORD *)(a3 + 56) )
    off_11268();
  v5 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a3 + 56) = a2;
  *(_DWORD *)(a3 + 24) = v4;
  if ( v5 )
  {
    v6 = *(_QWORD **)(v5 + 8);
    result = 1LL;
    if ( v6 )
    {
      *v6 = a3;
      *(_QWORD *)(a3 + 8) = v6;
      *(_QWORD *)(v5 + 8) = a3;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 16) = a3;
    result = 1LL;
    *(_QWORD *)(a3 + 8) = a3;
    *(_QWORD *)a3 = 0LL;
  }
  return result;
}
// 11268: using guessed type __int64 (*off_11268)(void);

//----- (0000000000009DC0) ----------------------------------------------------
__int64 __fastcall cJSON_AddItemReferenceToArray(__int64 a1, const __m128i *a2)
{
  _OWORD *v2; // rax
  _OWORD *v3; // rdx
  __int64 v4; // rax
  __int64 v5; // rcx
  _QWORD *v6; // rsi
  __int64 result; // rax

  if ( !a1 || !a2 )
    return 0LL;
  v2 = (_OWORD *)global_hooks(64LL);
  v3 = v2;
  if ( !v2 )
    return 0LL;
  *v2 = 0LL;
  v2[1] = 0LL;
  v2[2] = 0LL;
  v2[3] = 0LL;
  *v2 = _mm_loadu_si128(a2);
  v2[1] = _mm_loadu_si128(a2 + 1);
  v2[2] = _mm_loadu_si128(a2 + 2);
  v4 = a2[3].m128i_i64[0];
  *((_QWORD *)v3 + 7) = 0LL;
  *((_QWORD *)v3 + 6) = v4;
  *((_DWORD *)v3 + 6) |= 0x100u;
  *v3 = 0LL;
  if ( (_OWORD *)a1 == v3 )
    return 0LL;
  v5 = *(_QWORD *)(a1 + 16);
  if ( v5 )
  {
    v6 = *(_QWORD **)(v5 + 8);
    result = 1LL;
    if ( v6 )
    {
      *v6 = v3;
      *((_QWORD *)v3 + 1) = v6;
      *(_QWORD *)(v5 + 8) = v3;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 16) = v3;
    result = 1LL;
    *((_QWORD *)v3 + 1) = v3;
    *(_QWORD *)v3 = 0LL;
  }
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);

//----- (0000000000009EB0) ----------------------------------------------------
__int64 __fastcall cJSON_AddItemReferenceToObject(__int64 a1, const char *a2, const __m128i *a3)
{
  _OWORD *v4; // rax
  _OWORD *v5; // rbx
  __int64 v6; // rax
  size_t v7; // rbp
  void *v8; // rax
  void *v9; // r14
  unsigned int v10; // ebp
  __int64 v11; // rdx
  _QWORD *v12; // rcx
  __int64 result; // rax

  if ( !a1 || !a2 || !a3 )
    return 0LL;
  v4 = (_OWORD *)global_hooks(64LL);
  v5 = v4;
  if ( !v4 )
    return 0LL;
  *v4 = 0LL;
  v4[1] = 0LL;
  v4[2] = 0LL;
  v4[3] = 0LL;
  *v4 = _mm_loadu_si128(a3);
  v4[1] = _mm_loadu_si128(a3 + 1);
  v4[2] = _mm_loadu_si128(a3 + 2);
  v6 = a3[3].m128i_i64[0];
  *((_QWORD *)v5 + 7) = 0LL;
  *((_QWORD *)v5 + 6) = v6;
  *((_DWORD *)v5 + 6) |= 0x100u;
  *v5 = 0LL;
  if ( (_OWORD *)a1 == v5 )
    return 0LL;
  v7 = strlen(a2) + 1;
  v8 = (void *)global_hooks(v7);
  v9 = v8;
  if ( !v8 )
    return 0LL;
  memcpy(v8, a2, v7);
  v10 = *((_DWORD *)v5 + 6) & 0xFFFFFDFF;
  if ( (*((_DWORD *)v5 + 6) & 0x200) == 0 && *((_QWORD *)v5 + 7) )
    off_11268();
  v11 = *(_QWORD *)(a1 + 16);
  *((_QWORD *)v5 + 7) = v9;
  *((_DWORD *)v5 + 6) = v10;
  if ( v11 )
  {
    v12 = *(_QWORD **)(v11 + 8);
    result = 1LL;
    if ( v12 )
    {
      *v12 = v5;
      *((_QWORD *)v5 + 1) = v12;
      *(_QWORD *)(v11 + 8) = v5;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 16) = v5;
    result = 1LL;
    *((_QWORD *)v5 + 1) = v5;
    *(_QWORD *)v5 = 0LL;
  }
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11268: using guessed type __int64 (*off_11268)(void);

//----- (0000000000009FF0) ----------------------------------------------------
__int64 __fastcall cJSON_AddNullToObject(__int64 a1, const char *a2)
{
  __int64 v3; // rax
  __int64 v4; // rbx
  size_t v5; // r13
  void *v6; // rax
  void *v7; // r14
  unsigned int v8; // er12
  __int64 v9; // rdi
  __int64 v10; // rax
  __int64 *v11; // rdx
  __int64 result; // rax
  _DWORD *v13; // rdi

  v3 = global_hooks(64LL);
  v4 = v3;
  if ( !v3 )
    goto LABEL_12;
  *(_OWORD *)(v3 + 16) = 0LL;
  *(_OWORD *)v3 = 0LL;
  *(_OWORD *)(v3 + 32) = 0LL;
  *(_OWORD *)(v3 + 48) = 0LL;
  *(_DWORD *)(v3 + 24) = 4;
  if ( !a1 || !a2 || a1 == v3 || (v5 = strlen(a2) + 1, v6 = (void *)global_hooks(v5), (v7 = v6) == 0LL) )
  {
LABEL_12:
    v13 = (_DWORD *)v4;
    v4 = 0LL;
    cJSON_Delete(v13);
    return v4;
  }
  memcpy(v6, a2, v5);
  v8 = *(_DWORD *)(v4 + 24) & 0xFFFFFDFF;
  if ( (*(_DWORD *)(v4 + 24) & 0x200) == 0 )
  {
    v9 = *(_QWORD *)(v4 + 56);
    if ( v9 )
      off_11268(v9);
  }
  v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(v4 + 56) = v7;
  *(_DWORD *)(v4 + 24) = v8;
  if ( v10 )
  {
    v11 = *(__int64 **)(v10 + 8);
    if ( v11 )
    {
      *v11 = v4;
      *(_QWORD *)(v4 + 8) = v11;
      *(_QWORD *)(v10 + 8) = v4;
      return v4;
    }
    return v4;
  }
  *(_QWORD *)(a1 + 16) = v4;
  result = v4;
  *(_QWORD *)(v4 + 8) = v4;
  *(_QWORD *)v4 = 0LL;
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11268: using guessed type __int64 (__fastcall *off_11268)(_QWORD);

//----- (000000000000A110) ----------------------------------------------------
__int64 __fastcall cJSON_AddTrueToObject(__int64 a1, const char *a2)
{
  __int64 v3; // rax
  __int64 v4; // rbx
  size_t v5; // r13
  void *v6; // rax
  void *v7; // r14
  unsigned int v8; // er12
  __int64 v9; // rdi
  __int64 v10; // rax
  __int64 *v11; // rdx
  __int64 result; // rax
  _DWORD *v13; // rdi

  v3 = global_hooks(64LL);
  v4 = v3;
  if ( !v3 )
    goto LABEL_12;
  *(_OWORD *)(v3 + 16) = 0LL;
  *(_OWORD *)v3 = 0LL;
  *(_OWORD *)(v3 + 32) = 0LL;
  *(_OWORD *)(v3 + 48) = 0LL;
  *(_DWORD *)(v3 + 24) = 2;
  if ( !a1 || !a2 || a1 == v3 || (v5 = strlen(a2) + 1, v6 = (void *)global_hooks(v5), (v7 = v6) == 0LL) )
  {
LABEL_12:
    v13 = (_DWORD *)v4;
    v4 = 0LL;
    cJSON_Delete(v13);
    return v4;
  }
  memcpy(v6, a2, v5);
  v8 = *(_DWORD *)(v4 + 24) & 0xFFFFFDFF;
  if ( (*(_DWORD *)(v4 + 24) & 0x200) == 0 )
  {
    v9 = *(_QWORD *)(v4 + 56);
    if ( v9 )
      off_11268(v9);
  }
  v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(v4 + 56) = v7;
  *(_DWORD *)(v4 + 24) = v8;
  if ( v10 )
  {
    v11 = *(__int64 **)(v10 + 8);
    if ( v11 )
    {
      *v11 = v4;
      *(_QWORD *)(v4 + 8) = v11;
      *(_QWORD *)(v10 + 8) = v4;
      return v4;
    }
    return v4;
  }
  *(_QWORD *)(a1 + 16) = v4;
  result = v4;
  *(_QWORD *)(v4 + 8) = v4;
  *(_QWORD *)v4 = 0LL;
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11268: using guessed type __int64 (__fastcall *off_11268)(_QWORD);

//----- (000000000000A230) ----------------------------------------------------
__int64 __fastcall cJSON_AddFalseToObject(__int64 a1, const char *a2)
{
  __int64 v3; // rax
  __int64 v4; // rbx
  size_t v5; // r13
  void *v6; // rax
  void *v7; // r14
  unsigned int v8; // er12
  __int64 v9; // rdi
  __int64 v10; // rax
  __int64 *v11; // rdx
  __int64 result; // rax
  _DWORD *v13; // rdi

  v3 = global_hooks(64LL);
  v4 = v3;
  if ( !v3 )
    goto LABEL_12;
  *(_OWORD *)(v3 + 16) = 0LL;
  *(_OWORD *)v3 = 0LL;
  *(_OWORD *)(v3 + 32) = 0LL;
  *(_OWORD *)(v3 + 48) = 0LL;
  *(_DWORD *)(v3 + 24) = 1;
  if ( !a1 || !a2 || a1 == v3 || (v5 = strlen(a2) + 1, v6 = (void *)global_hooks(v5), (v7 = v6) == 0LL) )
  {
LABEL_12:
    v13 = (_DWORD *)v4;
    v4 = 0LL;
    cJSON_Delete(v13);
    return v4;
  }
  memcpy(v6, a2, v5);
  v8 = *(_DWORD *)(v4 + 24) & 0xFFFFFDFF;
  if ( (*(_DWORD *)(v4 + 24) & 0x200) == 0 )
  {
    v9 = *(_QWORD *)(v4 + 56);
    if ( v9 )
      off_11268(v9);
  }
  v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(v4 + 56) = v7;
  *(_DWORD *)(v4 + 24) = v8;
  if ( v10 )
  {
    v11 = *(__int64 **)(v10 + 8);
    if ( v11 )
    {
      *v11 = v4;
      *(_QWORD *)(v4 + 8) = v11;
      *(_QWORD *)(v10 + 8) = v4;
      return v4;
    }
    return v4;
  }
  *(_QWORD *)(a1 + 16) = v4;
  result = v4;
  *(_QWORD *)(v4 + 8) = v4;
  *(_QWORD *)v4 = 0LL;
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11268: using guessed type __int64 (__fastcall *off_11268)(_QWORD);

//----- (000000000000A350) ----------------------------------------------------
__int64 __fastcall cJSON_AddBoolToObject(__int64 a1, const char *a2, int a3)
{
  __int64 v5; // rax
  __int64 v6; // rbx
  size_t v7; // r13
  void *v8; // rax
  void *v9; // r14
  unsigned int v10; // er12
  __int64 v11; // rdi
  __int64 v12; // rax
  __int64 *v13; // rdx
  __int64 result; // rax
  _DWORD *v15; // rdi

  v5 = global_hooks(64LL);
  v6 = v5;
  if ( !v5 )
    goto LABEL_12;
  *(_OWORD *)v5 = 0LL;
  *(_OWORD *)(v5 + 16) = 0LL;
  *(_OWORD *)(v5 + 32) = 0LL;
  *(_OWORD *)(v5 + 48) = 0LL;
  *(_DWORD *)(v5 + 24) = (a3 != 0) + 1;
  if ( !a1 || !a2 || a1 == v5 || (v7 = strlen(a2) + 1, v8 = (void *)global_hooks(v7), (v9 = v8) == 0LL) )
  {
LABEL_12:
    v15 = (_DWORD *)v6;
    v6 = 0LL;
    cJSON_Delete(v15);
    return v6;
  }
  memcpy(v8, a2, v7);
  v10 = *(_DWORD *)(v6 + 24) & 0xFFFFFDFF;
  if ( (*(_DWORD *)(v6 + 24) & 0x200) == 0 )
  {
    v11 = *(_QWORD *)(v6 + 56);
    if ( v11 )
      off_11268(v11);
  }
  v12 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(v6 + 56) = v9;
  *(_DWORD *)(v6 + 24) = v10;
  if ( v12 )
  {
    v13 = *(__int64 **)(v12 + 8);
    if ( v13 )
    {
      *v13 = v6;
      *(_QWORD *)(v6 + 8) = v13;
      *(_QWORD *)(v12 + 8) = v6;
      return v6;
    }
    return v6;
  }
  *(_QWORD *)(a1 + 16) = v6;
  result = v6;
  *(_QWORD *)(v6 + 8) = v6;
  *(_QWORD *)v6 = 0LL;
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11268: using guessed type __int64 (__fastcall *off_11268)(_QWORD);

//----- (000000000000A470) ----------------------------------------------------
__int64 __fastcall cJSON_AddNumberToObject(__int64 a1, const char *a2, double a3)
{
  __int64 v4; // rax
  __int64 v5; // rbx
  size_t v6; // r13
  void *v7; // rax
  void *v8; // r14
  unsigned int v9; // er12
  __int64 v10; // rdi
  __int64 v11; // rax
  __int64 *v12; // rdx
  __int64 result; // rax
  _DWORD *v14; // rdi

  v4 = global_hooks(64LL);
  v5 = v4;
  if ( !v4 )
    goto LABEL_14;
  *(_OWORD *)(v4 + 16) = 0LL;
  *(_OWORD *)(v4 + 48) = 0LL;
  *(_OWORD *)v4 = 0LL;
  *(_OWORD *)(v4 + 32) = 0LL;
  *(_DWORD *)(v4 + 24) = 8;
  *(double *)(v4 + 48) = a3;
  if ( a3 < 2147483647.0 )
    *(_DWORD *)(v4 + 40) = a3 > -2147483648.0 ? (int)a3 : 0x80000000;
  else
    *(_DWORD *)(v4 + 40) = 0x7FFFFFFF;
  if ( !a1 || !a2 || a1 == v4 || (v6 = strlen(a2) + 1, v7 = (void *)global_hooks(v6), (v8 = v7) == 0LL) )
  {
LABEL_14:
    v14 = (_DWORD *)v5;
    v5 = 0LL;
    cJSON_Delete(v14);
    return v5;
  }
  memcpy(v7, a2, v6);
  v9 = *(_DWORD *)(v5 + 24) & 0xFFFFFDFF;
  if ( (*(_DWORD *)(v5 + 24) & 0x200) == 0 )
  {
    v10 = *(_QWORD *)(v5 + 56);
    if ( v10 )
      off_11268(v10);
  }
  v11 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(v5 + 56) = v8;
  *(_DWORD *)(v5 + 24) = v9;
  if ( v11 )
  {
    v12 = *(__int64 **)(v11 + 8);
    if ( v12 )
    {
      *v12 = v5;
      *(_QWORD *)(v5 + 8) = v12;
      *(_QWORD *)(v11 + 8) = v5;
      return v5;
    }
    return v5;
  }
  *(_QWORD *)(a1 + 16) = v5;
  result = v5;
  *(_QWORD *)(v5 + 8) = v5;
  *(_QWORD *)v5 = 0LL;
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11268: using guessed type __int64 (__fastcall *off_11268)(_QWORD);

//----- (000000000000A5F0) ----------------------------------------------------
__int64 __fastcall cJSON_AddStringToObject(__int64 a1, const char *a2, const char *a3)
{
  __int64 v5; // rax
  __int64 v6; // rbx
  size_t v7; // r12
  void *v8; // rax
  size_t v9; // rbp
  void *v10; // rax
  void *v11; // r12
  unsigned int v12; // ebp
  __int64 v13; // rdi
  __int64 v14; // rax
  __int64 *v15; // rdx
  __int64 result; // rax

  v5 = global_hooks(64LL);
  if ( !v5 )
    goto LABEL_16;
  v6 = v5;
  *(_OWORD *)(v5 + 16) = 0LL;
  *(_OWORD *)v5 = 0LL;
  *(_OWORD *)(v5 + 32) = 0LL;
  *(_OWORD *)(v5 + 48) = 0LL;
  *(_DWORD *)(v5 + 24) = 16;
  if ( !a3 || (v7 = strlen(a3) + 1, (v8 = (void *)global_hooks(v7)) == 0LL) )
  {
    *(_QWORD *)(v6 + 32) = 0LL;
    cJSON_Delete((_DWORD *)v6);
LABEL_16:
    v6 = 0LL;
LABEL_17:
    cJSON_Delete((_DWORD *)v6);
    return 0LL;
  }
  *(_QWORD *)(v6 + 32) = memcpy(v8, a3, v7);
  if ( !a1 )
    goto LABEL_17;
  if ( !a2 )
    goto LABEL_17;
  if ( a1 == v6 )
    goto LABEL_17;
  v9 = strlen(a2) + 1;
  v10 = (void *)global_hooks(v9);
  v11 = v10;
  if ( !v10 )
    goto LABEL_17;
  memcpy(v10, a2, v9);
  v12 = *(_DWORD *)(v6 + 24) & 0xFFFFFDFF;
  if ( (*(_DWORD *)(v6 + 24) & 0x200) == 0 )
  {
    v13 = *(_QWORD *)(v6 + 56);
    if ( v13 )
      off_11268(v13);
  }
  v14 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(v6 + 56) = v11;
  *(_DWORD *)(v6 + 24) = v12;
  if ( v14 )
  {
    v15 = *(__int64 **)(v14 + 8);
    if ( v15 )
    {
      *v15 = v6;
      *(_QWORD *)(v6 + 8) = v15;
      *(_QWORD *)(v14 + 8) = v6;
    }
    result = v6;
  }
  else
  {
    *(_QWORD *)(a1 + 16) = v6;
    result = v6;
    *(_QWORD *)(v6 + 8) = v6;
    *(_QWORD *)v6 = 0LL;
  }
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11268: using guessed type __int64 (__fastcall *off_11268)(_QWORD);

//----- (000000000000A750) ----------------------------------------------------
__int64 __fastcall cJSON_AddRawToObject(__int64 a1, const char *a2, const char *a3)
{
  __int64 v5; // rax
  __int64 v6; // rbx
  size_t v7; // r12
  void *v8; // rax
  size_t v9; // rbp
  void *v10; // rax
  void *v11; // r12
  unsigned int v12; // ebp
  __int64 v13; // rdi
  __int64 v14; // rax
  __int64 *v15; // rdx
  __int64 result; // rax

  v5 = global_hooks(64LL);
  if ( !v5 )
    goto LABEL_16;
  v6 = v5;
  *(_OWORD *)(v5 + 16) = 0LL;
  *(_OWORD *)v5 = 0LL;
  *(_OWORD *)(v5 + 32) = 0LL;
  *(_OWORD *)(v5 + 48) = 0LL;
  *(_DWORD *)(v5 + 24) = 128;
  if ( !a3 || (v7 = strlen(a3) + 1, (v8 = (void *)global_hooks(v7)) == 0LL) )
  {
    *(_QWORD *)(v6 + 32) = 0LL;
    cJSON_Delete((_DWORD *)v6);
LABEL_16:
    v6 = 0LL;
LABEL_17:
    cJSON_Delete((_DWORD *)v6);
    return 0LL;
  }
  *(_QWORD *)(v6 + 32) = memcpy(v8, a3, v7);
  if ( !a1 )
    goto LABEL_17;
  if ( !a2 )
    goto LABEL_17;
  if ( a1 == v6 )
    goto LABEL_17;
  v9 = strlen(a2) + 1;
  v10 = (void *)global_hooks(v9);
  v11 = v10;
  if ( !v10 )
    goto LABEL_17;
  memcpy(v10, a2, v9);
  v12 = *(_DWORD *)(v6 + 24) & 0xFFFFFDFF;
  if ( (*(_DWORD *)(v6 + 24) & 0x200) == 0 )
  {
    v13 = *(_QWORD *)(v6 + 56);
    if ( v13 )
      off_11268(v13);
  }
  v14 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(v6 + 56) = v11;
  *(_DWORD *)(v6 + 24) = v12;
  if ( v14 )
  {
    v15 = *(__int64 **)(v14 + 8);
    if ( v15 )
    {
      *v15 = v6;
      *(_QWORD *)(v6 + 8) = v15;
      *(_QWORD *)(v14 + 8) = v6;
    }
    result = v6;
  }
  else
  {
    *(_QWORD *)(a1 + 16) = v6;
    result = v6;
    *(_QWORD *)(v6 + 8) = v6;
    *(_QWORD *)v6 = 0LL;
  }
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11268: using guessed type __int64 (__fastcall *off_11268)(_QWORD);

//----- (000000000000A8B0) ----------------------------------------------------
__int64 __fastcall cJSON_AddObjectToObject(__int64 a1, const char *a2)
{
  __int64 v3; // rax
  __int64 v4; // rbx
  size_t v5; // r13
  void *v6; // rax
  void *v7; // r14
  unsigned int v8; // er12
  __int64 v9; // rdi
  __int64 v10; // rax
  __int64 *v11; // rdx
  __int64 result; // rax
  _DWORD *v13; // rdi

  v3 = global_hooks(64LL);
  v4 = v3;
  if ( !v3 )
    goto LABEL_12;
  *(_OWORD *)(v3 + 16) = 0LL;
  *(_OWORD *)v3 = 0LL;
  *(_OWORD *)(v3 + 32) = 0LL;
  *(_OWORD *)(v3 + 48) = 0LL;
  *(_DWORD *)(v3 + 24) = 64;
  if ( !a1 || !a2 || a1 == v3 || (v5 = strlen(a2) + 1, v6 = (void *)global_hooks(v5), (v7 = v6) == 0LL) )
  {
LABEL_12:
    v13 = (_DWORD *)v4;
    v4 = 0LL;
    cJSON_Delete(v13);
    return v4;
  }
  memcpy(v6, a2, v5);
  v8 = *(_DWORD *)(v4 + 24) & 0xFFFFFDFF;
  if ( (*(_DWORD *)(v4 + 24) & 0x200) == 0 )
  {
    v9 = *(_QWORD *)(v4 + 56);
    if ( v9 )
      off_11268(v9);
  }
  v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(v4 + 56) = v7;
  *(_DWORD *)(v4 + 24) = v8;
  if ( v10 )
  {
    v11 = *(__int64 **)(v10 + 8);
    if ( v11 )
    {
      *v11 = v4;
      *(_QWORD *)(v4 + 8) = v11;
      *(_QWORD *)(v10 + 8) = v4;
      return v4;
    }
    return v4;
  }
  *(_QWORD *)(a1 + 16) = v4;
  result = v4;
  *(_QWORD *)(v4 + 8) = v4;
  *(_QWORD *)v4 = 0LL;
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11268: using guessed type __int64 (__fastcall *off_11268)(_QWORD);

//----- (000000000000A9D0) ----------------------------------------------------
__int64 __fastcall cJSON_AddArrayToObject(__int64 a1, const char *a2)
{
  __int64 v3; // rax
  __int64 v4; // rbx
  size_t v5; // r13
  void *v6; // rax
  void *v7; // r14
  unsigned int v8; // er12
  __int64 v9; // rdi
  __int64 v10; // rax
  __int64 *v11; // rdx
  __int64 result; // rax
  _DWORD *v13; // rdi

  v3 = global_hooks(64LL);
  v4 = v3;
  if ( !v3 )
    goto LABEL_12;
  *(_OWORD *)(v3 + 16) = 0LL;
  *(_OWORD *)v3 = 0LL;
  *(_OWORD *)(v3 + 32) = 0LL;
  *(_OWORD *)(v3 + 48) = 0LL;
  *(_DWORD *)(v3 + 24) = 32;
  if ( !a1 || !a2 || a1 == v3 || (v5 = strlen(a2) + 1, v6 = (void *)global_hooks(v5), (v7 = v6) == 0LL) )
  {
LABEL_12:
    v13 = (_DWORD *)v4;
    v4 = 0LL;
    cJSON_Delete(v13);
    return v4;
  }
  memcpy(v6, a2, v5);
  v8 = *(_DWORD *)(v4 + 24) & 0xFFFFFDFF;
  if ( (*(_DWORD *)(v4 + 24) & 0x200) == 0 )
  {
    v9 = *(_QWORD *)(v4 + 56);
    if ( v9 )
      off_11268(v9);
  }
  v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(v4 + 56) = v7;
  *(_DWORD *)(v4 + 24) = v8;
  if ( v10 )
  {
    v11 = *(__int64 **)(v10 + 8);
    if ( v11 )
    {
      *v11 = v4;
      *(_QWORD *)(v4 + 8) = v11;
      *(_QWORD *)(v10 + 8) = v4;
      return v4;
    }
    return v4;
  }
  *(_QWORD *)(a1 + 16) = v4;
  result = v4;
  *(_QWORD *)(v4 + 8) = v4;
  *(_QWORD *)v4 = 0LL;
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11268: using guessed type __int64 (__fastcall *off_11268)(_QWORD);

//----- (000000000000AAF0) ----------------------------------------------------
_QWORD *__fastcall cJSON_DetachItemViaPointer(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rdx
  __int64 v3; // rax
  _QWORD *v4; // rcx
  _QWORD *result; // rax

  if ( !a1 || !a2 )
    return 0LL;
  v2 = *(_QWORD **)(a1 + 16);
  v3 = *a2;
  if ( v2 == a2 )
  {
    if ( v3 )
      *(_QWORD *)(v3 + 8) = a2[1];
    *(_QWORD *)(a1 + 16) = v3;
    result = a2;
    *(_OWORD *)a2 = 0LL;
  }
  else
  {
    v4 = (_QWORD *)a2[1];
    *v4 = v3;
    if ( *a2 )
      *(_QWORD *)(*a2 + 8LL) = v4;
    else
      v2[1] = v4;
    result = a2;
    *(_OWORD *)a2 = 0LL;
  }
  return result;
}

//----- (000000000000AB70) ----------------------------------------------------
_QWORD *__fastcall cJSON_DetachItemFromArray(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rdx
  _QWORD *result; // rax
  _QWORD *v4; // rcx
  _QWORD *v5; // rsi

  if ( (int)a2 < 0 )
    return 0LL;
  a2 = (int)a2;
  if ( !a1 )
    return 0LL;
  v2 = *(_QWORD **)(a1 + 16);
  if ( !v2 || !(_DWORD)a2 )
  {
    if ( v2 )
    {
      v4 = (_QWORD *)*v2;
      result = *(_QWORD **)(a1 + 16);
      goto LABEL_16;
    }
    return 0LL;
  }
  result = *(_QWORD **)(a1 + 16);
  do
  {
    result = (_QWORD *)*result;
    --a2;
  }
  while ( result && a2 );
  if ( !result )
    return result;
  v4 = (_QWORD *)*result;
  if ( v2 != result )
  {
    v5 = (_QWORD *)result[1];
    *v5 = v4;
    if ( *result )
      *(_QWORD *)(*result + 8LL) = v5;
    else
      v2[1] = v5;
    *(_OWORD *)result = 0LL;
    return result;
  }
LABEL_16:
  if ( v4 )
    v4[1] = result[1];
  *(_QWORD *)(a1 + 16) = v4;
  *(_OWORD *)result = 0LL;
  return result;
}

//----- (000000000000AC20) ----------------------------------------------------
void __fastcall cJSON_DeleteItemFromArray(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rdx
  _QWORD *v3; // rax
  _QWORD *v4; // rcx
  _QWORD *v5; // rsi

  if ( (int)a2 >= 0 )
  {
    a2 = (int)a2;
    if ( a1 )
    {
      v2 = *(_QWORD **)(a1 + 16);
      if ( v2 && (_DWORD)a2 )
      {
        v3 = *(_QWORD **)(a1 + 16);
        do
        {
          v3 = (_QWORD *)*v3;
          --a2;
        }
        while ( v3 && a2 );
        if ( !v3 )
          goto LABEL_13;
        v4 = (_QWORD *)*v3;
        if ( v2 != v3 )
        {
          v5 = (_QWORD *)v3[1];
          *v5 = v4;
          if ( *v3 )
            *(_QWORD *)(*v3 + 8LL) = v5;
          else
            v2[1] = v5;
LABEL_12:
          *(_OWORD *)v3 = 0LL;
LABEL_13:
          cJSON_Delete(v3);
          return;
        }
LABEL_16:
        if ( v4 )
          v4[1] = v3[1];
        *(_QWORD *)(a1 + 16) = v4;
        goto LABEL_12;
      }
      if ( v2 )
      {
        v4 = (_QWORD *)*v2;
        v3 = *(_QWORD **)(a1 + 16);
        goto LABEL_16;
      }
    }
  }
  cJSON_Delete(0LL);
}

//----- (000000000000ACC0) ----------------------------------------------------
_QWORD *__fastcall cJSON_DetachItemFromObject(__int64 a1, const char *a2)
{
  _QWORD *result; // rax
  _QWORD *v3; // rcx
  __int64 v4; // rdx
  _QWORD *v5; // rsi

  result = get_object_item(a1, a2, 0);
  if ( !a1 || !result )
    return 0LL;
  v3 = *(_QWORD **)(a1 + 16);
  v4 = *result;
  if ( result == v3 )
  {
    if ( v4 )
      *(_QWORD *)(v4 + 8) = result[1];
    *(_QWORD *)(a1 + 16) = v4;
  }
  else
  {
    v5 = (_QWORD *)result[1];
    *v5 = v4;
    if ( *result )
      *(_QWORD *)(*result + 8LL) = v5;
    else
      v3[1] = v5;
  }
  *(_OWORD *)result = 0LL;
  return result;
}

//----- (000000000000AD30) ----------------------------------------------------
_QWORD *__fastcall cJSON_DetachItemFromObjectCaseSensitive(__int64 a1, const char *a2)
{
  __int64 v2; // rbp
  const char *v4; // rsi
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _QWORD *v7; // rdx

  if ( !a1 )
    return 0LL;
  if ( !a2 )
    return 0LL;
  v2 = *(_QWORD *)(a1 + 16);
  if ( !v2 )
    return 0LL;
  v4 = *(const char **)(v2 + 56);
  v5 = *(_QWORD **)(a1 + 16);
  if ( !v4 )
    return 0LL;
  while ( strcmp(a2, v4) )
  {
    v5 = (_QWORD *)*v5;
    if ( !v5 )
      return v5;
    v4 = (const char *)v5[7];
    if ( !v4 )
      return 0LL;
  }
  v6 = (_QWORD *)*v5;
  if ( (_QWORD *)v2 == v5 )
  {
    if ( v6 )
      v6[1] = v5[1];
    *(_QWORD *)(a1 + 16) = v6;
  }
  else
  {
    v7 = (_QWORD *)v5[1];
    *v7 = v6;
    if ( *v5 )
      *(_QWORD *)(*v5 + 8LL) = v7;
    else
      *(_QWORD *)(v2 + 8) = v7;
  }
  *(_OWORD *)v5 = 0LL;
  return v5;
}

//----- (000000000000ADF0) ----------------------------------------------------
void __fastcall cJSON_DeleteItemFromObject(__int64 a1, const char *a2)
{
  _QWORD *v2; // rax
  _QWORD *v3; // rcx
  __int64 v4; // rdx
  _QWORD *v5; // rsi

  v2 = get_object_item(a1, a2, 0);
  if ( a1 && v2 )
  {
    v3 = *(_QWORD **)(a1 + 16);
    v4 = *v2;
    if ( v2 == v3 )
    {
      if ( v4 )
        *(_QWORD *)(v4 + 8) = v2[1];
      *(_QWORD *)(a1 + 16) = v4;
    }
    else
    {
      v5 = (_QWORD *)v2[1];
      *v5 = v4;
      if ( *v2 )
        *(_QWORD *)(*v2 + 8LL) = v5;
      else
        v3[1] = v5;
    }
    *(_OWORD *)v2 = 0LL;
    cJSON_Delete(v2);
  }
  else
  {
    cJSON_Delete(0LL);
  }
}

//----- (000000000000AE70) ----------------------------------------------------
void __fastcall cJSON_DeleteItemFromObjectCaseSensitive(__int64 a1, const char *a2)
{
  __int64 v2; // rbp
  const char *v4; // rsi
  _QWORD *v5; // rbx
  _QWORD *v6; // rax
  _QWORD *v7; // rdx

  if ( a1 && a2 && (v2 = *(_QWORD *)(a1 + 16)) != 0 && (v4 = *(const char **)(v2 + 56), v5 = *(_QWORD **)(a1 + 16), v4) )
  {
    while ( strcmp(a2, v4) )
    {
      v5 = (_QWORD *)*v5;
      if ( !v5 )
        goto LABEL_13;
      v4 = (const char *)v5[7];
      if ( !v4 )
        goto LABEL_14;
    }
    v6 = (_QWORD *)*v5;
    if ( (_QWORD *)v2 == v5 )
    {
      if ( v6 )
        v6[1] = v5[1];
      *(_QWORD *)(a1 + 16) = v6;
    }
    else
    {
      v7 = (_QWORD *)v5[1];
      *v7 = v6;
      if ( *v5 )
        *(_QWORD *)(*v5 + 8LL) = v7;
      else
        *(_QWORD *)(v2 + 8) = v7;
    }
    *(_OWORD *)v5 = 0LL;
LABEL_13:
    cJSON_Delete(v5);
  }
  else
  {
LABEL_14:
    cJSON_Delete(0LL);
  }
}

//----- (000000000000AF30) ----------------------------------------------------
__int64 __fastcall cJSON_InsertItemInArray(_QWORD *a1, __int64 a2, _QWORD *a3)
{
  __int64 result; // rax
  _QWORD *v4; // rcx
  _QWORD *v5; // rax
  __int64 v6; // rsi
  _QWORD *v7; // rsi
  __int64 v8; // rax

  result = 0LL;
  if ( (int)a2 >= 0 )
  {
    a2 = (int)a2;
    if ( a1 )
    {
      v4 = (_QWORD *)a1[2];
      if ( v4 && (_DWORD)a2 )
      {
        v5 = (_QWORD *)a1[2];
        do
        {
          v5 = (_QWORD *)*v5;
          --a2;
        }
        while ( v5 && a2 );
        if ( v5 )
        {
          v6 = v5[1];
          *a3 = v5;
          a3[1] = v6;
          v5[1] = a3;
          if ( v4 != v5 )
          {
            *(_QWORD *)a3[1] = a3;
            return 1LL;
          }
          goto LABEL_17;
        }
        if ( a1 != a3 && a3 )
        {
          v7 = (_QWORD *)v4[1];
          result = 1LL;
          if ( v7 )
          {
            *v7 = a3;
            a3[1] = v7;
            v4[1] = a3;
          }
          return result;
        }
      }
      else
      {
        if ( v4 )
        {
          v8 = v4[1];
          *a3 = v4;
          a3[1] = v8;
          v4[1] = a3;
LABEL_17:
          a1[2] = a3;
          return 1LL;
        }
        if ( a1 != a3 && a3 )
        {
          a1[2] = a3;
          result = 1LL;
          a3[1] = a3;
          *a3 = 0LL;
          return result;
        }
      }
      return 0LL;
    }
  }
  return result;
}

//----- (000000000000B000) ----------------------------------------------------
__int64 __fastcall cJSON_ReplaceItemViaPointer(__int64 a1, __m128i *a2, __m128i *a3)
{
  __int64 v3; // rax
  __m128i *v4; // rcx
  __m128i **v5; // rdi

  if ( a2 == 0LL || a3 == 0LL || !a1 )
    return 0LL;
  if ( a3 == a2 )
    return 1LL;
  v3 = a2->m128i_i64[0];
  *a3 = _mm_loadu_si128(a2);
  if ( v3 )
    *(_QWORD *)(v3 + 8) = a3;
  v4 = *(__m128i **)(a1 + 16);
  if ( a2 == v4 )
  {
    if ( a2 == (__m128i *)a2->m128i_i64[1] )
      a3->m128i_i64[1] = (__int64)a3;
    *(_QWORD *)(a1 + 16) = a3;
  }
  else
  {
    v5 = (__m128i **)a3->m128i_i64[1];
    if ( v5 )
    {
      *v5 = a3;
      v3 = a3->m128i_i64[0];
    }
    if ( !v3 )
      v4->m128i_i64[1] = (__int64)a3;
  }
  *a2 = 0LL;
  cJSON_Delete(a2);
  return 1LL;
}

//----- (000000000000B0B0) ----------------------------------------------------
__int64 __fastcall cJSON_ReplaceItemInArray(__int64 a1, __int64 a2, __m128i *a3)
{
  __int64 result; // rax
  __m128i *v4; // rcx
  __m128i *i; // rax
  __int64 v6; // rsi
  __m128i **v7; // rdi

  result = 0LL;
  if ( (int)a2 >= 0 )
  {
    a2 = (int)a2;
    if ( a1 )
    {
      v4 = *(__m128i **)(a1 + 16);
      for ( i = v4; i; --a2 )
      {
        if ( !a2 )
          break;
        i = (__m128i *)i->m128i_i64[0];
      }
      if ( i && a3 )
      {
        if ( a3 == i )
        {
          result = 1LL;
        }
        else
        {
          v6 = i->m128i_i64[0];
          *a3 = _mm_loadu_si128(i);
          if ( v6 )
            *(_QWORD *)(v6 + 8) = a3;
          if ( v4 == i )
          {
            if ( (__m128i *)i->m128i_i64[1] == i )
              a3->m128i_i64[1] = (__int64)a3;
            *(_QWORD *)(a1 + 16) = a3;
          }
          else
          {
            v7 = (__m128i **)a3->m128i_i64[1];
            if ( v7 )
            {
              *v7 = a3;
              v6 = a3->m128i_i64[0];
            }
            if ( !v6 )
              v4->m128i_i64[1] = (__int64)a3;
          }
          *i = 0LL;
          cJSON_Delete(i);
          result = 1LL;
        }
      }
      else
      {
        result = 0LL;
      }
    }
  }
  return result;
}

//----- (000000000000B190) ----------------------------------------------------
__int64 __fastcall cJSON_ReplaceItemInObject(__int64 a1, const char *a2, __m128i *a3)
{
  size_t v5; // rbp
  void *v6; // rax
  void *v7; // rcx
  __m128i *v8; // rax
  __int64 v9; // rdx
  __m128i *v10; // rcx
  __m128i **v11; // rsi
  __int64 v13; // rdi

  if ( !a3 || !a2 )
    return 0LL;
  if ( (a3[1].m128i_i8[9] & 2) == 0 )
  {
    v13 = a3[3].m128i_i64[1];
    if ( v13 )
      off_11268(v13);
  }
  v5 = strlen(a2) + 1;
  v6 = (void *)global_hooks(v5);
  v7 = v6;
  if ( v6 )
    v7 = memcpy(v6, a2, v5);
  a3[1].m128i_i32[2] &= 0xFFFFFDFF;
  a3[3].m128i_i64[1] = (__int64)v7;
  v8 = (__m128i *)get_object_item(a1, a2, 0);
  if ( !a1 || !v8 )
    return 0LL;
  if ( a3 == v8 )
    return 1LL;
  v9 = v8->m128i_i64[0];
  *a3 = _mm_loadu_si128(v8);
  if ( v9 )
    *(_QWORD *)(v9 + 8) = a3;
  v10 = *(__m128i **)(a1 + 16);
  if ( v8 == v10 )
  {
    if ( v8 == (__m128i *)v8->m128i_i64[1] )
      a3->m128i_i64[1] = (__int64)a3;
    *(_QWORD *)(a1 + 16) = a3;
  }
  else
  {
    v11 = (__m128i **)a3->m128i_i64[1];
    if ( v11 )
    {
      *v11 = a3;
      v9 = a3->m128i_i64[0];
    }
    if ( !v9 )
      v10->m128i_i64[1] = (__int64)a3;
  }
  *v8 = 0LL;
  cJSON_Delete(v8);
  return 1LL;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11268: using guessed type __int64 (__fastcall *off_11268)(_QWORD);

//----- (000000000000B2E0) ----------------------------------------------------
__int64 __fastcall cJSON_ReplaceItemInObjectCaseSensitive(__int64 a1, const char *a2, __m128i *a3)
{
  size_t v6; // rbp
  void *v7; // rax
  void *v8; // rcx
  __int64 v9; // r14
  const char *v10; // rsi
  __m128i *v11; // rbp
  __int64 v12; // rax
  __m128i **v13; // rdx
  __int64 v15; // rdi

  if ( !a3 || !a2 )
    return 0LL;
  if ( (a3[1].m128i_i8[9] & 2) == 0 )
  {
    v15 = a3[3].m128i_i64[1];
    if ( v15 )
      off_11268(v15);
  }
  v6 = strlen(a2) + 1;
  v7 = (void *)global_hooks(v6);
  v8 = v7;
  if ( v7 )
    v8 = memcpy(v7, a2, v6);
  a3[3].m128i_i64[1] = (__int64)v8;
  a3[1].m128i_i32[2] &= 0xFFFFFDFF;
  if ( !a1 )
    return 0LL;
  v9 = *(_QWORD *)(a1 + 16);
  if ( !v9 )
    return 0LL;
  v10 = *(const char **)(v9 + 56);
  v11 = *(__m128i **)(a1 + 16);
  if ( !v10 )
    return 0LL;
  while ( strcmp(a2, v10) )
  {
    v11 = (__m128i *)v11->m128i_i64[0];
    if ( v11 )
    {
      v10 = (const char *)v11[3].m128i_i64[1];
      if ( v10 )
        continue;
    }
    return 0LL;
  }
  if ( a3 == v11 )
    return 1LL;
  v12 = v11->m128i_i64[0];
  *a3 = _mm_loadu_si128(v11);
  if ( v12 )
    *(_QWORD *)(v12 + 8) = a3;
  if ( (__m128i *)v9 == v11 )
  {
    if ( v11 == (__m128i *)v11->m128i_i64[1] )
      a3->m128i_i64[1] = (__int64)a3;
    *(_QWORD *)(a1 + 16) = a3;
  }
  else
  {
    v13 = (__m128i **)a3->m128i_i64[1];
    if ( v13 )
    {
      *v13 = a3;
      v12 = a3->m128i_i64[0];
    }
    if ( !v12 )
      *(_QWORD *)(v9 + 8) = a3;
  }
  *v11 = 0LL;
  cJSON_Delete(v11);
  return 1LL;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);
// 11268: using guessed type __int64 (__fastcall *off_11268)(_QWORD);

//----- (000000000000B450) ----------------------------------------------------
__int64 cJSON_CreateNull()
{
  __int64 result; // rax

  result = global_hooks(64LL);
  if ( result )
  {
    *(_OWORD *)(result + 16) = 0LL;
    *(_DWORD *)(result + 24) = 4;
    *(_OWORD *)result = 0LL;
    *(_OWORD *)(result + 32) = 0LL;
    *(_OWORD *)(result + 48) = 0LL;
  }
  return result;
}
// B450: using guessed type __int64 __fastcall cJSON_CreateNull();
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);

//----- (000000000000B490) ----------------------------------------------------
__int64 cJSON_CreateTrue()
{
  __int64 result; // rax

  result = global_hooks(64LL);
  if ( result )
  {
    *(_OWORD *)(result + 16) = 0LL;
    *(_DWORD *)(result + 24) = 2;
    *(_OWORD *)result = 0LL;
    *(_OWORD *)(result + 32) = 0LL;
    *(_OWORD *)(result + 48) = 0LL;
  }
  return result;
}
// B490: using guessed type __int64 __fastcall cJSON_CreateTrue();
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);

//----- (000000000000B4D0) ----------------------------------------------------
__int64 cJSON_CreateFalse()
{
  __int64 result; // rax

  result = global_hooks(64LL);
  if ( result )
  {
    *(_OWORD *)(result + 16) = 0LL;
    *(_DWORD *)(result + 24) = 1;
    *(_OWORD *)result = 0LL;
    *(_OWORD *)(result + 32) = 0LL;
    *(_OWORD *)(result + 48) = 0LL;
  }
  return result;
}
// B4D0: using guessed type __int64 __fastcall cJSON_CreateFalse();
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);

//----- (000000000000B510) ----------------------------------------------------
__int64 __fastcall cJSON_CreateBool(int a1)
{
  __int64 result; // rax

  result = global_hooks(64LL);
  if ( result )
  {
    *(_OWORD *)(result + 16) = 0LL;
    *(_OWORD *)result = 0LL;
    *(_DWORD *)(result + 24) = (a1 != 0) + 1;
    *(_OWORD *)(result + 32) = 0LL;
    *(_OWORD *)(result + 48) = 0LL;
  }
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);

//----- (000000000000B550) ----------------------------------------------------
__int64 __fastcall cJSON_CreateNumber(double a1)
{
  __int64 result; // rax

  result = global_hooks(64LL);
  if ( result )
  {
    *(_OWORD *)(result + 16) = 0LL;
    *(_OWORD *)(result + 48) = 0LL;
    *(_OWORD *)result = 0LL;
    *(_OWORD *)(result + 32) = 0LL;
    *(_DWORD *)(result + 24) = 8;
    *(double *)(result + 48) = a1;
    if ( a1 < 2147483647.0 )
    {
      if ( a1 > -2147483648.0 )
        *(_DWORD *)(result + 40) = (int)a1;
      else
        *(_DWORD *)(result + 40) = 0x80000000;
    }
    else
    {
      *(_DWORD *)(result + 40) = 0x7FFFFFFF;
    }
  }
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);

//----- (000000000000B5E0) ----------------------------------------------------
__int64 __fastcall cJSON_CreateString(void *src)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  size_t v3; // r12
  void *v4; // rax

  v1 = global_hooks(64LL);
  v2 = v1;
  if ( !v1 )
    return v2;
  *(_OWORD *)(v1 + 16) = 0LL;
  *(_OWORD *)v1 = 0LL;
  *(_OWORD *)(v1 + 32) = 0LL;
  *(_OWORD *)(v1 + 48) = 0LL;
  *(_DWORD *)(v1 + 24) = 16;
  if ( src )
  {
    v3 = strlen((const char *)src) + 1;
    v4 = (void *)global_hooks(v3);
    if ( v4 )
    {
      *(_QWORD *)(v2 + 32) = memcpy(v4, src, v3);
      return v2;
    }
  }
  *(_QWORD *)(v2 + 32) = 0LL;
  cJSON_Delete((_DWORD *)v2);
  return 0LL;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);

//----- (000000000000B670) ----------------------------------------------------
__int64 __fastcall cJSON_CreateStringReference(__int64 a1)
{
  __int64 result; // rax

  result = global_hooks(64LL);
  if ( result )
  {
    *(_OWORD *)(result + 16) = 0LL;
    *(_OWORD *)(result + 32) = 0LL;
    *(_DWORD *)(result + 24) = 272;
    *(_QWORD *)(result + 32) = a1;
    *(_OWORD *)result = 0LL;
    *(_OWORD *)(result + 48) = 0LL;
  }
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);

//----- (000000000000B6B0) ----------------------------------------------------
__int64 __fastcall cJSON_CreateObjectReference(__int64 a1)
{
  __int64 result; // rax

  result = global_hooks(64LL);
  if ( result )
  {
    *(_OWORD *)(result + 16) = 0LL;
    *(_DWORD *)(result + 24) = 320;
    *(_QWORD *)(result + 16) = a1;
    *(_OWORD *)result = 0LL;
    *(_OWORD *)(result + 32) = 0LL;
    *(_OWORD *)(result + 48) = 0LL;
  }
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);

//----- (000000000000B6F0) ----------------------------------------------------
__int64 __fastcall cJSON_CreateArrayReference(__int64 a1)
{
  __int64 result; // rax

  result = global_hooks(64LL);
  if ( result )
  {
    *(_OWORD *)(result + 16) = 0LL;
    *(_DWORD *)(result + 24) = 288;
    *(_QWORD *)(result + 16) = a1;
    *(_OWORD *)result = 0LL;
    *(_OWORD *)(result + 32) = 0LL;
    *(_OWORD *)(result + 48) = 0LL;
  }
  return result;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);

//----- (000000000000B730) ----------------------------------------------------
__int64 __fastcall cJSON_CreateRaw(void *src)
{
  __int64 v1; // rax
  __int64 v2; // rbx
  size_t v3; // r12
  void *v4; // rax

  v1 = global_hooks(64LL);
  v2 = v1;
  if ( !v1 )
    return v2;
  *(_OWORD *)(v1 + 16) = 0LL;
  *(_OWORD *)v1 = 0LL;
  *(_OWORD *)(v1 + 32) = 0LL;
  *(_OWORD *)(v1 + 48) = 0LL;
  *(_DWORD *)(v1 + 24) = 128;
  if ( src )
  {
    v3 = strlen((const char *)src) + 1;
    v4 = (void *)global_hooks(v3);
    if ( v4 )
    {
      *(_QWORD *)(v2 + 32) = memcpy(v4, src, v3);
      return v2;
    }
  }
  *(_QWORD *)(v2 + 32) = 0LL;
  cJSON_Delete((_DWORD *)v2);
  return 0LL;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);

//----- (000000000000B7C0) ----------------------------------------------------
__int64 cJSON_CreateArray()
{
  __int64 result; // rax

  result = global_hooks(64LL);
  if ( result )
  {
    *(_OWORD *)(result + 16) = 0LL;
    *(_DWORD *)(result + 24) = 32;
    *(_OWORD *)result = 0LL;
    *(_OWORD *)(result + 32) = 0LL;
    *(_OWORD *)(result + 48) = 0LL;
  }
  return result;
}
// B7C0: using guessed type __int64 __fastcall cJSON_CreateArray();
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);

//----- (000000000000B800) ----------------------------------------------------
__int64 cJSON_CreateObject()
{
  __int64 result; // rax

  result = global_hooks(64LL);
  if ( result )
  {
    *(_OWORD *)(result + 16) = 0LL;
    *(_DWORD *)(result + 24) = 64;
    *(_OWORD *)result = 0LL;
    *(_OWORD *)(result + 32) = 0LL;
    *(_OWORD *)(result + 48) = 0LL;
  }
  return result;
}
// B800: using guessed type __int64 __fastcall cJSON_CreateObject();
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);

//----- (000000000000B840) ----------------------------------------------------
__int64 __fastcall cJSON_CreateIntArray(__int64 a1, int a2)
{
  __int64 v2; // rax
  __int64 v3; // r12
  _QWORD *v4; // rbp
  __int64 v5; // r15
  int v6; // er14
  __int64 v7; // rax
  __int64 v8; // rbx

  if ( a2 < 0 || !a1 )
    return 0LL;
  v2 = global_hooks(64LL);
  v3 = v2;
  if ( v2
    && (*(_OWORD *)(v2 + 16) = 0LL,
        *(_OWORD *)v2 = 0LL,
        *(_OWORD *)(v2 + 32) = 0LL,
        *(_OWORD *)(v2 + 48) = 0LL,
        *(_DWORD *)(v2 + 24) = 32,
        a2) )
  {
    v4 = 0LL;
    v5 = 0LL;
    while ( 1 )
    {
      v6 = *(_DWORD *)(a1 + 4 * v5);
      v7 = global_hooks(64LL);
      v8 = v7;
      if ( !v7 )
        break;
      *(_OWORD *)(v7 + 16) = 0LL;
      *(_OWORD *)(v7 + 48) = 0LL;
      *(_OWORD *)v7 = 0LL;
      *(_OWORD *)(v7 + 32) = 0LL;
      *(_DWORD *)(v7 + 24) = 8;
      *(double *)(v7 + 48) = (double)v6;
      *(_DWORD *)(v7 + 40) = v6;
      if ( v5 )
      {
        *v4 = v7;
        ++v5;
        *(_QWORD *)(v7 + 8) = v4;
        if ( v5 == a2 )
          goto LABEL_14;
      }
      else
      {
        *(_QWORD *)(v3 + 16) = v7;
        if ( a2 == 1LL )
          goto LABEL_14;
        v5 = 1LL;
      }
      v4 = (_QWORD *)v7;
    }
    cJSON_Delete((_DWORD *)v3);
  }
  else
  {
    v8 = 0LL;
LABEL_14:
    *(_QWORD *)(*(_QWORD *)(v3 + 16) + 8LL) = v8;
    v8 = v3;
  }
  return v8;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);

//----- (000000000000B960) ----------------------------------------------------
__int64 __fastcall cJSON_CreateFloatArray(__int64 a1, int a2)
{
  __int64 v2; // rax
  __int64 v3; // r12
  _QWORD *v4; // rbp
  __int64 v5; // r15
  __int64 v6; // rax
  __int64 v7; // rbx
  float v9; // [rsp+4h] [rbp-44h]

  if ( a2 < 0 || !a1 )
    return 0LL;
  v2 = global_hooks(64LL);
  v3 = v2;
  if ( v2
    && (*(_OWORD *)(v2 + 16) = 0LL,
        *(_OWORD *)v2 = 0LL,
        *(_OWORD *)(v2 + 32) = 0LL,
        *(_OWORD *)(v2 + 48) = 0LL,
        *(_DWORD *)(v2 + 24) = 32,
        a2) )
  {
    v4 = 0LL;
    v5 = 0LL;
    while ( 1 )
    {
      v9 = *(float *)(a1 + 4 * v5);
      v6 = global_hooks(64LL);
      v7 = v6;
      if ( !v6 )
        break;
      *(_OWORD *)(v6 + 16) = 0LL;
      *(_OWORD *)(v6 + 48) = 0LL;
      *(_OWORD *)v6 = 0LL;
      *(_OWORD *)(v6 + 32) = 0LL;
      *(_DWORD *)(v6 + 24) = 8;
      *(double *)(v6 + 48) = v9;
      if ( v9 < 2147483647.0 )
      {
        if ( v9 > -2147483600.0 )
          *(_DWORD *)(v6 + 40) = (int)v9;
        else
          *(_DWORD *)(v6 + 40) = 0x80000000;
      }
      else
      {
        *(_DWORD *)(v6 + 40) = 0x7FFFFFFF;
      }
      if ( v5 )
      {
        *v4 = v6;
        ++v5;
        *(_QWORD *)(v6 + 8) = v4;
        if ( v5 == a2 )
          goto LABEL_16;
      }
      else
      {
        *(_QWORD *)(v3 + 16) = v6;
        if ( a2 == 1LL )
          goto LABEL_16;
        v5 = 1LL;
      }
      v4 = (_QWORD *)v6;
    }
    cJSON_Delete((_DWORD *)v3);
  }
  else
  {
    v7 = 0LL;
LABEL_16:
    *(_QWORD *)(*(_QWORD *)(v3 + 16) + 8LL) = v7;
    v7 = v3;
  }
  return v7;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);

//----- (000000000000BAE0) ----------------------------------------------------
__int64 __fastcall cJSON_CreateDoubleArray(__int64 a1, int a2)
{
  __int64 v2; // rax
  __int64 v3; // r12
  _QWORD *v4; // rbp
  __int64 v5; // r15
  __int64 v6; // rax
  __int64 v7; // rbx
  double v9; // [rsp+0h] [rbp-48h]

  if ( a2 < 0 || !a1 )
    return 0LL;
  v2 = global_hooks(64LL);
  v3 = v2;
  if ( v2
    && (*(_OWORD *)(v2 + 16) = 0LL,
        *(_OWORD *)v2 = 0LL,
        *(_OWORD *)(v2 + 32) = 0LL,
        *(_OWORD *)(v2 + 48) = 0LL,
        *(_DWORD *)(v2 + 24) = 32,
        a2) )
  {
    v4 = 0LL;
    v5 = 0LL;
    while ( 1 )
    {
      v9 = *(double *)(a1 + 8 * v5);
      v6 = global_hooks(64LL);
      v7 = v6;
      if ( !v6 )
        break;
      *(_OWORD *)(v6 + 16) = 0LL;
      *(_OWORD *)(v6 + 48) = 0LL;
      *(_OWORD *)v6 = 0LL;
      *(_OWORD *)(v6 + 32) = 0LL;
      *(_DWORD *)(v6 + 24) = 8;
      *(double *)(v6 + 48) = v9;
      if ( v9 < 2147483647.0 )
      {
        if ( v9 > -2147483648.0 )
          *(_DWORD *)(v6 + 40) = (int)v9;
        else
          *(_DWORD *)(v6 + 40) = 0x80000000;
      }
      else
      {
        *(_DWORD *)(v6 + 40) = 0x7FFFFFFF;
      }
      if ( v5 )
      {
        *v4 = v6;
        ++v5;
        *(_QWORD *)(v6 + 8) = v4;
        if ( v5 == a2 )
          goto LABEL_16;
      }
      else
      {
        *(_QWORD *)(v3 + 16) = v6;
        if ( a2 == 1LL )
          goto LABEL_16;
        v5 = 1LL;
      }
      v4 = (_QWORD *)v6;
    }
    cJSON_Delete((_DWORD *)v3);
  }
  else
  {
    v7 = 0LL;
LABEL_16:
    *(_QWORD *)(*(_QWORD *)(v3 + 16) + 8LL) = v7;
    v7 = v3;
  }
  return v7;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);

//----- (000000000000BC50) ----------------------------------------------------
__int64 __fastcall cJSON_CreateStringArray(__int64 a1, int a2)
{
  __int64 v2; // rax
  __int64 v3; // r14
  _QWORD *v4; // rbp
  __int64 v5; // rbx
  const char *v6; // r13
  __int64 v7; // rax
  __int64 v8; // r15
  void *v9; // rax
  _DWORD *v11; // rdi
  size_t n; // [rsp+18h] [rbp-40h]

  if ( a2 < 0 || !a1 )
    return 0LL;
  v2 = global_hooks(64LL);
  v3 = v2;
  if ( v2
    && (*(_OWORD *)(v2 + 16) = 0LL,
        *(_OWORD *)v2 = 0LL,
        *(_OWORD *)(v2 + 32) = 0LL,
        *(_OWORD *)(v2 + 48) = 0LL,
        *(_DWORD *)(v2 + 24) = 32,
        a2) )
  {
    v4 = 0LL;
    v5 = 0LL;
    while ( 1 )
    {
      v6 = *(const char **)(a1 + 8 * v5);
      v7 = global_hooks(64LL);
      v8 = v7;
      if ( !v7 )
        break;
      *(_OWORD *)(v7 + 16) = 0LL;
      *(_OWORD *)v7 = 0LL;
      *(_OWORD *)(v7 + 32) = 0LL;
      *(_OWORD *)(v7 + 48) = 0LL;
      *(_DWORD *)(v7 + 24) = 16;
      if ( !v6 || (n = strlen(v6) + 1, (v9 = (void *)global_hooks(n)) == 0LL) )
      {
        *(_QWORD *)(v8 + 32) = 0LL;
        cJSON_Delete((_DWORD *)v8);
        break;
      }
      *(_QWORD *)(v8 + 32) = memcpy(v9, v6, n);
      if ( v5 )
      {
        *v4 = v8;
        ++v5;
        *(_QWORD *)(v8 + 8) = v4;
        if ( a2 == v5 )
          goto LABEL_16;
      }
      else
      {
        *(_QWORD *)(v3 + 16) = v8;
        if ( a2 == 1LL )
          goto LABEL_16;
        v5 = 1LL;
      }
      v4 = (_QWORD *)v8;
    }
    v11 = (_DWORD *)v3;
    v3 = 0LL;
    cJSON_Delete(v11);
  }
  else
  {
    v8 = 0LL;
LABEL_16:
    *(_QWORD *)(*(_QWORD *)(v3 + 16) + 8LL) = v8;
  }
  return v3;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);

//----- (000000000000BDC0) ----------------------------------------------------
_OWORD *__fastcall cJSON_Duplicate(__int64 a1, int a2)
{
  _OWORD *v2; // rax
  _OWORD *v3; // rbx
  int v4; // eax
  __int64 v5; // xmm0_8
  const char *v6; // r13
  int v7; // eax
  size_t v8; // r14
  void *v9; // rax
  void *v10; // r13
  _QWORD *v11; // rbp
  _QWORD *i; // r12
  __int64 v13; // rax
  __int64 v15; // rdx
  size_t v16; // r14
  void *v17; // rax

  if ( !a1 )
    return 0LL;
  v2 = (_OWORD *)global_hooks(64LL);
  v3 = v2;
  if ( !v2 )
    return 0LL;
  *v2 = 0LL;
  v2[1] = 0LL;
  v2[2] = 0LL;
  v2[3] = 0LL;
  v4 = *(_DWORD *)(a1 + 24);
  v5 = *(_QWORD *)(a1 + 48);
  v6 = *(const char **)(a1 + 32);
  BYTE1(v4) &= 0xFEu;
  *((_DWORD *)v3 + 6) = v4;
  v7 = *(_DWORD *)(a1 + 40);
  *((_QWORD *)v3 + 6) = v5;
  *((_DWORD *)v3 + 10) = v7;
  if ( v6 )
  {
    v8 = strlen(v6) + 1;
    v9 = (void *)global_hooks(v8);
    if ( !v9 )
    {
      *((_QWORD *)v3 + 4) = 0LL;
      goto LABEL_17;
    }
    *((_QWORD *)v3 + 4) = memcpy(v9, v6, v8);
  }
  v10 = *(void **)(a1 + 56);
  if ( !v10 )
    goto LABEL_9;
  if ( (*(_BYTE *)(a1 + 25) & 2) == 0 )
  {
    v16 = strlen(*(const char **)(a1 + 56)) + 1;
    v17 = (void *)global_hooks(v16);
    if ( v17 )
    {
      v10 = memcpy(v17, v10, v16);
      goto LABEL_8;
    }
    *((_QWORD *)v3 + 7) = 0LL;
LABEL_17:
    cJSON_Delete(v3);
    return 0LL;
  }
LABEL_8:
  *((_QWORD *)v3 + 7) = v10;
LABEL_9:
  if ( !a2 )
    return v3;
  v11 = *(_QWORD **)(a1 + 16);
  if ( v11 )
  {
    for ( i = 0LL; ; i = (_QWORD *)v13 )
    {
      v13 = cJSON_Duplicate(v11, 1LL);
      if ( !v13 )
        break;
      if ( i )
      {
        *i = v13;
        v11 = (_QWORD *)*v11;
        *(_QWORD *)(v13 + 8) = i;
        if ( !v11 )
          goto LABEL_23;
      }
      else
      {
        v11 = (_QWORD *)*v11;
        *((_QWORD *)v3 + 2) = v13;
        if ( !v11 )
        {
          v15 = v13;
          goto LABEL_24;
        }
      }
    }
    goto LABEL_17;
  }
  v13 = 0LL;
LABEL_23:
  v15 = *((_QWORD *)v3 + 2);
  if ( !v15 )
    return v3;
LABEL_24:
  *(_QWORD *)(v15 + 8) = v13;
  return v3;
}
// 11260: using guessed type __int64 (__fastcall *global_hooks)(_QWORD);

//----- (000000000000BF50) ----------------------------------------------------
void __fastcall cJSON_Minify(_BYTE *a1)
{
  char v1; // al
  _BYTE *v2; // rdx
  char v3; // cl
  __int64 v4; // rsi
  _BYTE *v5; // rsi
  char v6; // di
  _BYTE *v7; // rcx
  _BYTE *v8; // r8
  char v9; // al
  _BYTE *v10; // rsi
  char v11; // cl
  _BYTE *v12; // rax
  char v13; // al
  _BYTE *v14; // rcx
  char v15; // si

  if ( a1 )
  {
    v1 = *a1;
    v2 = a1;
    if ( !*a1 )
      goto LABEL_10;
    while ( 1 )
    {
      v3 = v1 - 9;
      if ( (unsigned __int8)(v1 - 9) > 0x26u )
        break;
      v4 = 1LL << v3;
      if ( ((1LL << v3) & 0x800013) != 0 )
        goto LABEL_12;
      if ( (v4 & 0x2000000) != 0 )
      {
        *v2 = v1;
        v5 = a1 + 1;
        v6 = a1[1];
        v7 = v2 + 1;
        if ( v6 )
        {
          v2[1] = v6;
          if ( v6 == 34 )
          {
            ++v2;
            v8 = v5;
LABEL_19:
            *v2 = 34;
            a1 = v8 + 1;
            ++v2;
            v1 = v8[1];
            goto LABEL_13;
          }
          while ( 2 )
          {
            v9 = v5[1];
            v8 = v5 + 1;
            v2 = v7 + 1;
            if ( v6 == 92 )
            {
              if ( v9 != 34 )
              {
                if ( !v9 )
                  goto LABEL_10;
                v7[1] = v9;
LABEL_23:
                v7 = v2;
                v5 = v8;
                v6 = v9;
                continue;
              }
              v7[1] = 34;
              v8 = v5 + 2;
              v9 = v5[2];
              v10 = v7 + 2;
              ++v7;
              v2 = v10;
            }
            break;
          }
          if ( !v9 )
            goto LABEL_10;
          v7[1] = v9;
          if ( v9 == 34 )
            goto LABEL_19;
          goto LABEL_23;
        }
        ++v2;
LABEL_10:
        *v2 = 0;
        return;
      }
      if ( (v4 & 0x4000000000LL) == 0 )
        break;
      v1 = a1[1];
      if ( v1 == 47 )
      {
        v11 = a1[2];
        v12 = a1 + 2;
        if ( !v11 )
          goto LABEL_10;
        while ( v11 != 10 )
        {
          v11 = *++v12;
          if ( !*v12 )
            goto LABEL_10;
        }
        a1 = v12 + 1;
        v1 = v12[1];
LABEL_13:
        if ( !v1 )
        {
          *v2 = 0;
          return;
        }
      }
      else
      {
        if ( v1 == 42 )
        {
          v13 = a1[2];
          v14 = a1 + 2;
          if ( !v13 )
            goto LABEL_10;
          while ( 1 )
          {
            v15 = v14[1];
            if ( v13 == 42 && v15 == 47 )
              break;
            ++v14;
            v13 = v15;
            if ( !v15 )
              goto LABEL_10;
          }
          a1 = v14 + 2;
          v1 = v14[2];
          goto LABEL_13;
        }
        ++a1;
        if ( !v1 )
          goto LABEL_10;
      }
    }
    *v2++ = v1;
LABEL_12:
    v1 = *++a1;
    goto LABEL_13;
  }
}

//----- (000000000000C100) ----------------------------------------------------
_BOOL8 __fastcall cJSON_IsInvalid(__int64 a1)
{
  _BOOL8 result; // rax

  if ( a1 )
    result = *(_BYTE *)(a1 + 24) == 0;
  else
    result = 0LL;
  return result;
}

//----- (000000000000C120) ----------------------------------------------------
_BOOL8 __fastcall cJSON_IsFalse(__int64 a1)
{
  _BOOL8 result; // rax

  if ( a1 )
    result = *(_BYTE *)(a1 + 24) == 1;
  else
    result = 0LL;
  return result;
}

//----- (000000000000C140) ----------------------------------------------------
_BOOL8 __fastcall cJSON_IsTrue(__int64 a1)
{
  _BOOL8 result; // rax

  if ( a1 )
    result = *(_BYTE *)(a1 + 24) == 2;
  else
    result = 0LL;
  return result;
}

//----- (000000000000C160) ----------------------------------------------------
_BOOL8 __fastcall cJSON_IsBool(__int64 a1)
{
  _BOOL8 result; // rax

  if ( a1 )
    result = (*(_BYTE *)(a1 + 24) & 3) != 0;
  else
    result = 0LL;
  return result;
}

//----- (000000000000C180) ----------------------------------------------------
_BOOL8 __fastcall cJSON_IsNull(__int64 a1)
{
  _BOOL8 result; // rax

  if ( a1 )
    result = *(_BYTE *)(a1 + 24) == 4;
  else
    result = 0LL;
  return result;
}

//----- (000000000000C1A0) ----------------------------------------------------
_BOOL8 __fastcall cJSON_IsNumber(__int64 a1)
{
  _BOOL8 result; // rax

  if ( a1 )
    result = *(_BYTE *)(a1 + 24) == 8;
  else
    result = 0LL;
  return result;
}

//----- (000000000000C1C0) ----------------------------------------------------
_BOOL8 __fastcall cJSON_IsString(__int64 a1)
{
  _BOOL8 result; // rax

  if ( a1 )
    result = *(_BYTE *)(a1 + 24) == 16;
  else
    result = 0LL;
  return result;
}

//----- (000000000000C1E0) ----------------------------------------------------
_BOOL8 __fastcall cJSON_IsArray(__int64 a1)
{
  _BOOL8 result; // rax

  if ( a1 )
    result = *(_BYTE *)(a1 + 24) == 32;
  else
    result = 0LL;
  return result;
}

//----- (000000000000C200) ----------------------------------------------------
_BOOL8 __fastcall cJSON_IsObject(__int64 a1)
{
  _BOOL8 result; // rax

  if ( a1 )
    result = *(_BYTE *)(a1 + 24) == 64;
  else
    result = 0LL;
  return result;
}

//----- (000000000000C220) ----------------------------------------------------
_BOOL8 __fastcall cJSON_IsRaw(__int64 a1)
{
  _BOOL8 result; // rax

  if ( a1 )
    result = *(_BYTE *)(a1 + 24) == 0x80;
  else
    result = 0LL;
  return result;
}

//----- (000000000000C240) ----------------------------------------------------
__int64 __fastcall cJSON_Compare(__int64 a1, __int64 a2, unsigned int a3)
{
  int v3; // eax
  unsigned int v4; // ebx
  int v5; // eax
  __int64 *i; // r14
  _QWORD *v8; // rax
  __int64 *v9; // r13
  _QWORD *v10; // rax
  const char *v12; // rdi
  const char *v13; // rsi
  _QWORD *v14; // r13
  _QWORD *v15; // rbp

  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  v3 = *(_DWORD *)(a1 + 24);
  v4 = (unsigned __int8)(v3 ^ *(_DWORD *)(a2 + 24));
  if ( (unsigned __int8)v3 != (unsigned __int8)*(_DWORD *)(a2 + 24) )
    return 0;
  v5 = (unsigned __int8)*(_DWORD *)(a1 + 24);
  if ( !(unsigned __int8)*(_DWORD *)(a1 + 24) )
    return v4;
  if ( v5 != 8 )
  {
    if ( (unsigned __int8)*(_DWORD *)(a1 + 24) <= 8u )
    {
      if ( (unsigned __int8)*(_DWORD *)(a1 + 24) > 2u && v5 != 4 )
        return v4;
    }
    else if ( v5 != 32 )
    {
      if ( (unsigned __int8)*(_DWORD *)(a1 + 24) <= 0x20u )
      {
        if ( v5 != 16 )
          return v4;
      }
      else if ( v5 != 64 && v5 != 128 )
      {
        return v4;
      }
    }
  }
  if ( a1 == a2 )
    return 1;
  if ( v5 == 8 )
    return fmax(COERCE_DOUBLE(*(_QWORD *)(a1 + 48) & 0x7FFFFFFFFFFFFFFFLL), fabs(*(double *)(a2 + 48)))
         * 2.220446049250313e-16 >= fabs(*(double *)(a1 + 48) - *(double *)(a2 + 48));
  if ( (unsigned __int8)*(_DWORD *)(a1 + 24) > 8u )
  {
    if ( v5 == 32 )
    {
      v14 = *(_QWORD **)(a2 + 16);
      v15 = *(_QWORD **)(a1 + 16);
      if ( !v14 || !v15 )
        return v15 == v14;
      while ( 1 )
      {
        v4 = cJSON_Compare(v15, v14, a3);
        if ( !v4 )
          break;
        v15 = (_QWORD *)*v15;
        v14 = (_QWORD *)*v14;
        if ( !v15 || !v14 )
          return v15 == v14;
      }
      return v4;
    }
    if ( (unsigned __int8)*(_DWORD *)(a1 + 24) <= 0x20u || v5 != 64 )
    {
      v12 = *(const char **)(a1 + 32);
      if ( v12 )
      {
        v13 = *(const char **)(a2 + 32);
        if ( v13 )
          v4 = strcmp(v12, v13) == 0;
      }
      return v4;
    }
    for ( i = *(__int64 **)(a1 + 16); i; i = (__int64 *)*i )
    {
      v8 = get_object_item(a2, (const char *)i[7], a3);
      if ( !v8 )
        return v4;
      if ( !(unsigned int)cJSON_Compare(i, v8, a3) )
        return 0;
    }
    v9 = *(__int64 **)(a2 + 16);
    if ( v9 )
    {
      while ( 1 )
      {
        v10 = get_object_item(a1, (const char *)v9[7], a3);
        if ( !v10 )
          break;
        if ( !(unsigned int)cJSON_Compare(v9, v10, a3) )
          return 0;
        v9 = (__int64 *)*v9;
        if ( !v9 )
          return 1;
      }
      return v4;
    }
    return 1;
  }
  v4 = 1;
  if ( (unsigned __int8)*(_DWORD *)(a1 + 24) <= 2u )
    return v4;
  return v5 == 4;
}
// C3AD: conditional instruction was optimized away because of 'eax.4==80'
// C3D3: conditional instruction was optimized away because of 'eax.4==10'
// C3E2: conditional instruction was optimized away because of 'eax.4 in (1..2|==4)'
// C382: conditional instruction was optimized away because of 'eax.4 in (1..7)'

//----- (000000000000C4D8) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=286 queued=132 decompiled=132 lumina nreq=0 worse=0 better=0
// ALL OK, 132 function(s) have been successfully decompiled
