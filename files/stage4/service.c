/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 init_proc(void); // weak
void sub_9020();
__int64 __fastcall sub_9030(_QWORD, _QWORD); // weak
__int64 __fastcall sub_9040(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_9050(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_9060(_QWORD, _QWORD); // weak
__int64 __fastcall sub_9070(_QWORD, _QWORD); // weak
void *__fastcall memcpy(void *, const void *, size_t);
__int64 __fastcall sub_9090(_QWORD); // weak
__int64 sub_90A0(void); // weak
__int64 __fastcall sub_90B0(_QWORD, _QWORD); // weak
__int64 __fastcall sub_90C0(_QWORD, _QWORD); // weak
__int64 __fastcall sub_90D0(_QWORD); // weak
__int64 __fastcall sub_90E0(_QWORD, _QWORD); // weak
__int64 __fastcall sub_90F0(_QWORD); // weak
__int64 __fastcall sub_9100(_QWORD, _QWORD); // weak
__int64 __fastcall sub_9110(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_9120(_QWORD, _QWORD); // weak
__int64 __fastcall sub_9130(_QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *__fastcall memcmp(__int64 a1, __int64 a2, __int64 a3))();
__int64 __fastcall sub_9150(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_9160(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_9170(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_9180(_QWORD); // weak
__int64 __fastcall sub_9190(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_91A0(_QWORD, _QWORD); // weak
__int64 __fastcall sub_91B0(_QWORD, _QWORD); // weak
__int64 __fastcall sub_91C0(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_91E0(_QWORD, _QWORD); // weak
__int64 __fastcall sub_91F0(_QWORD, _QWORD); // weak
__int64 __fastcall strlen(__int64 a1);
__int64 __fastcall sub_9210(_QWORD, _QWORD); // weak
__int64 __fastcall sub_9220(_QWORD, _QWORD); // weak
__int64 __fastcall sub_9228(_QWORD); // weak
__int64 __fastcall sub_9230(_QWORD, _QWORD); // weak
__int64 __fastcall sub_9238(_QWORD); // weak
__int64 __fastcall sub_9240(_QWORD); // weak
__int64 __fastcall sub_9248(_QWORD); // weak
__int64 __fastcall sub_9250(_QWORD); // weak
__int64 sub_9258(void); // weak
__int64 __fastcall sub_9260(_QWORD); // weak
__int64 __fastcall sub_9268(_QWORD, _QWORD); // weak
void __fastcall __noreturn exit();
void __fastcall sub_9860(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14);
void __fastcall sub_98B0(__int64 *a1, unsigned int *a2, __int64 a3);
unsigned __int64 sub_9BE0();
void __fastcall __noreturn start(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 (__fastcall **sub_9ED0())();
__int64 sub_9F00(void); // weak
__int64 (__fastcall **sub_9F40())();
__int64 sub_9F90();
__int64 __fastcall sstic_alloc_region(unsigned int a1, int a2, int a3);
int __fastcall sstic_assoc(unsigned __int64 a1, int a2, int a3);
int __fastcall sstic_cmd(int a1, int a2);
__int64 __fastcall do_sstic_decrypt(_QWORD *a1, unsigned int a2, _QWORD *a3);
__int64 __fastcall sstic_cmd2(void *prog, unsigned __int64 proglen, void *input, unsigned __int64 inputlen, void *out, unsigned __int64 outlen, void *dbg, unsigned __int64 dbgout);
__int64 __fastcall sstic_get_key(_QWORD *rdi0, __int64 a2);
__int64 sstic_get_debug_state();
unsigned __int64 __fastcall recv(unsigned int a1, void *a2, unsigned __int64 a3);
unsigned __int64 __fastcall handle_req0(int sock, req *a2); // idb
_BOOL8 __fastcall check_perm(int a1, unsigned __int64 a2);
int __fastcall decrypt_req(__int64 a1, req *a2, request *a3);
unsigned __int64 __fastcall handle_req1(unsigned int fd, request *a2); // idb
unsigned __int64 __fastcall handle_req2(__int64 fd); // idb
unsigned __int64 __fastcall handle_req3(unsigned int a1, request *a2); // idb
int __cdecl main(int argc, const char **argv, const char **envp);
__int64 __fastcall sub_BAF0(unsigned int *a1, int *a2, unsigned int *a3, _DWORD *a4);
__int64 sub_BBE0(void); // weak
__int64 sub_BC70(void); // weak
void __fastcall _libc_start_main(__int64 (__fastcall *a1)(_QWORD, _QWORD *, void *), unsigned int a2, _QWORD *a3, void (__fastcall *a4)(_QWORD, _QWORD *, void *), __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15);
__int64 __fastcall sub_C920(unsigned int a1, int a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_C9D0(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_CA10(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
__int64 __fastcall sub_CCC0(unsigned int a1, __int64 a2, __int64 a3);
void sub_CD60();
void __fastcall __noreturn sub_CDA0(unsigned __int64 a1, __int64 a2, __int64 a3, unsigned int a4, void *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13);
void __fastcall __noreturn sub_CF00(__int64 a1, __int64 a2, unsigned int a3, void *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
__int64 __fastcall sub_CF50(char *a1, unsigned __int8 *a2, unsigned int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_CF70(_DWORD *a1, __int64 a2);
__int64 __fastcall sub_D160(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_D1E0(__int64 a1, __int64 a2, unsigned __int8 *a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_DD90(char *a1, unsigned __int8 *a2, __int64 a3, int a4, __int64 a5, unsigned int a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
_QWORD *__fastcall sub_E670(char *a1, __int64 a2, void *a3, __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
unsigned __int64 __fastcall sub_E910(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, __int64 a14);
__int64 __fastcall sub_FF90(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_FFB0(__int64 a1, int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
u32 *__fastcall sub_10460(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14);
_QWORD *__fastcall sub_10650(_QWORD *a1, char *a2, size_t a3, int a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, void *a10, int a11);
_DWORD *__fastcall sub_10B60(unsigned __int8 *a1, unsigned __int64 a2);
__int64 __fastcall sub_10C80(unsigned __int8 *a1, unsigned __int8 **a2, _QWORD *a3, unsigned __int8 **a4, _QWORD *a5, _QWORD *a6);
void __fastcall sub_10E70(int *a1);
__int64 __fastcall sub_10ED0(_BYTE **a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
unsigned __int64 __fastcall sub_11980(__int64 a1, _BYTE **a2, unsigned __int64 *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
unsigned __int64 __fastcall sub_11AA0(unsigned __int8 *a1);
__int64 __fastcall sub_11B00(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7);
__int64 __fastcall sub_11B10(int sig); // idb
void *__fastcall sub_11CA0(__int64 *a1, char *a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_11FF0(void *a1, unsigned __int64 a2, unsigned __int64 a3, int (__fastcall *a4)(_QWORD, _QWORD, _QWORD), __int64 a5);
unsigned __int64 __fastcall sub_12340(void *a1, unsigned __int64 a2, unsigned __int64 a3, int (__fastcall *a4)(_QWORD, _QWORD, _QWORD));
_WORD *__fastcall sub_12350(_BYTE *a1);
void __fastcall __noreturn sub_12430(unsigned int a1, __int64 a2, char a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
void __fastcall __noreturn sub_126E0(unsigned int a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, u32 *a13, __int64 a14);
_QWORD *__fastcall sub_12700(_QWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, u32 *a13, __int64 a14);
__int64 __fastcall sub_12970(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, u32 *a13, __int64 a14);
unsigned __int64 __fastcall sub_129A0(char *a1, unsigned __int8 **a2, unsigned int a3);
unsigned __int64 __fastcall sub_12E90(unsigned __int64 a1, unsigned __int64 a2, char *a3, char *a4);
__int64 sub_130A0(__int64 *a1, unsigned __int64 a2, ...);
unsigned __int64 __fastcall sub_13160(__int64 a1, _BYTE *a2, unsigned int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall perror(char *a1);
__int64 __fastcall unlink(__int64 a1);
__int64 __fastcall sub_13300(__int64 a1, __int64 a2, __m128i *a3, unsigned int a4, __m128 a5, double a6, __m128i a7, __m128 a8, double a9, double a10, double a11, double a12);
__int64 __fastcall sub_13480(_QWORD *a1, __int64 a2, __m128i *a3, __int64 a4, __m128 a5, double a6, __m128i a7, __m128 a8, double a9, double a10, double a11, double a12, __int64 a13, u32 a14);
__int64 sub_13580(_QWORD *a1, __int64 a2, ...);
__int64 __fastcall sub_137F0(int *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6);
__int64 __fastcall fdopen(int a1, char *a2);
__int64 __fastcall sub_13CE0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
u32 *__fastcall sub_13E10(u32 *a1, int a2, int *a3);
__int64 __fastcall sub_140F0(const char *a1, _BYTE *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
unsigned __int64 __fastcall fwrite(char *a1, unsigned __int64 a2, unsigned __int64 a3, void *a4);
_BYTE *__fastcall sub_14470(__int64 a1, _BYTE *a2, unsigned __int64 a3, unsigned int a4, int a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13);
__int64 __fastcall sub_14480(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14);
signed __int64 __fastcall sub_146E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6);
__int64 __fastcall sub_14740(__int64 a1, __int64 a2, char *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall popen(__int64 a1, __int64 a2);
__int64 __fastcall puts(char *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall sub_14DA0(__int64 a1, void *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, __int64 a14);
__int64 __fastcall sub_15430(__int64 a1, char a2);
__int64 __fastcall sub_15520(__int64 a1, __int64 a2, unsigned int a3, int a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_15DE0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_15E20(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, unsigned __int64 a12, u32 *a13);
__int64 __fastcall sub_15F90(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_16190(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall sub_16460(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
unsigned __int64 __fastcall sub_16600(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_16780(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_168F0(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5, __int64 a6, __int64 a7, _QWORD *a8);
__int64 __fastcall sub_169E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5, __int64 a6, __int64 a7, _QWORD *a8);
__int64 __fastcall sub_16AD0(__int64 *a1);
__int64 __fastcall sub_16B00(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_16BC0(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6);
__int64 __fastcall sub_16CC0(_DWORD *a1);
__int64 __fastcall sub_16CF0(__int64 a1);
__int64 __fastcall sub_16D00(__int64 *a1, unsigned __int64 a2, __m128i *a3, unsigned int a4, __m128 a5, double a6, __m128i a7, __m128 a8, double a9, double a10, double a11, double a12);
unsigned __int64 sub_16EA0(char a1, _BYTE *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, ...);
void __fastcall __noreturn sub_17110(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
void __fastcall sub_17140(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
_BYTE *__fastcall sub_17160(_BYTE *a1, int a2, int *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_17200(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
unsigned __int64 __fastcall sub_17270(__int64 a1);
int *__fastcall sub_17280(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_172C0(__int64 a1, unsigned __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_17420(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14);
unsigned __int64 __fastcall sub_17740(__int64 a1);
__int64 __fastcall sub_17780(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
unsigned __int64 __fastcall sub_179E0(__int64 a1, off_t a2, unsigned int a3);
__int64 __fastcall sub_179F0(__int64 a1);
unsigned __int64 __fastcall sub_17A50(__int64 a1, double xmm0_8_0, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_17BF0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_17C50(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_17CC0(__int64 a1, __int64 a2, unsigned int a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
unsigned __int64 __fastcall sub_182B0(__int64 a1, struct stat *a2);
__int64 __fastcall sub_182D0(__int64 a1, const char *a2, __int64 a3);
__int64 __fastcall sub_18370(__int64 a1, __int64 a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_18490(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_186C0(__int64 a1, __int64 a2, int a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
__int64 __fastcall sub_187F0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
unsigned __int64 __fastcall sub_18880(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
int __fastcall sub_18A70(__int64 a1, char *a2, size_t a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
int *__fastcall sub_18AA0(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
unsigned __int64 __fastcall sub_18B30(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6);
int *__fastcall sub_18B90(int *a1, const char *a2, unsigned int a3, unsigned int a4, __int16 a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13);
__int64 __fastcall sub_18D30(__int64 a1, unsigned __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_18D60(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
int *__fastcall sub_18F00(__int64 a1, const char *a2, _BYTE *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
_QWORD *__fastcall sub_193A0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14);
__int64 __fastcall sub_19440(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall sub_19650(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
signed __int64 __fastcall sub_19740(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6);
__int64 __fastcall sub_19820(_QWORD *a1, __int64 a2);
void __fastcall sub_19CF0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, u32 a6);
unsigned __int64 __fastcall sub_19D10(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6);
__int64 __fastcall sub_1A000(__int64 a1);
__int64 __fastcall sub_1A060(int *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_1A100(int *a1);
__int64 __fastcall sub_1A150(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall sub_1A1C0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_1A330(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_1A4A0(int *a1, __int64 a2, __int64 a3, int a4);
void __fastcall sub_1A500(int *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall sub_1A5C0(); // weak
__int64 __fastcall sub_1A5D0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
unsigned __int64 __fastcall sub_1A630(_QWORD *a1, unsigned __int8 *a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
unsigned __int64 __fastcall sub_1A7C0(__int64 a1, __int64 a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
int *__fastcall sub_1A870(int *a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_1A970(__int64 a1, __int64 a2, unsigned int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_1A9E0(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
_QWORD *__fastcall sub_1AA50(__int64 a1, int a2);
_QWORD *__fastcall sub_1AD10(__int64 a1, int a2, int a3, _QWORD *a4, __int64 a5);
__int64 __fastcall sub_1AE60(); // weak
_QWORD *__fastcall sub_1AE70(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_1AEF0(); // weak
__int64 __fastcall sub_1AF00(__int64 a1, unsigned __int8 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall sub_1B000(int a1, unsigned __int64 a2, int a3);
__int64 __fastcall sub_1B030(int a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14);
void __fastcall sub_1BB30(int *a1);
__int64 __fastcall sub_1BBA0(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_1BD30(); // weak
__int64 __fastcall sub_1BD40(); // weak
__int64 __fastcall sub_1BD50(); // weak
__int64 __fastcall sub_1BD60(); // weak
__int64 __fastcall sub_1BD70(); // weak
void sub_1BD80();
__int64 __fastcall sub_1BEB0(int *a1);
__int64 __fastcall sub_1BF10(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14);
__int64 __fastcall sub_1C0B0(__int64 a1, __int64 a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, u32 *a13, u32 a14);
__int64 __fastcall sub_1C280(__int64 a1, __int64 a2, int a3, int a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_1C520(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
_QWORD *__fastcall sub_1C540(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_1C580(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4);
_BOOL8 __fastcall sub_1C780(unsigned __int64 a1);
__int64 __fastcall sub_1C7D0(volatile __int32 *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6);
__int64 __fastcall sub_1C810(__int64 *a1);
__int64 __fastcall sub_1C820(__int64 *a1);
unsigned __int64 __fastcall sub_1C830(unsigned __int64 *a1);
__int64 __fastcall sub_1C870(__int64 *a1);
__int64 __fastcall sub_1C890(__int64 *a1);
__int64 __fastcall sub_1C8A0(__int64 a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_1C930(__int64 a1, _QWORD *a2);
void *__fastcall sub_1CB30(void **a1);
void *__fastcall sub_1CB50(void **a1);
void *__fastcall sub_1CB70(void **a1);
__int64 __fastcall sub_1CBA0(__int64 *a1);
__int64 __fastcall sub_1CBC0(__int64 *a1);
unsigned __int64 __fastcall sub_1CBD0(unsigned __int64 *a1);
__int64 __fastcall sub_1CC00(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
unsigned __int64 __fastcall sub_1CC20(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
u32 *__fastcall sub_1CC80(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
void __fastcall __noreturn sub_1CDA0(const char *a1, __int64 a2, unsigned int a3, __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
char *__fastcall sub_1CE00(unsigned __int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_1CFB0(_QWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_1D050(__int64 a1, __int64 a2);
__int64 *__fastcall sub_1D070(__int64 *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
void __noreturn sub_1D1E0();
unsigned __int64 __fastcall sub_1D210(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6);
__int64 (__fastcall *__fastcall sub_1D3A0(unsigned int *a1))(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_1D960(unsigned __int64 a1);
_QWORD *__fastcall sub_1DA10(_QWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_1DAE0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, unsigned __int64 a10);
__int64 __fastcall sub_1DC90(u32 *uaddr, unsigned __int64 a2, unsigned int a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
_QWORD *__fastcall sub_1E6C0(unsigned __int64 a1, __int64 rsi0, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
void __fastcall sub_1EF20(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14);
u32 *__fastcall sub_1F070(u32 *a1, u32 *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14);
unsigned __int64 sub_1F5F0();
u32 *__fastcall sub_1F780(u32 *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
unsigned __int64 __fastcall sub_1F880(const char *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall sub_20790(unsigned __int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14);
_QWORD *__fastcall sub_20860(u32 *uaddr, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_20A40(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
u32 *__fastcall sub_20BD0(u32 *uaddr, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
int __fastcall sub_20E50(u32 *a1, unsigned __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
int __fastcall sub_21140(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_21500(u32 *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_21830(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_21870(unsigned __int64 a1, u32 *a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_21B20(unsigned __int64 a1, u32 *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, __int64 a14);
__int64 (__fastcall *__fastcall sub_21B70(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14))(_QWORD, _QWORD);
_QWORD *__fastcall sub_21DF0(const char *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_22260(unsigned __int64 a1, unsigned __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, __int64 a14);
unsigned __int64 __fastcall sub_22FE0(__int64 a1);
void *sub_23000();
void *sub_23040();
void *sub_23090();
_BYTE *(__fastcall *sub_230E0())(__int64 a1, const __m128i *a2);
void *__fastcall sub_23100(void *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall sub_23140(unsigned int a1, char *a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 (__fastcall *sub_231C0())();
void *sub_231F0();
__int64 __fastcall sub_23250(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4);
_BYTE *(__fastcall *sub_239D0())(__int64 a1, unsigned __int8 *a2);
void *sub_239F0();
__int64 (__fastcall *sub_23A20())();
__int64 (__fastcall *sub_23A80())();
__int64 (__fastcall *sub_23B30())();
void (*sub_23BC0())();
void *sub_23C70();
__int64 (__fastcall *sub_23CC0())();
__int64 (__fastcall *sub_23D10())();
void *sub_23DC0();
void *sub_23DF0();
__int64 __fastcall sub_23E20(__int64 *a1, __int64 *a2);
__int64 __fastcall sub_25270(const __m128i *a1, const __m128i *a2);
__int64 __fastcall sub_25520(__int64 *a1, __int64 *a2);
__int64 __fastcall sub_26790(unsigned __int64 _RDI, __int64 _RSI, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __m128 _XMM7);
__int64 __fastcall sub_26BD0(__int64 *a1, __int64 *a2, unsigned __int64 a3);
__int64 __fastcall sub_28430(__int64 *a1, __int64 *a2, unsigned __int64 a3);
__int64 __fastcall sub_29BA0(const __m128i *a1, const __m128i *a2, unsigned __int64 a3);
__int64 __fastcall sub_2AB80(unsigned __int64 _RDI, unsigned __int64 _RSI, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __m128 _XMM7);
__int64 __fastcall sub_2B0B0(const __m128i *a1, unsigned int a2, unsigned __int64 a3);
__int64 __fastcall sub_2B3E0(const __m128i *a1, unsigned __int64 a2);
unsigned __int64 __fastcall sub_2B5F0(unsigned __int64 a1, int _ESI, unsigned __int64 a3);
unsigned __int64 __fastcall sub_2B8C0(unsigned __int64 i, int _ESI);
__int64 __fastcall sub_2BA10(const __m128i *a1, unsigned __int8 *a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_2BE10(__int64 _RDI, __int64 _RSI, unsigned __int64 _RDX, __int64 _RCX);
__int64 __fastcall sub_2C1F0(const __m128i *_RDI, __m128i *_RSI, unsigned __int64 a3);
__int64 __fastcall sub_2D840(); // weak
__int64 __fastcall sub_2D860(__m128i *a1, const __m128i *_RSI, unsigned __int64 a3);
__int64 __fastcall sub_30240(); // weak
__int64 __fastcall sub_32DD0(); // weak
__int64 __fastcall sub_32DF0(__m128i *a1, const __m128i *a2, unsigned __int64 a3);
__int64 __fastcall sub_358E0(); // weak
__int64 __fastcall sub_38410(); // weak
unsigned __int64 __fastcall sub_38430(unsigned __int64 _RDI, _BYTE *_RSI, unsigned __int64 a3);
__int64 __fastcall sub_38B90(__int64 *a1, __int64 *a2, _QWORD *a3, __m128i a4, __m128i a5, __m128i a6, double a7, double a8);
__int64 __fastcall sub_3ADE0(__int64 *a1, __int64 *a2, __int64 a3, __m128i a4, __m128i a5, __m128i a6, double a7, double a8);
__int64 __fastcall sub_3CF34(const __m128i *a1, const __m128i *a2, __int64 a3, double a4, double a5, double a6, double a7);
__int64 __fastcall sub_3EAE4(__int64 _RDI, __int64 _RSI, __int64 a3, __m128 _XMM0, double a5, double a6, double a7);
char *__fastcall sub_40380(const __m128i *a1, unsigned int a2);
__int64 __fastcall sub_40590(unsigned __int64 _RDI, int _ESI);
unsigned __int64 __fastcall sub_407C0(unsigned __int64 _RDI, int _ESI);
int __fastcall sub_409B0(const __m128i *a1);
unsigned __int64 __fastcall sub_40B50(unsigned __int64 _RDI, __m128 _XMM0);
__int64 __fastcall sub_40CF0(__int64 _RDI, unsigned __int64 _RSI, unsigned __int64 _RDX, __m128 _XMM0);
_BYTE *__fastcall sub_41080(_BYTE *a1, _BYTE *a2);
_BYTE *__fastcall sub_41170(_BYTE *a1, _BYTE *a2);
_QWORD *__fastcall sub_41260(_QWORD *a1, _BYTE *a2);
unsigned __int64 __fastcall sub_42A10(_QWORD *a1, _BYTE *a2);
__int64 __fastcall sub_44220(__m128i *a1, const __m128i *a2);
__int64 __fastcall sub_44850(__m128i *a1, const __m128i *a2);
__int64 __fastcall sub_44F10(__int64 _RDI, unsigned __int64 _RSI, unsigned __int64 _RDX, __m128 _XMM0);
const __m128i *__fastcall sub_452C0(__int64 a1, unsigned int a2);
__int64 __fastcall sub_455E0(const __m128i *a1, const __m128i *a2, unsigned __int64 a3);
_BYTE *__fastcall sub_46D50(__int64 a1, unsigned __int8 *a2);
_BYTE *__fastcall sub_472A0(__int64 a1, const __m128i *a2);
unsigned __int64 __fastcall sub_473F0(unsigned __int64 _RDI, int _ESI, unsigned __int64 a3, __m128 _XMM0);
void sub_47670();
unsigned __int64 __fastcall sub_47680(unsigned __int64 a1, __int64 *a2, unsigned __int64 a3);
void sub_47A40();
__int64 *__fastcall sub_47A50(__int64 *_RDI, __int64 *_RSI, unsigned __int64 _RDX);
void sub_47E80();
__int64 *__fastcall sub_47E90(__int64 *_RDI, __int64 *_RSI, unsigned __int64 _RDX);
void sub_483D0();
__m128i *__fastcall sub_483F0(__m128i *a1, unsigned int a2, unsigned __int64 a3);
__int64 __fastcall sub_48440(__int64 a1);
__m128i *__fastcall sub_48460(__m128i *a1, char a2, unsigned __int64 a3);
void __fastcall sub_48550(__int64 a1, int _ESI);
_QWORD *__fastcall sub_48570(_QWORD *_RDI, int _ESI, unsigned __int64 _RDX);
void __fastcall sub_486D0(__int64 a1, int _ESI);
_QWORD *__fastcall sub_486F0(_QWORD *_RDI, int _ESI, unsigned __int64 _RDX);
__int64 __fastcall sub_48900(int a1);
__int64 __fastcall sub_48AE0(int a1);
__int64 __fastcall sub_48C20(int a1, int a2, _BYTE *a3, _BYTE *a4);
__int64 __fastcall sub_48E90(int a1);
__int64 __fastcall sub_48FC0(int a1);
__int64 __fastcall sub_49000(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_49010(__int64 a1, __int64 *a2, void **a3, __int64 *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, __int64 a13, __int64 a14);
__int64 __fastcall sub_49040(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6);
unsigned __int64 __fastcall sub_49110(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, u32 *a13, u32 a14);
int __fastcall sub_49450(__m128i *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14);
__int64 __fastcall sub_495A0(__int64 *a1, __int64 a2);
unsigned __int64 __fastcall time(time_t *tloc);
unsigned __int64 __fastcall sub_49A80(pid_t a1, int *a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
void __fastcall __noreturn sub_49B40(int a1);
__int64 __fastcall sub_49B90(void *); // weak
__int64 __fastcall sub_49C90(int a1, __int64 a2, int a3);
unsigned __int64 sub_4A0C0();
__int64 __fastcall sub_4A0F0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, u32 *a13, __int64 a14);
__int64 __fastcall sub_4A130(_OWORD *a1);
__int64 __fastcall sub_4A150(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_4A1C0(__int64 a1, __int64 a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_4A230(__int64 a1, __int64 a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
bool __fastcall sub_4A2C0(int a1, __int64 a2, int a3);
__int64 __fastcall sub_4A300(pid_t *a1, __int64 a2, __int64 a3, char *a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_4A320(pid_t *a1, __int64 a2, __int64 a3, char *a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, int a15, __int64 a16);
void __fastcall sub_4A5B0(__int64 a1);
__int64 __fastcall sub_4A990(pid_t *a1, __int64 a2, __int64 a3, char *a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, int a15);
rlim64_t sub_4A9C0();
unsigned __int64 __fastcall sub_4AA20(unsigned int a1, const char *a2, struct stat *a3);
unsigned __int64 __fastcall sub_4AA80(unsigned int a1, unsigned int a2, struct stat *a3);
int open(const char *, int, ...);
int __fastcall sub_4AC10(unsigned int a1, char *a2, size_t a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
unsigned __int64 __fastcall send(unsigned int a1, const void *a2, size_t a3);
unsigned __int64 __fastcall sub_4AD50(unsigned int a1, off_t a2, unsigned int a3);
unsigned __int64 __fastcall sub_4AD80(unsigned int a1, unsigned int a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
unsigned __int64 __fastcall close(unsigned int a1);
unsigned __int64 __fastcall sub_4AF10(unsigned int a1);
unsigned __int64 __fastcall sub_4AF40(unsigned int a1, unsigned int a2);
unsigned __int64 __fastcall sub_4AF70(int *a1, int a2);
unsigned __int64 __fastcall sub_4AFA0(const char *a1);
unsigned __int64 __fastcall sub_4AFD0(unsigned int a1);
__int64 __fastcall sub_4B000(__int64 a1, unsigned __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14);
unsigned __int64 __fastcall sub_4B740(const char *a1);
unsigned __int64 __fastcall sub_4B770(const char *a1);
unsigned __int64 __fastcall sub_4B7A0(unsigned int a1);
unsigned __int64 __fastcall sub_4B7D0(unsigned int a1, unsigned int a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7);
unsigned __int64 __fastcall sub_4B880(unsigned int a1, unsigned int a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_4B910(const char *filename, int flags, int a3);
unsigned __int64 __fastcall sub_4B9C0(int a1, const char *a2, int a3, int a4);
unsigned __int64 __fastcall sub_4BA60(unsigned int a1, char *a2, size_t a3);
unsigned __int64 __fastcall sub_4BA90(unsigned int a1, const char *a2, size_t a3);
unsigned __int64 __fastcall sub_4BAC0(unsigned int resource, struct rlimit64 *old_rlim);
unsigned __int64 __fastcall sub_4BB00(__int64 a1);
int ioctl(int fd, unsigned __int64 request, ...);
Elf64_Rela *__fastcall sub_4BBD0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
__int64 __fastcall sub_4BC10(); // weak
void *__fastcall mmap(void *addr, unsigned __int64 a2, unsigned __int64 a3, unsigned int a4, unsigned __int64 a5, unsigned __int64 a6);
unsigned __int64 __fastcall munmap(void *a1, size_t a2); // idb
unsigned __int64 __fastcall sub_4BD40(unsigned __int64 a1, size_t a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_4BD70(unsigned __int64 a1, size_t a2, int a3);
__int64 __fastcall sub_4BDA0(__int64 a1, void (__fastcall *a2)(__int64, _QWORD), __int64 a3);
__int64 __fastcall sub_4BE30(__int64 a1, void (__fastcall *a2)(__int64, __int64, __int64), __int64 a3);
__int64 (__fastcall *__fastcall sub_4BEC0(_QWORD *a1, double (__fastcall *a2)(_QWORD), double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10))(_QWORD, _QWORD);
unsigned __int64 __fastcall sub_4BF10(__int64 a1, _QWORD *a2, unsigned __int64 *a3, int a4, int a5, int a6);
__int64 __fastcall sub_4C080(__int64 a1, __int64 *a2, __int64 (__fastcall *a3)(__int64, _QWORD), __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, __int64 a13, u32 a14);
_QWORD *__fastcall sub_4C220(__int64 a1, _QWORD *a2, __int64 (__fastcall *a3)(__int64, _QWORD));
unsigned __int64 __fastcall sub_4C2A0(__int64 a1, __int64 *a2, __int64 (__fastcall *a3)(__int64, __int64), double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_4C850(__int64 a1, void (__fastcall *a2)(__int64, __int64, __int64), __int64 a3);
__int64 (__fastcall *__fastcall sub_4C870(_QWORD *a1, double (__fastcall *a2)(_QWORD), double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10))(_QWORD, _QWORD);
char *__fastcall sub_4C890(unsigned int a1, char *a2, _QWORD *a3, char **a4, char *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13);
__int64 __fastcall sub_4CA20(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
__int64 __fastcall sub_4CD40(__int64 a1, unsigned __int8 **a2, int a3);
__kernel_ulong_t sub_4CE40();
__kernel_ulong_t sub_4CED0();
__int64 __fastcall sub_4CF60(); // weak
void __fastcall sub_4CF80(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_4CFE0(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, void *a5);
unsigned __int64 __fastcall sub_4D040(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, unsigned __int64 a5);
unsigned __int64 __fastcall sub_4D070(struct sysinfo *a1);
unsigned __int64 __fastcall accept(int a1, struct sockaddr *a2, int *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
unsigned __int64 __fastcall bind(int a1, struct sokaddr *a2, int a3);
unsigned __int64 __fastcall listen(int a1, int a2);
unsigned __int64 __fastcall socket(int a1, int a2, int a3);
// void __noreturn __stack_chk_fail();
void __fastcall __noreturn sub_4D210(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall htonl(unsigned int a1);
__int16 __fastcall htons(__int16 a1);
void sub_4D260();
void **__fastcall sub_4D270(__int64 a1, __int64 a2);
__int64 __fastcall sub_4D2F0(unsigned __int64 a1);
unsigned __int64 __fastcall sub_4D380(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
_QWORD *__fastcall sub_4D500(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, u32 *a13, u32 a14);
__int64 __fastcall sub_4D9C0(__int64 a1);
__int64 __fastcall sub_4DA40(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_4DB40(__int64 a1, unsigned __int64 *a2);
__int64 __fastcall sub_4DBB0(_QWORD); // weak
__int64 __fastcall sub_4E120(unsigned int a1, char **a2, __int64 (__fastcall *a3)(char **));
__int64 __fastcall sub_4E190(__int64 *a1);
unsigned __int64 __fastcall sub_4E5B0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
void *sub_4F240();
__int64 sub_4F250(void); // weak
void __fastcall sub_4F2B0(__int64 a1);
void __fastcall sub_4F2E0(char **a1);
__int64 __fastcall sub_4FDD0(const __m128i **a1);
__int64 __fastcall sub_4FE60(const __m128i **a1);
__int64 sub_4FEF0(void); // weak
void __fastcall __noreturn sub_50000(__int64 a1, _BYTE *a2, const char *a3, __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
void __fastcall __noreturn sub_500B0(unsigned int a1, const __m128i *a2, const char *a3, __m128 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
void __fastcall __noreturn sub_50110(__int64 a1, _BYTE *a2, const char *a3, const char *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
__int64 __fastcall sub_50170(__int64 a1, void (__fastcall *a2)(__int64), __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_50290(_QWORD *a1, _QWORD *a2, bool *a3, void (__fastcall *a4)(__int64), __int64 a5, __int64 a6);
void **__fastcall sub_50300(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
unsigned __int64 __fastcall sub_50FA0(char a1);
void __fastcall sub_50FC0(unsigned int a1, _QWORD *a2, void *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_51050(__int64 a1, __int64 **a2, char a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_51370(_QWORD *a1, __int64 *a2, unsigned __int64 a3, __int64 *a4, __int64 a5, _QWORD *a6);
__int64 __fastcall sub_51590(__int64 *a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_515F0(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_51600(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_51660(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_516E0(void *a1, __int64 a2, void *a3, void *a4, __int64 *a5, unsigned __int64 *a6);
__int64 __fastcall sub_521F0(unsigned __int8 *a1, unsigned __int8 *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall sub_522D0(unsigned __int8 *a1, unsigned __int8 *a2, __int64 *a3, __int64 *a4, char a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13);
__int64 __fastcall sub_525E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6);
unsigned __int64 __fastcall sub_52730(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
void __fastcall sub_52AD0(__int64 a1, int a2);
_QWORD *__fastcall sub_52BE0(void *a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall sub_52C70(char *a1, __int64 a2, __int64 a3, int a4, __int64 a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13);
unsigned __int64 __fastcall sub_52FD0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
unsigned __int64 __fastcall sub_53490(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
__int64 __fastcall sub_534E0(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall sub_535D0(__int64 a1, char a2);
__int64 __fastcall sub_535F0(__int64 a1, unsigned __int64 *a2, __int64 *a3, unsigned __int64 a4, unsigned __int64 *a5, __int64 *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16);
__int64 __fastcall sub_53B20(__int64 a1, __int64 a2, unsigned int **a3, unsigned int *a4, int **a5, __int64 *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16);
__int64 __fastcall sub_54110(__int64 a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 a4, unsigned __int64 *a5, __int64 *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16);
__int64 __fastcall sub_54630(__int64 a1, __int64 a2, unsigned __int64 *a3, unsigned __int64 a4, _QWORD *a5, _QWORD *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16);
__int64 __fastcall sub_54C60(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, _QWORD *a5, _QWORD *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16);
__int64 __fastcall sub_55100(_QWORD *a1, __int64 a2, __int64 *a3, unsigned __int64 a4, _QWORD *a5, __int64 *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16);
__int64 __fastcall sub_55D30(_QWORD *a1, __int64 a2, __int64 *a3, unsigned __int64 a4, _QWORD *a5, _QWORD *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16);
__int64 __fastcall sub_56A10(__int64 a1, __int64 a2, unsigned __int8 **a3, unsigned __int64 a4, unsigned int **a5, _QWORD *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, int a16);
__int64 __fastcall sub_57700(__int64 a1, __int64 a2, unsigned __int64 *a3, unsigned __int64 a4, _QWORD *a5, _QWORD *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16);
__int64 __fastcall sub_57E60(_QWORD *a1, __int64 a2, __int64 *a3, unsigned __int64 a4, char **a5, __int64 *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16);
__int64 __fastcall sub_58B30(__int64 a1, __int64 a2, unsigned __int64 *a3, unsigned __int64 a4, _QWORD *a5, __int64 *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16);
__int64 __fastcall sub_592D0(_QWORD *a1, __int64 a2, __int64 *a3, unsigned __int64 a4, char **a5, __int64 *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16);
__int64 __fastcall sub_59FA0(_QWORD *a1, __int64 a2, __int64 a3, unsigned int **a4, unsigned __int64 a5, __int64 *a6, _QWORD *a7);
__int64 __fastcall sub_5A460(unsigned __int8 *a1, _QWORD *a2);
__int64 __fastcall sub_5A540(__int64 a1, const void *a2, _QWORD *a3);
__int64 __fastcall sub_5A660(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
__int64 __fastcall sub_5A880(unsigned __int8 *a1, unsigned __int8 *a2, _DWORD *a3);
__int64 __fastcall sub_5A920(unsigned __int8 *a1, unsigned __int8 *a2, __int64 *a3, __int64 *a4, char a5);
__int64 __fastcall sub_5AE00(__int64 a1);
__int64 __fastcall sub_5AE20(_QWORD *a1, _QWORD *a2);
void __fastcall sub_5AE30(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_5AEB0(void *a1);
__int64 __fastcall sub_5B0B0(__int64 a1);
char *__fastcall sub_5B0D0(int a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
void **__fastcall sub_5B980(char *a1, size_t a2, int a3, __int64 **a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
__int64 __fastcall sub_5C1E0(unsigned int a1, unsigned int *a2, unsigned __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
unsigned __int64 __fastcall sub_5C440(__int64 a1, unsigned int a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 (__fastcall *__fastcall sub_5C7A0(__int64 a1, size_t a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14))(_QWORD, _QWORD);
size_t __fastcall sub_5C800(int a1, __int64 **a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
void *sub_5CD70();
__int64 __fastcall sub_5CDF0(int a1);
unsigned __int64 sub_5CE70();
__int64 sub_5CED0(void); // weak
__int64 __fastcall sub_5CF30(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7);
__int64 __fastcall sub_5CFE0(__int64 a1);
__int64 __fastcall sub_5D080(unsigned __int64 a1, __int64 a2);
__int64 __fastcall sub_5D090(int a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_5D270(int a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_5D2B0(int a1, const __m128i *a2, sigset_t *a3);
unsigned __int64 __fastcall sub_5D2F0(char *a1, unsigned __int64 a2, unsigned __int64 a3, int (__fastcall *a4)(_QWORD, _QWORD, _QWORD), __int64 a5);
__int64 __fastcall sub_5D780(__int64 a1, void *a2, void *a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
__int64 __fastcall sub_5DBA0(_BYTE *a1);
__int64 __fastcall sub_5DD00(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14);
__int64 __fastcall sub_5DDD0(_BYTE *a1);
unsigned __int64 __fastcall sub_5DE10(unsigned __int8 *a1, unsigned __int8 **a2, unsigned int a3);
__int64 sub_5E360(__int64 a1, unsigned __int64 a2, ...);
__int64 sub_5E420(char *a1, __int64 a2, __int64 a3, ...);
__int64 __fastcall sub_5E560(unsigned __int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5);
__int64 __fastcall sub_5E680(_QWORD *a1, unsigned __int8 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
_QWORD *__fastcall sub_5E770(__int64 a1, __int64 a2, _QWORD *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 sub_5EA90(void); // weak
__int64 __fastcall sub_5EE80(__int64 a1, __int64 a2, int a3, __m128 a4, __m128 a5, __m128 a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, __int64 a13, int a14, int a15, _BYTE *a16, char *a17, unsigned int a18, char *a19, __int64 a20, char a21);
__int64 __fastcall sub_61370(__int64 a1, unsigned __int64 a2, __m128i *a3, unsigned int a4, __m128 a5, double a6, __m128i a7, __m128 a8, double a9, double a10, double a11, double a12);
__int64 __fastcall sub_636E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
__int64 __fastcall sub_63960(int **a1);
__int64 __fastcall sub_639E0(__int64 a1, unsigned int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14);
__int64 __fastcall sub_63B00(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, int a5);
char *__fastcall sub_63BE0(char *a1, __int64 a2, char *a3);
void __fastcall __noreturn sub_63D50(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
__int64 __fastcall sub_63D80(__int64 a1, __int64 a2, int a3, int a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_64130(_QWORD *a1, __int64 a2, int a3, __m128 a4, __m128 a5, __m128 a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, unsigned __int64 a13, int a14, int a15, _DWORD *a16, char *a17, unsigned int a18, _BYTE *a19, int a20, char a21);
__int64 __fastcall sub_66830(_QWORD *a1, __int64 a2, __m128i *a3, __int64 a4, u32 *a5, u32 a6, __m128 a7, double a8, __m128i a9, __m128 a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_68C50(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
char *__fastcall sub_68F10(unsigned int a1);
__int64 __fastcall sub_68F70(__int64 *a1);
__int64 __fastcall sub_68FF0(__int64 a1, int a2, __int64 a3, __int64 *a4);
__int64 __fastcall sub_695C0(int **a1);
__int64 __fastcall sub_69640(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_69C30(__int64 a1, _WORD *a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_69DA0(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall sub_69F20(__int64 a1, _WORD *a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_69FB0(const char **a1, unsigned __int64 *a2, unsigned int a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_6A2A0(__int64 a1, int a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_6A3E0(__int64 a1, int a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_6A520(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall sub_6A820(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_6A890(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
void __fastcall sub_6AA40(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14);
__int64 __fastcall sub_6AAD0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_6AB50(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_6ABD0(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, u32 *a13, u32 a14);
_QWORD *__fastcall sub_6AD40(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall sub_6ADE0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_6AE60(int *a1);
_QWORD *__fastcall sub_6AEE0(int *a1);
__int64 __fastcall sub_6B0C0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, u32 *a13, u32 a14);
unsigned __int64 __fastcall sub_6B220(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_6B660(__int64 a1, unsigned int a2);
__int64 __fastcall sub_6B6D0(char *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5);
void __fastcall sub_6B7F0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
void __fastcall sub_6B870(char a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_6B920(int a1, const __m128i *a2, sigset_t *a3);
__int64 __fastcall sub_6BA10(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, u32 *a13, u32 a14);
__int64 __fastcall sub_6BAD0(__int64 *a1, unsigned __int64 a2, __int64 a3);
void *__fastcall sub_6BB80(void *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
void *sub_6BBD0();
void *sub_6BC00();
_BYTE *__fastcall sub_6BC30(_BYTE *a1, __int64 a2, _BYTE **a3);
unsigned __int64 __fastcall sub_6BCB0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4);
unsigned __int64 __fastcall sub_6C060(unsigned __int8 *a1, unsigned __int64 a2, unsigned __int8 *a3, unsigned __int64 a4);
__int64 __fastcall sub_6C2B0(__int64 a1, __int64 a2, __int64 *a3, __int64 *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
__int64 __fastcall sub_6C390(const char **a1, _QWORD *a2, __int64 a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
char *__fastcall sub_6C460(const __m128i *a1, unsigned int a2);
unsigned __int64 __fastcall sub_6C760(__int64 _RDI, unsigned __int64 a2, __m128 _XMM0);
char *__fastcall sub_6C930(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_6CB50(unsigned __int64 _RDI, unsigned __int64 a2, __m128 _XMM0);
void *sub_6CE70();
void *__fastcall sub_6CEA0(void *a1, const void *a2, __int64 a3);
__int64 __fastcall sub_6CEB0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_6CEC0(unsigned int a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14);
__int64 __fastcall sub_6D090(char *a1, __int64 a2, void *a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_6D280(__int64 a1, __int64 *a2, __int64 a3, __int64 *a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
void *sub_6D580();
_DWORD *__fastcall sub_6D5D0(_DWORD *a1, int a2);
unsigned __int64 __fastcall sub_6D5F0(__int64 a1, __int64 a2);
__int64 __fastcall sub_6D810(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_6D850(_DWORD *a1);
unsigned __int64 __fastcall sub_6DAF0(unsigned __int64 _RDI, __m128 _XMM0);
unsigned __int64 __fastcall sub_6DCB0(unsigned __int64 _RDI, __int64 a2, __m128 _XMM0);
unsigned __int64 __fastcall sub_6E000(const clockid_t which_clock, struct timespec *tp);
__int64 __fastcall sub_6E070(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_6E270(const char *a1, __int64 a2, int a3);
unsigned __int64 __fastcall sub_6E2B0(unsigned int *a1);
int __fastcall sub_6E2E0(__int64 _RDI, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6);
__int64 __fastcall sub_6E3A0(__int64 _RDI, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6);
__int64 __fastcall sub_6E4B0(unsigned int a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
unsigned __int64 __fastcall sub_6E570(struct old_utsname *a1);
unsigned __int64 __fastcall sub_6E5A0(const char *a1, const char *const *a2, const char *const *a3);
unsigned __int64 __fastcall sub_6E5D0(const char *a1, _QWORD *a2, const char *const *a3);
__int64 __fastcall sub_6E6E0(const char *a1, const char **a2, const char *const *a3, char a4);
__int64 __fastcall sub_6EA10(const char *a1, const char **a2, const char *const *a3);
signed __int64 sub_6EA20();
signed __int64 sub_6EA30();
signed __int64 sub_6EA40();
signed __int64 sub_6EA50();
unsigned __int64 __fastcall sub_6EA60(pid_t a1, pid_t a2);
unsigned __int64 sub_6EA90();
unsigned __int64 __fastcall sub_6EAC0(pid_t a1, struct sched_param *a2);
unsigned __int64 __fastcall sub_6EAF0(pid_t a1, int a2, struct sched_param *a3);
__int64 __fastcall sub_6EB20(unsigned int a1);
unsigned __int64 __fastcall sub_6EB80(unsigned int a1, int a2, const char *a3, struct stat *a4, int a5);
_BOOL8 __fastcall sub_6EBE0(unsigned int a1);
__int64 __fastcall sub_6EC30(unsigned int a1);
__int64 __fastcall sub_6ED00(unsigned __int64 a1);
__int64 __fastcall sub_6ED60(__int64 a1);
__int64 __fastcall sub_6EDF0(unsigned int a1, _DWORD *a2);
__int64 __fastcall sub_6EE40(unsigned __int64 a1, unsigned __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall sub_6F050(_BYTE *a1, __int64 a2);
_BOOL8 __fastcall sub_6F100(char *a1, __int64 a2);
void __fastcall __noreturn sub_6F220(unsigned int a1, unsigned int a2, _BYTE *a3, __int64 a4, __int64 a5, const char *a6, double xmm0_8_0, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a7);
__int64 __fastcall sub_6F2A0(const char *a1, __int64 a2, _BYTE *a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
void __fastcall sub_6F850(__int64 a1, __int64 *a2);
__int64 __fastcall sub_6F920(__int64 a1, __int64 a2, int a3, __int64 *a4, _QWORD *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, _BYTE *a16);
void *__fastcall sub_6FF90(_QWORD *a1, _BYTE *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall sub_70080(__int64 a1);
char *__fastcall sub_70130(__int64 a1, char *a2, char *a3);
char *__fastcall sub_702B0(__int64 a1, void *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
char *__fastcall sub_703B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, const void *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_70670(__int64 a1, _BYTE *a2, __int64 a3, __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
const char *__fastcall sub_70840(_BYTE *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
_QWORD *__fastcall sub_70A70(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_70AE0(_BYTE *a1, unsigned int a2, __int64 a3, char *a4, _QWORD *r8_0, char a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, int a15, __int64 a16, __int64 a17);
__int64 __fastcall sub_71D90(__int64 a1, _BYTE *a2, char a3, int a4, int a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
unsigned int *__fastcall sub_728F0(__int64 a1, unsigned int *a2, __int64 a3, char a4, unsigned __int8 a5, unsigned int *a6, double xmm0_8_0, double xmm1_8_0, double xmm2_8_0, double xmm3_8_0, double xmm4_8_0, double a12, double a13, double a14, unsigned int a7, __int64 a8, __int64 a9, unsigned int **a10, _DWORD *a11);
__int64 __fastcall sub_72A80(unsigned __int8 *a1, unsigned __int64 a2, unsigned __int64 *a3, unsigned int *a4, unsigned int **a5, __int64 *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, __int64 a16, char a17, __int64 a18, int a19, __int64 a20);
__int64 __fastcall sub_73690(unsigned __int8 *a1, __int64 a2, unsigned int **a3, __int64 **a4, const char **a5, int a6, __m128 a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, int a15, __int64 a16);
unsigned int *__fastcall sub_741B0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_74270(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_74330(char *a1, const void *a2, char a3, _QWORD *a4, char a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_74640(__int64 a1, char a2);
__int64 __fastcall sub_74730(__int64 a1);
__int64 __fastcall sub_74770(_QWORD *a1);
unsigned __int64 __fastcall sub_747C0(__int64 a1);
void __fastcall __noreturn sub_74830(__int64 a1, unsigned int a2);
void __fastcall sub_74900(__int64 a1, __int64 **a2, int a3, int a4, u32 *a5, void (*a6)(void), double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
_QWORD *__fastcall sub_76190(__int64 *a1, _QWORD *a2, __int64 *a3, _QWORD *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
signed __int64 __fastcall sub_76770(int a1, int a2, _BYTE *a3, int *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
__int64 __fastcall sub_76E00(const char *a1, __off_t *a2, unsigned int a3);
signed __int64 sub_76EA0(_BYTE *a1, ...);
signed __int64 sub_76F50(_BYTE *a1, ...);
signed __int64 sub_77150(_BYTE *a1, ...);
void __noreturn sub_77200(_BYTE *a1, ...);
__int64 __fastcall sub_772B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_77320(unsigned __int64 a1);
unsigned __int64 __fastcall sub_77370(char *a1, char **a2);
__int64 __fastcall sub_774E0(__m128 a1, __m128 a2, __m128 a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14);
void __fastcall sub_77C60(__int64 a1, __int64 a2);
__int64 __fastcall sub_77EB0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
__int64 __fastcall sub_78000(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
unsigned int __fastcall sub_780E0(_QWORD *a1);
__int64 __fastcall sub_78A30(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __m128 a7, __m128 a8, __m128 a9, __m128 a10, __m128 a11, __m128 a12, __m128 a13, __m128 a14, unsigned int a15, __int64 a16, __int64 a17);
__int64 __fastcall sub_78C30(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, unsigned int a15);
__int64 __fastcall sub_78CB0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, __int64 a16, __int64 a17, __int64 a18, __int64 a19, int a20, char a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63);
__int64 __fastcall sub_78D80(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, __int64 a16, __int64 a17, __int64 a18, __int64 a19, __int64 a20, char a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63);
void __noreturn sub_78E40();
const char *__fastcall sub_78E60(const char **a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
void *__fastcall sub_78F10(_QWORD *a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6, double xmm0_8_0, double a8, double a9, double a10, double a11, double a12, double a13, double a14, char a7);
__int64 __fastcall sub_79330(_QWORD *a1);
__int64 __fastcall sub_79360(char *a1, char *a2);
void *__fastcall sub_79440(char *a1);
__int64 sub_79A50();
__int64 __fastcall sub_79A90(); // weak
unsigned __int64 __fastcall sub_79AA0();
__int64 __fastcall sub_79AC0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __m128 a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_79B40(); // weak
__int64 __fastcall sub_79BC0(__int64 a1);
__int64 __fastcall sub_79C00(void (__fastcall *a1)(__int64), __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_79C80(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_79D10(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 *a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall sub_79E70(__int64 *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_79F00(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_79F40(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_79F80(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_79F90(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_7A020(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_7A0B0(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
_QWORD *__fastcall sub_7A160(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_7A1B0(unsigned __int64 a1, __int64 a2, unsigned int a3, int a4);
__int64 __fastcall sub_7A300(__int64 a1);
_QWORD *__fastcall sub_7A450(__int64 a1, __int64 a2, _QWORD *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall sub_7D1B0(_QWORD *a1, __int64 a2, const __m128i **a3, __m128i a4, __m128 a5, __m128i a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, __int64 a13, __int64 a14);
__int64 __fastcall sub_7D370(_QWORD *a1, unsigned __int64 a2, const __m128i **a3, __m128 a4, __m128 a5, __m128 a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, u32 *a13);
__int64 __fastcall sub_7F220(unsigned __int8 **a1, __int64 a2);
__int64 __fastcall sub_7F2F0(unsigned int **a1, __int64 a2);
signed __int64 __fastcall sub_7F4E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6);
void *sub_7F530();
__int64 (__fastcall *__fastcall sub_7F580(__int64 a1, u32 *a2, __int64 a3, unsigned __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, __int64 a13, __int64 a14))(_QWORD, _QWORD);
__int64 __fastcall sub_7F5F0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14);
_BOOL8 __fastcall sub_7F870(void (__fastcall *a1)(__int64), __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14);
_QWORD *__fastcall sub_7F9E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_7FA10(unsigned __int64 a1, _QWORD *a2);
void __fastcall sub_7FA20(__int64 a1, _QWORD *a2);
void __fastcall sub_7FA50(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
_BOOL8 __fastcall sub_7FB30(__int64 a1, int a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_7FB90(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_7FC00(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
unsigned __int8 *__fastcall sub_7FC80(unsigned int a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
signed __int64 (__fastcall *sub_7FCA0())(__m128i *a1, const __m128i *a2);
__int64 __fastcall sub_7FCC0(_QWORD *a1, __int64 a2);
signed __int64 __fastcall sub_7FED0(__m128i *a1, const __m128i *a2);
void *sub_80000();
void *sub_80030();
__int64 __fastcall sub_80080(const __m128i *a1, unsigned int a2, __int64 a3);
unsigned __int64 __fastcall sub_803B0(unsigned __int64 a1, int _ESI, __int64 a3);
unsigned __int64 __fastcall sub_80680(unsigned int a1, struct linux_dirent64 *a2, unsigned __int64 a3);
signed __int64 sub_806C0();
unsigned __int64 __fastcall sub_806D0(unsigned __int64 a1, char *a2, size_t a3, loff_t a4);
unsigned __int64 __fastcall sub_80710(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_80760(__int64 a1, unsigned __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_80920(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *__fastcall sub_80930(__int64 a1, unsigned int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10))(unsigned __int8 *, __int64 *, __int64);
__int64 (__fastcall *__fastcall sub_80AF0(__int64 a1, unsigned int a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, _QWORD *a13))(unsigned __int8 *, __int64 *, __int64);
void sub_80D40();
_DWORD *__fastcall sub_80D50(__int64 a1);
__int64 __fastcall sub_80EB0(__int64 *a1);
void __fastcall __noreturn sub_80ED0(_BYTE **a1);
unsigned __int64 __fastcall sub_80EF0(__int64 a1);
_QWORD *__fastcall sub_81070(unsigned __int64 a1);
__int64 __fastcall sub_81120(_BYTE *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7);
signed __int64 __fastcall sub_81380(_QWORD *a1, unsigned int a2);
__int64 __fastcall sub_814C0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
void (**__fastcall sub_81E80(_QWORD *a1))(void);
__int64 __fastcall sub_81F00(__int64 a1, unsigned __int64 *a2, __int64 a3, unsigned __int8 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
__int64 __fastcall sub_82030(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_8203E(__int64 a1, char a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12);
__int64 __fastcall sub_82F70(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
void __fastcall sub_83000(__int64 a1, unsigned int a2, __int64 a3, char a4);
void __fastcall sub_832B0(__int64 *a1, unsigned __int8 a2);
unsigned __int64 (__fastcall *__fastcall sub_83340(__int64 a1, __int64 a2, __m128 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10))();
__int64 __fastcall sub_834E0(__int64 a1);
unsigned __int64 __fastcall sub_83550(__int64 a1);
__int64 __fastcall sub_83570(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4, int a5);
__int64 __fastcall sub_83B60(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_83BE0(unsigned __int64 *a1);
__int64 __fastcall sub_83D80(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_83DC0(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4, __int64 *a5, __int64 a6);
unsigned __int64 __fastcall sub_841E0(__int64 a1, __int64 a2, unsigned __int64 a3, char a4);
unsigned __int64 __fastcall sub_84300(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 a3, char a4);
__int64 __fastcall sub_84410(__int64 *a1, __int64 *a2, __int64 a3, unsigned __int64 *a4, __int64 a5);
__int64 __fastcall sub_847C0(_QWORD *a1, _QWORD *a2, __int64 a3, unsigned __int64 a4);
unsigned __int64 __fastcall sub_848E0(_QWORD *a1, __int64 *a2, unsigned __int64 *a3, __int64 a4);
__int64 __fastcall sub_849E0(__int64 *a1, __int64 *a2, unsigned __int64 *a3, __int64 a4, __int64 *a5);
unsigned __int64 __fastcall sub_84E90(_QWORD *a1, unsigned __int64 *a2, __int64 a3);
__int64 __fastcall sub_84F90(unsigned __int64 *a1, unsigned __int64 *a2, __int64 a3, __int64 *a4);
_BOOL8 __fastcall sub_85440(__int64 a1, unsigned __int64 *a2, __int64 *a3, __int64 a4);
unsigned __int64 __fastcall sub_854F0(unsigned __int64 *a1, unsigned __int64 *a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall sub_855E0(__int64 *a1, double a2, __int64 a3, _DWORD *a4, _DWORD *a5);
__int64 __fastcall sub_85670(_QWORD *a1, __int64 a2, _DWORD *a3, int *a4, __int64 a5, __int64 a6, __int64 a7, __int16 a8);
__int64 __fastcall sub_85730(_QWORD *a1, __m128i a2, __int64 a3, _DWORD *a4, _DWORD *a5);
__int64 __fastcall sub_85860(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_858E0(__int64 a1, int a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_85960(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
_BOOL8 __fastcall sub_85970(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14);
__int64 (__fastcall *__fastcall sub_859A0(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9))(__m128i *, __int64 (__fastcall *)(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9));
__int64 __fastcall sub_859C0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 (__fastcall *__fastcall sub_85A60(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9))(__m128i *, __int64 (__fastcall *)(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9));
__int64 __fastcall sub_85A90(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
unsigned __int64 __fastcall sub_85B30(int a1, struct itimerval *a2, struct itimerval *a3);
__int64 __fastcall sub_85B60(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_85BF0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall sub_85C30(__int64 a1, __int64 *a2, unsigned int a3, int a4, int a5);
__int64 __fastcall sub_86CD0(__int64 a1, unsigned int a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_86F50(_QWORD *a1, unsigned int a2, unsigned int a3, __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
unsigned int *__fastcall sub_876C0(_QWORD *a1, __int64 a2, __int64 a3, int a4, unsigned int a5);
unsigned int *__fastcall sub_87780(__int64 a1, unsigned __int8 *a2, unsigned int a3, __int64 a4, int a5);
__int64 __fastcall sub_87950(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 (__fastcall *__fastcall sub_87990(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3, const char **a4, int a5, __m128 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13))(__m128i *, __int64 (__fastcall *)(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9));
__int64 (__fastcall *__fastcall sub_87BD0(__int64 a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int64 a4, __m128 a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12))(__m128i *, __int64 (__fastcall *)(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9));
__int64 (__fastcall *__fastcall sub_87CD0(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3, __m128 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11))(__m128i *, __int64 (__fastcall *)(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9));
__int64 __fastcall sub_87CF0(__int64 a1, __int64 *a2, __int64 *a3, __int64 a4);
unsigned __int64 __fastcall sub_87DA0(__int64 *a1, unsigned __int64 *a2, __int64 a3, unsigned __int64 a4);
unsigned __int64 __fastcall sub_87E90(__m128 a1, __m128 a2);
unsigned __int64 __fastcall sub_880A0(__m128 a1, __m128 a2);
float __fastcall sub_88330(char a1);
void sub_883B0();
char *__fastcall sub_88430(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_885D0(__int64 a1, char a2, __int64 a3, _QWORD *a4);
__int64 __fastcall sub_88780(_BYTE *a1, unsigned __int64 a2, __int64 a3, __int64 a4);
unsigned __int64 __fastcall sub_88EB0(const __m128i *a1, __int64 a2);
void __fastcall sub_892F0(char *a1, unsigned __int64 a2, __int64 a3, _QWORD *a4);
void sub_89B47();
__int64 __fastcall sub_89B60(_QWORD *a1, char *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14);
unsigned __int64 __fastcall sub_8A1D0(__m128i *a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, u32 *a13, u32 a14);
__int64 __fastcall sub_8A350(_QWORD *a1, __m128i *a2, __int64 *a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_8A4A0(_QWORD *a1, __m128i *a2, __int64 *a3, char *a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_8A680(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_8A6F0(__int64 a1, _DWORD *a2);
void __fastcall sub_8A710(__int64 a1, __int64 a2);
__int64 __fastcall sub_8A720(__int64 a1);
__int64 __fastcall sub_8A730(__int64 a1);
__int64 __fastcall sub_8A770(__int64 a1);
__int64 __fastcall sub_8A780(__int64 a1);
void sub_8A8B0();
__int64 __fastcall sub_8A8C0(_QWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, u32 *a13, u32 a14, char a15);
__int64 __fastcall sub_8AC80(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, char a15);
void __fastcall __spoils<rdx,rcx,r8,r9,r10,r11,xmm0,xmm4,xmm5> sub_8AE60(_QWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, u32 *a13, u32 a14, char a15);
__int64 __fastcall sub_8B040(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, char a15);
__int64 __fastcall sub_8B190(unsigned int (__fastcall *a1)(__m128i *, __int64), __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14, char a15);
__int64 __fastcall sub_8B2A0(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_8B2C0(__int64 a1, __int64 (__fastcall *a2)(__int64, __int64, __int64), __int64 a3, int a4, int a5);
void __fastcall sub_8B390(__int64 a1, __int64 (__fastcall *a2)(__int64, __int64, __int64), __int64 a3);
_QWORD *__fastcall sub_8B440(char a1, __int64 a2, __int64 a3, _QWORD *a4);
__int64 __fastcall sub_8B590(_BYTE *a1);
__int64 __fastcall sub_8B6C0(__int64 a1, unsigned int *a2);
__int64 __fastcall sub_8B8B0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_8B970(__int64 a1, __int64 a2, __int64 a3);
__int16 __fastcall sub_8BAA0(__int64 a1, __int64 *a2, unsigned int *a3);
unsigned int *__fastcall sub_8BD50(__int64 a1, unsigned int *a2, __int64 a3);
__int64 __fastcall sub_8C060(__int64 *a1, unsigned __int64 a2, __int64 a3);
unsigned int *__fastcall sub_8C610(__int64 a1, unsigned int *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14);
__int64 __fastcall sub_8D160(_DWORD *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 *a12, u32 *a13, __int64 a14);
unsigned int *__fastcall sub_8D2D0(unsigned int *a1, _QWORD *a2, __int64 *a3, unsigned __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall sub_8D540(char a1, __int64 a2);
_QWORD *__fastcall sub_8D5D0(char a1, __int64 a2, __int64 a3, _QWORD *a4);
__int64 __fastcall sub_8D720(int a1, char a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_8DA20(__int64 (__fastcall *a1)(__int64 *, __int64, __int64), __int64 a2);
__int64 (__fastcall *__fastcall sub_8DB50(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14))(_QWORD, _QWORD);
__int64 (__fastcall *__fastcall sub_8DC10(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, size_t a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14))(_QWORD, _QWORD);
__int64 (__fastcall *__fastcall sub_8DC70(__int64 a1, size_t a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14))(_QWORD, _QWORD);
__int64 (__fastcall *__fastcall sub_8DD60(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14))(_QWORD, _QWORD);
__int64 (__fastcall *__fastcall sub_8DDB0(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14))(_QWORD, _QWORD);
_BYTE *__fastcall sub_8DE70(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
_BYTE *__fastcall sub_8DEC0(__int64 a1, __int64 (__fastcall *(__fastcall *a2)(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14))(_QWORD, _QWORD), __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
void *__fastcall sub_8DF30(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14);
unsigned __int64 __fastcall sub_8DF60(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14);
__int64 (__fastcall *__fastcall sub_8DFA0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14))(_QWORD, _QWORD);
__int64 (__fastcall *__fastcall sub_8DFC0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8))(_QWORD, _QWORD);
__int64 (*__fastcall sub_8DFF0(int a1, size_t a2, void **a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14))(void);
void __fastcall sub_8E0A0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, size_t a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14);
__int64 (__fastcall *__fastcall sub_8E3C0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14))(_QWORD, _QWORD);
__int64 __fastcall sub_8E3F0(unsigned __int64 **a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 (__fastcall *__fastcall sub_8E480(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14))(_QWORD, _QWORD);
__int64 (__fastcall *__fastcall sub_8E5A0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14))(_QWORD, _QWORD);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

__int64 (*dword_0)(void) = (__int64 (*)(void))0x3010102464C457FLL; // weak
char byte_6 = '\x01'; // weak
char byte_8[] = { '\0' }; // weak
char byte_9[7] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
__int16 word_10 = 3; // weak
void (__fastcall __noreturn *off_18)() = &start; // weak
__int64 qword_20[] = { 64LL }; // weak
__int64 qword_28[] = { 788056LL }; // weak
int dword_30 = 0; // weak
int dword_40 = 1; // weak
__int64 qword_50 = 0LL; // weak
__int64 qword_60 = 33784LL; // weak
int dword_78 = 1; // weak
__int64 qword_80 = 36864LL; // weak
__int64 qword_C8 = 585728LL; // weak
__int64 qword_198 = 761120LL; // weak
void *off_1D8 = &unk_AC670; // weak
int dword_200 = 1685382481; // weak
char byte_280[20] =
{
  '\x90',
  '\x83',
  '\x87',
  '\xD0',
  's',
  'j',
  '\x98',
  '\x1B',
  'K',
  '\x83',
  '#',
  'Z',
  'r',
  '{',
  'A',
  '\xD7',
  '\x96',
  '\xEB',
  '\xC3',
  '\xED'
}; // weak
Elf64_Rela stru_3E8 = { 765312uLL, 8uLL, 774144LL }; // weak
Elf64_Rela stru_8C8 = { 765920uLL, 8uLL, 669550LL }; // weak
Elf64_Rela stru_1000 = { 766696uLL, 8uLL, 399264LL }; // weak
Elf64_Rela stru_1FF0 = { 768152uLL, 8uLL, 413872LL }; // weak
Elf64_Rela stru_2020 = { 768168uLL, 8uLL, 413840LL }; // weak
Elf64_Rela stru_2FF8 = { 769616uLL, 8uLL, 422704LL }; // weak
Elf64_Rela stru_8020 = { 787080uLL, 8uLL, 107984LL }; // weak
_UNKNOWN loc_FFFC; // weak
_UNKNOWN loc_20000; // weak
_UNKNOWN loc_20042; // weak
_UNKNOWN loc_236D0; // weak
_UNKNOWN loc_27FFD; // weak
_UNKNOWN loc_31068; // weak
_UNKNOWN loc_3FFFD; // weak
_UNKNOWN loc_40150; // weak
_UNKNOWN loc_471F0; // weak
_UNKNOWN loc_476C0; // weak
_UNKNOWN loc_476F0; // weak
_UNKNOWN loc_47730; // weak
_UNKNOWN loc_47740; // weak
_UNKNOWN loc_47A90; // weak
_UNKNOWN loc_47AA0; // weak
_UNKNOWN loc_47ED0; // weak
_UNKNOWN loc_47EE0; // weak
_UNKNOWN loc_5E4E0; // weak
_UNKNOWN loc_5EAC0; // weak
_UNKNOWN loc_60000; // weak
_UNKNOWN sub_78130; // weak
_UNKNOWN sub_785B0; // weak
_UNKNOWN loc_7FE20; // weak
char byte_7FFFF = '\x90'; // weak
filedesc g_files[21] =
{
  { 8053871312753130136uLL, -1LL },
  { 6358060479430109957uLL, -1LL },
  { 7444838242612745115uLL, -1LL },
  { 624832810405902604uLL, 3432049662LL },
  { 2093604997323443034uLL, 3432049662LL },
  { 4218420224075904135uLL, 3432049662LL },
  { 3625760418553805431uLL, 3432049662LL },
  { 5106168677559809944uLL, 3432049662LL },
  { 5540153297377940183uLL, 3432049662LL },
  { 4703183482490277324uLL, 3432049662LL },
  { 7447718283600799817uLL, 0LL },
  { 4263859378937521387uLL, 0LL },
  { 6392802491245051107uLL, 0LL },
  { 2823736633628760641uLL, 0LL },
  { 18149254671986122202uLL, 0LL },
  { 17106791112360743998uLL, 4096LL },
  { 7536276361534256706uLL, -1LL },
  { 7498967280090894431uLL, 3432049662LL },
  { 6466555557455139565uLL, 0LL },
  { 8497728679412615671uLL, 0LL },
  { 15421389320240577600uLL, 4096LL }
};
char g_sstic_pwcheck[769] =
{
  'N',
  '\x01',
  '@',
  ' ',
  'B',
  '\x1B',
  '\0',
  '\0',
  '\t',
  '\x1B',
  '\x10',
  '\0',
  '\f',
  '\xE3',
  '$',
  '\x10',
  '\t',
  '\x02',
  '\x06',
  '\0',
  '\f',
  'c',
  '\x1C',
  '\x10',
  'L',
  '\x03',
  '\xAC',
  '\x10',
  '\0',
  '\x1B',
  '\x01',
  '\0',
  'L',
  '\x03',
  '\b',
  '\x10',
  'N',
  '\x05',
  '\0',
  '\x02',
  '\x19',
  'b',
  '\x01',
  '\0',
  '\x1C',
  '#',
  '\xAC',
  '\x10',
  ')',
  'A',
  '\x10',
  '\x02',
  ',',
  '\xE3',
  '<',
  '\x10',
  'L',
  '\x03',
  '\xAC',
  '\x10',
  '9',
  '!',
  ' ',
  '\x02',
  '<',
  '#',
  '\xAC',
  '\x10',
  'E',
  '\x16',
  '\x05',
  '\0',
  ' ',
  '\x17',
  '\r',
  '\a',
  '\'',
  '\x17',
  '\x10',
  '\0',
  ' ',
  '\x17',
  '\0',
  '\f',
  ')',
  '\x02',
  '\x05',
  '\0',
  ',',
  'c',
  '`',
  '\x10',
  'L',
  '\x03',
  '\xAC',
  '\x10',
  'E',
  '\x16',
  '\x05',
  '\0',
  ' ',
  '\x17',
  '\x06',
  '\x01',
  '\'',
  '\x17',
  '\x10',
  '\0',
  ' ',
  '\x17',
  '\x0F',
  '\x02',
  ')',
  '\x02',
  '\x05',
  '\0',
  ',',
  'c',
  '|',
  '\x10',
  'L',
  '\x03',
  '\xAC',
  '\x10',
  '\x19',
  '\x03',
  '\b',
  '\x04',
  '\x1C',
  'c',
  '\x88',
  '\x10',
  'L',
  '\x03',
  '\xAC',
  '\x10',
  'B',
  '\x1F',
  '\0',
  '\x11',
  'I',
  '\x1F',
  '\0',
  '\x13',
  'L',
  '\xE3',
  '\xA8',
  '\x10',
  'N',
  '\x04',
  '\a',
  '\0',
  'E',
  '\x06',
  '\0',
  '\0',
  'O',
  '\x04',
  '\a',
  '\0',
  '@',
  '\x1F',
  '\x10',
  '\0',
  'L',
  '\x03',
  '\x8C',
  '\x10',
  '}',
  '\x03',
  '\0',
  '\x11',
  '\v',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  'K',
  '\x05',
  '\x04',
  '\n',
  'A',
  '\x03',
  'I',
  '\v',
  'L',
  '\xEF',
  '!',
  '\x16',
  'M',
  '\x1D',
  '\x06',
  '!',
  'L',
  '\x18',
  '\x05',
  ':',
  'H',
  '\x1A',
  '\b',
  '\v',
  '@',
  '\x16',
  '\f',
  '\a',
  'A',
  '\x02',
  '\x01',
  '\x01',
  'A',
  '\x03',
  '\x03',
  '\n',
  'H',
  '\x03',
  '\x19',
  '\v',
  'L',
  '\x0F',
  '\t',
  '\x16',
  'J',
  '\x1C',
  '\x01',
  '\x01',
  'G',
  '\x1C',
  '\x11',
  '\n',
  'D',
  '\xE7',
  '1',
  '\x19',
  'B',
  '\x17',
  '\r',
  '7',
  'A',
  '\x02',
  '\0',
  '\x01',
  'N',
  '\x18',
  '\x15',
  '\n',
  'F',
  '\0',
  '\x0F',
  '\v',
  '@',
  '\x17',
  '\x1D',
  '\a',
  'A',
  '\n',
  '\0',
  '\x01',
  'N',
  '\x18',
  '\x15',
  '\n',
  'F',
  '\b',
  '\x0F',
  '\v',
  'E',
  '\x16',
  '\v',
  '\a',
  'O',
  '\x19',
  '\a',
  '\x01',
  'M',
  '\x19',
  '\x02',
  '\n',
  'M',
  '\x12',
  '\f',
  '\v',
  'I',
  '\x16',
  '\b',
  '\a',
  'C',
  '\xA1',
  '\x9E',
  '\x10',
  's',
  '\0',
  '\xD5',
  '\x1B',
  'J',
  '\x1F',
  '\t',
  ';',
  'O',
  '\f',
  '\v',
  '\a',
  'O',
  '\x19',
  '\x16',
  '\x01',
  'A',
  '\a',
  '\x03',
  '\n',
  'H',
  '\x1F',
  '\x19',
  '\v',
  'O',
  '\x04',
  '\v',
  '\a',
  'O',
  '\x19',
  '\x16',
  '\x01',
  'A',
  '\x0F',
  '\x03',
  '\n',
  'D',
  '\a',
  '9',
  '\x1A',
  '*',
  '\b',
  '\r',
  '\a',
  '%',
  '\n',
  '\x06',
  '\x01',
  '$',
  '\v',
  '\x05',
  '\n',
  '\"',
  '\b',
  '\t',
  '\v',
  '*',
  '\0',
  '\r',
  '\a',
  '%',
  '\x0E',
  '\x06',
  '\x01',
  's',
  '\0',
  '\xD5',
  '\x1B',
  '\"',
  '\b',
  '\t',
  '\v',
  '*',
  '\x04',
  '\r',
  '\a',
  '%',
  '\n',
  '\x06',
  '\x01',
  '$',
  '\a',
  '\x05',
  '\n',
  '\"',
  '\0',
  '\t',
  '\v',
  '*',
  '\b',
  '\r',
  '\a',
  'C',
  '\x01',
  'r',
  '\x10',
  '.',
  '\x01',
  '\x04',
  '\n',
  '-',
  '\n',
  '\t',
  '\v',
  'B',
  '\x1A',
  '\x0E',
  '\a',
  '(',
  '\x15',
  '\x16',
  '\x01',
  '(',
  '\f',
  '\x15',
  '\n',
  ',',
  '\n',
  '\f',
  '\v',
  ' ',
  '\x06',
  '\x0E',
  '\a',
  '*',
  '\x04',
  '\x04',
  '\x01',
  'L',
  '\x15',
  '\x04',
  '\n',
  '/',
  '\x13',
  '\x05',
  '\v',
  '&',
  '\v',
  '\x19',
  '\a',
  '+',
  '\x04',
  '\x03',
  '\x01',
  '.',
  '\x01',
  '\x04',
  '\n',
  '-',
  '\n',
  '\t',
  '\v',
  'B',
  '\x1A',
  '\x0E',
  '\a',
  '(',
  '\x15',
  '\x0E',
  '\x01',
  '(',
  '\f',
  '\x1D',
  '\n',
  ',',
  '\n',
  '\f',
  '\v',
  ' ',
  '\x06',
  '\x0E',
  '\a',
  '*',
  '\x04',
  '\x04',
  '\x01',
  'L',
  '\x15',
  '\x04',
  '\n',
  '/',
  '\x13',
  '\x0E',
  '\v',
  '&',
  '\v',
  '\x14',
  '\a',
  '+',
  '\x04',
  '\x03',
  '\x01',
  'N',
  '\x1C',
  '\x04',
  '\n',
  '\x03',
  '\x04',
  '\t',
  '\v',
  'B',
  '\x0F',
  '\r',
  '\'',
  'M',
  '\t',
  '\x06',
  '\0',
  '@',
  '\x06',
  '\x05',
  ':',
  'F',
  '\b',
  '\v',
  '\v',
  ' ',
  '\n',
  '\r',
  '\a',
  'J',
  '\x04',
  '\x05',
  '\x01',
  'A',
  '\x06',
  '\x05',
  ':',
  'H',
  '\a',
  '\x19',
  '\v',
  '@',
  '\a',
  '\x1D',
  '\a',
  'A',
  '\a',
  '\x16',
  '1',
  '@',
  '\x0F',
  '\a',
  '\n',
  '(',
  '\x02',
  '\t',
  '\v',
  'E',
  '\n',
  '\x0E',
  '\a',
  '@',
  '\a',
  '\x16',
  '1',
  'N',
  '\0',
  '\x15',
  '\n',
  'H',
  '\x0F',
  '\x19',
  '\v',
  'N',
  '\t',
  '-',
  '7',
  'A',
  '\x0E',
  '\x04',
  '\x01',
  '.',
  '\x05',
  '\x05',
  '\n',
  'M',
  '\x02',
  '\n',
  '\v',
  'O',
  '\t',
  '-',
  '7',
  'O',
  '\x01',
  '\x16',
  '\x01',
  'N',
  '\b',
  '\x15',
  '\n',
  'F',
  '\x01',
  '9',
  ';',
  'N',
  '\0',
  '\x0F',
  '\a',
  '/',
  '\x04',
  '\x06',
  '\x01',
  'K',
  '\x05',
  '\x06',
  '\n',
  'G',
  '\x01',
  '9',
  ';',
  '\v',
  '\f',
  '\r',
  '\a',
  '\x0F',
  '\x02',
  '\x06',
  '\x01',
  '\x0E',
  '\x03',
  '\x05',
  '\n',
  '\b',
  '\x04',
  '\t',
  '\v',
  '\0',
  '\f',
  '\r',
  '\a',
  '\x0F',
  '\x02',
  '\x06',
  '\x01',
  '\x0E',
  '\x03',
  '\x05',
  '\n',
  '\b',
  '\x04',
  '\t',
  '\v',
  '\0',
  '\f',
  '\r',
  '\a',
  '\x0F',
  '\x02',
  '\x06',
  '\x01',
  '\x0E',
  '\x03',
  '\x05',
  '\n',
  '\b',
  '\x04',
  '\t',
  '\v',
  '\0',
  '\f',
  '\r',
  '\a',
  '\x0F',
  '\x02',
  '\x06',
  '\x01',
  '\x0E',
  '\x03',
  '\x05',
  '\n',
  '\b',
  '\x04',
  '\t',
  '\v',
  '\0',
  '\f',
  '\r',
  '\a',
  '\x0F',
  '\x02',
  '\x06',
  '\x01',
  '\x0E',
  '\x03',
  '\x05',
  '\n',
  '\b',
  '\x04',
  '\t',
  '\v',
  '\0',
  '\f',
  '\r',
  '\a',
  '\x0F',
  '\x02',
  '\x06',
  '\x01',
  '\0'
}; // weak
void *off_8FB58 = (void *)0x252F7325000A0920LL; // weak
char byte_8FDE8[16] =
{
  '\0',
  '\x02',
  '\x01',
  '\x05',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x02',
  '\x01',
  '\x01',
  '\x03',
  '\0',
  '\0'
}; // idb
char byte_8FDF8[40] =
{
  '\0',
  '\x10',
  '\x11',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_8FE20[64] =
{
  '\x01',
  '\0',
  '\x05',
  '\x04',
  '\a',
  '\b',
  '\t',
  '\n',
  '\n',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x03',
  '\x04',
  '\x05',
  '\xFF',
  '\a',
  '\b',
  '\t',
  '\n',
  '\x19',
  '\x03',
  '\x04',
  '\x05',
  '\x0F',
  '\a',
  '\b',
  '\t',
  '\n',
  '\x06',
  '\f',
  '\t',
  '\n',
  '\xFF',
  '\v',
  '\xFF',
  '\r',
  '\x0E',
  '\x03',
  '\x04',
  '\x05',
  '\xFF',
  '\a',
  '\b',
  '\t',
  '\n',
  '\a',
  '\b',
  '\t',
  '\n',
  '\b',
  '\t',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_BYTE byte_8FE60[64] =
{
  7,
  9,
  12,
  8,
  13,
  14,
  15,
  16,
  16,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  10,
  11,
  12,
  0,
  13,
  14,
  15,
  16,
  26,
  10,
  11,
  12,
  17,
  13,
  14,
  15,
  16,
  1,
  25,
  15,
  16,
  0,
  2,
  0,
  3,
  4,
  10,
  11,
  12,
  0,
  13,
  14,
  15,
  16,
  13,
  14,
  15,
  16,
  14,
  15,
  16,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
char byte_8FEA0[32] =
{
  '\0',
  '\0',
  '\f',
  '\v',
  '\0',
  '\0',
  '\x02',
  '\n',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\r',
  '\0',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_8FEC0[263] =
{
  '\0',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x06',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x05',
  '\x02',
  '\x0E',
  '\x0F',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\f',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x03',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\r',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x04',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x01',
  '\x02',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v'
}; // idb
void *__ptr32 off_8FFC7 = (void *__ptr32)0x605FFLL; // weak
char byte_8FFCB[2] = { '\xFC', '\xFC' }; // idb
char byte_8FFD0[28] =
{
  '\x1B',
  '\x1B',
  '\xFC',
  '\xFC',
  '\x1B',
  '\x01',
  '\'',
  '\xFC',
  '\r',
  '\xFC',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\xFC',
  '\x16',
  '\xFD',
  '+',
  '.',
  '\x1A',
  '\xFE',
  '\xFC',
  '\x1B',
  '\'',
  '\0'
}; // idb
_UNKNOWN unk_900A0; // weak
int dword_91618[16] =
{
  -448184,
  -447864,
  -447544,
  -447224,
  -446904,
  -446584,
  -446264,
  -445944,
  -445624,
  -445304,
  -444984,
  -444664,
  -444344,
  -444024,
  -443704,
  -448344
}; // idb
int dword_91658[16] =
{
  -442360,
  -442072,
  -441784,
  -441496,
  -441208,
  -440920,
  -440632,
  -440344,
  -440056,
  -439768,
  -439480,
  -439192,
  -438904,
  -438616,
  -438328,
  -442520
}; // idb
int dword_91698[16] =
{
  -436536,
  -436152,
  -435768,
  -435384,
  -435000,
  -434616,
  -434232,
  -433848,
  -433464,
  -433080,
  -432696,
  -432312,
  -431928,
  -431544,
  -431160,
  -436744
}; // idb
int dword_916D8[16] =
{
  -430360,
  -429992,
  -429624,
  -429256,
  -428888,
  -428520,
  -428152,
  -427784,
  -427416,
  -427048,
  -426680,
  -426312,
  -425944,
  -425576,
  -425208,
  -430568
}; // idb
int dword_91718[16] =
{
  -424456,
  -424216,
  -423976,
  -423736,
  -423496,
  -423256,
  -423016,
  -422776,
  -422536,
  -422296,
  -422056,
  -421816,
  -421576,
  -421336,
  -421096,
  -424632
}; // idb
int dword_91758[80] =
{
  -412009,
  -411288,
  -411562,
  -411304,
  -412023,
  -411816,
  -411576,
  -411336,
  -412066,
  -411894,
  -411686,
  -411430,
  -412040,
  -411864,
  -411624,
  -411384,
  -412083,
  -411911,
  -411703,
  -411447,
  -411191,
  -411063,
  -410935,
  -410807,
  -410679,
  -410551,
  -410407,
  -410263,
  -410119,
  -409975,
  -409815,
  -409655,
  -409530,
  -411938,
  -411730,
  -411474,
  -411218,
  -411090,
  -410962,
  -410834,
  -410706,
  -410578,
  -410434,
  -410290,
  -410146,
  -410002,
  -409842,
  -409682,
  -409553,
  -411965,
  -411757,
  -411501,
  -411245,
  -411117,
  -410989,
  -410861,
  -410733,
  -410605,
  -410461,
  -410317,
  -410173,
  -410029,
  -409869,
  -409709,
  -409576,
  -411992,
  -411784,
  -411528,
  -411272,
  -411144,
  -411016,
  -410888,
  -410760,
  -410632,
  -410488,
  -410344,
  -410200,
  -410056,
  -409896,
  -409736
}; // idb
int dword_91898[80] =
{
  -402848,
  -402392,
  -401912,
  -401432,
  -400952,
  -400440,
  -399928,
  -399416,
  -402856,
  -402408,
  -401928,
  -401448,
  -400968,
  -400472,
  -399960,
  -399448,
  -402888,
  -402440,
  -401960,
  -401480,
  -401000,
  -400504,
  -399992,
  -399480,
  -402920,
  -402472,
  -401992,
  -401512,
  -401032,
  -400552,
  -400040,
  -399528,
  -402968,
  -402520,
  -402040,
  -401560,
  -401080,
  -400600,
  -400088,
  -399576,
  -403016,
  -402568,
  -402088,
  -401608,
  -401128,
  -400664,
  -400152,
  -399640,
  -403080,
  -402632,
  -402152,
  -401672,
  -401192,
  -400728,
  -400216,
  -399704,
  -403144,
  -402696,
  -402216,
  -401736,
  -401256,
  -400792,
  -400280,
  -399768,
  -403208,
  -402760,
  -402296,
  -401816,
  -401320,
  -400856,
  -400344,
  -399832,
  -403272,
  -402840,
  -402376,
  -401896,
  -401400,
  -400936,
  -400424,
  -399912
}; // idb
int dword_919D8[16] =
{
  -409736,
  -408632,
  -408296,
  -407960,
  -407624,
  -407288,
  -406952,
  -406616,
  -406280,
  -405944,
  -405608,
  -405272,
  -404936,
  -404600,
  -404264,
  -403928
}; // idb
int dword_91A18[16] =
{
  -409240,
  -408520,
  -408184,
  -407848,
  -407512,
  -407176,
  -406840,
  -406504,
  -406168,
  -405832,
  -405496,
  -405160,
  -404824,
  -404488,
  -404152,
  -403816
}; // idb
int dword_91C18[144] =
{
  -379354,
  -377688,
  -377800,
  -377912,
  -378024,
  -378136,
  -378248,
  -378360,
  -378472,
  -378584,
  -378696,
  -378808,
  -378920,
  -379032,
  -379144,
  -379256,
  -379362,
  -377714,
  -377826,
  -377938,
  -378050,
  -378162,
  -378274,
  -378386,
  -378498,
  -378610,
  -378722,
  -378834,
  -378946,
  -379058,
  -379170,
  -379282,
  -379372,
  -377724,
  -377836,
  -377948,
  -378060,
  -378172,
  -378284,
  -378396,
  -378508,
  -378620,
  -378732,
  -378844,
  -378956,
  -379068,
  -379180,
  -379292,
  -379382,
  -377734,
  -377846,
  -377958,
  -378070,
  -378182,
  -378294,
  -378406,
  -378518,
  -378630,
  -378742,
  -378854,
  -378966,
  -379078,
  -379190,
  -379302,
  -379392,
  -377744,
  -377856,
  -377968,
  -378080,
  -378192,
  -378304,
  -378416,
  -378528,
  -378640,
  -378752,
  -378864,
  -378976,
  -379088,
  -379200,
  -379312,
  -379402,
  -377754,
  -377866,
  -377978,
  -378090,
  -378202,
  -378314,
  -378426,
  -378538,
  -378650,
  -378762,
  -378874,
  -378986,
  -379098,
  -379210,
  -379322,
  -379412,
  -377764,
  -377876,
  -377988,
  -378100,
  -378212,
  -378324,
  -378436,
  -378548,
  -378660,
  -378772,
  -378884,
  -378996,
  -379108,
  -379220,
  -379332,
  -379422,
  -377774,
  -377886,
  -377998,
  -378110,
  -378222,
  -378334,
  -378446,
  -378558,
  -378670,
  -378782,
  -378894,
  -379006,
  -379118,
  -379230,
  -379342,
  -379432,
  -377784,
  -377896,
  -378008,
  -378120,
  -378232,
  -378344,
  -378456,
  -378568,
  -378680,
  -378792,
  -378904,
  -379016,
  -379128,
  -379240,
  -379352
}; // idb
int dword_91E58[144] =
{
  -382008,
  -380024,
  -380152,
  -380296,
  -380424,
  -380552,
  -380680,
  -380808,
  -380936,
  -381064,
  -381192,
  -381320,
  -381448,
  -381592,
  -381736,
  -381880,
  -382018,
  -380060,
  -380188,
  -380332,
  -380460,
  -380588,
  -380716,
  -380844,
  -380972,
  -381100,
  -381228,
  -381356,
  -381484,
  -381628,
  -381772,
  -381916,
  -382028,
  -380070,
  -380198,
  -380342,
  -380470,
  -380598,
  -380726,
  -380854,
  -380982,
  -381110,
  -381238,
  -381366,
  -381494,
  -381638,
  -381782,
  -381926,
  -382038,
  -380080,
  -380208,
  -380352,
  -380480,
  -380608,
  -380736,
  -380864,
  -380992,
  -381120,
  -381248,
  -381376,
  -381504,
  -381648,
  -381792,
  -381936,
  -382048,
  -380090,
  -380218,
  -380362,
  -380490,
  -380618,
  -380746,
  -380874,
  -381002,
  -381130,
  -381258,
  -381386,
  -381514,
  -381658,
  -381802,
  -381946,
  -382058,
  -380100,
  -380228,
  -380372,
  -380500,
  -380628,
  -380756,
  -380884,
  -381012,
  -381140,
  -381268,
  -381396,
  -381524,
  -381668,
  -381812,
  -381956,
  -382068,
  -380110,
  -380238,
  -380382,
  -380510,
  -380638,
  -380766,
  -380894,
  -381022,
  -381150,
  -381278,
  -381406,
  -381534,
  -381678,
  -381822,
  -381966,
  -382078,
  -380120,
  -380248,
  -380392,
  -380520,
  -380648,
  -380776,
  -380904,
  -381032,
  -381160,
  -381288,
  -381416,
  -381544,
  -381688,
  -381832,
  -381976,
  -382088,
  -380136,
  -380264,
  -380408,
  -380536,
  -380664,
  -380792,
  -380920,
  -381048,
  -381176,
  -381304,
  -381432,
  -381560,
  -381704,
  -381848,
  -381992
}; // idb
int dword_92098[16] =
{
  -389528,
  -389240,
  -388856,
  -388472,
  -388088,
  -387704,
  -387320,
  -386936,
  -386552,
  -386168,
  -385784,
  -385400,
  -385016,
  -384632,
  -384248,
  -383864
}; // idb
int dword_920D8[16] =
{
  -389432,
  -389112,
  -388728,
  -388344,
  -387960,
  -387576,
  -387192,
  -386808,
  -386424,
  -386040,
  -385656,
  -385272,
  -384888,
  -384504,
  -384120,
  -383736
}; // idb
__int128 xmmword_92620 = 0x40404040404040404040404040404040LL; // weak
__int128 xmmword_92630 = 0x5B5B5B5B5B5B5B5B5B5B5B5B5B5B5B5BLL; // weak
__int128 xmmword_92640 = 0x20202020202020202020202020202020LL; // weak
int dword_92650[16] =
{
  -366640,
  -366112,
  -365584,
  -365056,
  -364528,
  -364000,
  -363472,
  -362944,
  -362416,
  -361888,
  -361360,
  -360832,
  -360304,
  -359776,
  -359248,
  -367024
}; // idb
int dword_92690[16] =
{
  -357920,
  -357408,
  -356896,
  -356384,
  -355872,
  -355360,
  -354848,
  -354336,
  -353824,
  -353312,
  -352800,
  -352288,
  -351776,
  -351264,
  -350752,
  -358304
}; // idb
int dword_926D0[16] =
{
  -349472,
  -349056,
  -348640,
  -348224,
  -347808,
  -347392,
  -346976,
  -346560,
  -346144,
  -345728,
  -345312,
  -344896,
  -344480,
  -344064,
  -343648,
  -349840
}; // idb
int dword_92720[16] =
{
  -342576,
  -342240,
  -341904,
  -341568,
  -341232,
  -340896,
  -340560,
  -340224,
  -339888,
  -339552,
  -339216,
  -338880,
  -338544,
  -338208,
  -337872,
  -342848
}; // idb
int dword_92760[32] =
{
  -319968,
  -319952,
  -319936,
  -319920,
  -319904,
  -319888,
  -319872,
  -319856,
  -319840,
  -319824,
  -319808,
  -319792,
  -319776,
  -319760,
  -319744,
  -319728,
  -319712,
  -319696,
  -319664,
  -319648,
  -319632,
  -319600,
  -319568,
  -319536,
  -319504,
  -319472,
  -319440,
  -319408,
  -319376,
  -319344,
  -319312,
  -319280
}; // idb
int dword_927E0[32] =
{
  -318512,
  -318496,
  -318480,
  -318464,
  -318448,
  -318432,
  -318400,
  -318384,
  -318368,
  -318352,
  -318320,
  -318288,
  -318256,
  -318224,
  -318192,
  -318160,
  -318144,
  -318128,
  -318096,
  -318064,
  -318032,
  -318000,
  -317968,
  -317936,
  -317904,
  -317872,
  -317840,
  -317808,
  -317776,
  -317744,
  -317712,
  -317680
}; // idb
_UNKNOWN unk_92860; // weak
_UNKNOWN unk_929C0; // weak
const sigset_t nset =
{
  {
    18446744073709551615uLL,
    18446744073709551615uLL,
    18446744073709551615uLL,
    18446744073709551615uLL,
    18446744073709551615uLL,
    18446744073709551615uLL,
    18446744073709551615uLL,
    18446744073709551615uLL,
    18446744073709551615uLL,
    18446744073709551615uLL,
    18446744073709551615uLL,
    18446744073709551615uLL,
    18446744073709551615uLL,
    18446744073709551615uLL,
    18446744073709551615uLL,
    18446744073709551615uLL
  }
}; // idb
char aVarTmp[9] = "/var/tmp"; // weak
char aGconvPath[11] = "GCONV_PATH"; // weak
char aSse2[5] = "sse2"; // weak
_BYTE byte_94173[12] = { 37, 115, 58, 32, 37, 115, 58, 32, 37, 115, 37, 115 }; // idb
_UNKNOWN unk_94A50; // weak
_BYTE byte_94B41[7] = { -64, -32, -16, -8, -4, 0, 0 }; // idb
unsigned __int8 byte_950F0[16] = { 8u, 10u, 7u, 10u, 11u, 11u, 6u, 8u, 7u, 10u, 12u, 14u, 17u, 0u, 0u, 0u }; // idb
unsigned __int8 byte_95100[32] =
{
  11u,
  32u,
  43u,
  0u,
  20u,
  51u,
  0u,
  63u,
  72u,
  80u,
  91u,
  104u,
  119u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
char aLcCollate[11] = "LC_COLLATE"; // weak
int dword_95200[13] = { 14, 5, 110, 18, 45, 4, 0, 2, 6, 12, 4, 1, 15 }; // idb
_QWORD qword_958A0[14] = { 86LL, 6LL, 159LL, 19LL, 46LL, 5LL, 0LL, 3LL, 7LL, 13LL, 5LL, 2LL, 16LL, 0LL }; // idb
_DWORD dword_962A0[256] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  64,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  123,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  207,
  208,
  209,
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  219,
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  235,
  236,
  237,
  238,
  239,
  240,
  241,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250,
  251,
  252,
  253,
  254,
  255
}; // idb
_DWORD dword_968A0[256] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  64,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  75,
  76,
  77,
  78,
  79,
  80,
  81,
  82,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  75,
  76,
  77,
  78,
  79,
  80,
  81,
  82,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  123,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  207,
  208,
  209,
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  219,
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  235,
  236,
  237,
  238,
  239,
  240,
  241,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250,
  251,
  252,
  253,
  254,
  255
}; // idb
_BYTE byte_971A0[512] =
{
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  3,
  32,
  2,
  32,
  2,
  32,
  2,
  32,
  2,
  32,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  1,
  96,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  8,
  -43,
  8,
  -43,
  8,
  -43,
  8,
  -43,
  8,
  -43,
  8,
  -43,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  8,
  -42,
  8,
  -42,
  8,
  -42,
  8,
  -42,
  8,
  -42,
  8,
  -42,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  2,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
void *off_A37E0 = (void *)0x607010300030001LL; // weak
_QWORD qword_A3820[6] =
{
  9223372036854775807LL,
  6148914691236517205LL,
  4611686018427387903LL,
  3689348814741910323LL,
  3074457345618258602LL,
  2635249153387078802LL
}; // idb
_UNKNOWN unk_A3A20; // weak
_UNKNOWN unk_A3A40; // weak
_UNKNOWN unk_A3AC8; // weak
_UNKNOWN unk_A3AE0; // weak
_UNKNOWN unk_A3B60; // weak
_UNKNOWN unk_A6360; // weak
int dword_A6379 = 0; // weak
int dword_A6380 = 0; // weak
_UNKNOWN unk_A6AF8; // weak
_UNKNOWN unk_A6B47; // weak
void *__ptr32 off_A6B5F = &unk_A7325; // weak
unsigned __int8 byte_A6D55[3] = { 111u, 110u, 0u }; // idb
_UNKNOWN unk_A6D62; // weak
_UNKNOWN unk_A6E65; // weak
char a0123456789abcd[37] = "0123456789abcdefghijklmnopqrstuvwxyz"; // weak
char a0_16[2] = "0"; // weak
__int128 xmmword_A7C60 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFLL; // weak
__int128 xmmword_A7C70 = 0x7FFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFLL; // weak
_UNKNOWN unk_A8498; // weak
_UNKNOWN unk_A85B8; // weak
unsigned __int64 qword_A8600[1725] =
{
  0uLL,
  10uLL,
  0uLL,
  100uLL,
  0uLL,
  10000uLL,
  0uLL,
  100000000uLL,
  0uLL,
  10000000000000000uLL,
  0uLL,
  9632337040368467968uLL,
  5421010862427uLL,
  0uLL,
  0uLL,
  7942358959831785217uLL,
  16807427164405733357uLL,
  1593091uLL,
  0uLL,
  0uLL,
  0uLL,
  279109966635548161uLL,
  2554917779393558781uLL,
  14124656261812188652uLL,
  11976055582626787546uLL,
  2537941837315uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  13750482914757213185uLL,
  1302999927698857842uLL,
  14936872543252795590uLL,
  2788415840139466767uLL,
  2095640732773017264uLL,
  7205570348933370714uLL,
  7348167152523113408uLL,
  9285516396840364274uLL,
  6907659600622710236uLL,
  349175uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  8643096425819600897uLL,
  6743743997439985372uLL,
  14059704609098336919uLL,
  10729359125898331411uLL,
  4933048501514368705uLL,
  12258131603170554683uLL,
  2172371001088594721uLL,
  13569903330219142946uLL,
  13809142207969578845uLL,
  16716360519037769646uLL,
  9631256923806107285uLL,
  12866941232305103710uLL,
  1397931361048440292uLL,
  7619627737732970332uLL,
  12725409486282665900uLL,
  11703051443360963910uLL,
  9947078370803086083uLL,
  13966287901448440471uLL,
  121923442132uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  17679772531488845825uLL,
  2216509366347768155uLL,
  1568689219195129479uLL,
  5511594616325588277uLL,
  1067709417009240089uLL,
  9070650952098657518uLL,
  11515285870634858015uLL,
  2539561553659505564uLL,
  17604889300961091799uLL,
  14511540856854204724uLL,
  12099083339557485471uLL,
  7115240299237943815uLL,
  313979240050606788uLL,
  10004784664717172195uLL,
  15570268847930131473uLL,
  10359715202835930803uLL,
  17685054012115162812uLL,
  13183273382855797757uLL,
  7743260039872919062uLL,
  9284593436392572926uLL,
  11105921222066415013uLL,
  18198799323400703846uLL,
  16314988383739458320uLL,
  4387527177871570570uLL,
  8476708682254672590uLL,
  4925096874831034057uLL,
  14075687868072027455uLL,
  112866656203221926uLL,
  9852830467773230418uLL,
  25755239915196746uLL,
  2201493076310172510uLL,
  8342165458688466438uLL,
  13954006576066379050uLL,
  15193819059903295636uLL,
  12565616718911389531uLL,
  3815854855847885129uLL,
  15696762163583540628uLL,
  805uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  16359721904723189761uLL,
  5323973632697650495uLL,
  17187956456762001185uLL,
  3930387638628283780uLL,
  3374723710406992273uLL,
  16884225088663222131uLL,
  10967440051041439154uLL,
  9686916182456720060uLL,
  10554548046311730194uLL,
  7390739362393647554uLL,
  6316162333127736719uLL,
  18122464886584070891uLL,
  4044404959645932768uLL,
  3801320885861987401uLL,
  12080950653257274590uLL,
  16414324262488991299uLL,
  16395687498836410113uLL,
  12173633940896186260uLL,
  10843185433142632150uLL,
  11048169832730399808uLL,
  12674828934734683716uLL,
  17370808310130582550uLL,
  10500926985433408692uLL,
  10252725158410704555uLL,
  14170108270502067523uLL,
  3698946465517688080uLL,
  989984870770509463uLL,
  10965601426733943069uLL,
  11389898658438335655uLL,
  6901098232861256586uLL,
  1921335291173932590uLL,
  7662788640922083388uLL,
  9775023833308395430uLL,
  4640401278902814207uLL,
  14532050972198413359uLL,
  8378549018693130223uLL,
  11672322628395371653uLL,
  8930704142764178555uLL,
  6275193859483102017uLL,
  15782593304269205087uLL,
  8673060659034172558uLL,
  8018354414354334043uLL,
  1824896661540749038uLL,
  11345563346725559868uLL,
  14959216444480821949uLL,
  970189517688324683uLL,
  3338835207603007873uLL,
  17684964260791738489uLL,
  1436466329061721851uLL,
  4554134986752476101uLL,
  6398757850768963907uLL,
  4709779218751158342uLL,
  10033277748582410264uLL,
  17932125878679265063uLL,
  10004750887749091440uLL,
  256584531835386932uLL,
  14396282740722731628uLL,
  3086085133731396950uLL,
  17831272085689600064uLL,
  10573926491412564693uLL,
  14888061047859191737uLL,
  4570995450261499817uLL,
  10410165022312935266uLL,
  5691078631447480790uLL,
  8632710455805418155uLL,
  790672778942823293uLL,
  16505464105756800547uLL,
  2092171438149740401uLL,
  17505030673829275878uLL,
  1291290830058928444uLL,
  14856191690683232796uLL,
  8916773426496500052uLL,
  10152003807578858265uLL,
  13104441193763861714uLL,
  649395uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  15308384451594534913uLL,
  17913664074042735335uLL,
  6115977719198531863uLL,
  5794980608663993169uLL,
  16544350702855106930uLL,
  9253787637781258566uLL,
  4977988951675168190uLL,
  9087837664087448770uLL,
  2098480401110016986uLL,
  15474332540882100712uLL,
  14042133997396540944uLL,
  1090855284423485362uLL,
  12639956485351058381uLL,
  1454115676006639319uLL,
  3180465001342538023uLL,
  14649076551958697729uLL,
  9801292446545910916uLL,
  13552201410826594004uLL,
  6101141927469189381uLL,
  1881431857880609316uLL,
  4907847477899433595uLL,
  8714572486973123228uLL,
  3514969632331374520uLL,
  11667642286891470094uLL,
  2391499697425323350uLL,
  17486585679659076043uLL,
  18267223761882105642uLL,
  2886610765822313148uLL,
  9302834862968900288uLL,
  15246507846733637044uLL,
  15924227519624562840uLL,
  9743741243284697760uLL,
  3159780987244964246uLL,
  7304816812369628428uLL,
  17584602612559717809uLL,
  4146812420657846766uLL,
  14525415362681041515uLL,
  8477630142371600195uLL,
  4380695748062263745uLL,
  12119915994367943173uLL,
  16970630866565485122uLL,
  4332724980155264503uLL,
  8079943140620527639uLL,
  1687908087554405626uLL,
  17051081099834002166uLL,
  12638146269730763230uLL,
  11883749876933445771uLL,
  4662462156371383785uLL,
  4796962238316531176uLL,
  3325504751659868927uLL,
  6469595803187862550uLL,
  5852556621152583005uLL,
  9229334792448387881uLL,
  17979733373938620709uLL,
  13951623534175792756uLL,
  17075879371091039277uLL,
  14212246479457938037uLL,
  4008999959804158260uLL,
  2414266395366403722uLL,
  3252733766253918247uLL,
  6382678985007829216uLL,
  2245927470982310841uLL,
  13790724502051307301uLL,
  13116936866733148041uLL,
  9718402891306794538uLL,
  13516274400356104875uLL,
  17859223875778049403uLL,
  4396895129099725471uLL,
  3563053650368467915uLL,
  12176845952536972668uLL,
  3492050964335269015uLL,
  2740656767075170753uLL,
  4409704077614761919uLL,
  10237775279597492710uLL,
  3314206875098230827uLL,
  16437361028114095448uLL,
  12361736225407656572uLL,
  16792510651790145480uLL,
  11449053143229929935uLL,
  18336641737580333136uLL,
  6558939822118891088uLL,
  4606255756908155300uLL,
  2360792578991605004uLL,
  160428430149144538uLL,
  11644861220729221511uLL,
  10785178451159739786uLL,
  14923560618031934681uLL,
  1902620814992781610uLL,
  14064076995338910412uLL,
  11547019064112212657uLL,
  16847481479966225734uLL,
  8331994491163145469uLL,
  11739712981738851885uLL,
  8008309968651120619uLL,
  10266969595459035264uLL,
  15175153381217702033uLL,
  12208659352573720245uLL,
  7714061140750342961uLL,
  2892831567213510541uLL,
  15453714249045017319uLL,
  71020323573871677uLL,
  15431137995750602633uLL,
  5659146884637671933uLL,
  5998809010488554503uLL,
  16552192379299157850uLL,
  1192197967194298797uLL,
  16157555793424861524uLL,
  10929371590994640255uLL,
  3194469143425738352uLL,
  6651586784672005225uLL,
  11062427140788057791uLL,
  6834443579468668318uLL,
  16421563197797455922uLL,
  6251046422506172884uLL,
  13952303462156793860uLL,
  16632486601871393224uLL,
  11313454360291325172uLL,
  5587835232504462834uLL,
  3105197524618514637uLL,
  18268568531031972989uLL,
  2397205535804309313uLL,
  59413027864729597uLL,
  11869878125348715710uLL,
  12592801707270523266uLL,
  8070632061321113656uLL,
  18403647807860650811uLL,
  267109013517069093uLL,
  6537214311028855260uLL,
  5220826919973709902uLL,
  3448740582779163661uLL,
  16822239213112884941uLL,
  5975299384311048185uLL,
  10294433804430712138uLL,
  4739856055412448774uLL,
  12057273038326387897uLL,
  13119002941950056609uLL,
  3354445304051737058uLL,
  13592813067499314594uLL,
  3890182464434078629uLL,
  17820384357466425060uLL,
  9785228118969879380uLL,
  1778431746734556271uLL,
  10075313876350055029uLL,
  13994048489400919028uLL,
  17948287074199726448uLL,
  2815088342305858722uLL,
  2676626035777198370uLL,
  1174257960026283968uLL,
  421714788677uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  11471884475673051137uLL,
  8902860357476377573uLL,
  13350296775839230505uLL,
  10609191786344608888uLL,
  7261211985859587338uLL,
  11439672689354862964uLL,
  16789708072300570627uLL,
  4607056528866348430uLL,
  3202978990421512997uLL,
  2024899620433984146uLL,
  17666950207239811774uLL,
  4233228489390288200uLL,
  9137580478688460738uLL,
  4060411066587388546uLL,
  11119949806060600124uLL,
  867715462473090103uLL,
  14382394941384869610uLL,
  4856042377419278489uLL,
  8265605599571137921uLL,
  538981667666252469uLL,
  4270263388700786523uLL,
  3281140600308898503uLL,
  4121392524544394174uLL,
  2077884106245940229uLL,
  9773041957329767574uLL,
  7550623316597646685uLL,
  8611033926449791714uLL,
  18137922955420802793uLL,
  2796546741236224013uLL,
  15477096484628446761uLL,
  9517540128113714010uLL,
  9471917970500821378uLL,
  15938570248662483124uLL,
  5228016831978462619uLL,
  15720991252586974501uLL,
  7662829825220776698uLL,
  17328310068068434348uLL,
  3371736428170309730uLL,
  3803724952191098855uLL,
  13115926536504376719uLL,
  16752571196153442257uLL,
  16540185467776259880uLL,
  3432518182450051120uLL,
  5880364967211798870uLL,
  12355748840305392783uLL,
  14196090758536469575uLL,
  7370123524686686319uLL,
  6819740424617592686uLL,
  13037938013537368753uLL,
  15029273671291927100uLL,
  3671312928327205696uLL,
  7473228676544792780uLL,
  17234079691312938123uLL,
  14164740848093544419uLL,
  13169904779481875902uLL,
  7179036968465894054uLL,
  8244653688947194445uLL,
  17179797746073799490uLL,
  5591970751047577674uLL,
  17530550506268329742uLL,
  5965746721852312330uLL,
  1604149463243472865uLL,
  7734199791463116918uLL,
  11305790396015856714uLL,
  4441196105025505137uLL,
  13046431581185664762uLL,
  124776524294606713uLL,
  1134521334706523966uLL,
  11671728093344476434uLL,
  14103440020972933148uLL,
  3966727403013869059uLL,
  9828094508409132821uLL,
  4355682486381147287uLL,
  10261407143988481234uLL,
  3800455155249557199uLL,
  12700901937937547500uLL,
  18184475466894579360uLL,
  13267691151779895412uLL,
  4714157123477697445uLL,
  10770360171308585263uLL,
  9083344917597998040uLL,
  12078649873810212155uLL,
  18218989082046199377uLL,
  4454285072780637351uLL,
  5287307245618354742uLL,
  16042289702059031730uLL,
  4131926574212754010uLL,
  217692071448455473uLL,
  3624845916216282093uLL,
  2901203491797614218uLL,
  6679177724033967080uLL,
  44561358851332790uLL,
  9094639944041587162uLL,
  13690915012276084311uLL,
  1408896670826320686uLL,
  5359130319612337580uLL,
  6148412925099835601uLL,
  5211368532286409612uLL,
  11386360825549027374uLL,
  16895182466965795071uLL,
  3392940493846427241uLL,
  438089879085393580uLL,
  4783928372776399972uLL,
  6278117363595909959uLL,
  12569481049412674733uLL,
  15648622492570893902uLL,
  1966316336235305115uLL,
  1603775390515993547uLL,
  13576113010204316709uLL,
  10821754650102840474uLL,
  18198222517222903152uLL,
  6966163076615302988uLL,
  1373932372410129684uLL,
  3285839581819684990uLL,
  30177575069719475uLL,
  16447047871247307061uLL,
  11618654126674833808uLL,
  990072222556306872uLL,
  1260682336135768017uLL,
  13862055046689532489uLL,
  15668483092844698432uLL,
  1879572630092764264uLL,
  13912027797058626108uLL,
  6231679788219816920uLL,
  13857858054844167403uLL,
  18101470072534728857uLL,
  4144579812461609229uLL,
  7048589655616599284uLL,
  9946956499532694630uLL,
  9771303850109874038uLL,
  6477823708780339765uLL,
  17526247621747041971uLL,
  13525995675852669549uLL,
  3928768291901239810uLL,
  8094153383078124544uLL,
  11214278667728965552uLL,
  11251547162596832610uLL,
  5964946855123292381uLL,
  3622548288590237903uLL,
  13469765967150053587uLL,
  17798986288523466082uLL,
  14684592818807932259uLL,
  16724077276802963921uLL,
  7119877993753121290uLL,
  1864571304902781632uLL,
  12871984921385213812uLL,
  9065447042604670298uLL,
  3987130777300360550uLL,
  6890545752116901685uLL,
  17275341711601865750uLL,
  6296474927799264658uLL,
  1257436973037243463uLL,
  13854281781965301421uLL,
  1657132483318662716uLL,
  17309399540017292849uLL,
  12808111630089217242uLL,
  1098489625264462071uLL,
  14010458905686364135uLL,
  16134414519481621220uLL,
  14288255900328821475uLL,
  3469093466388187882uLL,
  15982710881468295872uLL,
  4056765540058056052uLL,
  15945176389096104089uLL,
  8625339365793505375uLL,
  12316179968863788913uLL,
  15334123773538054321uLL,
  9536238824220581765uLL,
  16080825720106203271uLL,
  6235695225418121745uLL,
  12035192956458019349uLL,
  3235835166714703698uLL,
  5348960676912581218uLL,
  15315062772709464647uLL,
  17335089708021308662uLL,
  16855855317958414409uLL,
  2369751139431140406uLL,
  3693542588628609043uLL,
  7350405893393987577uLL,
  17402072586341663801uLL,
  7007897690013647122uLL,
  15671767872059304758uLL,
  9259490518292347915uLL,
  14836045474406130394uLL,
  4654005815464502513uLL,
  6487825998330548401uLL,
  7013356660323385022uLL,
  7136200343936679946uLL,
  15341236858676437716uLL,
  3657357368867197449uLL,
  12621075530054608378uLL,
  5603868621997066972uLL,
  7683447656788439942uLL,
  450883379216880060uLL,
  14291494350184945047uLL,
  5466258454997635048uLL,
  14206933098432772126uLL,
  4775870327277641692uLL,
  1864430798867181939uLL,
  13748978265070608793uLL,
  12250822864261576589uLL,
  12561896977498605296uLL,
  16060949594257359328uLL,
  17775189113543311529uLL,
  11835965177892927035uLL,
  4218664174878121437uLL,
  3499000902478111683uLL,
  15169853304359126294uLL,
  7076121963053575143uLL,
  832652347668916805uLL,
  1292148207755194737uLL,
  7556838978364207852uLL,
  5904021986723518500uLL,
  4610244652288570024uLL,
  4526508363195533871uLL,
  746120481022614726uLL,
  737965197247830486uLL,
  4006266184415762653uLL,
  9272188239892688050uLL,
  15346235246415709678uLL,
  11850675997347533184uLL,
  11181059668610842701uLL,
  6687857983250662774uLL,
  2908718488661492818uLL,
  4828337780126983225uLL,
  18071738646453002184uLL,
  12790187227727197880uLL,
  17602483480871623153uLL,
  12523532189621855977uLL,
  10598805712727696716uLL,
  2179787555896149376uLL,
  2242193929457337594uLL,
  14908923241136742532uLL,
  8369182018012550027uLL,
  13385381554043022324uLL,
  3332327430110633913uLL,
  16138090784046208492uLL,
  16172324607469047339uLL,
  8279089815915615244uLL,
  12872906602736235247uLL,
  10894545290539475621uLL,
  15428756545851905023uLL,
  4155747980686992922uLL,
  4074479178894544043uLL,
  66083965608603584uLL,
  13873786284662268377uLL,
  8861183628277687555uLL,
  12119497911296021430uLL,
  2154012318305274287uLL,
  15490706314503067312uLL,
  13643145488710608367uLL,
  672340241093017103uLL,
  6039493278284091973uLL,
  9679797700977436461uLL,
  18070795828318171174uLL,
  2188146431134935377uLL,
  5247392385741514952uLL,
  1852539214842869734uLL,
  12235621681634112739uLL,
  8812930319623534062uLL,
  5585597406294108629uLL,
  11312989214475901864uLL,
  1547377291787797995uLL,
  8641748937186208205uLL,
  12518148659168623694uLL,
  6611379197521520985uLL,
  18096591571068008576uLL,
  15087021227100112139uLL,
  13058454842015958418uLL,
  1473584652966833794uLL,
  4387660670140018168uLL,
  8452836916843525402uLL,
  14376083294443363955uLL,
  13998026203969090659uLL,
  611968444648172645uLL,
  990232438801273845uLL,
  18001186324715561929uLL,
  13470591857250177501uLL,
  14881554140239420091uLL,
  16696367836720124495uLL,
  6328076032778459673uLL,
  17027497695968504616uLL,
  10192245646262428833uLL,
  8282482589527318647uLL,
  4319014353374321425uLL,
  14134087271041670980uLL,
  5060230880114618599uLL,
  13179509240430058600uLL,
  3903514232614801894uLL,
  17774749744702165255uLL,
  15448635507030969726uLL,
  15983775238358480209uLL,
  14542832143965487887uLL,
  9385618098039514666uLL,
  14431419612662304843uLL,
  730863073501675978uLL,
  16750118380379734815uLL,
  9640uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  4734805469491560449uLL,
  10121257849976593262uLL,
  15515629337278225642uLL,
  2212915151774210058uLL,
  6663637332045858029uLL,
  17106819522173841436uLL,
  3033795390447658772uLL,
  7718383707400077069uLL,
  12070305067207246826uLL,
  15269198220603765480uLL,
  12022708185728420608uLL,
  77444305565097111uLL,
  8296127084146860649uLL,
  14577212820789302003uLL,
  13899605314113795749uLL,
  8897556787106485718uLL,
  7107770150399380644uLL,
  1369953078461852783uLL,
  6979674467786437514uLL,
  2729737685714719189uLL,
  9190845266052516846uLL,
  6386092840706145984uLL,
  16884110044525508193uLL,
  497786295510831247uLL,
  15336071592842749761uLL,
  17156058692796322532uLL,
  16661818661295323366uLL,
  12481489461498853344uLL,
  18251396167712326597uLL,
  15236682849758868873uLL,
  16333707862015760982uLL,
  17136221655482026951uLL,
  17258581931538932704uLL,
  3160048940096833902uLL,
  121625224721269761uLL,
  3015482372342246716uLL,
  8342191648913931706uLL,
  2246028606627019557uLL,
  7104930024182662526uLL,
  11730316574742269048uLL,
  17174226397389258387uLL,
  3293804579498370401uLL,
  12229660688171001513uLL,
  17808938300559919671uLL,
  6264083323008108029uLL,
  4820815117438024262uLL,
  1979000428121124723uLL,
  5000774170954614568uLL,
  13400083969695276429uLL,
  7428139934551454625uLL,
  18219586041198889900uLL,
  8109609685913604125uLL,
  10689190222021330491uLL,
  3943907756943551137uLL,
  15603232223630142478uLL,
  10606089764396743274uLL,
  9383719762736370775uLL,
  13694736319478899974uLL,
  429624420090361397uLL,
  227546753412414805uLL,
  10958941985171486308uLL,
  9317445823423829521uLL,
  11863145362419627165uLL,
  124380730737735756uLL,
  12552037702125281698uLL,
  9506975322446266162uLL,
  6361070452196727670uLL,
  5864118314335574899uLL,
  18198500491023879415uLL,
  693710845576296048uLL,
  8428067657989979622uLL,
  9190375061780140607uLL,
  10233837080291626964uLL,
  4057199436792326716uLL,
  13045485967964913036uLL,
  11817552225424326361uLL,
  5663867194179809591uLL,
  15664113128692531456uLL,
  6644074694371287637uLL,
  16610458961791675163uLL,
  13432715223539641941uLL,
  6940147613714364150uLL,
  18261330529675285112uLL,
  2770687570340300641uLL,
  166471986444296544uLL,
  12221445684842817040uLL,
  3714622590696147444uLL,
  13395141296670025798uLL,
  18078325802076901297uLL,
  9544778141000382241uLL,
  8850914703500200093uLL,
  3810737736735386096uLL,
  2117555260343410051uLL,
  7753203251593962517uLL,
  15352731779707439967uLL,
  9760728061453422725uLL,
  2483876614472218676uLL,
  10699122055411684078uLL,
  5879369345516927746uLL,
  9820609875533667240uLL,
  1291610685003704965uLL,
  6744219916322133607uLL,
  6377819355385901546uLL,
  9082047296049079505uLL,
  262618211405078579uLL,
  13492211879229157542uLL,
  4724420303847709296uLL,
  9288067968855177716uLL,
  18081871568052183444uLL,
  15255571885403220809uLL,
  2246442144788530940uLL,
  5989308098935123279uLL,
  12615376019575866866uLL,
  4096604902035173619uLL,
  1905680188673640379uLL,
  8808037380749664979uLL,
  8867179827953113686uLL,
  7941208416960536773uLL,
  18347042130696346271uLL,
  15584880924717276034uLL,
  13897724177272848634uLL,
  12551787830541190531uLL,
  2110016464489331948uLL,
  14992959231120953655uLL,
  5155915500390579529uLL,
  12442146891740213991uLL,
  2160740412631082538uLL,
  9730887319064298835uLL,
  1978135137454895105uLL,
  15897433142756147197uLL,
  13898937827296434258uLL,
  5590837795874025034uLL,
  9484905015510360453uLL,
  17275755682218086779uLL,
  10314851585219303017uLL,
  5146514476452997833uLL,
  2685838092360807032uLL,
  15747968310853364118uLL,
  7575162550584052276uLL,
  1821625350956509481uLL,
  10447650892868985115uLL,
  15463586423088736703uLL,
  8070960717235237951uLL,
  13868706090985122474uLL,
  13236089072964070824uLL,
  5790854297122038982uLL,
  2061890046203343898uLL,
  5137585270307907960uLL,
  15715866395455301341uLL,
  11014733278402684640uLL,
  4568822892720381524uLL,
  12213368994331367452uLL,
  5943072258025584213uLL,
  7505656341731662881uLL,
  14753420679915426390uLL,
  9664331041129200534uLL,
  17199517800612930949uLL,
  5794715994807321562uLL,
  8979439602782410600uLL,
  4013690875255814327uLL,
  4788592446297410452uLL,
  7881249861415092932uLL,
  977213487573654953uLL,
  923062152329155855uLL,
  4256185035634640191uLL,
  13906774969675892998uLL,
  14161724765760561488uLL,
  6255788174608088660uLL,
  10210013452150317293uLL,
  8367282897729021557uLL,
  10862241542321977678uLL,
  11187115365641634717uLL,
  3891102563569129293uLL,
  7629137599207408133uLL,
  7206037909846636727uLL,
  2254919723564098762uLL,
  345833071429309102uLL,
  6402540102058174110uLL,
  9993931782660189727uLL,
  17117048624709230955uLL,
  15351552506541377956uLL,
  7713128122863319014uLL,
  13063338318504485937uLL,
  8043383629459294916uLL,
  4270244130714287096uLL,
  4616501241752789289uLL,
  12917970067360550833uLL,
  15216767300886581640uLL,
  4002001954492136096uLL,
  5582674356224425892uLL,
  15691189327006698731uLL,
  496217562383964892uLL,
  12932605376116838262uLL,
  10129998758561910460uLL,
  13865559614370304939uLL,
  9217339887777235754uLL,
  7243018590514884616uLL,
  18294862474403337033uLL,
  16142146085195415143uLL,
  14886871845072019831uLL,
  2300006803713887302uLL,
  18387940067694584475uLL,
  3556096087578066588uLL,
  6264767967456942360uLL,
  15681931933092219954uLL,
  4390515012152303249uLL,
  3076968672531178662uLL,
  685494910557321329uLL,
  1554506352208529567uLL,
  1048563793801477249uLL,
  7544257401359168115uLL,
  4899780768732861239uLL,
  6228153394030153705uLL,
  3875228905107521478uLL,
  12213353771590417241uLL,
  3665307925385752280uLL,
  10879570772616087791uLL,
  16415046184014461354uLL,
  14801994811320008192uLL,
  11119987069880539776uLL,
  17228333530235298435uLL,
  3719945549511708577uLL,
  14039959997874172910uLL,
  14719985354109373991uLL,
  15442706550340326076uLL,
  13047800856127100021uLL,
  2288611147839956377uLL,
  9448949895124092391uLL,
  13804128556948045390uLL,
  8247673722161199901uLL,
  148315241783422880uLL,
  15789799508766571876uLL,
  12877528415822026998uLL,
  10366825621887250416uLL,
  11898814583440249363uLL,
  16071290835298069823uLL,
  8389982701544306242uLL,
  5531549643251140676uLL,
  13247162871222536649uLL,
  7934349776229807266uLL,
  4538358977143258963uLL,
  3866163666857351430uLL,
  8435037624664422256uLL,
  3945944434010580332uLL,
  10612995937096529291uLL,
  10841492461118130552uLL,
  13689459140963273483uLL,
  12189878734466096599uLL,
  14694040652629156278uLL,
  4909641398634409324uLL,
  5780023090082049999uLL,
  14771108088292417007uLL,
  8441958620808173734uLL,
  5802132159669142617uLL,
  3837336995815619849uLL,
  13094846272644807387uLL,
  14842572029935447119uLL,
  10928844086004218498uLL,
  8622139958963810291uLL,
  4422969696044156012uLL,
  18185137623170258852uLL,
  17863661099822387132uLL,
  8953841731266092224uLL,
  36243936373993352uLL,
  16633041120702408291uLL,
  7739468521893678775uLL,
  5400063286861787915uLL,
  5911383954510574696uLL,
  13549567227410895618uLL,
  4462297794485792433uLL,
  4488813832859891898uLL,
  9149453056204172263uLL,
  16072057649937339852uLL,
  14906252576287692882uLL,
  8271452853949304499uLL,
  12682978554623931762uLL,
  14161437512065128627uLL,
  13784333364958352242uLL,
  17498790818744364869uLL,
  4386398306651350959uLL,
  17752071168966977669uLL,
  11751121423168546560uLL,
  8513311550241749682uLL,
  5506446386574490598uLL,
  16816145206245824821uLL,
  15370636948415514970uLL,
  12935074577649872510uLL,
  1795701080378382525uLL,
  16421062591580980484uLL,
  5877668516262607274uLL,
  14470586578551447980uLL,
  615937378094845009uLL,
  12778027080395170404uLL,
  3791679676342426565uLL,
  4743847784124955223uLL,
  3939428438826997938uLL,
  12226466631961438040uLL,
  380016710757123738uLL,
  14087416469497764374uLL,
  8138182875361518595uLL,
  5750736256044723814uLL,
  1619983966589145066uLL,
  18357635038569013170uLL,
  14814083067111296201uLL,
  715413425090626948uLL,
  9135518289989772581uLL,
  13925186074541670108uLL,
  3364764793476385191uLL,
  1508568848530349820uLL,
  14805458262187994201uLL,
  2581819420077395771uLL,
  6278762597119133640uLL,
  3556184041718296984uLL,
  5439958548908742630uLL,
  7479012800218807592uLL,
  7955047275508466584uLL,
  4458066949235466665uLL,
  14405619857460450990uLL,
  8679876237645706046uLL,
  7090760345643478520uLL,
  10420916073231012493uLL,
  13969307499797965498uLL,
  15606609066046934242uLL,
  13475028426200374633uLL,
  14582819938952771207uLL,
  17922194891837345081uLL,
  4125754028215992048uLL,
  8237728046923545536uLL,
  15834689908400742596uLL,
  9482414039290099121uLL,
  16180514410995101061uLL,
  6361338485692057877uLL,
  4650210388499741911uLL,
  3177294050395039042uLL,
  12878722309003899601uLL,
  14776805802460653631uLL,
  12417795414619379443uLL,
  8638306631721133406uLL,
  13374993531057029467uLL,
  16794297820608458695uLL,
  13065224726059011467uLL,
  18161090566516283883uLL,
  10000991812735694046uLL,
  15726288451780480573uLL,
  14325417656278098057uLL,
  18276442862297480992uLL,
  15021258950012786934uLL,
  2673275801057568021uLL,
  10980729785569853527uLL,
  714465189390498639uLL,
  7710723724879456621uLL,
  5953251749140717989uLL,
  118077562892454633uLL,
  6530344183011542391uLL,
  4783103019933741530uLL,
  8503129753748748176uLL,
  1373327054916871614uLL,
  6669491806629209052uLL,
  4619390691939421970uLL,
  5179515648996959200uLL,
  17155187161697855366uLL,
  766338409476030181uLL,
  6174714569872033076uLL,
  17368333665660907914uLL,
  16120237955114327542uLL,
  10439866645798423118uLL,
  6237193887174943905uLL,
  7900288714350616477uLL,
  5028236635819917577uLL,
  14941654990907225065uLL,
  1275793776340190361uLL,
  13597436476261611948uLL,
  318366277531347168uLL,
  3197935369052220685uLL,
  12180226880536647184uLL,
  2504132107801706035uLL,
  2093311415691930214uLL,
  6922968032991936927uLL,
  11927163809467665465uLL,
  6498538161365680020uLL,
  5317923361881221976uLL,
  1984350716132981565uLL,
  17114404654485726811uLL,
  2972873668403553411uLL,
  6222876120405539532uLL,
  13784618221787804389uLL,
  11899182145211787639uLL,
  4978466172617045902uLL,
  5472336470505433178uLL,
  7507908464930718658uLL,
  4578519326550553428uLL,
  17096232158379453321uLL,
  10976393345146391307uLL,
  13157233092310693755uLL,
  5837651449315757829uLL,
  3522472294424637525uLL,
  13371242401898742198uLL,
  18396572553515496657uLL,
  1479883141297090646uLL,
  12234424566944963686uLL,
  5420445628202743048uLL,
  10731003223710911985uLL,
  10358986641882413654uLL,
  14138233474367093252uLL,
  10161105303174940855uLL,
  5221210355222047774uLL,
  13316923634258916882uLL,
  12994861201109634664uLL,
  449688148965171360uLL,
  17412473396382420084uLL,
  10163377233794373973uLL,
  8790836677585569327uLL,
  14338671742972842895uLL,
  9635950892958167495uLL,
  10265929424288084660uLL,
  6215699239099148302uLL,
  6957179226869499802uLL,
  8451901963419586670uLL,
  12670061005932332406uLL,
  16726097683059026649uLL,
  16063955088469276942uLL,
  13102397751801344190uLL,
  11417447281476489587uLL,
  13359637725955156344uLL,
  8245110187859509816uLL,
  7339993977514879941uLL,
  10129395182840808247uLL,
  3659997764317471742uLL,
  4691598600072034734uLL,
  8284964964162430336uLL,
  9566823205505672627uLL,
  4189915749727266302uLL,
  5308965371519461459uLL,
  2054797008891295341uLL,
  18127093924196552729uLL,
  4299196883765669209uLL,
  11827607050011750044uLL,
  4366869471967700896uLL,
  14900107216279217013uLL,
  5151825020866902336uLL,
  12851456451705123783uLL,
  14964368771570310647uLL,
  16330134348011374408uLL,
  5025013570029662271uLL,
  11274104849752320816uLL,
  1053939472501839694uLL,
  4221769898647927732uLL,
  4357920165500097666uLL,
  7834076884326979563uLL,
  4272063780046627846uLL,
  4039116997058321770uLL,
  15719527290815271228uLL,
  1348202375856620388uLL,
  2301898783875571271uLL,
  6460035136011136646uLL,
  10697760313953023253uLL,
  9757329734462923813uLL,
  4584246636790019109uLL,
  6885835975334039940uLL,
  6249906805861885349uLL,
  1725716591743982184uLL,
  11654361487674072621uLL,
  9884822493454733233uLL,
  12987911935559252168uLL,
  4902101741859337225uLL,
  18350419941460675969uLL,
  15398558065995343830uLL,
  15727956704498719552uLL,
  9775692600225218369uLL,
  5118530954824848124uLL,
  941859248514608678uLL,
  6746433271605450562uLL,
  2114129833224464615uLL,
  12546478733877450220uLL,
  6395367805235268478uLL,
  6351512176232662553uLL,
  11672948938689807397uLL,
  15146708894654240359uLL,
  12711757839786531851uLL,
  10393967024288635114uLL,
  1079482412171585708uLL,
  1660095950523830107uLL,
  4570275898977334110uLL,
  9984337143728963412uLL,
  8352020334175620458uLL,
  7268817811428017472uLL,
  10186204447584012985uLL,
  17127960777199221886uLL,
  16597698406407271981uLL,
  7425334241403613730uLL,
  4771374893546118783uLL,
  3442128010744075328uLL,
  10027420342430549022uLL,
  12083075240219002361uLL,
  588527856080217357uLL,
  305227581199019801uLL,
  9136966043892137413uLL,
  16167939901854583435uLL,
  9361845494630744524uLL,
  8878612434848834319uLL,
  16060149010011229344uLL,
  17919194163411307292uLL,
  6639113234980662253uLL,
  18078320177945311096uLL,
  15546328468071953813uLL,
  13546331756440638230uLL,
  14199943778032405328uLL,
  10630353806352961533uLL,
  18144698404047954644uLL,
  1197376723885704574uLL,
  16230126305972622040uLL,
  13879110215555232370uLL,
  227176813662154075uLL,
  12259279986700132039uLL,
  16436033856146448774uLL,
  5277417808893919132uLL,
  15407423850140845350uLL,
  14941017342975270852uLL,
  5674047306833804966uLL,
  7851051224316364461uLL,
  9425565812167574176uLL,
  2943367180561279421uLL,
  8105073495705153153uLL,
  18155546573049577216uLL,
  5697406480502376064uLL,
  5877477751337405235uLL,
  16569231526066812308uLL,
  15537884248800472423uLL,
  10457536541605423473uLL,
  2223801759201342324uLL,
  14316208179399799868uLL,
  15637346486681360577uLL,
  4608566767287318283uLL,
  15573142054250388104uLL,
  6547935807155622982uLL,
  2358717164769637863uLL,
  16614977917201558734uLL,
  9224005500602735395uLL,
  10714921687208609333uLL,
  8671288339249264200uLL,
  5608869571866323513uLL,
  16021647703108623168uLL,
  7977466863429629561uLL,
  10348410572281587866uLL,
  7242289474995514715uLL,
  1567169508226279381uLL,
  13859779875488551809uLL,
  11529389869754286116uLL,
  12412500515456065757uLL,
  17353677876775041213uLL,
  1025395215826879256uLL,
  1615699621365775136uLL,
  4321995075701125085uLL,
  7179077730157579846uLL,
  11538444951899202355uLL,
  4448248277864616299uLL,
  8394522697799974727uLL,
  7265749836394272542uLL,
  562550948483866244uLL,
  8433249156541039618uLL,
  12740995855244699898uLL,
  6288290551140793701uLL,
  17808079497555484198uLL,
  5018038877509214997uLL,
  18911087437259851uLL,
  16955519772417071495uLL,
  7864500398214309565uLL,
  975518652973548277uLL,
  17802037049267904108uLL,
  622187558004557147uLL,
  15318501651330331146uLL,
  5598898530851347884uLL,
  15022728920480447812uLL,
  7970622010814221179uLL,
  10467490273800292370uLL,
  1251993471097504428uLL,
  6584765995150877185uLL,
  12775098777202305839uLL,
  9528624601268067443uLL,
  6791359573957131238uLL,
  8524739724542477550uLL,
  5391013523391169218uLL,
  16544365194255056399uLL,
  5551858142341314141uLL,
  13150694727490329004uLL,
  7884679690313721309uLL,
  13646039774517641819uLL,
  15511235226750475393uLL,
  14308408534714033049uLL,
  16894040979321575468uLL,
  17625365623029753264uLL,
  15655709270582917808uLL,
  11127891396163609889uLL,
  10343413873168693000uLL,
  92947107uLL
}; // idb
_UNKNOWN unk_AC630; // weak
__int64 (__fastcall *off_BAD40[4])() = { &sub_9F90, &sub_9BE0, &sub_9F40, &sub_9860 }; // weak
__int64 (__fastcall *off_BAD50[2])() = { &sub_9F40, &sub_9860 }; // weak
_UNKNOWN unk_BAD60; // weak
void *off_BAD80 = &unk_BD000; // weak
void *off_BAE20 = (void *)0x93F50LL; // weak
void *jpt_625C0[30] =
{
  &loc_61593,
  &loc_61593,
  &loc_61593,
  &loc_61593,
  &loc_61593,
  &loc_61593,
  &loc_61593,
  &loc_61593,
  &loc_61593,
  &loc_61593,
  &loc_62530,
  &loc_61593,
  &loc_61593,
  &loc_61593,
  &loc_624F8,
  &loc_62350,
  &loc_624D0,
  &loc_62380,
  &loc_62480,
  &loc_61593,
  &loc_61593,
  &loc_61593,
  &loc_61593,
  &loc_61EA0,
  &loc_61593,
  &loc_61593,
  &loc_61593,
  &loc_61593,
  &loc_61593,
  &loc_61593
}; // weak
void *jpt_6711A[30] =
{
  &def_66BD6,
  &def_66BD6,
  &def_66BD6,
  &def_66BD6,
  &def_66BD6,
  &def_66BD6,
  &def_66BD6,
  &def_66BD6,
  &def_66BD6,
  &def_66BD6,
  &def_66BD6,
  &loc_67090,
  &def_66BD6,
  &def_66BD6,
  &loc_67710,
  &loc_676E0,
  &loc_67030,
  &loc_66F90,
  &loc_676D0,
  &loc_675E8,
  &loc_66E00,
  &loc_66D98,
  &loc_674B8,
  &loc_66EF8,
  &loc_66ED0,
  &loc_66C50,
  &loc_67510,
  &def_66BD6,
  &def_66BD6,
  &def_66BD6
}; // weak
char *off_BBF20[41] =
{
  "Success",
  "Operation not permitted",
  "No such file or directory",
  "No such process",
  "Interrupted system call",
  "Input/output error",
  "No such device or address",
  "Argument list too long",
  "Exec format error",
  "Bad file descriptor",
  "No child processes",
  "Resource temporarily unavailable",
  "Cannot allocate memory",
  "Permission denied",
  "Bad address",
  "Block device required",
  "Device or resource busy",
  "File exists",
  "Invalid cross-device link",
  "No such device",
  "Not a directory",
  "Is a directory",
  "Invalid argument",
  "Too many open files in system",
  "Too many open files",
  "Inappropriate ioctl for device",
  "Text file busy",
  "File too large",
  "No space left on device",
  "Illegal seek",
  "Read-only file system",
  "Too many links",
  "Broken pipe",
  "Numerical argument out of domain",
  "Numerical result out of range",
  "Resource deadlock avoided",
  "File name too long",
  "No locks available",
  "Function not implemented",
  "Directory not empty",
  "Too many levels of symbolic links"
}; // weak
void *off_BC3E0 = (void *)0x93F50LL; // weak
void *off_BC5A0 = (void *)0x93F50LL; // weak
char *off_BD080 = "glibc.rtld.nns"; // weak
_UNKNOWN unk_BD0A8; // weak
int dword_BD704 = 0; // weak
__int64 qword_BD720[] = { 0LL }; // weak
__int64 qword_BD728 = 0LL; // weak
__int64 qword_BD7B0 = 0LL; // weak
__int64 qword_BD7B8 = 0LL; // weak
__int64 qword_BD7C0 = 0LL; // weak
__int64 qword_BD7C8 = 0LL; // weak
__int64 qword_BD7D0 = 0LL; // weak
__int64 qword_BD7D8 = 0LL; // weak
int dword_BD7E0 = 1; // weak
char *off_BD800 = "=INTERNAL->ucs4"; // weak
char *off_BD820 = "=ucs4->INTERNAL"; // weak
__int64 (__fastcall *off_BD980)() = &sub_5CD70; // weak
_QWORD qword_BDA00[16] =
{
  2LL,
  2LL,
  0LL,
  0LL,
  2LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL
}; // idb
void **off_BDA80[6] = { &off_BAE20, &off_BC5A0, &off_BC620, &off_BCEA0, &off_BC3E0, &off_BC360 }; // weak
void **off_BDB00[6] = { &off_BAE20, &off_BC5A0, &off_BC620, &off_BCEA0, &off_BC3E0, &off_BC360 }; // weak
__int64 qword_BDBF0 = 0LL; // weak
int dword_BDBF8 = 0; // weak
__int64 qword_BDC00 = 0LL; // weak
__int64 qword_BDC08 = 0LL; // weak
__int64 qword_BDC10 = 0LL; // weak
__int64 qword_BDC20 = 0LL; // weak
int dword_BDC30 = 16777216; // weak
Elf64_Dyn stru_BDC38 = { 12uLL, 36864uLL }; // weak
_QWORD perms[4] = { -1LL, -1LL, 256LL, 16LL }; // idb
char *off_BE040 = "messages"; // weak
void *off_BE048 = &unk_C0D80; // weak
void *off_BE060 = &unk_BE080; // weak
void *stderr = &unk_BE080; // idb
void *off_BE610 = &unk_BE260; // weak
int dword_BE620 = -1; // weak
int dword_BE624 = -1; // weak
__int64 qword_BE628 = 1LL; // weak
void *off_BE640 = &loc_20000; // weak
void *off_BE648 = &loc_20000; // weak
void *off_BE650 = &loc_20000; // weak
__int64 qword_BE658 = 8LL; // weak
__int64 qword_BE660 = 0LL; // weak
int dword_BE668 = 0; // weak
int dword_BE66C = 65536; // weak
int dword_BE670 = 0; // weak
int dword_BE674 = 0; // weak
__int64 qword_BE678 = 0LL; // weak
__int64 qword_BE680 = 0LL; // weak
__int64 qword_BE688 = 0LL; // weak
int *off_BE690 = &dword_40; // weak
__int64 qword_BE698 = 1032LL; // weak
__int64 qword_BE6A0 = 7LL; // weak
__int64 qword_BE6A8 = 0LL; // weak
__int64 (*off_BE6C0)(void) = &sub_21B20; // weak
__int64 (__fastcall *off_BE6C8)(_QWORD, _QWORD, _QWORD) = &loc_22150; // weak
__int64 (__fastcall *off_BE6D0)(_QWORD, _QWORD, _QWORD) = &sub_21830; // weak
u32 dword_BE6E0 = 0u; // idb
int dword_BE6E4 = 0; // weak
int dword_BE6E8 = 0; // weak
__int64 qword_BE740 = 0LL; // weak
int *off_BEF50[2] = { &dword_BE6E0, &dword_0 }; // weak
__int64 qword_BEF68 = 0LL; // weak
__int64 (__fastcall *off_BEF78)(_QWORD) = &sub_22FE0; // weak
__int64 qword_BEF80 = 2048LL; // weak
__int64 qword_BEF88 = 2048LL; // weak
__int64 qword_BEF90 = 1048576LL; // weak
__int64 (__fastcall *off_BEF98)() = &sub_80000; // weak
__int64 qword_BEFA0 = 1048576LL; // weak
__int64 (__fastcall *off_BEFA8)() = &sub_80000; // weak
__int64 qword_BEFB0 = 32768LL; // weak
Elf64_Rela *off_BEFB8 = &stru_4000; // weak
__int64 qword_BEFC0 = 32768LL; // weak
Elf64_Rela *off_BEFC8 = &stru_4000; // weak
int dword_BEFD0 = -1; // weak
void *off_BEFD8 = &unk_A6E65; // weak
void *off_BEFE0 = &unk_A6E65; // weak
int dword_BF068 = 7; // weak
__int16 word_BF06C = 895; // weak
int dword_BF070 = 771; // weak
int dword_BF074 = 2; // weak
Elf64_Rela *off_BF078 = &stru_1000; // weak
__int64 qword_BF080 = 1LL; // weak
__int64 qword_BF088 = 1LL; // weak
__int64 qword_BF090 = -2LL; // weak
__int64 (__fastcall *off_BF098)(_QWORD) = &sub_780E0; // weak
__int64 (__fastcall *off_BF0A0)(_QWORD) = &sub_74770; // weak
void **off_BF0B0 = &off_BF0C0; // weak
int dword_BF0B8 = 1; // weak
void *off_BF0E0 = &unk_BF180; // weak
int dword_BF0E8 = 1; // weak
void ***off_BF0F0 = &off_BF440; // weak
int dword_BF0F8 = 0; // weak
_UNKNOWN unk_BF180; // weak
__int64 qword_BF428 = 0LL; // weak
__int16 word_BF438 = 0; // weak
__int64 qword_BF4C8 = 0LL; // weak
__int64 qword_BF5E8 = 0LL; // weak
__int64 qword_BF5F0 = 0LL; // weak
int dword_BF628 = 1; // weak
char *off_BF640[2] = { "INTERNAL", "ISO-10646/UCS4/" }; // weak
void **off_BF8E0[6] = { &off_BAE20, &off_BC5A0, &off_BC620, &off_BCEA0, &off_BC3E0, &off_BC360 }; // weak
void *off_BF948 = &byte_971A0; // weak
void *off_BF950 = &dword_962A0; // weak
void *off_BF958 = &dword_968A0; // weak
void *off_BF960 = (void *)0x93F50LL; // weak
void *off_BF990 = (void *)0x93F50LL; // weak
__int16 word_BF9C8 = 895; // weak
char byte_BF9CA = '\x01'; // weak
__int64 (__fastcall *off_BF9E0[4])() = { &sub_7A0B0, &sub_79C80, &sub_79F90, &sub_79D10 }; // weak
__int64 (__fastcall *off_BFA20[9])() =
{
  &sub_858E0,
  &sub_85970,
  &sub_859C0,
  &sub_85A90,
  &sub_7F5F0,
  &sub_7FA10,
  &sub_7FA20,
  &sub_7FB30,
  &sub_7FC00
}; // weak
__int64 qword_BFA88 = -1LL; // weak
__int64 (__fastcall *off_BFA90[9])() =
{
  &sub_8DB50,
  &sub_8DD60,
  &sub_8DEC0,
  &sub_8DF30,
  &sub_8DF60,
  &sub_8DFC0,
  &sub_8E3C0,
  &sub_8E480,
  &sub_8E5A0
}; // weak
_UNKNOWN unk_BFAE0; // weak
_UNKNOWN unk_BFBA0; // weak
_UNKNOWN unk_BFC60; // weak
_UNKNOWN unk_BFD20; // weak
_UNKNOWN unk_BFDE0; // weak
_UNKNOWN unk_BFEA0; // weak
_UNKNOWN unk_BFF60; // weak
__int64 (__fastcall *off_BFFF8[2])() = { &sub_1BD70, &sub_1BD80 }; // weak
_UNKNOWN unk_C0020; // weak
_UNKNOWN unk_C00E0; // weak
_UNKNOWN unk_C01A0; // weak
_UNKNOWN unk_C0260; // weak
void *off_C0308 = &loc_1B330; // weak
void (*qword_C0310[2])(void); // idb
char byte_C0320; // weak
__int64 qword_C0340; // weak
__int64 qword_C0348; // weak
__int64 qword_C0350; // weak
__int64 qword_C0358; // weak
__int64 qword_C0360; // weak
__int64 qword_C0368; // weak
__int64 qword_C0370; // weak
__int64 qword_C0378; // weak
char byte_C0380; // weak
__int64 qword_C0388; // weak
__int64 qword_C03A0; // weak
_UNKNOWN unk_C03B0; // weak
__int64 qword_C03C0; // weak
__int64 qword_C03C8; // weak
__int64 qword_C07A0; // weak
__int64 qword_C07C8; // weak
__int64 qword_C0BF8; // weak
__int64 qword_C0C00; // weak
int dword_C0C08; // weak
__int64 qword_C0C10; // weak
__int64 qword_C0C18; // weak
u32 dword_C0C20; // idb
__int64 qword_C0C28; // weak
__int64 qword_C0C30; // weak
__int64 qword_C0CB8; // weak
int dword_C0CC0; // weak
u32 dword_C0CD0; // idb
int dword_C0CD4; // weak
__int64 qword_C0CD8; // weak
__int64 qword_C0CE0; // weak
__int64 qword_C0CE8; // weak
__int64 qword_C0CF0; // weak
__int64 qword_C0CF8; // weak
__int64 qword_C0D00; // weak
u32 dword_C0D08; // idb
__int64 qword_C0D10; // weak
u32 uaddr; // idb
int dword_C0D24; // weak
__int64 qword_C0D28; // weak
int dword_C0D30; // weak
__int64 qword_C0D38; // weak
int dword_C0D40; // weak
char byte_C0D44; // weak
__int64 qword_C0D60; // weak
u32 dword_C0D68; // idb
u32 dword_C1190; // idb
int dword_C1194; // weak
__int64 qword_C1198; // weak
__int64 qword_C11A0; // weak
__int64 qword_C11B0; // weak
char byte_C11B8; // weak
int dword_C11BC; // weak
__int64 qword_C11C0; // weak
u32 qword_C11D0; // idb
__int64 qword_C11D8; // weak
__int64 (__fastcall *qword_C1210)(double, double, double, double, double, double, double, double); // weak
__int64 (__fastcall *qword_C1218)(_QWORD, _QWORD); // weak
__int64 qword_C1220; // weak
__int64 qword_C1228; // weak
int dword_C1230; // weak
void *addr; // idb
u32 dword_C1240; // idb
__int64 qword_C1248; // weak
u32 dword_C1250; // idb
int dword_C1254; // weak
__int64 qword_C1258; // weak
__int64 qword_C1260; // weak
_UNKNOWN unk_C1268; // weak
void *qword_C1270; // idb
__int64 qword_C1278; // weak
_UNKNOWN unk_C1280; // weak
__int64 qword_C12A0; // weak
int dword_C12C0; // weak
__int64 qword_C12C8; // weak
__int64 qword_C12D0; // weak
__int64 qword_C12D8; // weak
__int64 (__fastcall *qword_C12E0)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 qword_C12F0; // weak
__int64 qword_C12F8; // weak
__int64 qword_C1300; // weak
__int64 qword_C1308; // weak
__int64 qword_C1310; // weak
__int64 qword_C1318; // weak
__int64 qword_C1320; // weak
int dword_C1328; // weak
int dword_C132C; // weak
int dword_C1340; // weak
int dword_C1344; // weak
int dword_C1348; // weak
int dword_C134C; // weak
int dword_C1350; // weak
__int128 xmmword_C1354; // weak
__int128 xmmword_C1364; // weak
__int128 xmmword_C1374; // weak
__int128 xmmword_C1384; // weak
int dword_C1394; // weak
int dword_C1398; // weak
int dword_C139C; // weak
int dword_C13A0; // weak
int dword_C13AC; // weak
int dword_C13B0; // weak
int dword_C13B4; // weak
int dword_C13B8; // weak
int dword_C13BC; // weak
int dword_C13C0; // weak
int dword_C13C4; // weak
int dword_C13D4; // weak
int dword_C13D8; // weak
int dword_C13DC; // weak
int dword_C13E0; // weak
int dword_C13F0; // weak
int dword_C13F4; // weak
int dword_C13F8; // weak
int dword_C13FC; // weak
int dword_C1400; // weak
int dword_C1408; // weak
int dword_C1414; // weak
int dword_C1418; // weak
int dword_C141C; // weak
int dword_C1420; // weak
int dword_C1424; // weak
int dword_C1434; // weak
__int64 qword_C1438; // weak
int dword_C1440; // weak
__int64 qword_C1448; // weak
__int64 qword_C1450; // weak
__int64 qword_C1458; // weak
__int64 qword_C1460; // weak
__int64 qword_C1468; // weak
char byte_C1470; // weak
int dword_C1474; // weak
int dword_C1478; // weak
__int64 qword_C1480; // weak
__int64 qword_C1488; // weak
__int64 qword_C1498; // weak
__int64 qword_C14A0; // weak
int dword_C14A8; // weak
int dword_C14AC; // weak
int dword_C14B0; // weak
int dword_C14B4; // weak
__int64 qword_C14B8; // weak
__int64 qword_C14C0; // weak
int dword_C14D0; // weak
__int64 qword_C14D8; // weak
int dword_C14E0; // weak
u32 dword_C14E8; // idb
__int64 qword_C14F0; // weak
__int64 qword_C14F8; // weak
__int64 qword_C1500; // weak
__int64 qword_C1508; // weak
__int64 qword_C1510; // weak
__int64 qword_C1518; // weak
int dword_C1520; // weak
int dword_C1524; // weak
int dword_C1528; // weak
__int64 qword_C1530; // weak
__int64 qword_C1538; // weak
__int64 qword_C1540; // weak
_QWORD qword_C15A0[16]; // idb
__int64 qword_C1620; // weak
_UNKNOWN unk_C1640; // weak
unsigned __int64 qword_C1670; // idb
__int64 qword_C16D0; // weak
int dword_C16DC; // weak
__int64 qword_C16E8; // weak
__int64 qword_C16F0; // weak
__int64 qword_C16F8; // weak
u32 dword_C1700; // idb
_UNKNOWN unk_C1708; // weak
_UNKNOWN unk_C1710; // weak
__int64 qword_C1718; // weak
__int64 qword_C1720; // weak
int dword_C1728; // weak
__int64 qword_C1730; // weak
__int64 qword_C1738; // weak
int dword_C1740; // weak
int dword_C1744; // weak
__int64 qword_C1748; // weak
__int64 qword_C1750; // weak
__int64 qword_C1758; // weak
int dword_C1760; // weak
int dword_C1764; // weak
__int64 qword_C1768; // weak
__int64 qword_C1770; // weak
__int64 qword_C1778; // weak
__int64 qword_C1780; // weak
__int64 qword_C1788; // weak
__int64 qword_C1798; // weak
int dword_C17C0; // weak
__int64 qword_C17C8; // weak
_UNKNOWN unk_C17E0; // weak
__int64 qword_C17F8; // weak
_UNKNOWN unk_C1800; // weak
struct itimerval stru_C18A0; // idb
int dword_C18C0; // weak
__int64 qword_C18C8; // weak
__int64 qword_C18D0; // weak
__int64 qword_C18D8; // weak
int dword_C18E0; // weak
char byte_C1900[]; // weak
char byte_C1907; // weak
_UNKNOWN unk_C1920; // weak
__int64 qword_C1928; // weak
__int64 qword_C1930; // weak
_UNKNOWN unk_C1940; // weak
_UNKNOWN unk_C1970; // weak
__int64 qword_C1AB8; // weak
int dword_C1AE8; // weak
__int64 qword_C1AF0; // weak
__int64 qword_C1AF8; // weak
__int64 qword_C1B00; // weak
__int64 qword_C1B08; // weak
__int64 qword_C1B10; // weak
__int64 qword_C1B18; // weak


//----- (0000000000009000) ----------------------------------------------------
__int64 init_proc()
{
  return 0LL;
}
// 0: using guessed type __int64 (*dword_0)(void);
// 9000: using guessed type __int64 __fastcall init_proc();

//----- (0000000000009020) ----------------------------------------------------
void sub_9020()
{
  JUMPOUT(0LL);
}
// 9026: control flows out of bounds to 0

//----- (0000000000009284) ----------------------------------------------------
void __fastcall __noreturn exit()
{
  __int64 v0; // rcx
  __int64 *v1; // rsi
  u32 *v2; // r8
  u32 v3; // er9
  unsigned __int64 v4; // rbx
  bool v6; // zf
  __int32 v7; // eax
  signed __int64 v8; // rax
  __int64 v9; // rcx
  u32 *v10; // r8
  u32 v11; // er9
  unsigned __int64 v12; // rbx
  __int64 v14; // rcx
  char *v15; // rdi
  __int64 v16[16]; // [rsp+0h] [rbp-128h] BYREF
  char v17[8]; // [rsp+80h] [rbp-A8h] BYREF
  __int64 v18; // [rsp+88h] [rbp-A0h]
  unsigned __int64 v19; // [rsp+118h] [rbp-10h]

  v4 = __readfsqword(0x10u);
  v19 = __readfsqword(0x28u);
  if ( qword_C0D28 != v4 )
  {
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedCompareExchange((volatile signed __int32 *)&uaddr, 1, 0) )
        sub_1C7D0((volatile __int32 *)&uaddr, (__int64)v1, 1LL, v0, v2, v3);
    }
    else
    {
      _EDX = 1;
      __asm { cmpxchg cs:uaddr, edx }
    }
    qword_C0D28 = v4;
  }
  ++dword_C0D24;
  if ( !dword_C0D30 )
  {
    v1 = v16;
    dword_C0D30 = 1;
    v16[0] = 32LL;
    sub_5D2B0(1, (const __m128i *)v16, 0LL);
  }
  if ( dword_C0D30 == 1 )
  {
    dword_C0D30 = 0;
    v6 = dword_C0D24 == 1;
    v7 = --dword_C0D24;
    if ( v6 )
    {
      qword_C0D28 = 0LL;
      if ( __readfsdword(0x18u) )
      {
        if ( _InterlockedExchange((volatile __int32 *)&uaddr, v7) > 1 )
        {
          v1 = &qword_80 + 1;
          v8 = sys_futex(&uaddr, 129, 1u, 0LL, v2, v3);
        }
      }
      else
      {
        --uaddr;
      }
    }
    sub_11B10(6);
    v12 = __readfsqword(0x10u);
    if ( qword_C0D28 != v12 )
    {
      if ( __readfsdword(0x18u) )
      {
        if ( _InterlockedCompareExchange((volatile signed __int32 *)&uaddr, 1, 0) )
          sub_1C7D0((volatile __int32 *)&uaddr, (__int64)v1, 1LL, v9, v10, v11);
      }
      else
      {
        _EDX = 1;
        __asm { cmpxchg cs:uaddr, edx }
      }
      qword_C0D28 = v12;
    }
    ++dword_C0D24;
  }
  else if ( dword_C0D30 != 2 )
  {
    goto LABEL_27;
  }
  v14 = 38LL;
  dword_C0D30 = 3;
  v15 = v17;
  while ( v14 )
  {
    *(_DWORD *)v15 = 0;
    v15 += 4;
    --v14;
  }
  v18 = -1LL;
  sub_5D270(6, (__int64)v17, 0LL);
LABEL_27:
  if ( dword_C0D30 == 3 )
  {
    dword_C0D30 = 4;
    sub_11B10(6);
  }
  if ( dword_C0D30 == 4 )
  {
    dword_C0D30 = 5;
    __halt();
  }
  if ( dword_C0D30 == 5 )
  {
    dword_C0D30 = 6;
    sub_49B40(127);
  }
  __halt();
}
// 92E7: variable 'v1' is possibly undefined
// 92E7: variable 'v0' is possibly undefined
// 92E7: variable 'v2' is possibly undefined
// 92E7: variable 'v3' is possibly undefined
// 93DE: variable 'v9' is possibly undefined
// 93DE: variable 'v10' is possibly undefined
// 93DE: variable 'v11' is possibly undefined
// 80: using guessed type __int64 qword_80;
// C0D24: using guessed type int dword_C0D24;
// C0D28: using guessed type __int64 qword_C0D28;
// C0D30: using guessed type int dword_C0D30;

//----- (0000000000009860) ----------------------------------------------------
void __fastcall sub_9860(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14)
{
  bool v14; // cf
  bool v15; // zf
  unsigned __int64 v16; // rcx
  const char *v17; // rdi
  const char *v18; // rsi

  v14 = 0;
  v15 = qword_C17F8 == 0;
  if ( qword_C17F8 )
  {
    v16 = 14LL;
    v17 = "out of memory";
    v18 = (const char *)qword_C17F8;
    do
    {
      if ( !v16 )
        break;
      v14 = *v18 < (unsigned int)*v17;
      v15 = *v18++ == *v17++;
      --v16;
    }
    while ( v15 );
    if ( (!v14 && !v15) != v14 )
    {
      sub_21B70(qword_C17F8, a1, a2, a3, a4, a5, a6, a7, a8, (__int64)v18, a11, v16, (u32 *)qword_C17F8, a14);
      qword_C17F8 = 0LL;
    }
  }
}
// C17F8: using guessed type __int64 qword_C17F8;

//----- (00000000000098B0) ----------------------------------------------------
void __fastcall sub_98B0(__int64 *a1, unsigned int *a2, __int64 a3)
{
  __int64 v5; // r15
  __int64 v6; // r9
  unsigned int v7; // er13
  int v8; // er14
  signed int v9; // esi
  int v10; // er8
  int v11; // ecx
  int v12; // edi
  int v18; // ecx
  _BOOL4 v19; // eax
  int v20; // edi
  int v26; // ecx
  int i; // edx
  int v28; // er8
  unsigned int v33; // ecx
  int v34; // ebx
  unsigned int v35; // ecx
  __int64 v36; // rax
  unsigned int v37; // ecx
  bool v38; // [rsp+1h] [rbp-41h]
  int v39; // [rsp+2h] [rbp-40h]

  v5 = a3;
  v6 = *a1;
  v7 = *a2;
  if ( *a1 <= 0 )
  {
    v39 = 2;
    v6 = a3;
    v8 = -1;
  }
  else
  {
    v39 = 3;
    v8 = 0;
  }
  if ( (HIBYTE(xmmword_C1364) & 0x10) == 0 )
    goto LABEL_14;
  if ( dword_C1344 <= 3 )
  {
    v38 = 1;
    v9 = 0;
LABEL_6:
    v7 = BYTE6(xmmword_C1354);
    goto LABEL_7;
  }
  v10 = 3;
  if ( v8 )
  {
    v10 = 1;
    v8 = -1;
  }
  v38 = 1;
  v11 = 0;
  v9 = 0;
  while ( 1 )
  {
    v12 = v11 + 1;
    _RAX = 4LL;
    __asm { cpuid }
    if ( dword_C1340 == 1 )
      break;
    v18 = (unsigned __int8)_RAX >> 5;
    if ( v18 == 2 )
      goto LABEL_27;
LABEL_20:
    if ( v18 == 3 && (v10 & 2) != 0 )
    {
      v10 &= 0xFFFFFFFD;
      v8 = ((unsigned int)_RAX >> 14) & 0x3FF;
      v38 = (_RDX & 2) != 0;
      goto LABEL_23;
    }
LABEL_24:
    v11 = v12;
  }
  if ( (_RAX & 0x1F) == 0 )
    goto LABEL_6;
  v18 = (unsigned __int8)_RAX >> 5;
  if ( v18 != 2 )
    goto LABEL_20;
LABEL_27:
  if ( (v10 & 1) == 0 )
    goto LABEL_24;
  v10 &= 0xFFFFFFFE;
  v9 = ((unsigned int)_RAX >> 14) & 0x3FF;
LABEL_23:
  if ( v10 )
    goto LABEL_24;
  if ( dword_C1340 == 3 && dword_C1348 == 6 || dword_C1344 <= 10 )
    goto LABEL_44;
  v19 = v9 > 0 && v39 == 3;
  v20 = v19 | 2;
  if ( v8 > 0 || (v20 = v19 | (2 * (v9 > 0 && v39 == 2))) != 0 )
  {
    _RAX = 11LL;
    __asm { cpuid }
    LODWORD(_RBX) = (unsigned __int8)_RBX;
    v26 = _RCX & 0xFF00;
    if ( v26 && (_BYTE)_RBX )
    {
      for ( i = 1; ; i = v28 )
      {
        if ( v26 == 256 )
        {
          if ( (v20 & 1) == 0 )
            goto LABEL_37;
          _BitScanReverse(&v33, v9);
          v20 &= 0xFFFFFFFE;
          v9 = (_RBX - 1) & ~(-1 << (v33 + 1));
        }
        else
        {
          if ( v26 != 512 || (v20 & 2) == 0 )
            goto LABEL_37;
          v34 = _RBX - 1;
          if ( v39 == 2 )
          {
            _BitScanReverse(&v37, v9);
            v9 = v34 & ~(-1 << (v37 + 1));
          }
          else
          {
            _BitScanReverse(&v35, v8);
            v8 = v34 & ~(-1 << (v35 + 1));
          }
          v20 &= 0xFFFFFFFD;
        }
        if ( !v20 )
          break;
LABEL_37:
        v28 = i + 1;
        _RAX = 11LL;
        __asm { cpuid }
        v26 = _RCX & 0xFF00;
        LODWORD(_RBX) = (unsigned __int8)_RBX;
        if ( !(_BYTE)_RBX || !v26 )
          break;
      }
    }
LABEL_44:
    if ( v9 )
      goto LABEL_45;
    goto LABEL_46;
  }
  if ( !v9 )
  {
    if ( v39 == 2 )
      goto LABEL_7;
LABEL_54:
    if ( v8 )
      v7 = -1;
    goto LABEL_7;
  }
LABEL_45:
  ++v9;
LABEL_46:
  if ( v8 <= 0 )
  {
    if ( v39 != 2 )
      goto LABEL_54;
  }
  else if ( v39 != 2 )
  {
    v7 = v8 + 1;
    goto LABEL_7;
  }
  if ( v9 )
  {
    v7 = v9;
    if ( dword_C1340 == 1 && (unsigned int)v9 > 2 && dword_C1348 == 6 )
    {
      v36 = (unsigned int)(dword_C134C - 55);
      if ( (unsigned int)v36 <= 0x26 )
        __asm { jmp     rax }
    }
  }
LABEL_7:
  if ( v6 > 0 && v7 )
    v6 /= (__int64)v7;
  if ( !v38 )
  {
    if ( v9 )
      v5 /= v9;
    v6 += v5;
  }
LABEL_14:
  *a1 = v6;
  *a2 = v7;
}
// C1340: using guessed type int dword_C1340;
// C1344: using guessed type int dword_C1344;
// C1348: using guessed type int dword_C1348;
// C134C: using guessed type int dword_C134C;
// C1354: using guessed type __int128 xmmword_C1354;
// C1364: using guessed type __int128 xmmword_C1364;

//----- (0000000000009BE0) ----------------------------------------------------
unsigned __int64 sub_9BE0()
{
  __int64 v0; // rax
  __int64 v1; // rbp
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  unsigned __int64 v7; // rdx
  __int64 v9; // r12
  __int64 v10; // rax
  __int64 v11; // r12
  __int64 v12; // rsi
  unsigned int v23; // ebx
  unsigned int v24; // eax
  unsigned int v30; // [rsp+Ch] [rbp-2Ch] BYREF
  __int64 v31; // [rsp+10h] [rbp-28h] BYREF
  unsigned __int64 v32; // [rsp+18h] [rbp-20h]

  v32 = __readfsqword(0x28u);
  v30 = 0;
  v31 = -1LL;
  switch ( dword_C1340 )
  {
    case 1:
      v1 = sub_48E90(188);
      v9 = sub_48E90(191);
      v10 = sub_48E90(194);
LABEL_23:
      v31 = v10;
      sub_98B0(&v31, &v30, v9);
      goto LABEL_24;
    case 3:
      v1 = sub_48AE0(188);
      v9 = sub_48AE0(191);
      v10 = sub_48AE0(194);
      goto LABEL_23;
    case 2:
      v1 = sub_48900(188);
      v11 = sub_48900(191);
      v12 = sub_48900(194);
      v31 = v12;
      _RAX = 0x80000000LL;
      __asm { cpuid }
      if ( v12 <= 0 )
      {
        v31 = v11;
LABEL_24:
        v0 = qword_C1448;
        if ( !qword_C1448 )
        {
LABEL_6:
          if ( v1 > 0 )
          {
            v2 = v1;
            qword_BEFB0 = v1;
            LOBYTE(v1) = 0;
            qword_BEFC0 = v1;
            off_BEFB8 = (Elf64_Rela *)(v2 >> 1);
            off_BEFC8 = (Elf64_Rela *)(v1 >> 1);
          }
          v3 = qword_C1450;
          if ( !qword_C1450 )
            goto LABEL_9;
          goto LABEL_20;
        }
LABEL_5:
        v1 = v0;
        goto LABEL_6;
      }
      if ( (unsigned int)_RAX > 0x80000007 )
      {
        _RAX = 2147483656LL;
        __asm { cpuid }
        v24 = 1 << ((unsigned __int16)_RCX >> 12);
        v30 = v24;
      }
      else
      {
        _RAX = 1LL;
        __asm { cpuid }
        if ( (_RDX & 0x10000000) == 0 )
          goto LABEL_31;
        v23 = WORD1(_RBX);
        v24 = (unsigned __int8)v23;
        v30 = (unsigned __int8)v23;
        if ( !(_BYTE)v23 )
          goto LABEL_31;
      }
      v31 = v12 / v24;
LABEL_31:
      v31 += v11;
      goto LABEL_24;
  }
  v0 = qword_C1448;
  if ( qword_C1448 )
    goto LABEL_5;
  v3 = qword_C1450;
  if ( !qword_C1450 )
    goto LABEL_11;
LABEL_20:
  v31 = v3;
LABEL_9:
  v4 = v31;
  if ( v31 > 0 )
  {
    qword_BEF90 = v31;
    LOBYTE(v4) = 0;
    qword_BEFA0 = v4;
    off_BEF98 = (__int64 (__fastcall *)())(v31 >> 1);
    off_BEFA8 = (__int64 (__fastcall *)())(v4 >> 1);
  }
LABEL_11:
  v5 = qword_C1458;
  if ( !qword_C1458 )
    v5 = 3 * qword_BEFA0 * v30 / 4;
  qword_C1260 = v5;
  if ( (BYTE6(xmmword_C1384) & 1) != 0 && (dword_C1434 & 0x4000) == 0 )
  {
    v6 = 0x2000LL;
    v7 = 512LL;
  }
  else
  {
    v6 = (dword_C1434 & 0x100) == 0 ? 2048 : 4096;
    v7 = (dword_C1434 & 0x100) == 0 ? 128 : 256;
  }
  if ( qword_C1460 > v7 )
    v6 = qword_C1460;
  qword_BEF88 = v6;
  qword_BEF80 = qword_C1468;
  return v32 - __readfsqword(0x28u);
}
// BEF80: using guessed type __int64 qword_BEF80;
// BEF88: using guessed type __int64 qword_BEF88;
// BEF90: using guessed type __int64 qword_BEF90;
// BEF98: using guessed type __int64 (__fastcall *off_BEF98)();
// BEFA0: using guessed type __int64 qword_BEFA0;
// BEFA8: using guessed type __int64 (__fastcall *off_BEFA8)();
// BEFB0: using guessed type __int64 qword_BEFB0;
// BEFB8: using guessed type Elf64_Rela *off_BEFB8;
// BEFC0: using guessed type __int64 qword_BEFC0;
// BEFC8: using guessed type Elf64_Rela *off_BEFC8;
// C1260: using guessed type __int64 qword_C1260;
// C1340: using guessed type int dword_C1340;
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;
// C1448: using guessed type __int64 qword_C1448;
// C1450: using guessed type __int64 qword_C1450;
// C1458: using guessed type __int64 qword_C1458;
// C1460: using guessed type __int64 qword_C1460;
// C1468: using guessed type __int64 qword_C1468;

//----- (0000000000009EA0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  __int64 v11; // rax
  unsigned int v12; // esi
  __int64 v13; // [rsp-8h] [rbp-8h] BYREF
  void *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v12 = v13;
  v13 = v11;
  _libc_start_main(
    (__int64 (__fastcall *)(_QWORD, _QWORD *, void *))main,
    v12,
    &retaddr,
    (void (__fastcall *)(_QWORD, _QWORD *, void *))sub_CCC0,
    (__int64)sub_CD60,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10,
    a11,
    (__int64)&v13);
  __halt();
}
// 9EAA: positive sp value 8 has been found
// 9EB1: variable 'v11' is possibly undefined

//----- (0000000000009ED0) ----------------------------------------------------
__int64 (__fastcall **sub_9ED0())()
{
  return off_BFA90;
}
// BFA90: using guessed type __int64 (__fastcall *off_BFA90[9])();

//----- (0000000000009F00) ----------------------------------------------------
__int64 sub_9F00()
{
  return 0LL;
}
// 9F00: using guessed type __int64 __fastcall sub_9F00();

//----- (0000000000009F40) ----------------------------------------------------
__int64 (__fastcall **sub_9F40())()
{
  __int64 (__fastcall **result)(); // rax

  if ( !byte_C0320 )
  {
    result = sub_9ED0();
    byte_C0320 = 1;
  }
  return result;
}
// 0: using guessed type __int64 (*dword_0)(void);
// C0320: using guessed type char byte_C0320;

//----- (0000000000009F90) ----------------------------------------------------
// attributes: thunk
__int64 sub_9F90()
{
  return sub_9F00();
}
// 9F00: using guessed type __int64 sub_9F00(void);

//----- (0000000000009F99) ----------------------------------------------------
__int64 __fastcall sstic_alloc_region(unsigned int a1, int a2, int a3)
{
  int v4[6]; // [rsp+20h] [rbp-20h] BYREF
  unsigned __int64 v5; // [rsp+38h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  v4[0] = a2;
  v4[1] = a3;
  if ( ioctl(a1, 0xC0185300uLL, v4) == -1 )
  {
    perror("allocate region");
    exit();
  }
  return (unsigned int)v4[2];
}

//----- (000000000000A012) ----------------------------------------------------
int __fastcall sstic_assoc(unsigned __int64 a1, int a2, int a3)
{
  int v4[6]; // [rsp+20h] [rbp-20h] BYREF
  unsigned __int64 v5; // [rsp+38h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  v4[0] = a2;
  v4[1] = a3;
  if ( ioctl(a1, 0xC0185302uLL, v4) != -1 )
    return 0;
  perror("assoc region");
  return -1;
}

//----- (000000000000A08B) ----------------------------------------------------
int __fastcall sstic_cmd(int a1, int a2)
{
  int v3[6]; // [rsp+20h] [rbp-20h] BYREF
  unsigned __int64 v4; // [rsp+38h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  v3[0] = a2;
  if ( ioctl(a1, 0xC0185303uLL, v3) != -1 )
    return 0;
  perror("submit command");
  return -1;
}

//----- (000000000000A0FF) ----------------------------------------------------
__int64 __fastcall do_sstic_decrypt(_QWORD *a1, unsigned int a2, _QWORD *a3)
{
  __int64 v3; // rdx
  __int64 v4; // rdx
  unsigned int v7; // [rsp+20h] [rbp-20h]
  unsigned int fd; // [rsp+24h] [rbp-1Ch]
  unsigned int a2a; // [rsp+28h] [rbp-18h]
  unsigned int a6; // [rsp+2Ch] [rbp-14h]
  _QWORD *m_stdin; // [rsp+30h] [rbp-10h]
  _QWORD *m_stdout; // [rsp+38h] [rbp-8h]

  fd = open("/dev/sstic", 2);
  if ( fd == -1 )
  {
    perror("open session");
    v7 = -1;
  }
  else
  {
    a2a = sstic_alloc_region(fd, 1, 3);
    a6 = sstic_alloc_region(fd, 1, 1);
    v7 = sstic_assoc(fd, a2a, 0);
    if ( !v7 )
    {
      v7 = sstic_assoc(fd, a6, 1);
      if ( !v7 )
      {
        m_stdin = mmap(0LL, 0x1000uLL, 3uLL, 1u, fd, a2a);
        if ( m_stdin == (_QWORD *)-1LL )
        {
          perror("map stdin");
          v7 = -1;
        }
        else
        {
          m_stdout = mmap(0LL, 0x1000uLL, 1uLL, 1u, fd, a6);
          if ( m_stdout == (_QWORD *)-1LL )
          {
            perror("map stdout");
            v7 = -1;
          }
          else
          {
            v3 = a1[1];
            *m_stdin = *a1;
            m_stdin[1] = v3;
            m_stdin[2] = a2;
            v7 = sstic_cmd(fd, 1);
            if ( v7 != -1 )
            {
              v4 = m_stdout[1];
              *a3 = *m_stdout;
              a3[1] = v4;
            }
            munmap(m_stdout, 0x1000uLL);
          }
          munmap(m_stdin, 0x1000uLL);
        }
      }
    }
    close(fd);
  }
  return v7;
}

//----- (000000000000A2CF) ----------------------------------------------------
__int64 __fastcall sstic_cmd2(void *prog, unsigned __int64 proglen, void *input, unsigned __int64 inputlen, void *out, unsigned __int64 outlen, void *dbg, unsigned __int64 dbgout)
{
  unsigned int v13; // [rsp+38h] [rbp-38h]
  unsigned int a1; // [rsp+3Ch] [rbp-34h]
  unsigned int chan0; // [rsp+40h] [rbp-30h]
  unsigned int chan1; // [rsp+44h] [rbp-2Ch]
  unsigned int chan3; // [rsp+48h] [rbp-28h]
  unsigned int chan2; // [rsp+4Ch] [rbp-24h]
  void *chan1mem; // [rsp+50h] [rbp-20h]
  void *chan0mem; // [rsp+58h] [rbp-18h]
  void *chan3mem; // [rsp+60h] [rbp-10h]
  void *chan2mem; // [rsp+68h] [rbp-8h]

  if ( proglen > 0x1000 || inputlen > 0x1000 || dbgout > 0x1000 || outlen > 0x1000 )
    return 0xFFFFFFFFLL;
  a1 = open("/dev/sstic", 2);
  if ( a1 != -1 )
  {
    chan0 = sstic_alloc_region(a1, 1, 3);
    chan1 = sstic_alloc_region(a1, 1, 1);
    chan3 = sstic_alloc_region(a1, 1, 3);
    chan2 = sstic_alloc_region(a1, 1, 1);
    v13 = sstic_assoc(a1, chan0, 0);
    if ( v13 )
      goto LABEL_20;
    v13 = sstic_assoc(a1, chan1, 1);
    if ( v13 )
      goto LABEL_20;
    v13 = sstic_assoc(a1, chan3, 3);
    if ( v13 )
      goto LABEL_20;
    v13 = sstic_assoc(a1, chan2, 2);
    if ( v13 )
      goto LABEL_20;
    chan0mem = mmap(0LL, 0x1000uLL, 3uLL, 1u, a1, chan0);
    if ( chan0mem == (void *)-1LL )
    {
      perror("map stdin");
      v13 = -1;
LABEL_20:
      close(a1);
      return v13;
    }
    chan3mem = mmap(0LL, 0x1000uLL, 3uLL, 1u, a1, chan3);
    memcpy(chan0mem, input, inputlen);
    memcpy(chan3mem, prog, proglen);
    v13 = sstic_cmd(a1, 2);
    if ( v13 != -1 )
    {
      chan1mem = mmap(0LL, 0x1000uLL, 1uLL, 1u, a1, chan1);
      if ( chan1mem == (void *)-1LL )
      {
        perror("map stdout");
        v13 = -1;
LABEL_19:
        munmap(chan3mem, 0x1000uLL);
        munmap(chan0mem, 0x1000uLL);
        goto LABEL_20;
      }
      chan2mem = mmap(0LL, 0x1000uLL, 1uLL, 1u, a1, chan2);
      memcpy(out, chan1mem, outlen);
      memcpy(dbg, chan2mem, dbgout);
      munmap(chan2mem, 0x1000uLL);
    }
    munmap(chan1mem, 0x1000uLL);
    goto LABEL_19;
  }
  perror("open session");
  return (unsigned int)-1;
}
// A4AE: conditional instruction was optimized away because of '%chan0mem.8!=FFFFFFFFFFFFFFFF'
// A588: conditional instruction was optimized away because of '%chan1mem.8!=FFFFFFFFFFFFFFFF'
// A5EA: variable 'chan1mem' is possibly undefined

//----- (000000000000A62C) ----------------------------------------------------
__int64 __fastcall sstic_get_key(_QWORD *rdi0, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // rdx
  int a1; // [rsp+18h] [rbp-28h]
  __int64 v5[4]; // [rsp+20h] [rbp-20h] BYREF

  v5[3] = __readfsqword(0x28u);
  v5[0] = a2;
  a1 = open("/dev/sstic", 2);
  if ( a1 == -1 )
  {
    perror("open session");
    exit();
  }
  if ( ioctl(a1, 0xC0185304uLL, v5) == -1 )
  {
    perror("get_key");
    close(a1);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v3 = v5[2];
    *rdi0 = v5[1];
    rdi0[1] = v3;
    close(a1);
    result = 0LL;
  }
  return result;
}

//----- (000000000000A6F9) ----------------------------------------------------
__int64 sstic_get_debug_state()
{
  __int64 result; // rax
  int a1; // [rsp+8h] [rbp-28h]
  unsigned int v2[6]; // [rsp+10h] [rbp-20h] BYREF
  unsigned __int64 v3; // [rsp+28h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  a1 = open("/dev/sstic", 2);
  if ( a1 == -1 )
  {
    perror("open session");
    result = 0xFFFFFFFFLL;
  }
  else if ( ioctl(a1, 0xC0185305uLL, v2) == -1 )
  {
    perror("get_debug_state");
    close(a1);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    close(a1);
    result = v2[0];
  }
  return result;
}

//----- (000000000000A7A3) ----------------------------------------------------
unsigned __int64 __fastcall recv(unsigned int a1, void *a2, unsigned __int64 a3)
{
  double v3; // xmm0_8
  double v4; // xmm1_8
  double v5; // xmm2_8
  double v6; // xmm3_8
  double v7; // xmm4_8
  double v8; // xmm5_8
  double v9; // xmm6_8
  double v10; // xmm7_8
  unsigned __int64 result; // rax
  int v13; // [rsp+24h] [rbp-Ch]
  unsigned __int64 v14; // [rsp+28h] [rbp-8h]

  v14 = 0LL;
  if ( a3 > 0xDBBA0 )
  {
    fwrite("message too big\n", 1uLL, 0x10uLL, stderr);
    exit();
  }
  while ( 1 )
  {
    result = v14;
    if ( v14 >= a3 )
      break;
    v13 = sub_4AC10(a1, (char *)a2 + v14, a3 - v14, v3, v4, v5, v6, v7, v8, v9, v10);
    if ( v13 < 0 )
    {
      fwrite("error while reading\n", 1uLL, 0x14uLL, stderr);
      exit();
    }
    v14 += v13;
  }
  return result;
}
// A812: variable 'v3' is possibly undefined
// A812: variable 'v4' is possibly undefined
// A812: variable 'v5' is possibly undefined
// A812: variable 'v6' is possibly undefined
// A812: variable 'v7' is possibly undefined
// A812: variable 'v8' is possibly undefined
// A812: variable 'v9' is possibly undefined
// A812: variable 'v10' is possibly undefined

//----- (000000000000A85C) ----------------------------------------------------
unsigned __int64 __fastcall handle_req0(int sock, req *a2)
{
  unsigned int check; // [rsp+1Ch] [rbp-34h] BYREF
  int v4; // [rsp+20h] [rbp-30h] BYREF
  int a2a; // [rsp+24h] [rbp-2Ch] BYREF
  unsigned int curtime; // [rsp+28h] [rbp-28h]
  _QWORD v8[3]; // [rsp+30h] [rbp-20h] BYREF
  unsigned __int64 v9; // [rsp+48h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  curtime = time(0LL);
  recv(sock, &check, 4uLL);
  v4 = 0;
  if ( (unsigned int)do_sstic_decrypt(a2->payload, check, v8) )
  {
    fwrite("unexpected error while decrypting\n", 1uLL, 0x22uLL, stderr);
    a2a = 255;
    send(sock, &a2a, 1uLL);
  }
  else
  {
    if ( curtime <= check || check + 3600 <= curtime )
    {
      fwrite("check EXPIRED\n", 1uLL, 0xEuLL, stderr);
      v4 = 2;
      send(sock, &v4, 1uLL);
    }
    else
    {
      fwrite("check OK\n", 1uLL, 9uLL, stderr);
      v4 = 1;
      send(sock, &v4, 1uLL);
    }
    send(sock, v8, 0x10uLL);
  }
  return v9 - __readfsqword(0x28u);
}

//----- (000000000000A9CA) ----------------------------------------------------
_BOOL8 __fastcall check_perm(int a1, unsigned __int64 a2)
{
  return a2 <= perms[a1];
}

//----- (000000000000A9F7) ----------------------------------------------------
int __fastcall decrypt_req(__int64 a1, req *a2, request *a3)
{
  int result; // eax
  unsigned int check; // [rsp+28h] [rbp-18h] BYREF
  int a2a; // [rsp+2Ch] [rbp-14h] BYREF
  unsigned int curtime; // [rsp+30h] [rbp-10h]
  int v8; // [rsp+34h] [rbp-Ch]
  unsigned __int64 v9; // [rsp+38h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  curtime = time(0LL);
  recv(a1, &check, 4uLL);
  if ( check + 3600 > curtime )
  {
    v8 = do_sstic_decrypt(a2->payload, check, a3);
    if ( v8 )
    {
      fwrite("unexpected error while decrypting\n", 1uLL, 0x22uLL, stderr);
      a2a = 255;
      send(a1, &a2a, 1uLL);
      result = v8;
    }
    else if ( check_perm(a2->reqno, a3->perms) )
    {
      result = 0;
    }
    else
    {
      fwrite("bad perms for this req type\n", 1uLL, 0x1CuLL, stderr);
      a2a = 254;
      send(a1, &a2a, 1uLL);
      result = -1;
    }
  }
  else
  {
    fwrite("get key expired\n", 1uLL, 0x10uLL, stderr);
    a2a = 4;
    send(a1, &a2a, 1uLL);
    result = -1;
  }
  return result;
}

//----- (000000000000AB76) ----------------------------------------------------
unsigned __int64 __fastcall handle_req1(unsigned int fd, request *a2)
{
  int a2a; // [rsp+1Ch] [rbp-34h] BYREF
  int i; // [rsp+20h] [rbp-30h]
  int v5; // [rsp+24h] [rbp-2Ch]
  int v6; // [rsp+28h] [rbp-28h]
  int v7; // [rsp+2Ch] [rbp-24h]
  _QWORD v8[3]; // [rsp+30h] [rbp-20h] BYREF
  unsigned __int64 v9; // [rsp+48h] [rbp-8h]

  v9 = __readfsqword(0x28u);
  v5 = a2->ident >> 63;
  v6 = sstic_get_debug_state();
  if ( v6 == -1 )
  {
    fwrite("unexpected error while decrypting\n", 1uLL, 0x22uLL, stderr);
    a2a = 255;
    send(fd, &a2a, 1uLL);
  }
  else if ( v5 && v6 == 1 )
  {
    fwrite("trying to access prod key while device is in debug mode!\n", 1uLL, 0x39uLL, stderr);
    a2a = 7;
    send(fd, &a2a, 1uLL);
  }
  else
  {
    for ( i = 0; ; ++i )
    {
      if ( (unsigned __int64)i >= 0x15 )
      {
        fwrite("file not found\n", 1uLL, 0xFuLL, stderr);
        a2a = 6;
        send(fd, &a2a, 1uLL);
        return v9 - __readfsqword(0x28u);
      }
      if ( g_files[i].ident == a2->ident )
        break;
    }
    if ( g_files[i].perms && a2->perms <= g_files[i].perms )
    {
      v7 = sstic_get_key(v8, a2->ident);
      if ( v7 == -1 )
      {
        fwrite("unexpected error while decrypting\n", 1uLL, 0x22uLL, stderr);
        a2a = 255;
        send(fd, &a2a, 1uLL);
      }
      else
      {
        a2a = 3;
        send(fd, &a2a, 1uLL);
        send(fd, v8, 0x10uLL);
      }
    }
    else
    {
      fwrite("bad perms\n", 1uLL, 0xAuLL, stderr);
      a2a = 5;
      send(fd, &a2a, 1uLL);
    }
  }
  return v9 - __readfsqword(0x28u);
}

//----- (000000000000AE02) ----------------------------------------------------
unsigned __int64 __fastcall handle_req2(__int64 fd)
{
  __int64 v1; // rax
  int v3; // [rsp+10h] [rbp-4030h] BYREF
  unsigned __int64 proglen; // [rsp+18h] [rbp-4028h] BYREF
  unsigned __int64 inputlen; // [rsp+20h] [rbp-4020h] BYREF
  size_t out1len; // [rsp+28h] [rbp-4018h] BYREF
  __int64 prog[2]; // [rsp+30h] [rbp-4010h] BYREF
  char v9[4080]; // [rsp+40h] [rbp-4000h] BYREF
  __int64 input[2]; // [rsp+1030h] [rbp-3010h] BYREF
  char v11[4080]; // [rsp+1040h] [rbp-3000h] BYREF
  __int64 out1[2]; // [rsp+2030h] [rbp-2010h] BYREF
  char v13[4080]; // [rsp+2040h] [rbp-2000h] BYREF
  __int64 dbgout[2]; // [rsp+3030h] [rbp-1010h] BYREF
  char v15[4080]; // [rsp+3040h] [rbp-1000h] BYREF
  unsigned __int64 v16; // [rsp+4038h] [rbp-8h]

  v16 = __readfsqword(0x28u);
  prog[0] = 0LL;
  prog[1] = 0LL;
  memset(v9, 0, sizeof(v9));
  input[0] = 0LL;
  input[1] = 0LL;
  memset(v11, 0, sizeof(v11));
  out1[0] = 0LL;
  out1[1] = 0LL;
  memset(v13, 0, sizeof(v13));
  dbgout[0] = 0LL;
  dbgout[1] = 0LL;
  memset(v15, 0, sizeof(v15));
  recv(fd, &proglen, 8uLL);
  if ( proglen <= 0x1000 )
  {
    recv(fd, prog, proglen);
    recv(fd, &inputlen, 8uLL);
    if ( inputlen <= 0x1000 )
    {
      recv(fd, input, inputlen);
      recv(fd, &out1len, 8uLL);
      if ( out1len <= 0x1000 )
      {
        if ( (unsigned int)sstic_cmd2(prog, proglen, input, inputlen, out1, out1len, dbgout, 0x200uLL) )
        {
          fwrite("unexpected error while executing code\n", 1uLL, 0x26uLL, stderr);
          v3 = 255;
          send(fd, &v3, 1uLL);
        }
        else
        {
          v3 = 8;
          send(fd, &v3, 1uLL);
          send(fd, out1, out1len);
          send(fd, "---DEBUG LOG START---\n", 0x16uLL);
          v1 = strlen((__int64)dbgout);
          send(fd, dbgout, v1);
          send(fd, "---DEBUG LOG END---\n", 0x14uLL);
        }
      }
      else
      {
        fwrite("output size too big\n", 1uLL, 0x14uLL, stderr);
        v3 = 9;
        send(fd, &v3, 1uLL);
      }
    }
    else
    {
      fwrite("input size too big\n", 1uLL, 0x13uLL, stderr);
      LODWORD(out1len) = 9;
      send(fd, &out1len, 1uLL);
    }
  }
  else
  {
    fwrite("code size too big\n", 1uLL, 0x12uLL, stderr);
    LODWORD(out1len) = 9;
    send(fd, &out1len, 1uLL);
  }
  return v16 - __readfsqword(0x28u);
}

//----- (000000000000B1CD) ----------------------------------------------------
unsigned __int64 __fastcall handle_req3(unsigned int a1, request *a2)
{
  size_t v2; // rax
  __int64 v3; // rsi
  __int64 v4; // rdx
  __int64 v5; // rcx
  u32 *v6; // r8
  u32 v7; // er9
  int v9; // [rsp+1Ch] [rbp-5064h] BYREF
  _BOOL4 v10; // [rsp+20h] [rbp-5060h]
  int i; // [rsp+24h] [rbp-505Ch]
  unsigned int a1a; // [rsp+2Ch] [rbp-5054h]
  unsigned __int64 sz; // [rsp+30h] [rbp-5050h] BYREF
  unsigned __int64 j; // [rsp+38h] [rbp-5048h]
  size_t v16; // [rsp+40h] [rbp-5040h]
  unsigned __int64 proglen; // [rsp+48h] [rbp-5038h]
  int *v18; // [rsp+50h] [rbp-5030h]
  u32 *v19; // [rsp+58h] [rbp-5028h]
  unsigned __int64 v20; // [rsp+60h] [rbp-5020h]
  size_t a3; // [rsp+68h] [rbp-5018h]
  __int64 prog[512]; // [rsp+70h] [rbp-5010h] BYREF
  char data[4096]; // [rsp+1070h] [rbp-4010h] BYREF
  char out1[4096]; // [rsp+2070h] [rbp-3010h] BYREF
  char out2[4096]; // [rsp+3070h] [rbp-2010h] BYREF
  char v26[4096]; // [rsp+4070h] [rbp-1010h] BYREF
  unsigned __int64 v27; // [rsp+5078h] [rbp-8h]

  v27 = __readfsqword(0x28u);
  memset(&prog[2], 0, 0xFF0uLL);
  *(_QWORD *)data = 0LL;
  *(_QWORD *)&data[8] = 0LL;
  memset(&data[16], 0, 0xFF0uLL);
  *(_QWORD *)out1 = 0LL;
  *(_QWORD *)&out1[8] = 0LL;
  memset(&out1[16], 0, 0xFF0uLL);
  *(_QWORD *)out2 = 0LL;
  *(_QWORD *)&out2[8] = 0LL;
  memset(&out2[16], 0, 0xFF0uLL);
  *(_QWORD *)v26 = 0LL;
  *(_QWORD *)&v26[8] = 0LL;
  memset(&v26[16], 0, 0xFF0uLL);
  v16 = 0LL;
  v10 = 0;
  recv(a1, data, 0x50uLL);
  qmemcpy(prog, g_sstic_pwcheck, 0x301uLL);
  proglen = 0x301LL;
  if ( (unsigned int)sstic_cmd2(prog, 0x301uLL, data, 0x50uLL, out1, 0x40uLL, out2, 0LL) )
  {
    fwrite("unexpected error while executing code\n", 1uLL, 0x26uLL, stderr);
    LODWORD(sz) = 255;
    send(a1, &sz, 1uLL);
  }
  else
  {
    v10 = 1;
    for ( i = 0; i <= 47; ++i )
    {
      if ( out1[i] != (char)0xFF )
      {
        v10 = 0;
        break;
      }
    }
    if ( v10 )
      v10 = (unsigned int)memcmp((__int64)&out1[48], (__int64)"EXECUTE FILE OK!", 16LL) == 0;
    if ( v10 )
    {
      fwrite("good pass\n", 1uLL, 0xAuLL, stderr);
      LODWORD(sz) = 10;
      send(a1, &sz, 1uLL);
      recv(a1, &sz, 8uLL);
      if ( sz <= 900000 )
      {
        a1a = open("/home/sstic/execfile", 0x41, 0700LL);
        if ( a1a == -1 )
        {
          fwrite("unexpected error while creating executable file\n", 1uLL, 0x30uLL, stderr);
          v9 = 255;
          send(a1, &v9, 1uLL);
        }
        else
        {
          for ( j = sz; j; j -= a3 )
          {
            v2 = 4096LL;
            if ( j <= 0x1000 )
              v2 = j;
            a3 = v2;
            recv(a1, v26, v2);
            v20 = send(a1a, v26, a3);
            if ( v20 != a3 )
            {
              fwrite("unexpected error while writing file\n", 1uLL, 0x24uLL, stderr);
              v9 = 255;
              send(a1, &v9, 1uLL);
              close(a1a);
              return v27 - __readfsqword(0x28u);
            }
          }
          close(a1a);
          v18 = (int *)popen((__int64)"/home/sstic/execfile", (__int64)"r");
          if ( v18 )
          {
            v3 = 0LL;
            sub_9190((__int64)v26, 0LL, 4096LL);
            while ( !(unsigned int)sub_16BC0((unsigned int *)v18, v3, v4, v5, v6, v7) && v16 <= 0xFFE )
            {
              v3 = (unsigned int)(4095 - v16);
              v19 = sub_13E10((u32 *)&v26[v16], v3, v18);
              if ( v19 )
              {
                v20 = strlen((__int64)v19);
                v4 = v20;
                if ( v20 + v16 > 0xFFF )
                  exit();
                v16 += v20;
              }
            }
            sub_16CF0((__int64)v18);
            unlink((__int64)"/home/sstic/execfile");
            v9 = 12;
            send(a1, &v9, 1uLL);
            send(a1, "---EXEC OUTPUT START---\n", 0x18uLL);
            send(a1, v26, v16);
            send(a1, "---EXEC OUTPUT END---\n", 0x16uLL);
          }
          else
          {
            fwrite("unexpected error while writing file\n", 1uLL, 0x24uLL, stderr);
            v9 = 255;
            send(a1, &v9, 1uLL);
          }
        }
      }
      else
      {
        fwrite("executable too big\n", 1uLL, 0x13uLL, stderr);
        v9 = 13;
        send(a1, &v9, 1uLL);
      }
    }
    else
    {
      fwrite("wrong pass\n", 1uLL, 0xBuLL, stderr);
      LODWORD(sz) = 11;
      send(a1, &sz, 1uLL);
    }
  }
  return v27 - __readfsqword(0x28u);
}
// B7FB: variable 'v4' is possibly undefined
// B7FB: variable 'v5' is possibly undefined
// B7FB: variable 'v6' is possibly undefined
// B7FB: variable 'v7' is possibly undefined

//----- (000000000000B8BC) ----------------------------------------------------
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  double v3; // xmm0_8
  double v4; // xmm1_8
  double v5; // xmm2_8
  double v6; // xmm3_8
  double v7; // xmm6_8
  double v8; // xmm7_8
  double v9; // xmm4_8
  double v10; // xmm5_8
  double v11; // xmm4_8
  double v12; // xmm5_8
  int v13; // [rsp+8h] [rbp-68h] BYREF
  int v14; // [rsp+Ch] [rbp-64h] BYREF
  int a2; // [rsp+10h] [rbp-60h] BYREF
  int ssock; // [rsp+14h] [rbp-5Ch]
  unsigned int a1; // [rsp+18h] [rbp-58h]
  int v18; // [rsp+1Ch] [rbp-54h]
  request v19; // [rsp+20h] [rbp-50h] BYREF
  sockaddr_in v20; // [rsp+30h] [rbp-40h] BYREF
  char v21[16]; // [rsp+40h] [rbp-30h] BYREF
  req v22; // [rsp+50h] [rbp-20h] BYREF
  unsigned __int64 v23; // [rsp+68h] [rbp-8h]

  v23 = __readfsqword(0x28u);
  ssock = socket(2, 1, 0);
  if ( ssock == -1 )
  {
    perror("socket listen\n");
    exit();
  }
  v20.sin_family = 2;
  *(_DWORD *)&v20.sin_zero[4] = 0;
  *(_QWORD *)&v20.sin_addr.s_addr = (unsigned int)htonl(0);
  v20.sin_port = htons(1337);
  if ( (unsigned int)bind(ssock, (struct sokaddr *)&v20, 16) )
  {
    perror("bind\n");
    exit();
  }
  puts("service started!", (__int64)&v20, v3, v4, v5, v6, v9, v10, v7, v8);
  if ( (unsigned int)listen(ssock, 1) )
  {
    perror("listen\n");
    exit();
  }
  v14 = 16;
  a1 = accept(ssock, (struct sockaddr *)v21, &v14, v3, v4, v5, v6, v11, v12, v7, v8);
  if ( (a1 & 0x80000000) != 0 )
  {
    perror("server acccept\n");
    exit();
  }
  send(a1, "STIC", 4uLL);
  while ( 1 )
  {
    while ( 1 )
    {
      do
      {
        while ( 1 )
        {
          while ( 1 )
          {
            recv(a1, &v22, 0x11uLL);
            if ( v22.reqno <= 3u )
              break;
            fwrite("bad reqno\n", 1uLL, 0xAuLL, stderr);
            a2 = 254;
            send(a1, &a2, 1uLL);
          }
          if ( v22.reqno )
            break;
          handle_req0(a1, &v22);
        }
        v18 = decrypt_req(a1, &v22, &v19);
      }
      while ( v18 == -1 );
      if ( v22.reqno != 3 )
        break;
      handle_req3(a1, &v19);
    }
    if ( v22.reqno > 3u )
    {
LABEL_23:
      v13 = 254;
      send(a1, &v13, 1uLL);
    }
    else if ( v22.reqno == 1 )
    {
      handle_req1(a1, &v19);
    }
    else
    {
      if ( v22.reqno != 2 )
        goto LABEL_23;
      handle_req2(a1);
    }
  }
}
// B967: variable 'v3' is possibly undefined
// B967: variable 'v4' is possibly undefined
// B967: variable 'v5' is possibly undefined
// B967: variable 'v6' is possibly undefined
// B967: variable 'v9' is possibly undefined
// B967: variable 'v10' is possibly undefined
// B967: variable 'v7' is possibly undefined
// B967: variable 'v8' is possibly undefined
// B9A7: variable 'v11' is possibly undefined
// B9A7: variable 'v12' is possibly undefined

//----- (000000000000BAF0) ----------------------------------------------------
__int64 __fastcall sub_BAF0(unsigned int *a1, int *a2, unsigned int *a3, _DWORD *a4)
{
  __int64 result; // rax

  _RAX = 1LL;
  __asm { cpuid }
  HIDWORD(xmmword_C1354) = _RDX;
  DWORD1(xmmword_C1354) = _RBX;
  DWORD2(xmmword_C1354) = _RCX;
  LODWORD(xmmword_C1354) = result;
  *a1 = ((unsigned int)result >> 8) & 0xF;
  *a2 = (unsigned __int8)result >> 4;
  *a3 = ((unsigned int)result >> 12) & 0xF0;
  *a4 = result & 0xF;
  if ( *a1 == 15 )
  {
    *a1 = (unsigned __int8)((unsigned int)result >> 20) + 15;
    result = *a3;
    *a2 += result;
  }
  if ( dword_C1344 > 6 )
  {
    _RAX = 7LL;
    __asm { cpuid }
    LODWORD(xmmword_C1374) = _RAX;
    _RAX = 7LL;
    DWORD2(xmmword_C1374) = _RCX;
    DWORD1(xmmword_C1374) = _RBX;
    HIDWORD(xmmword_C1374) = _RDX;
    __asm { cpuid }
    dword_C1414 = result;
    dword_C1418 = _RBX;
    dword_C141C = _RCX;
    dword_C1420 = _RDX;
  }
  if ( dword_C1344 > 12 )
  {
    _RAX = 13LL;
    __asm { cpuid }
    dword_C13B4 = result;
    dword_C13B8 = _RBX;
    dword_C13BC = _RCX;
    dword_C13C0 = _RDX;
  }
  return result;
}
// C1344: using guessed type int dword_C1344;
// C1354: using guessed type __int128 xmmword_C1354;
// C1374: using guessed type __int128 xmmword_C1374;
// C13B4: using guessed type int dword_C13B4;
// C13B8: using guessed type int dword_C13B8;
// C13BC: using guessed type int dword_C13BC;
// C13C0: using guessed type int dword_C13C0;
// C1414: using guessed type int dword_C1414;
// C1418: using guessed type int dword_C1418;
// C141C: using guessed type int dword_C141C;
// C1420: using guessed type int dword_C1420;

//----- (000000000000BBE0) ----------------------------------------------------
__int64 sub_BBE0()
{
  __int64 result; // rax
  unsigned int v5; // esi

  _RAX = 0x80000000LL;
  __asm { cpuid }
  if ( (unsigned int)result > 0x80000000 )
  {
    v5 = result;
    _RAX = 2147483649LL;
    __asm { cpuid }
    dword_C1394 = result;
    dword_C1398 = _RBX;
    dword_C139C = _RCX;
    dword_C13A0 = _RDX;
    if ( v5 > 0x80000006 )
    {
      _RAX = 2147483655LL;
      __asm { cpuid }
      dword_C13D4 = result;
      dword_C13D8 = _RBX;
      dword_C13DC = _RCX;
      dword_C13E0 = _RDX;
      if ( v5 != -2147483641 )
      {
        _RAX = 2147483656LL;
        __asm { cpuid }
        dword_C13F4 = result;
        dword_C13F8 = _RBX;
        dword_C13FC = _RCX;
        dword_C1400 = _RDX;
      }
    }
  }
  return result;
}
// BBE0: using guessed type __int64 __fastcall sub_BBE0();
// C1394: using guessed type int dword_C1394;
// C1398: using guessed type int dword_C1398;
// C139C: using guessed type int dword_C139C;
// C13A0: using guessed type int dword_C13A0;
// C13D4: using guessed type int dword_C13D4;
// C13D8: using guessed type int dword_C13D8;
// C13DC: using guessed type int dword_C13DC;
// C13E0: using guessed type int dword_C13E0;
// C13F4: using guessed type int dword_C13F4;
// C13F8: using guessed type int dword_C13F8;
// C13FC: using guessed type int dword_C13FC;
// C1400: using guessed type int dword_C1400;

//----- (000000000000BC70) ----------------------------------------------------
__int64 sub_BC70()
{
  __m128i v0; // xmm1
  __int64 result; // rax
  int v2; // esi
  unsigned int v3; // edi
  unsigned int v4; // er11
  char v5; // r8
  int v6; // edi
  unsigned int v11; // ebx
  char *v12; // r9
  int *v13; // r10
  unsigned int v14; // esi
  int v15; // er11
  int v16; // ebp
  unsigned int v22; // eax
  int v23; // [rsp+0h] [rbp-130h] BYREF
  int v24; // [rsp+74h] [rbp-BCh]
  char v25; // [rsp+7Ch] [rbp-B4h] BYREF
  int v26; // [rsp+F4h] [rbp-3Ch]

  v0 = _mm_loadu_si128((const __m128i *)&xmmword_C1374);
  result = dword_C139C & 0x200000;
  v2 = result | dword_C139C & 0x8000 | (dword_C13AC | dword_C139C & 0x165) & 0xFFFEF7FF;
  dword_C13B0 |= dword_C13A0 & 0x2C100800;
  dword_C13F0 |= dword_C13E0 & 0x100;
  v3 = (dword_C13C4 | dword_C13B4 & 0xF) & 0xFFFFFFED;
  v4 = (dword_C1414 & 0x20 | dword_C1424) & 0xFFFFFFDF;
  *(_QWORD *)&xmmword_C1364 = 0LL;
  LODWORD(xmmword_C1384) = 0;
  dword_C1408 |= dword_C13F8 & 0x200;
  *((_QWORD *)&xmmword_C1364 + 1) = (*(unsigned __int128 *)&_mm_loadu_si128((const __m128i *)&xmmword_C1354) >> 64) & 0xBFEFFBFF4FFEEFFFLL;
  DWORD1(xmmword_C1384) = v0.m128i_i32[1] & 0x239CBF9F;
  dword_C13AC = v2;
  dword_C13C4 = v3;
  DWORD2(xmmword_C1384) = v0.m128i_i32[2] & 0xFA7E01B5;
  HIDWORD(xmmword_C1384) = v0.m128i_i32[3] & 0xFC15C410;
  dword_C1424 = v4;
  if ( (DWORD2(xmmword_C1354) & 0x8000000) == 0 )
  {
    v5 = BYTE8(xmmword_C1374);
    goto LABEL_3;
  }
  __asm { xgetbv }
  v5 = BYTE8(xmmword_C1374);
  result = 0LL;
  if ( !(_DWORD)&loc_60000 )
  {
    result = HIDWORD(xmmword_C1374) & 0x3400000;
    HIDWORD(xmmword_C1384) |= result;
  }
  v6 = dword_C13B4 & 0x10 | v3;
  dword_C13C4 = v6;
  if ( dword_C1344 > 12 )
  {
    _RAX = 13LL;
    __asm { cpuid }
    if ( (_DWORD)_RBX )
    {
      v11 = (_RBX + 127) & 0xFFFFFFC0;
      result = v11;
      dword_C1440 = v11;
      qword_C1438 = v11;
      if ( (dword_C13B4 & 2) != 0 )
      {
        v12 = &v25;
        v13 = &v23;
        v14 = 2;
        v23 = 576;
        v15 = 3;
        v16 = 238;
        while ( 1 )
        {
          if ( _bittest(&v16, v14) )
          {
            _RAX = 13LL;
            __asm { cpuid }
            *((_DWORD *)v12 + 1) = _RAX;
            if ( v14 == 2 )
              goto LABEL_17;
            v22 = *(v13 - 1) + *(_DWORD *)v12;
            if ( (_RCX & 2) != 0 )
              v22 = (v22 + 63) & 0xFFFFFFC0;
            *v13 = v22;
          }
          else
          {
            *((_DWORD *)v12 + 1) = 0;
            if ( v14 == 2 )
              goto LABEL_17;
            *v13 = *(v13 - 1) + *(_DWORD *)v12;
          }
          if ( v15 == 32 )
          {
            result = (unsigned int)(v24 + v26);
            if ( v24 + v26 )
            {
              result = ((_DWORD)result + 127) & 0xFFFFFFC0;
              dword_C13C4 = v6 | 2;
              qword_C1438 = (unsigned int)result;
            }
            break;
          }
LABEL_17:
          ++v14;
          ++v15;
          v12 += 4;
          ++v13;
        }
      }
    }
  }
LABEL_3:
  if ( (v5 & 0x10) != 0 )
    DWORD2(xmmword_C1384) |= 8u;
  return result;
}
// BC70: using guessed type __int64 __fastcall sub_BC70();
// C1344: using guessed type int dword_C1344;
// C1354: using guessed type __int128 xmmword_C1354;
// C1364: using guessed type __int128 xmmword_C1364;
// C1374: using guessed type __int128 xmmword_C1374;
// C1384: using guessed type __int128 xmmword_C1384;
// C139C: using guessed type int dword_C139C;
// C13A0: using guessed type int dword_C13A0;
// C13AC: using guessed type int dword_C13AC;
// C13B0: using guessed type int dword_C13B0;
// C13B4: using guessed type int dword_C13B4;
// C13C4: using guessed type int dword_C13C4;
// C13E0: using guessed type int dword_C13E0;
// C13F0: using guessed type int dword_C13F0;
// C13F8: using guessed type int dword_C13F8;
// C1408: using guessed type int dword_C1408;
// C1414: using guessed type int dword_C1414;
// C1424: using guessed type int dword_C1424;
// C1434: using guessed type int dword_C1434;
// C1438: using guessed type __int64 qword_C1438;
// C1440: using guessed type int dword_C1440;

//----- (000000000000C010) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall _libc_start_main(__int64 (__fastcall *a1)(_QWORD, _QWORD *, void *), unsigned int a2, _QWORD *a3, void (__fastcall *a4)(_QWORD, _QWORD *, void *), __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15)
{
  char *v18; // rdi
  int v39; // edx
  unsigned __int64 *v40; // rdx
  double v41; // xmm4_8
  double v42; // xmm5_8
  int v43; // eax
  unsigned __int64 *v44; // rdx
  signed __int64 v45; // rax
  int v46; // edx
  unsigned __int64 *v47; // rdx
  signed __int64 v48; // rax
  __int64 v49; // rcx
  u32 *v50; // r8
  __int64 v51; // r9
  double v52; // xmm4_8
  double v53; // xmm5_8
  __int64 v54; // rsi
  __int64 v55; // rdi
  double v56; // xmm4_8
  double v57; // xmm5_8
  unsigned __int64 v58; // rdx
  __int64 v59; // rcx
  u32 *v60; // r8
  __int64 v61; // r9
  double v62; // xmm4_8
  double v63; // xmm5_8
  __int64 v64; // rsi
  __int64 v65; // rdx
  __int64 v66; // rcx
  __int64 v67; // r8
  __int64 v68; // r9
  __int64 v69; // rdx
  __int64 v70; // rcx
  unsigned int v71; // edi
  u32 *v72; // r8
  __int64 v73; // r9
  double v74; // xmm4_8
  double v75; // xmm5_8
  signed __int32 v76; // et0
  signed __int64 v77; // rax
  const char *v78; // rax
  int v79; // eax
  int v80; // eax
  int v81; // eax
  int v82; // eax
  int v83; // eax
  unsigned int v84; // edx
  __int64 v85; // rcx
  char v86; // [rsp+0h] [rbp-128h]
  int v90; // [rsp+24h] [rbp-104h] BYREF
  int v91; // [rsp+28h] [rbp-100h] BYREF
  unsigned int v92; // [rsp+2Ch] [rbp-FCh] BYREF
  unsigned int v93; // [rsp+30h] [rbp-F8h] BYREF
  unsigned int v94; // [rsp+34h] [rbp-F4h] BYREF
  unsigned int v95; // [rsp+38h] [rbp-F0h] BYREF
  int v96; // [rsp+3Ch] [rbp-ECh] BYREF
  char *v97; // [rsp+40h] [rbp-E8h] BYREF
  char *v98; // [rsp+48h] [rbp-E0h] BYREF
  char *v99; // [rsp+50h] [rbp-D8h] BYREF
  char *v100; // [rsp+58h] [rbp-D0h] BYREF
  char *v101; // [rsp+60h] [rbp-C8h] BYREF
  char *v102; // [rsp+68h] [rbp-C0h] BYREF
  char *v103; // [rsp+70h] [rbp-B8h] BYREF
  char *v104; // [rsp+78h] [rbp-B0h] BYREF
  __int64 code[21]; // [rsp+80h] [rbp-A8h] BYREF

  dword_BF628 = 0;
  sub_50300(a7, a8, a9, a10, a11, a12, a13, a14);
  v18 = (char *)&a3[(int)a2 + 1];
  qword_C1270 = v18;
  qword_BD7B0 = a15;
  do
    v18 += 8;
  while ( *((_QWORD *)v18 - 1) );
  sub_4E190((__int64 *)v18);
  if ( !qword_C1300 && &dword_0 )
  {
    qword_C1300 = (__int64)&dword_40;
    qword_C12F8 = 10LL;
  }
  sub_4F250();
  sub_4DBB0(qword_C1270);
  _RAX = 0LL;
  v90 = 0;
  __asm { cpuid }
  v91 = 0;
  v92 = 0;
  dword_C1344 = _RAX;
  if ( (_DWORD)_RBX == 1970169159 && (_DWORD)_RCX == 1818588270 )
  {
    if ( (_DWORD)_RDX != 1231384169 )
    {
LABEL_9:
      if ( dword_C1344 > 6 )
      {
        _RAX = 7LL;
        __asm { cpuid }
        LODWORD(xmmword_C1374) = _RAX;
        _RAX = 7LL;
        DWORD2(xmmword_C1374) = _RCX;
        DWORD1(xmmword_C1374) = _RBX;
        HIDWORD(xmmword_C1374) = _RDX;
        __asm { cpuid }
        dword_C1414 = _RAX;
        dword_C1418 = _RBX;
        dword_C141C = _RCX;
        dword_C1420 = _RDX;
      }
      if ( dword_C1344 > 12 )
      {
        _RAX = 13LL;
        __asm { cpuid }
        dword_C13B4 = _RAX;
        dword_C13B8 = _RBX;
        dword_C13BC = _RCX;
        dword_C13C0 = _RDX;
      }
      sub_BC70();
      v39 = 4;
      goto LABEL_14;
    }
    sub_BAF0((unsigned int *)&v90, &v91, &v93, &v92);
    sub_BBE0();
    sub_BC70();
    if ( v90 != 6 )
      goto LABEL_84;
    v84 = v93 + v91;
    v85 = v93 + v91 - 26;
    v91 += v93;
    if ( (unsigned int)v85 <= 0x82 )
      __asm { jmp     rcx }
    if ( (BYTE11(xmmword_C1354) & 0x10) != 0 )
      dword_C1434 |= 0x434u;
    if ( v84 == 63 )
    {
      if ( v92 > 3 )
        goto LABEL_84;
    }
    else if ( v84 > 0x3F )
    {
      if ( v84 - 69 > 1 )
        goto LABEL_84;
    }
    else if ( v84 != 60 )
    {
LABEL_84:
      v81 = dword_C1434;
      BYTE1(v81) = BYTE1(dword_C1434) | 0x40;
      if ( (BYTE7(xmmword_C1374) & 8) != 0 )
      {
        v81 = dword_C1434;
        BYTE1(v81) = BYTE1(dword_C1434) | 8;
      }
      dword_C1434 = v81;
      v39 = 1;
      goto LABEL_14;
    }
    DWORD1(xmmword_C1384) &= 0xFFFFF7FF;
    goto LABEL_84;
  }
  if ( (_DWORD)_RBX == 1752462657 && (_DWORD)_RCX == 1145913699 )
  {
    if ( (_DWORD)_RDX != 1769238117 )
      goto LABEL_9;
    goto LABEL_24;
  }
  if ( (_DWORD)_RBX == 1869052232 && (_DWORD)_RCX == 1701734773 )
  {
    if ( (_DWORD)_RDX != 1852131182 )
      goto LABEL_9;
LABEL_24:
    sub_BAF0((unsigned int *)&v90, &v91, &v94, &v92);
    sub_BBE0();
    sub_BC70();
    if ( (BYTE11(xmmword_C1364) & 0x10) != 0 )
      dword_C13AC |= dword_C139C & 0x10000;
    if ( v90 == 21 && (unsigned int)(v91 - 96) <= 0x1F )
    {
      v82 = dword_C1434;
      BYTE1(v82) = BYTE1(dword_C1434) & 0xFE;
      dword_C1434 = v82 | 0x18;
    }
    v39 = 2;
LABEL_14:
    if ( (BYTE13(xmmword_C1354) & 1) != 0 )
      dword_C1434 |= 1u;
    if ( (SBYTE13(xmmword_C1354) & 0x80u) != 0 )
      dword_C1434 |= 2u;
    dword_C1340 = v39;
    dword_C1348 = v90;
    dword_C134C = v91;
    dword_C1350 = v92;
    sub_4E120(0x13u, &v97, (__int64 (__fastcall *)(char **))sub_4F2E0);
    sub_4E120(0xCu, &v98, 0LL);
    qword_C1458 = (__int64)v98;
    sub_4E120(7u, &v99, 0LL);
    qword_C1460 = (__int64)v99;
    sub_4E120(0xBu, &v100, 0LL);
    qword_C1468 = (__int64)v100;
    sub_4E120(0x17u, &v101, 0LL);
    qword_C1448 = (__int64)v101;
    sub_4E120(4u, &v102, 0LL);
    qword_C12F0 = 2LL;
    qword_C1450 = (__int64)v102;
    if ( dword_C1340 != 1 )
    {
LABEL_19:
      sub_4E120(0x12u, &v103, (__int64 (__fastcall *)(char **))sub_4FDD0);
      sub_4E120(0xDu, &v104, (__int64 (__fastcall *)(char **))sub_4FE60);
      if ( sys_arch_prctl((struct task_struct *)((char *)&stru_2FF8.r_info + 1), (int)code, v40) )
        goto LABEL_20;
      if ( !LODWORD(code[0]) )
        goto LABEL_20;
      dword_C1474 = code[0];
      if ( (code[0] & 3) == 0 )
        goto LABEL_20;
      v43 = BYTE8(xmmword_C1384) & 0x80;
      if ( (BYTE14(xmmword_C1384) & 0x10) != 0 )
      {
        if ( (BYTE8(xmmword_C1384) & 0x80) != 0 )
        {
LABEL_36:
          v47 = (unsigned __int64 *)(byte_C1470 & 3);
          if ( (_BYTE)v47 != 3 && (byte_C1470 & 0xC) != 12 )
            v48 = sys_arch_prctl((struct task_struct *)((char *)&stru_2FF8.r_info + 3), 0, v47);
LABEL_20:
          sub_CA10(a7, a8, a9, a10, v41, v42, a13, a14);
          __writefsdword(0x48u, dword_C1474);
          __writefsqword(0x28u, 0x3010102464C4500uLL);
          if ( !dword_BF628 )
          {
            v80 = sub_4FEF0();
            if ( v80 < 0 )
              sub_17110((__int64)"FATAL: cannot determine kernel version\n", a7, a8, a9, a10, v52, v53, a13, a14);
            if ( !dword_C1328 || dword_C1328 > (unsigned int)v80 )
              dword_C1328 = v80;
            if ( v80 <= 197119 )
              sub_17110((__int64)"FATAL: kernel too old\n", a7, a8, a9, a10, v52, v53, a13, a14);
          }
          __writefsqword(0x30u, 0LL);
          if ( a6 )
            sub_12970(a6, 0LL, 0LL, a7, a8, a9, a10, v52, v53, a13, a14, v49, v50, v51);
          sub_50FA0(1);
          v54 = (__int64)a3;
          v55 = a2;
          sub_50FC0(a2, a3, qword_C1270, a7, a8, a9, a10, v56, v57, a13, a14);
          if ( a5 )
          {
            v54 = 0LL;
            v55 = a5;
            sub_12970(a5, 0LL, 0LL, a7, a8, a9, a10, v62, v63, a13, a14, v59, v60, v61);
          }
          sub_C9D0(v55, v54, v58, v59, (__int64)v60, v61);
          if ( a4 )
            a4(a2, a3, qword_C1270);
          v64 = 0LL;
          sub_4D270(0LL, 0LL);
          if ( (unsigned int)sub_11B00((__int64)code, 0LL, v65, v66, v67, v68, v86) )
          {
            sub_90A0();
            v76 = _InterlockedDecrement(0LL);
            LOBYTE(v69) = v76 == 0;
            if ( v76 )
            {
              while ( 1 )
                v77 = sys_exit(0);
            }
            v71 = 0;
          }
          else
          {
            code[9] = __readfsqword(0x300u);
            code[10] = __readfsqword(0x2F8u);
            __writefsqword(0x300u, (unsigned __int64)code);
            v64 = (__int64)a3;
            v71 = a1(a2, a3, qword_C1270);
          }
          sub_126E0(v71, a7, a8, a9, a10, v74, v75, a13, a14, v64, v69, v70, v72, v73);
        }
      }
      else
      {
        v44 = (unsigned __int64 *)(&dword_0 + 1);
        if ( (BYTE8(xmmword_C1384) & 0x80) != 0 )
          goto LABEL_34;
        v43 = 1;
      }
      v44 = (unsigned __int64 *)(v43 | 2u);
LABEL_34:
      v45 = sys_arch_prctl((struct task_struct *)((char *)&stru_2FF8.r_info + 2), (int)v44, v44);
      if ( !(_DWORD)v45 )
        dword_C1474 &= ~v46;
      goto LABEL_36;
    }
    if ( (DWORD1(xmmword_C1384) & 0x10000000) != 0 )
    {
      if ( (DWORD1(xmmword_C1384) & 0x8000000) != 0 )
      {
        if ( (DWORD1(xmmword_C1384) & 0x4000000) != 0 )
        {
          v78 = "xeon_phi";
          goto LABEL_60;
        }
      }
      else if ( (DWORD1(xmmword_C1384) & 0x40020000) == 1073872896 && (SDWORD1(xmmword_C1384) & 0x80000000) != 0 )
      {
        qword_C12F0 = 6LL;
      }
    }
    if ( (BYTE4(xmmword_C1384) & 0x20) == 0
      || (BYTE9(xmmword_C1364) & 0x10) == 0
      || (WORD2(xmmword_C1384) & 0x108) != 264
      || (dword_C13AC & 0x20) == 0
      || (DWORD2(xmmword_C1364) & 0xC00000) != 12582912 )
    {
      goto LABEL_19;
    }
    v78 = "haswell";
LABEL_60:
    qword_C14C0 = (__int64)v78;
    goto LABEL_19;
  }
  if ( (_DWORD)_RBX == 1953391939 && (_DWORD)_RCX == 1936487777 )
  {
    if ( (_DWORD)_RDX != 1215460705 )
      goto LABEL_9;
  }
  else if ( (_DWORD)_RCX != 538995041 || (_DWORD)_RBX != 1750278176 || (_DWORD)_RDX != 1751608929 )
  {
    goto LABEL_9;
  }
  sub_BAF0((unsigned int *)&v90, &v91, &v95, &v96);
  sub_BBE0();
  sub_BC70();
  v79 = v91 + v95;
  v91 += v95;
  if ( v90 == 6 )
  {
    if ( v79 != 15 && v79 != 25 )
      goto LABEL_66;
  }
  else
  {
    if ( v90 != 7 )
    {
LABEL_66:
      v39 = 3;
      goto LABEL_14;
    }
    if ( v79 != 27 )
    {
      if ( v79 == 59 )
      {
        DWORD2(xmmword_C1364) &= 0xEFFFFFFF;
        DWORD1(xmmword_C1384) &= 0xFFFFFFDF;
        dword_C1434 &= 0xFFFFFEFF;
      }
      goto LABEL_66;
    }
  }
  HIWORD(v83) = HIWORD(dword_C1434);
  DWORD1(xmmword_C1384) &= 0xFFFFFFDF;
  DWORD2(xmmword_C1364) &= 0xEFFFFFFF;
  BYTE1(v83) = BYTE1(dword_C1434) & 0xFE;
  LOBYTE(v83) = dword_C1434 | 0x80;
  dword_C1434 = v83;
  goto LABEL_66;
}
// C07C: write access to const memory at BD7B0 has been detected
// C2EC: variable 'v40' is possibly undefined
// C485: variable 'v41' is possibly undefined
// C485: variable 'v42' is possibly undefined
// C421: variable 'v46' is possibly undefined
// C4E9: variable 'v52' is possibly undefined
// C4E9: variable 'v53' is possibly undefined
// C4E9: variable 'v49' is possibly undefined
// C4E9: variable 'v50' is possibly undefined
// C4E9: variable 'v51' is possibly undefined
// C508: variable 'v56' is possibly undefined
// C508: variable 'v57' is possibly undefined
// C519: variable 'v62' is possibly undefined
// C519: variable 'v63' is possibly undefined
// C519: variable 'v59' is possibly undefined
// C519: variable 'v60' is possibly undefined
// C519: variable 'v61' is possibly undefined
// C8DD: variable 'v58' is possibly undefined
// C553: variable 'v65' is possibly undefined
// C553: variable 'v66' is possibly undefined
// C553: variable 'v67' is possibly undefined
// C553: variable 'v68' is possibly undefined
// C553: variable 'v86' is possibly undefined
// C5AC: variable 'v74' is possibly undefined
// C5AC: variable 'v75' is possibly undefined
// C5AC: variable 'v69' is possibly undefined
// C5AC: variable 'v70' is possibly undefined
// C5AC: variable 'v72' is possibly undefined
// C5AC: variable 'v73' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);
// 20: using guessed type __int64 qword_20[];
// 40: using guessed type int dword_40;
// 2FF8: using guessed type Elf64_Rela stru_2FF8;
// 90A0: using guessed type __int64 sub_90A0(void);
// 9258: using guessed type __int64 sub_9258(void);
// BBE0: using guessed type __int64 sub_BBE0(void);
// BC70: using guessed type __int64 sub_BC70(void);
// 4DBB0: using guessed type __int64 __fastcall sub_4DBB0(_QWORD);
// 4F250: using guessed type __int64 sub_4F250(void);
// 4FEF0: using guessed type __int64 sub_4FEF0(void);
// BD7A0: using guessed type __int64 qword_BD7A0;
// BD7B0: using guessed type __int64 qword_BD7B0;
// BD7E0: using guessed type int dword_BD7E0;
// BF628: using guessed type int dword_BF628;
// C12F0: using guessed type __int64 qword_C12F0;
// C12F8: using guessed type __int64 qword_C12F8;
// C1300: using guessed type __int64 qword_C1300;
// C1328: using guessed type int dword_C1328;
// C1340: using guessed type int dword_C1340;
// C1344: using guessed type int dword_C1344;
// C1348: using guessed type int dword_C1348;
// C134C: using guessed type int dword_C134C;
// C1350: using guessed type int dword_C1350;
// C1354: using guessed type __int128 xmmword_C1354;
// C1364: using guessed type __int128 xmmword_C1364;
// C1374: using guessed type __int128 xmmword_C1374;
// C1384: using guessed type __int128 xmmword_C1384;
// C139C: using guessed type int dword_C139C;
// C13AC: using guessed type int dword_C13AC;
// C13B4: using guessed type int dword_C13B4;
// C13B8: using guessed type int dword_C13B8;
// C13BC: using guessed type int dword_C13BC;
// C13C0: using guessed type int dword_C13C0;
// C1414: using guessed type int dword_C1414;
// C1418: using guessed type int dword_C1418;
// C141C: using guessed type int dword_C141C;
// C1420: using guessed type int dword_C1420;
// C1434: using guessed type int dword_C1434;
// C1448: using guessed type __int64 qword_C1448;
// C1450: using guessed type __int64 qword_C1450;
// C1458: using guessed type __int64 qword_C1458;
// C1460: using guessed type __int64 qword_C1460;
// C1468: using guessed type __int64 qword_C1468;
// C1470: using guessed type char byte_C1470;
// C1474: using guessed type int dword_C1474;
// C14C0: using guessed type __int64 qword_C14C0;

//----- (000000000000C920) ----------------------------------------------------
__int64 __fastcall sub_C920(unsigned int a1, int a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  const char *v8; // rdi
  struct stat v9; // [rsp+0h] [rbp-A8h] BYREF

  result = sub_4B7D0(a1, 1u, a3, a4, a5, a6, v9.st_dev);
  if ( (_DWORD)result == -1 )
  {
    result = -64LL;
    if ( __readfsdword(0xFFFFFFC0) == 9 )
    {
      v8 = "/dev/full";
      if ( a2 == (_DWORD)&loc_20000 )
        v8 = "/dev/null";
      if ( a1 != (unsigned int)sub_4B910(v8, a2, 0)
        || (unsigned int)sub_4AA80(1u, a1, &v9)
        || (result = v9.st_mode & 0xF000, (_DWORD)result != 0x2000)
        || v9.st_rdev != 4LL * (a2 != (_DWORD)&loc_20000) + 259 )
      {
        __halt();
      }
    }
  }
  return result;
}

//----- (000000000000C9D0) ----------------------------------------------------
__int64 __fastcall sub_C9D0(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9

  sub_C920(0, 131073, a3, a4, a5, a6);
  sub_C920(1u, (int)&loc_20000, v6, v7, v8, v9);
  return sub_C920(2u, (int)&loc_20000, v10, v11, v12, v13);
}
// C9EE: variable 'v6' is possibly undefined
// C9EE: variable 'v7' is possibly undefined
// C9EE: variable 'v8' is possibly undefined
// C9EE: variable 'v9' is possibly undefined
// CA01: variable 'v10' is possibly undefined
// CA01: variable 'v11' is possibly undefined
// CA01: variable 'v12' is possibly undefined
// CA01: variable 'v13' is possibly undefined

//----- (000000000000CA10) ----------------------------------------------------
unsigned __int64 __fastcall sub_CA10(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  _QWORD *v8; // rbx
  _QWORD *v9; // r14
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rbp
  __int64 v12; // r9
  unsigned __int64 v13; // r12
  __int64 v14; // r15
  __int64 v15; // rcx
  unsigned __int64 v16; // r13
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // rsi
  unsigned __int64 v19; // rax
  __int64 v20; // r15
  __int64 v21; // r13
  _QWORD *v22; // rsi
  unsigned __int64 *v23; // rdx
  signed __int64 v24; // rax
  double v25; // xmm4_8
  double v26; // xmm5_8
  __int64 v27; // rax
  unsigned __int64 result; // rax
  unsigned __int64 v29; // [rsp+8h] [rbp-60h]
  unsigned __int64 v30; // [rsp+8h] [rbp-60h]
  size_t v31; // [rsp+10h] [rbp-58h]
  __int64 v32; // [rsp+18h] [rbp-50h]
  __int64 v33; // [rsp+20h] [rbp-48h]
  __int64 v34; // [rsp+28h] [rbp-40h]

  v8 = (_QWORD *)qword_C1300;
  v9 = off_BF0E0;
  if ( qword_C1300 )
  {
    v10 = qword_C1300 + 56 * qword_C12F8;
    if ( qword_C1300 < v10 )
    {
      while ( *(_DWORD *)v8 != 7 )
      {
        v8 += 7;
        if ( (unsigned __int64)v8 >= v10 )
          goto LABEL_16;
      }
      v11 = v8[6];
      v12 = 64LL;
      v13 = v8[5];
      v31 = v8[4];
      if ( v11 >= 0x40 )
        v12 = v8[6];
      v33 = v12 - 1;
      v14 = -v12;
      v15 = 1LL;
      if ( v11 )
        v15 = v8[6];
      v34 = v12 + 2496;
      v8 = (_QWORD *)(*(_QWORD *)off_BF0E0 + v8[2]);
      v16 = v15;
    }
    else
    {
LABEL_16:
      v34 = 2560LL;
      v11 = 0LL;
      v8 = 0LL;
      v13 = 0LL;
      v33 = 63LL;
      v16 = 1LL;
      v14 = -64LL;
      v12 = 64LL;
      v31 = 0LL;
    }
  }
  else
  {
    v34 = 2560LL;
    v16 = 1LL;
    v12 = 64LL;
    v11 = 0LL;
    v33 = 63LL;
    v14 = -64LL;
    v13 = 0LL;
    v31 = 0LL;
  }
  v29 = v12;
  sub_4D2F0(0LL);
  v32 = v29;
  v30 = v29 * ((v29 + v13 + qword_C0350 - 1) / v29);
  v17 = sub_4BB00(v30 + v34);
  qword_C03A0 = 62LL;
  qword_C03C8 = 0LL;
  v18 = v17 + v33;
  v19 = v13 + v11 - 1;
  v20 = v18 & v14;
  if ( !v11 )
    v19 = v13;
  v21 = v19 / v16 * v16;
  v9[138] = v21;
  qword_C03C0 = v20 + v30 - v21;
  memcpy((void *)qword_C03C0, v8, v31);
  v22 = (_QWORD *)(v20 + v30);
  v22[1] = &unk_C03B0;
  *v22 = v22;
  v22[2] = v22;
  v24 = sys_arch_prctl((struct task_struct *)((char *)&stru_1000.r_offset + 2), (int)v20 + (int)v30, v23);
  if ( (_DWORD)v24 )
    sub_17110((__int64)"cannot set %fs base address for thread-local storage", a1, a2, a3, a4, v25, v26, a7, a8);
  v9[136] = v11;
  v9[135] = v13;
  v9[134] = v31;
  qword_C0378 = (__int64)&qword_C07A0;
  v27 = qword_C0350;
  v9[133] = v8;
  qword_C07C8 = (__int64)v9;
  v9[139] = 1LL;
  result = ((v21 + v27 + 63) & 0xFFFFFFFFFFFFFFC0LL) + 2496;
  qword_C0360 = v21;
  qword_C07A0 = 64LL;
  qword_C0388 = 1LL;
  qword_C0368 = result;
  qword_C0358 = v32;
  qword_C0370 = 1LL;
  return result;
}
// CB89: variable 'v23' is possibly undefined
// CB9B: variable 'v25' is possibly undefined
// CB9B: variable 'v26' is possibly undefined
// 1000: using guessed type Elf64_Rela stru_1000;
// BF0E0: using guessed type void *off_BF0E0;
// C0350: using guessed type __int64 qword_C0350;
// C0358: using guessed type __int64 qword_C0358;
// C0360: using guessed type __int64 qword_C0360;
// C0368: using guessed type __int64 qword_C0368;
// C0370: using guessed type __int64 qword_C0370;
// C0378: using guessed type __int64 qword_C0378;
// C0388: using guessed type __int64 qword_C0388;
// C03A0: using guessed type __int64 qword_C03A0;
// C03C0: using guessed type __int64 qword_C03C0;
// C03C8: using guessed type __int64 qword_C03C8;
// C07A0: using guessed type __int64 qword_C07A0;
// C07C8: using guessed type __int64 qword_C07C8;
// C12F8: using guessed type __int64 qword_C12F8;
// C1300: using guessed type __int64 qword_C1300;

//----- (000000000000CCC0) ----------------------------------------------------
__int64 __fastcall sub_CCC0(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  signed __int64 v5; // r14
  __int64 i; // rbx

  result = init_proc();
  v5 = off_BAD50 - off_BAD40;
  if ( v5 )
  {
    for ( i = 0LL; i != v5; ++i )
      result = ((__int64 (__fastcall *)(_QWORD, __int64, __int64))off_BAD40[i])(a1, a2, a3);
  }
  return result;
}
// 9000: using guessed type __int64 init_proc(void);
// BAD40: using guessed type __int64 (__fastcall *off_BAD40[4])();
// BAD50: using guessed type __int64 (__fastcall *off_BAD50[2])();

//----- (000000000000CD60) ----------------------------------------------------
void sub_CD60()
{
  signed __int64 i; // rbx

  for ( i = (&unk_BAD60 - (_UNKNOWN *)off_BAD50) >> 3; i; --i )
    off_BAD50[i - 1]();
  term_proc();
}
// BAD50: using guessed type __int64 (__fastcall *off_BAD50[2])();

//----- (000000000000CDA0) ----------------------------------------------------
void __fastcall __noreturn sub_CDA0(unsigned __int64 a1, __int64 a2, __int64 a3, unsigned int a4, void *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  void *v14; // rbx
  const char *v15; // rax
  const char *v16; // rcx
  int v17; // ecx
  int v18; // er8
  int v19; // er9
  __int64 v20; // rdx
  __int64 v21; // rcx
  u32 *v22; // r8
  u32 v23; // er9
  double v24; // xmm4_8
  double v25; // xmm5_8
  _DWORD *v26; // rbx
  __int64 v27; // rsi
  unsigned int *v28; // rdi
  int v29; // [rsp+Ch] [rbp-3Ch] BYREF
  __int64 v30[7]; // [rsp+10h] [rbp-38h] BYREF

  v14 = a5;
  v30[1] = __readfsqword(0x28u);
  v15 = ": ";
  if ( !a5 )
  {
    v14 = &unk_A6E65;
    v15 = (const char *)&unk_A6E65;
  }
  v16 = ": ";
  if ( !*(_BYTE *)off_BEFD8 )
    v16 = (const char *)&unk_A6E65;
  if ( (int)sub_130A0(v30, a1, off_BEFD8, v16, a3, a4, v14, v15, a2, &v29) < 0 )
  {
    send(2u, "Unexpected error.\n", 0x12uLL);
  }
  else
  {
    sub_13580(0, (unsigned int)"%s", v30[0], v17, v18, v19);
    sub_13CE0((__int64)stderr, (__int64)"%s", v20, v21, v22, v23, a6, a7, a8, a9, v24, v25, a12, a13);
    v29 = -(int)off_BF078 & ((_DWORD)off_BF078 + v29);
    v26 = mmap(0LL, v29, 3uLL, 0x22u, 0xFFFFFFFFuLL, 0LL);
    if ( v26 != (_DWORD *)-1LL )
    {
      v27 = v30[0];
      *v26 = v29;
      sub_9030(v26 + 1, v27);
      v28 = (unsigned int *)_InterlockedExchange64(&qword_C0D10, (__int64)v26);
      if ( v28 )
        munmap(v28, *v28);
    }
    sub_21B70(v30[0]);
  }
  exit();
}
// CE4C: variable 'v17' is possibly undefined
// CE4C: variable 'v18' is possibly undefined
// CE4C: variable 'v19' is possibly undefined
// CE58: variable 'v20' is possibly undefined
// CE58: variable 'v21' is possibly undefined
// CE58: variable 'v22' is possibly undefined
// CE58: variable 'v23' is possibly undefined
// CE58: variable 'v24' is possibly undefined
// CE58: variable 'v25' is possibly undefined
// 9030: using guessed type __int64 __fastcall sub_9030(_QWORD, _QWORD);
// 90C0: using guessed type __int64 __fastcall sub_90C0(_QWORD, _QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// BEFD8: using guessed type void *off_BEFD8;
// BF078: using guessed type Elf64_Rela *off_BF078;
// C0D10: using guessed type __int64 qword_C0D10;

//----- (000000000000CF00) ----------------------------------------------------
void __fastcall __noreturn sub_CF00(__int64 a1, __int64 a2, unsigned int a3, void *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  __int64 v14; // rax
  double v15; // xmm4_8
  double v16; // xmm5_8

  v14 = sub_CF50("libc", "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", 5u, a5, a6, a7, a8, a9, a10, a11, a12);
  sub_CDA0(v14, a1, a2, a3, a4, a5, a6, a7, a8, v15, v16, a11, a12);
}
// CF41: variable 'v15' is possibly undefined
// CF41: variable 'v16' is possibly undefined

//----- (000000000000CF50) ----------------------------------------------------
__int64 __fastcall sub_CF50(char *a1, unsigned __int8 *a2, unsigned int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  return sub_DD90(a1, a2, 0LL, 0, 0LL, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

//----- (000000000000CF70) ----------------------------------------------------
__int64 __fastcall sub_CF70(_DWORD *a1, __int64 a2)
{
  _DWORD *v2; // rbx
  int v3; // eax
  bool v4; // cc
  __int64 v5; // r12
  int v7; // eax
  __int64 v8; // rax
  int v9; // eax

  v2 = a1;
  v3 = *a1;
  v4 = *a1 <= 2;
  if ( *a1 == 2 )
  {
LABEL_9:
    v5 = sub_CF70(*((_DWORD **)v2 + 1), a2);
    v7 = v2[1];
    if ( v7 == 15 )
    {
      if ( v5 )
        return 1LL;
    }
    else
    {
      if ( v7 != 14 )
      {
        sub_CF70(*((_DWORD **)v2 + 2), a2);
        v8 = (unsigned int)(v2[1] - 3);
        if ( (unsigned int)v8 <= 0xA )
          __asm { jmp     rax }
        return 0LL;
      }
      if ( !v5 )
        return v5;
    }
    return sub_CF70(*((_DWORD **)v2 + 2), a2) != 0;
  }
  while ( !v4 )
  {
    if ( v3 != 3 )
      return 0LL;
    v2 = *(_DWORD **)&v2[2 * (sub_CF70(*((_DWORD **)v2 + 1), a2) == 0) + 4];
    v3 = *v2;
    v4 = *v2 <= 2;
    if ( *v2 == 2 )
      goto LABEL_9;
  }
  if ( v3 )
  {
    if ( v3 == 1 )
      return sub_CF70(*((_DWORD **)v2 + 1), a2) == 0;
  }
  else
  {
    v9 = v2[1];
    v5 = a2;
    if ( !v9 )
      return v5;
    if ( v9 == 1 )
      return *((_QWORD *)v2 + 1);
  }
  return 0LL;
}

//----- (000000000000D160) ----------------------------------------------------
__int64 __fastcall sub_D160(__int64 a1, __int64 a2)
{
  __int64 v4; // rsi
  __int64 v5; // rdi
  __int64 result; // rax

  if ( *(_QWORD *)(a2 + 32) )
    v4 = a2 + 56;
  else
    v4 = *(_QWORD *)(a2 + 56);
  v5 = a1 + 56;
  if ( !*(_QWORD *)(a1 + 32) )
    v5 = *(_QWORD *)(a1 + 56);
  result = sub_91B0(v5, v4);
  if ( !(_DWORD)result )
  {
    result = sub_91B0(*(_QWORD *)a1, *(_QWORD *)a2);
    if ( !(_DWORD)result )
    {
      result = sub_91B0(*(_QWORD *)(a1 + 16), *(_QWORD *)(a2 + 16));
      if ( !(_DWORD)result )
        result = (unsigned int)(*(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8));
    }
  }
  return result;
}
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);

//----- (000000000000D1E0) ----------------------------------------------------
unsigned __int64 __fastcall sub_D1E0(__int64 a1, __int64 a2, unsigned __int8 *a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  int v15; // er11
  __int64 *v16; // r14
  bool v17; // zf
  unsigned int v18; // eax
  unsigned int v19; // esi
  int v20; // er10
  __int64 v21; // r12
  u32 v22; // er9
  unsigned int v23; // er15
  int v24; // er11
  int v25; // er13
  unsigned int *v26; // rdi
  unsigned int v27; // eax
  __int64 v28; // rax
  __int64 v29; // rsi
  size_t v30; // rsi
  int v31; // eax
  u32 *v32; // r8
  double v33; // xmm4_8
  double v34; // xmm5_8
  unsigned int v35; // eax
  unsigned int v36; // ebx
  unsigned __int32 v37; // eax
  unsigned __int64 v38; // rbx
  size_t *v39; // rax
  unsigned __int64 v40; // r15
  unsigned __int64 v41; // r13
  __int64 v42; // rdx
  int v43; // eax
  __int64 *v45; // rax
  unsigned __int64 v46; // rdx
  __int64 v47; // rax
  __int64 v48; // r15
  unsigned int *v49; // rdx
  __int64 v50; // rax
  unsigned int v51; // edx
  char *v52; // r15
  __int64 v53; // r13
  const char *v54; // rsi
  __int64 v55; // r12
  const char *v56; // rcx
  __int64 v57; // r10
  __int64 v58; // rbx
  __int64 v59; // rdx
  __int64 *v60; // r13
  __int64 v61; // rdi
  __int64 v62; // rax
  const char *v63; // r10
  __int64 v64; // r12
  void *v65; // rax
  __int64 v66; // rdi
  __int64 v67; // rax
  __int64 v68; // rdi
  __int64 v69; // rax
  __int64 v70; // r15
  __int64 v71; // rdx
  void *v72; // rsp
  u32 **v73; // r13
  _BYTE *v74; // rax
  double v75; // xmm4_8
  double v76; // xmm5_8
  char *v77; // rcx
  const char *v78; // r10
  __int64 v79; // rdx
  char *v80; // rax
  unsigned __int64 v81; // rsi
  char v82; // di
  void *v83; // rsp
  u32 **v84; // r8
  _BYTE *v85; // rax
  _BYTE *v86; // rdi
  char *v87; // rdx
  __int64 v88; // rax
  char v89; // cl
  char *v90; // rcx
  void *v91; // rsp
  u32 **v92; // r8
  _BYTE *v93; // rdx
  _BYTE *v94; // rdi
  int v95; // eax
  __int64 v96; // rax
  __int64 *v97; // rax
  _WORD *v98; // rax
  const void *v99; // r12
  int v101; // er14
  unsigned __int64 v102; // rdx
  __int64 *v103; // rbx
  __int64 v104; // rdx
  __int64 v105; // r13
  _QWORD *v106; // rax
  int v107; // eax
  __int64 v108; // rdx
  char *v110; // rax
  __int64 v111; // rsi
  __int64 v112; // rdi
  char *v113; // r9
  u32 *v114; // r8
  __int64 v115; // rcx
  __int64 v116; // rcx
  __int64 v117; // rcx
  __int64 v118; // r9
  signed __int64 v119; // rax
  __int64 v120; // rax
  _QWORD *v121; // rax
  signed __int64 v122; // rax
  __int64 v123; // r8
  signed __int64 v124; // rax
  _BYTE *v125; // [rsp-Eh] [rbp-C0h] BYREF
  _BYTE *v126; // [rsp-6h] [rbp-B8h]
  u32 *v127; // [rsp+2h] [rbp-B0h] BYREF
  __int64 v128; // [rsp+Ah] [rbp-A8h]
  int v129; // [rsp+12h] [rbp-A0h]
  int v130; // [rsp+16h] [rbp-9Ch]
  const char *v131; // [rsp+1Ah] [rbp-98h]
  __int64 v132; // [rsp+22h] [rbp-90h]
  unsigned __int64 v133; // [rsp+2Ah] [rbp-88h]
  size_t v134; // [rsp+32h] [rbp-80h]
  __int64 v135; // [rsp+3Ah] [rbp-78h]
  unsigned __int64 v136; // [rsp+42h] [rbp-70h]
  unsigned __int64 v137; // [rsp+4Ah] [rbp-68h]
  unsigned __int64 v138; // [rsp+52h] [rbp-60h] BYREF
  _QWORD *v139; // [rsp+5Ah] [rbp-58h] BYREF
  __int64 v140[2]; // [rsp+62h] [rbp-50h] BYREF
  __int16 v141; // [rsp+72h] [rbp-40h]
  unsigned __int64 v142; // [rsp+7Ah] [rbp-38h]

  v132 = a1;
  v15 = *(_DWORD *)(a1 + 8);
  v128 = a2;
  v129 = a4;
  v127 = a5;
  v142 = __readfsqword(0x28u);
  if ( v15 <= 0 )
    sub_E910(a1, a2, a7, a8, a9, a10, a11, a12, a13, a14, (__int64)a3, a4, a5, a6);
  v16 = *(__int64 **)(v132 + 16);
  if ( !v16 )
    return 0LL;
  v17 = v16[12] == 0;
  LODWORD(v137) = *((_DWORD *)v16 + 10);
  if ( !v17 )
  {
    LODWORD(v135) = strlen((__int64)a3);
    v18 = sub_11AA0(a3);
    v19 = *((_DWORD *)v16 + 22);
    v20 = *((_DWORD *)v16 + 26);
    v133 = (unsigned __int64)a3;
    v21 = v16[12];
    v134 = (unsigned int)v135;
    v22 = v18 % (v19 - 2) + 1;
    v23 = v18 % v19;
    LODWORD(v136) = v19 - v22;
    v24 = v22 - v19;
    v25 = v20;
    while ( 1 )
    {
      v36 = *(_DWORD *)(v21 + 4LL * v23);
      v37 = _byteswap_ulong(v36);
      if ( v25 )
        v36 = v37;
      if ( !v36 )
        return 0LL;
      v38 = v36 - 1;
      if ( (unsigned int)v137 > (unsigned int)v38 )
      {
        v26 = (unsigned int *)(v16[6] + 8 * v38);
        v27 = *v26;
        if ( *((_DWORD *)v16 + 6) )
        {
          if ( (unsigned int)v135 > _byteswap_ulong(v27) )
            goto LABEL_11;
          v28 = *v16;
          v29 = _byteswap_ulong(v26[1]);
        }
        else
        {
          if ( (unsigned int)v135 > v27 )
            goto LABEL_11;
          v28 = *v16;
          v29 = v26[1];
        }
        v130 = v24;
        v30 = v28 + v29;
        LODWORD(v131) = v22;
      }
      else
      {
        v39 = (size_t *)(v16[9] + 16LL * (unsigned int)(v38 - v137));
        if ( *v39 <= v134 )
          goto LABEL_11;
        v130 = v24;
        v30 = v39[1];
        LODWORD(v131) = v22;
      }
      v31 = sub_91B0(v133, v30);
      v22 = (unsigned int)v131;
      v24 = v130;
      if ( !v31 )
      {
        v136 = (unsigned int)v137;
        goto LABEL_33;
      }
LABEL_11:
      v35 = v23 + v24;
      if ( (unsigned int)v136 > v23 )
        v35 = v23 + v22;
      v23 = v35;
    }
  }
  v40 = 0LL;
  v136 = (unsigned int)v137;
  v41 = (unsigned int)v137;
LABEL_21:
  if ( v41 <= v40 )
    return 0LL;
  while ( 1 )
  {
    v38 = (v41 + v40) >> 1;
    v42 = *(unsigned int *)(v16[6] + 8 * v38 + 4);
    if ( *((_DWORD *)v16 + 6) )
      v42 = _byteswap_ulong(*(_DWORD *)(v16[6] + 8 * v38 + 4));
    v43 = sub_91B0(a3, v42 + *v16);
    if ( v43 < 0 )
    {
      v41 = (v41 + v40) >> 1;
      goto LABEL_21;
    }
    if ( !v43 )
      break;
    v40 = v38 + 1;
    if ( v41 <= v38 + 1 )
      return 0LL;
  }
LABEL_33:
  if ( v38 < v136 )
  {
    v32 = (u32 *)*((unsigned int *)v16 + 6);
    v48 = *v16;
    v49 = (unsigned int *)(v16[7] + 8 * v38);
    v50 = v49[1];
    v51 = *v49;
    if ( (_DWORD)v32 )
    {
      v51 = _byteswap_ulong(v51);
      v136 = v48 + _byteswap_ulong(v50);
    }
    else
    {
      v136 = v48 + v50;
    }
    v135 = v51 + 1;
  }
  else
  {
    v45 = (__int64 *)(v16[10] + 16 * (v38 - v136));
    v46 = v45[1];
    v47 = *v45;
    v136 = v46;
    v135 = v47;
  }
  if ( !v129 )
    goto LABEL_36;
  if ( !v128 || (v52 = *(char **)(v128 + 16)) == 0LL )
  {
    v52 = (char *)qword_C0C00;
    if ( !dword_C0C08 )
    {
      v98 = sub_12350("OUTPUT_CHARSET");
      v99 = v98;
      if ( v98 && *(_BYTE *)v98 )
      {
        v134 = strlen((__int64)v98) + 1;
        v110 = (char *)sub_21500(v134);
        v52 = v110;
        if ( v110 )
          memcpy(v110, v99, v134);
        qword_C0C00 = (__int64)v52;
      }
      else
      {
        v52 = (char *)qword_C0C00;
      }
      dword_C0C08 = 1;
    }
    if ( !v52 )
      v52 = *(char **)(*(_QWORD *)__readfsqword(0xFFFFFFA0) + 176LL);
  }
  v53 = v16[15];
  while ( v53 )
  {
    --v53;
    v54 = v52;
    v55 = v16[14] + 24 * v53;
    if ( !(unsigned int)sub_91B0(*(_QWORD *)v55, v52) )
      goto LABEL_69;
  }
  v57 = v16[15];
  v56 = (const char *)v16[14];
  v133 = v38;
  v131 = v56;
  v58 = v57;
  v59 = (__int64)&v56[24 * v57 - 24];
  v134 = 24 * v57;
  v60 = (__int64 *)v59;
  while ( 2 )
  {
    if ( !v58 )
    {
      v38 = v133;
      v133 = 0LL;
      if ( v131 )
        v62 = sub_21DF0(v131, v134 + 24, v59, (__int64)v56, v32, v22, a7, a8, a9, a10, v33, v34, a13, a14);
      else
        v62 = sub_21500(v134 + 24);
      v63 = (const char *)v133;
      v64 = v62;
      if ( v62 )
      {
        v16[14] = v62;
        v131 = v63;
        v65 = sub_23100(v52);
        v133 = (unsigned __int64)v65;
        if ( v65 )
        {
          v55 = v134 + v64;
          v66 = v132;
          *(_QWORD *)v55 = v65;
          v54 = (const char *)v128;
          *(_QWORD *)(v55 + 8) = -1LL;
          v67 = sub_D1E0(v66, v54, &unk_A6E65, 0LL, &v139);
          v68 = v67;
          if ( v67 == -1 )
            return v68;
          if ( !v67 )
            goto LABEL_68;
          v54 = "charset=";
          v69 = sub_9120(v67, "charset=");
          if ( !v69 )
            goto LABEL_68;
          v70 = v69 + 8;
          v71 = sub_91E0(v69 + 8, &off_8FB58);
          v72 = alloca(v71 + 9);
          v134 = (size_t)&v127;
          v73 = &v127;
          v74 = (_BYTE *)sub_91D0(&v127, v70, v71);
          v77 = (char *)v134;
          v78 = v131;
          *v74 = 0;
          v79 = *v77;
          if ( (_BYTE)v79 )
          {
            v80 = v77;
            v81 = 0LL;
            v82 = *v77;
            do
            {
              ++v80;
              v81 += v82 == 47;
              v82 = *v80;
            }
            while ( *v80 );
            v83 = alloca(v80 - v77 + 11);
            v84 = &v127;
            v85 = &v127;
            do
            {
              v86 = v85;
              v73 = (u32 **)((char *)v73 + 1);
              *v85++ = dword_968A0[v79];
              v79 = *(char *)v73;
            }
            while ( (_BYTE)v79 );
            if ( v81 > 1 )
            {
LABEL_61:
              v87 = (char *)v133;
              *v85 = 0;
              v140[0] = (__int64)v84;
              v88 = *v87;
              if ( (_BYTE)v88 )
              {
                v89 = *v87;
                do
                {
                  ++v87;
                  v78 += v89 == 47;
                  v89 = *v87;
                }
                while ( *v87 );
                v90 = (char *)v133;
                v91 = alloca((signed __int64)&v87[-v133 + 11]);
                v92 = &v127;
                v93 = &v127;
                do
                {
                  v94 = v93;
                  ++v90;
                  *v93++ = dword_968A0[v88];
                  v88 = *v90;
                }
                while ( (_BYTE)v88 );
                if ( (unsigned __int64)v78 > 1 )
                {
LABEL_67:
                  *v93 = 0;
                  v54 = (const char *)(v55 + 8);
                  v140[1] = (__int64)v92;
                  v141 = 1;
                  v95 = sub_51050((__int64)v140, (__int64 **)(v55 + 8), 1, a7, a8, a9, a10, v75, v76, a13, a14);
                  if ( !v95 )
                  {
LABEL_68:
                    *(_QWORD *)(v55 + 16) = 0LL;
                    ++v16[15];
                    goto LABEL_69;
                  }
                  if ( v95 == -1 )
                  {
                    *(_QWORD *)(v55 + 8) = -1LL;
                    goto LABEL_68;
                  }
                  sub_21B70(v133);
                  return 0LL;
                }
                *v93 = 47;
                if ( v78 )
                {
                  v93 = v94 + 2;
                  goto LABEL_67;
                }
                v121 = v93;
              }
              else
              {
                v126 = v87;
                v125 = v87;
                v121 = &v125;
                LOBYTE(v125) = 47;
                v92 = (u32 **)&v125;
              }
              *((_BYTE *)v121 + 1) = 47;
              v93 = (char *)v121 + 2;
              goto LABEL_67;
            }
            *v85 = 47;
            if ( v81 )
            {
              v85 = v86 + 2;
              goto LABEL_61;
            }
          }
          else
          {
            v126 = v74;
            v125 = v74;
            v85 = &v125;
            LOBYTE(v125) = 47;
            v84 = (u32 **)&v125;
          }
          v85[1] = 47;
          v85 += 2;
          goto LABEL_61;
        }
      }
      return -1LL;
    }
    v61 = *v60;
    v54 = v52;
    v55 = (__int64)v60;
    --v58;
    v60 -= 3;
    if ( (unsigned int)sub_91B0(v61, v52) )
      continue;
    break;
  }
  v38 = v133;
LABEL_69:
  if ( *(_QWORD *)(v55 + 8) == -1LL )
    goto LABEL_36;
  v96 = *(_QWORD *)(v55 + 16);
  if ( !v96 )
  {
    if ( __readfsdword(0x18u) )
    {
      _RDX = 1LL;
      if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C0C20, 1, 0) )
        sub_1C7D0((volatile __int32 *)&dword_C0C20, (__int64)v54, 1LL, (__int64)v56, v32, v22);
    }
    else
    {
      _RDX = 1LL;
      __asm { cmpxchg cs:dword_C0C20, edx }
    }
    if ( !*(_QWORD *)(v55 + 16) )
    {
      v54 = byte_8;
      v120 = sub_22260(
               (unsigned int)(*((_DWORD *)v16 + 16) + v137),
               8uLL,
               a7,
               a8,
               a9,
               a10,
               v33,
               v34,
               a13,
               a14,
               _RDX,
               (__int64)v56,
               v32,
               v22);
      *(_QWORD *)(v55 + 16) = v120;
      if ( v120 )
        goto LABEL_85;
      *(_QWORD *)(v55 + 16) = -1LL;
    }
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedExchange((volatile __int32 *)&dword_C0C20, 0) > 1 )
      {
        v54 = (_BYTE *)(&qword_80 + 1);
        v124 = sys_futex(&dword_C0C20, 129, 1u, 0LL, v32, v22);
      }
      v96 = *(_QWORD *)(v55 + 16);
    }
    else
    {
      --dword_C0C20;
      v96 = *(_QWORD *)(v55 + 16);
    }
  }
  if ( v96 == -1 )
    return -1LL;
  v97 = *(__int64 **)(v96 + 8 * v38);
  if ( v97 )
    goto LABEL_73;
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C0C20, 1, 0) )
      sub_1C7D0((volatile __int32 *)&dword_C0C20, (__int64)v54, 1LL, (__int64)v56, v32, v22);
  }
  else
  {
    _EDX = 1;
    __asm { cmpxchg cs:dword_C0C20, edx }
  }
LABEL_85:
  v137 = v38;
  v101 = 0;
  v102 = qword_C0C10;
  v138 = v136;
  v139 = (_QWORD *)(qword_C0C18 + 8);
  while ( 2 )
  {
    if ( v102 <= 7 )
    {
LABEL_93:
      if ( v101 )
      {
        ++v101;
        v103 = (__int64 *)qword_C0C28;
        v104 = (unsigned int)(4080 * v101);
        v105 = (int)v104;
        qword_C0C10 = (int)v104;
        v106 = (_QWORD *)sub_21DF0(
                           (const char *)qword_C0C28,
                           (int)v104,
                           v104,
                           (__int64)v56,
                           v32,
                           v22,
                           a7,
                           a8,
                           a9,
                           a10,
                           v33,
                           v34,
                           a13,
                           a14);
        if ( !v106 )
        {
          qword_C0C28 = *v103;
          sub_21B70(v103);
LABEL_98:
          qword_C0C18 = 0LL;
          qword_C0C10 = 0LL;
          if ( !__readfsdword(0x18u) )
          {
            --dword_C0C20;
            return -1LL;
          }
          v136 = -1LL;
          if ( _InterlockedExchange((volatile __int32 *)&dword_C0C20, 0) > 1 )
          {
LABEL_124:
            v119 = sys_futex(&dword_C0C20, 129, 1u, 0LL, v32, v22);
            return v136;
          }
          return v136;
        }
        qword_C0C28 = (__int64)v106;
        v102 = v105 - 8;
      }
      else
      {
        qword_C0C10 = 4080LL;
        v106 = (_QWORD *)sub_21500(4080LL);
        if ( !v106 )
          goto LABEL_98;
        v108 = qword_C0C28;
        v101 = 1;
        qword_C0C28 = (__int64)v106;
        *v106 = v108;
        v102 = 4072LL;
      }
      v56 = (const char *)(v106 + 1);
      qword_C0C10 = v102;
      qword_C0C18 = (__int64)(v106 + 1);
      v139 = v106 + 2;
      continue;
    }
    break;
  }
  v107 = sub_51370(
           *(_QWORD **)(v55 + 8),
           (__int64 *)&v138,
           v138 + v135,
           (__int64 *)&v139,
           (__int64)v139 + v102 - 8,
           v140);
  if ( (v107 & 0xFFFFFFFB) != 0 )
  {
    if ( v107 != 5 )
    {
      if ( !__readfsdword(0x18u) )
      {
        --dword_C0C20;
        return 0LL;
      }
      v136 = 0LL;
      if ( _InterlockedExchange((volatile __int32 *)&dword_C0C20, 0) > 1 )
        goto LABEL_124;
      return v136;
    }
    v138 = v136;
    goto LABEL_93;
  }
  v111 = (__int64)v139;
  v97 = (__int64 *)qword_C0C18;
  v112 = *(_QWORD *)(v55 + 16);
  v113 = (char *)v139 - qword_C0C18;
  v114 = (u32 *)(8 * v137);
  v115 = (__int64)v139 - qword_C0C18 - 8;
  *(_QWORD *)qword_C0C18 = v115;
  v135 = v115;
  v116 = qword_C0C10;
  *(_QWORD *)((char *)v114 + v112) = v97;
  v117 = v116 - (_QWORD)v113;
  v118 = v117 & 7;
  qword_C0C10 = v117 & 0xFFFFFFFFFFFFFFF8LL;
  qword_C0C18 = v118 + v111;
  if ( !__readfsdword(0x18u) )
  {
    --dword_C0C20;
    goto LABEL_74;
  }
  if ( _InterlockedExchange((volatile __int32 *)&dword_C0C20, 0) <= 1 )
  {
    v97 = *(__int64 **)((char *)v114 + v112);
    v135 = *v97;
    goto LABEL_74;
  }
  v122 = sys_futex(&dword_C0C20, 129, 1u, 0LL, v114, v118);
  v97 = *(__int64 **)(*(_QWORD *)(v55 + 16) + v123);
LABEL_73:
  v135 = *v97;
LABEL_74:
  v136 = (unsigned __int64)(v97 + 1);
LABEL_36:
  *(_QWORD *)v127 = v135;
  return v136;
}
// D5CD: variable 'v59' is possibly undefined
// D5CD: variable 'v56' is possibly undefined
// D5CD: variable 'v32' is possibly undefined
// D5CD: variable 'v22' is possibly undefined
// D5CD: variable 'v33' is possibly undefined
// D5CD: variable 'v34' is possibly undefined
// D7BD: variable 'v75' is possibly undefined
// D7BD: variable 'v76' is possibly undefined
// DC5C: variable '_RDX' is possibly undefined
// DD59: variable 'v123' is possibly undefined
// 80: using guessed type __int64 qword_80;
// 9090: using guessed type __int64 __fastcall sub_9090(_QWORD);
// 9120: using guessed type __int64 __fastcall sub_9120(_QWORD, _QWORD);
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// 91E0: using guessed type __int64 __fastcall sub_91E0(_QWORD, _QWORD);
// 9238: using guessed type __int64 __fastcall sub_9238(_QWORD);
// 9240: using guessed type __int64 __fastcall sub_9240(_QWORD);
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// 8FB58: using guessed type void *off_8FB58;
// C0C00: using guessed type __int64 qword_C0C00;
// C0C08: using guessed type int dword_C0C08;
// C0C10: using guessed type __int64 qword_C0C10;
// C0C18: using guessed type __int64 qword_C0C18;
// C0C28: using guessed type __int64 qword_C0C28;

//----- (000000000000DD90) ----------------------------------------------------
__int64 __fastcall sub_DD90(char *a1, unsigned __int8 *a2, __int64 a3, int a4, __int64 a5, unsigned int a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  char *v14; // r13
  _QWORD *v15; // rax
  __int64 v16; // r12
  char *v17; // r15
  char *v18; // rax
  char *v19; // rbx
  void *v20; // rsp
  _BYTE *v21; // rax
  __int64 v22; // rdx
  __int64 v23; // rax
  double v24; // xmm4_8
  double v25; // xmm5_8
  __int64 v26; // r13
  void *v27; // rsp
  char *v28; // r15
  char v29; // al
  char *v30; // rax
  u32 v31; // er9
  char *v32; // r12
  unsigned __int64 v33; // rax
  u32 v34; // er9
  char *v35; // rcx
  void *v36; // r13
  char *v37; // r10
  char *v38; // rcx
  int v40; // eax
  double v41; // xmm4_8
  double v42; // xmm5_8
  bool v43; // zf
  __int64 v44; // rax
  int v45; // er8
  int v46; // er9
  __int64 v47; // r15
  int v48; // ebx
  char *v49; // rax
  char *v50; // rdx
  __int64 v51; // rdi
  u32 *v52; // rbx
  __int64 v53; // r15
  unsigned __int64 v54; // rax
  char *v55; // r10
  __int64 v56; // rax
  __int64 v57; // rdx
  __int64 v58; // rbx
  __int64 v59; // rax
  __int64 v60; // r13
  unsigned __int64 v61; // rax
  unsigned __int64 v62; // r12
  char *v63; // rdi
  char *v64; // rbx
  bool v65; // cf
  __int64 v66; // r13
  __int64 v67; // rbx
  unsigned __int64 v68; // rax
  unsigned __int64 v69; // r12
  char *v70; // rdi
  char *v71; // rbx
  char *v72; // r13
  __int64 v73; // r15
  __int64 v74; // rax
  __int64 v75; // rbx
  __int64 v76; // rax
  __int64 v77; // r12
  size_t v78; // rbx
  char *v79; // r14
  char *v80; // rbx
  int v81; // eax
  char *v82; // r10
  char *v83; // rcx
  int v84; // eax
  __int64 v85; // rax
  _QWORD *v86; // rax
  char v87[8]; // [rsp+0h] [rbp-100h] BYREF
  char *v88; // [rsp+8h] [rbp-F8h]
  char *v89; // [rsp+10h] [rbp-F0h]
  __int64 v90; // [rsp+18h] [rbp-E8h]
  unsigned int v91; // [rsp+24h] [rbp-DCh]
  _QWORD *v92; // [rsp+28h] [rbp-D8h]
  __int64 v93; // [rsp+30h] [rbp-D0h]
  __int64 v94; // [rsp+38h] [rbp-C8h]
  __int64 v95; // [rsp+40h] [rbp-C0h]
  void *v96; // [rsp+48h] [rbp-B8h]
  int v97; // [rsp+50h] [rbp-B0h]
  int v98; // [rsp+54h] [rbp-ACh]
  __int64 *v99; // [rsp+58h] [rbp-A8h]
  char *v100; // [rsp+60h] [rbp-A0h]
  char *v101; // [rsp+68h] [rbp-98h]
  char *v102; // [rsp+70h] [rbp-90h] BYREF
  __int64 v103; // [rsp+78h] [rbp-88h] BYREF
  char *v104; // [rsp+80h] [rbp-80h] BYREF
  int v105; // [rsp+88h] [rbp-78h]
  __int64 v106; // [rsp+90h] [rbp-70h]
  __int64 v107; // [rsp+A0h] [rbp-60h]
  unsigned __int8 *v108; // [rsp+B8h] [rbp-48h]
  unsigned __int64 v109; // [rsp+C8h] [rbp-38h]

  v94 = a3;
  v97 = a4;
  v95 = a5;
  v98 = a6;
  v109 = __readfsqword(0x28u);
  v102 = 0LL;
  if ( !a2 )
    return 0LL;
  if ( a6 > 0xC || a6 == 6 )
  {
    if ( !v97 || v95 == 1 )
      return (__int64)a2;
    return v94;
  }
  v14 = a1;
  v91 = __readfsdword(0xFFFFFFC0);
  if ( !a1 )
    v14 = off_BE040;
  v108 = a2;
  v107 = 0LL;
  v104 = v14;
  v105 = v98;
  v90 = sub_5CDF0(v98);
  v106 = v90;
  v92 = sub_4C220((__int64)&v104, &qword_C0C30, sub_D160);
  if ( v92 )
  {
    v15 = (_QWORD *)*v92;
    if ( *(_DWORD *)(*v92 + 24LL) == dword_C0CC0 )
    {
      v38 = (char *)v15[5];
      if ( !v97 )
        goto LABEL_53;
      v58 = v15[6];
      v59 = v15[4];
      v101 = v38;
      v60 = *(_QWORD *)(v59 + 16);
      v61 = sub_CF70(*(_DWORD **)(v60 + 184), v95);
      v38 = v101;
      v62 = v61;
      if ( v61 >= *(_QWORD *)(v60 + 192) )
        goto LABEL_53;
      v63 = v101;
      v64 = &v101[v58];
      while ( 1 )
      {
        v65 = v62-- == 0;
        if ( v65 )
          break;
        v63 = (char *)(sub_9060(v63, 0LL) + 1);
        if ( v63 >= v64 )
        {
          v38 = v101;
LABEL_53:
          __writefsdword(0xFFFFFFC0, v91);
          return (__int64)v38;
        }
      }
      v38 = v63;
      goto LABEL_53;
    }
  }
  v16 = qword_C0BF8;
  if ( !qword_C0BF8 )
    goto LABEL_9;
  while ( 1 )
  {
    v40 = sub_91B0(v14, v16 + 24);
    if ( !v40 )
    {
      v43 = **(_BYTE **)(v16 + 8) == 47;
      v101 = *(char **)(v16 + 8);
      if ( v43 )
        goto LABEL_10;
      v44 = sub_4B000(0LL, 0LL, a7, a8, a9, a10, v41, v42, a13, a14);
      v47 = v44;
      if ( v44 )
      {
        v48 = sub_130A0((unsigned int)&v102, (unsigned int)&off_8FB58 + 4, v44, (_DWORD)v101, v45, v46, v87[0]);
        sub_21B70(v47);
        if ( v48 >= 0 )
        {
          v101 = v102;
          goto LABEL_10;
        }
      }
LABEL_22:
      sub_21B70(v102);
      __writefsdword(0xFFFFFFC0, v91);
      if ( v95 == 1 || !v97 )
        return (__int64)a2;
      return v94;
    }
    if ( v40 < 0 )
      break;
    v16 = *(_QWORD *)v16;
    if ( !v16 )
      goto LABEL_9;
  }
  v16 = 0LL;
LABEL_9:
  v101 = "/usr/share/locale";
LABEL_10:
  v17 = &aLcCollate[byte_95100[v98]];
  v18 = (char *)sub_5CDF0(v98);
  v19 = v18;
  if ( *v18 != 67 || v18[1] )
  {
    v49 = (char *)sub_12350("LANGUAGE");
    if ( v49 )
    {
      if ( *v49 )
        v19 = v49;
    }
  }
  v93 = strlen((__int64)v14);
  v20 = alloca(v93 + strlen((__int64)v17) + 13);
  v100 = v87;
  v21 = (_BYTE *)sub_90F0(v87);
  v22 = v93;
  *v21 = 47;
  *(_DWORD *)sub_91D0(v21 + 1, v14, v22) = 7302446;
  v23 = strlen((__int64)v19);
  v96 = v14;
  v26 = v16;
  v27 = alloca(v23 + 9);
  v28 = v87;
  while ( 1 )
  {
    do
    {
LABEL_13:
      while ( 2 )
      {
        while ( 1 )
        {
          v29 = *v19;
          if ( *v19 != 58 )
            break;
          ++v19;
        }
        if ( v29 )
        {
          v50 = v28;
          do
          {
            ++v19;
            *v50++ = v29;
            v29 = *v19;
          }
          while ( *v19 && v29 != 58 );
          *v50 = 0;
          if ( sub_9210(v28, 47LL) )
            continue;
        }
        else
        {
          *(_WORD *)v28 = 67;
        }
        break;
      }
      if ( *v28 == 67 && !v28[1] || !strcmp(v28, "POSIX") )
        goto LABEL_22;
      v30 = (char *)sub_E670(v101, (__int64)v28, v100, v26, a7, a8, a9, a10, v24, v25, a13, a14);
      v32 = v30;
    }
    while ( !v30 );
    v99 = &v103;
    v33 = sub_D1E0((__int64)v30, v26, a2, 1LL, (u32 *)&v103, v31, a7, a8, a9, a10, v24, v25, a13, a14);
    v35 = (char *)v33;
    if ( v33 )
      break;
    v51 = *((_QWORD *)v32 + 4);
    if ( v51 )
    {
      v89 = v19;
      v52 = (u32 *)v99;
      v88 = v28;
      v53 = 0LL;
      while ( 1 )
      {
        LODWORD(v99) = v53;
        v54 = sub_D1E0(v51, v26, a2, 1LL, v52, v34, a7, a8, a9, a10, v24, v25, a13, a14);
        if ( v54 == -1LL )
          goto LABEL_22;
        if ( v54 )
        {
          v36 = v96;
          v35 = (char *)v54;
          v37 = *(char **)&v32[8 * (int)v99 + 32];
          goto LABEL_57;
        }
        ++v53;
        v51 = *(_QWORD *)&v32[8 * v53 + 32];
        if ( !v51 )
        {
          v19 = v89;
          v28 = v88;
          goto LABEL_13;
        }
      }
    }
  }
  v36 = v96;
  v37 = v32;
  if ( v33 == -1LL )
    goto LABEL_22;
LABEL_57:
  v100 = v35;
  v101 = v37;
  sub_21B70(v102);
  v55 = v101;
  v38 = v100;
  if ( v92 )
  {
    v56 = *v92;
    *(_DWORD *)(v56 + 24) = dword_C0CC0;
    v57 = v103;
    *(_QWORD *)(v56 + 32) = v55;
    *(_QWORD *)(v56 + 40) = v38;
    *(_QWORD *)(v56 + 48) = v57;
  }
  else
  {
    v73 = strlen((__int64)a2) + 1;
    v74 = strlen(v90);
    v75 = v93;
    v76 = sub_21500(v73 + v93 + v74 + 58);
    v55 = v101;
    v38 = v100;
    v77 = v76;
    if ( v76 )
    {
      v78 = v75 + 1;
      v79 = (char *)sub_91D0(v76 + 56, a2, v73);
      memcpy(v79, v36, v78);
      v80 = &v79[v78];
      sub_9030(v80, v90);
      v81 = v98;
      v82 = v101;
      *(_QWORD *)v77 = v79;
      v83 = v100;
      *(_QWORD *)(v77 + 16) = v80;
      *(_DWORD *)(v77 + 8) = v81;
      v84 = dword_C0CC0;
      *(_QWORD *)(v77 + 32) = v82;
      *(_DWORD *)(v77 + 24) = v84;
      v85 = v103;
      *(_QWORD *)(v77 + 40) = v83;
      *(_QWORD *)(v77 + 48) = v85;
      v100 = v83;
      v101 = v82;
      v86 = (_QWORD *)sub_4C080(v77, &qword_C0C30, sub_D160);
      v55 = v101;
      v38 = v100;
      if ( !v86 || *v86 != v77 )
      {
        sub_21B70(v77);
        v55 = v101;
        v38 = v100;
      }
    }
  }
  __writefsdword(0xFFFFFFC0, v91);
  if ( v97 )
  {
    v66 = *((_QWORD *)v55 + 2);
    v101 = v38;
    v67 = v103;
    v68 = sub_CF70(*(_DWORD **)(v66 + 184), v95);
    v38 = v101;
    v69 = v68;
    if ( v68 < *(_QWORD *)(v66 + 192) )
    {
      v70 = v101;
      v71 = &v101[v67];
      v72 = v101;
      while ( 1 )
      {
        v65 = v69-- == 0;
        if ( v65 )
          break;
        v70 = (char *)(sub_9060(v70, 0LL) + 1);
        if ( v70 >= v71 )
          return (__int64)v72;
      }
      v38 = v70;
    }
  }
  return (__int64)v38;
}
// E013: variable 'v24' is possibly undefined
// E013: variable 'v25' is possibly undefined
// E03C: variable 'v31' is possibly undefined
// E12D: variable 'v41' is possibly undefined
// E12D: variable 'v42' is possibly undefined
// E158: variable 'v45' is possibly undefined
// E158: variable 'v46' is possibly undefined
// E2A0: variable 'v34' is possibly undefined
// 9030: using guessed type __int64 __fastcall sub_9030(_QWORD, _QWORD);
// 9060: using guessed type __int64 __fastcall sub_9060(_QWORD, _QWORD);
// 9090: using guessed type __int64 __fastcall sub_9090(_QWORD);
// 90F0: using guessed type __int64 __fastcall sub_90F0(_QWORD);
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// 9210: using guessed type __int64 __fastcall sub_9210(_QWORD, _QWORD);
// 9238: using guessed type __int64 __fastcall sub_9238(_QWORD);
// 9240: using guessed type __int64 __fastcall sub_9240(_QWORD);
// 130A0: using guessed type __int64 __fastcall sub_130A0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// 8FB58: using guessed type void *off_8FB58;
// BD7E0: using guessed type int dword_BD7E0;
// BE040: using guessed type char *off_BE040;
// C0BF8: using guessed type __int64 qword_C0BF8;
// C0C30: using guessed type __int64 qword_C0C30;
// C0CC0: using guessed type int dword_C0CC0;

//----- (000000000000E670) ----------------------------------------------------
_QWORD *__fastcall sub_E670(char *a1, __int64 a2, void *a3, __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  unsigned __int8 *v13; // r12
  __int64 v15; // rax
  __int64 v16; // rdx
  __int64 v17; // rcx
  u32 *v18; // r8
  u32 v19; // er9
  _QWORD *v20; // r14
  double v21; // xmm4_8
  double v22; // xmm5_8
  __int64 v24; // rdi
  _QWORD *v25; // rbx
  __int64 v26; // rcx
  u32 *v27; // rax
  size_t v28; // r15
  unsigned __int8 *v29; // rax
  int v30; // er15
  __int64 v31; // rax
  __int64 v32; // rcx
  u32 *v33; // r8
  u32 v34; // er9
  double v35; // xmm4_8
  double v36; // xmm5_8
  __int64 v37; // rdx
  __int64 v38; // rdi
  _QWORD *v39; // rbx
  u32 *v40; // [rsp+8h] [rbp-70h]
  unsigned __int8 *v41; // [rsp+10h] [rbp-68h] BYREF
  __int64 v42; // [rsp+18h] [rbp-60h] BYREF
  unsigned __int8 *v43; // [rsp+20h] [rbp-58h] BYREF
  __int64 v44; // [rsp+28h] [rbp-50h] BYREF
  __int64 v45[9]; // [rsp+30h] [rbp-48h] BYREF

  v13 = (unsigned __int8 *)a2;
  v45[1] = __readfsqword(0x28u);
  v15 = strlen((__int64)a1);
  v20 = sub_10650(&qword_C0CB8, a1, v15 + 1, 0, a2, 0LL, 0LL, 0LL, 0LL, a3, 0);
  if ( v20 )
  {
    if ( *((int *)v20 + 2) <= 0 )
      sub_E910((__int64)v20, a4, a5, a6, a7, a8, v21, v22, a11, a12, v16, v17, v18, v19);
    if ( !v20[2] )
    {
      v24 = v20[4];
      if ( v24 )
      {
        v25 = v20 + 4;
        do
        {
          v26 = *(unsigned int *)(v24 + 8);
          if ( (int)v26 <= 0 )
            sub_E910(v24, a4, a5, a6, a7, a8, v21, v22, a11, a12, v16, v26, v18, v19);
          if ( *(_QWORD *)(*v25 + 16LL) )
            break;
          v24 = v25[1];
          ++v25;
        }
        while ( v24 );
      }
    }
  }
  else
  {
    v27 = sub_10460(a2, (__int64)a1, a5, a6, a7, a8, v21, v22, a11, a12, v16, v17, v18, v19);
    v40 = v27;
    if ( v27 )
    {
      v28 = strlen((__int64)v27) + 1;
      v29 = (unsigned __int8 *)sub_21500(v28);
      v13 = v29;
      if ( !v29 )
        return v20;
      memcpy(v29, v40, v28);
    }
    v30 = sub_10C80(v13, &v41, &v42, &v43, &v44, v45);
    if ( v30 != -1 )
    {
      v31 = strlen((__int64)a1);
      v20 = sub_10650(&qword_C0CB8, a1, v31 + 1, v30, (__int64)v41, (__int64)v43, v44, v45[0], v42, a3, 1);
      if ( v20 )
      {
        v37 = *((unsigned int *)v20 + 2);
        if ( (int)v37 <= 0 )
          sub_E910((__int64)v20, a4, a5, a6, a7, a8, v35, v36, a11, a12, v37, v32, v33, v34);
        if ( !v20[2] )
        {
          v38 = v20[4];
          if ( v38 )
          {
            v39 = v20 + 4;
            do
            {
              if ( *(int *)(v38 + 8) <= 0 )
                sub_E910(v38, a4, a5, a6, a7, a8, v35, v36, a11, a12, v37, v32, v33, v34);
              if ( *(_QWORD *)(*v39 + 16LL) )
                break;
              v38 = v39[1];
              ++v39;
            }
            while ( v38 );
          }
        }
        if ( v40 )
          sub_21B70(v13);
      }
      if ( (v30 & 1) != 0 )
        sub_21B70(v45[0]);
    }
  }
  return v20;
}
// E786: variable 'v21' is possibly undefined
// E786: variable 'v22' is possibly undefined
// E786: variable 'v16' is possibly undefined
// E786: variable 'v17' is possibly undefined
// E786: variable 'v18' is possibly undefined
// E786: variable 'v19' is possibly undefined
// E8F6: variable 'v35' is possibly undefined
// E8F6: variable 'v36' is possibly undefined
// E8F6: variable 'v32' is possibly undefined
// E8F6: variable 'v33' is possibly undefined
// E8F6: variable 'v34' is possibly undefined
// E8E1: variable 'v37' is possibly undefined
// 9090: using guessed type __int64 __fastcall sub_9090(_QWORD);
// 9238: using guessed type __int64 __fastcall sub_9238(_QWORD);
// 9240: using guessed type __int64 __fastcall sub_9240(_QWORD);
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// C0CB8: using guessed type __int64 qword_C0CB8;

//----- (000000000000E910) ----------------------------------------------------
unsigned __int64 __fastcall sub_E910(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, __int64 a14)
{
  __int64 v14; // rbx
  unsigned __int64 v15; // rbp
  int v17; // eax
  const char *v18; // rdi
  unsigned int v19; // eax
  unsigned int v20; // ebp
  u32 *v21; // r15
  __int64 v22; // rsi
  __int64 v23; // rdx
  __int64 v24; // rcx
  u32 *v25; // r8
  u32 v26; // er9
  int *v27; // r14
  double v28; // xmm4_8
  double v29; // xmm5_8
  __int64 v30; // rdx
  __int64 v31; // rcx
  u32 *v32; // r8
  u32 v33; // er9
  double v34; // xmm4_8
  double v35; // xmm5_8
  int v36; // er13
  _BOOL8 v37; // r12
  __int64 v38; // rax
  double v39; // xmm4_8
  double v40; // xmm5_8
  __int64 v41; // rbp
  __int64 v42; // rdx
  unsigned int v43; // eax
  unsigned __int32 v44; // ecx
  unsigned int v45; // er10
  unsigned int v46; // ecx
  __int64 v47; // rcx
  __int64 v48; // r12
  __int64 v49; // rsi
  char *v50; // r12
  int v51; // edi
  __int64 v52; // r9
  double v53; // xmm4_8
  double v54; // xmm5_8
  __int64 v55; // rdx
  u32 *v56; // r8
  unsigned int v57; // er10
  char *v58; // rcx
  __int64 v59; // rcx
  _BYTE *v60; // rax
  int v61; // er10
  int v62; // edi
  int v63; // er10
  char v64; // cl
  signed __int64 v66; // rax
  __int64 v67; // rcx
  __int64 v68; // rdi
  double v69; // xmm4_8
  double v70; // xmm5_8
  __int64 v71; // r13
  int v72; // eax
  __int64 v73; // rcx
  __int64 v74; // rax
  char *v75; // r13
  size_t v76; // r12
  signed __int64 v77; // rax
  __int64 v78; // rdx
  __int64 v79; // rax
  __int64 v80; // rcx
  __int64 v81; // r15
  __int64 v82; // rbp
  __int64 i; // rbx
  unsigned int v84; // edx
  __int64 v85; // rdx
  bool v86; // al
  __int64 v87; // r12
  __int64 v88; // r9
  __int64 v89; // rdx
  unsigned int *j; // rbx
  __int64 v91; // rdi
  unsigned int v92; // eax
  __int64 v93; // r14
  unsigned __int8 v94; // cl
  bool v95; // zf
  unsigned __int8 v96; // cl
  __int64 v97; // rax
  __int64 v98; // rax
  char *v99; // r12
  int *v100; // r15
  __int64 v101; // r14
  __int64 v102; // rbp
  int v103; // ecx
  int v104; // esi
  char *v105; // rdx
  unsigned int v106; // eax
  char *v107; // rbp
  __int64 v108; // rax
  unsigned __int32 v109; // ecx
  unsigned int *v110; // rcx
  char *v111; // rbx
  __int64 v112; // rax
  char *v113; // r15
  unsigned int *v114; // rbp
  const void *v115; // r13
  __int64 v116; // r12
  unsigned int v117; // eax
  unsigned int v118; // er12
  const void *v119; // rsi
  void *v120; // rdi
  char *k; // rdx
  unsigned __int32 v122; // edi
  __int64 v123; // r9
  int *v124; // r14
  __int64 v125; // rsi
  unsigned int v126; // eax
  unsigned int v127; // ecx
  int v128; // er13
  unsigned __int8 **v129; // r14
  unsigned int v130; // eax
  unsigned int v131; // edi
  unsigned int v132; // ecx
  unsigned int v133; // edx
  int *v134; // rax
  unsigned int l; // edx
  unsigned int v136; // eax
  int v137; // edx
  unsigned __int32 v139; // [rsp+8h] [rbp-180h]
  __int64 v140; // [rsp+8h] [rbp-180h]
  unsigned int v141; // [rsp+10h] [rbp-178h]
  int *v142; // [rsp+10h] [rbp-178h]
  unsigned int v143; // [rsp+18h] [rbp-170h]
  int *v144; // [rsp+18h] [rbp-170h]
  __int64 v145; // [rsp+18h] [rbp-170h]
  int v146; // [rsp+18h] [rbp-170h]
  __int64 v147; // [rsp+18h] [rbp-170h]
  unsigned int v148; // [rsp+20h] [rbp-168h]
  char v149; // [rsp+20h] [rbp-168h]
  char *v150; // [rsp+20h] [rbp-168h]
  char v151; // [rsp+28h] [rbp-160h]
  char *v152; // [rsp+28h] [rbp-160h]
  int v153; // [rsp+30h] [rbp-158h]
  unsigned int v154; // [rsp+34h] [rbp-154h]
  __int64 v155; // [rsp+38h] [rbp-150h]
  __int64 v156; // [rsp+38h] [rbp-150h]
  __int64 v157; // [rsp+40h] [rbp-148h]
  unsigned int v158; // [rsp+40h] [rbp-148h]
  u32 *v159; // [rsp+48h] [rbp-140h]
  _QWORD *v160; // [rsp+48h] [rbp-140h]
  __int64 v161; // [rsp+50h] [rbp-138h]
  __int64 v162; // [rsp+50h] [rbp-138h]
  __int64 v163; // [rsp+58h] [rbp-130h]
  _QWORD *v164; // [rsp+58h] [rbp-130h]
  __int64 v165; // [rsp+60h] [rbp-128h]
  _QWORD *v166; // [rsp+60h] [rbp-128h]
  __int64 v167; // [rsp+68h] [rbp-120h]
  u32 *v168; // [rsp+70h] [rbp-118h]
  __int64 v169; // [rsp+78h] [rbp-110h]
  __int64 v170; // [rsp+80h] [rbp-108h]
  int *v171; // [rsp+88h] [rbp-100h]
  char v172[8]; // [rsp+98h] [rbp-F0h] BYREF
  __int64 v173[2]; // [rsp+A0h] [rbp-E8h]
  struct stat v174; // [rsp+B0h] [rbp-D8h] BYREF
  unsigned __int64 v175; // [rsp+148h] [rbp-40h]

  v14 = a1;
  v15 = __readfsqword(0x10u);
  v175 = __readfsqword(0x28u);
  if ( qword_C0CD8 != v15 )
  {
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C0CD0, 1, 0) )
        sub_1C7D0((volatile __int32 *)&dword_C0CD0, a2, 1LL, a12, a13, a14);
    }
    else
    {
      _EDX = 1;
      __asm { cmpxchg cs:dword_C0CD0, edx }
    }
    qword_C0CD8 = v15;
  }
  v17 = dword_C0CD4++;
  if ( *(_DWORD *)(a1 + 8) )
    goto LABEL_54;
  v18 = *(const char **)a1;
  *(_DWORD *)(v14 + 8) = -1;
  *(_QWORD *)(v14 + 16) = 0LL;
  if ( !v18 )
    goto LABEL_53;
  v19 = sub_4B910(v18, 0, 0);
  v20 = v19;
  if ( v19 == -1 )
  {
LABEL_52:
    v17 = dword_C0CD4 - 1;
    goto LABEL_53;
  }
  v153 = sub_4AA80(1u, v19, &v174);
  if ( v153 )
    goto LABEL_51;
  v21 = (u32 *)v174.st_size;
  if ( v174.st_size <= 0x2FuLL )
    goto LABEL_51;
  v22 = v174.st_size;
  v27 = (int *)mmap(0LL, v174.st_size, 1uLL, 2u, v20, 0LL);
  if ( v27 != (int *)-1LL )
  {
    sub_4B7A0(v20);
    v36 = *v27;
    LOBYTE(v37) = *v27 != -1794895138;
    if ( *v27 != -569244523 && v36 != -1794895138 )
    {
      munmap(v27, (size_t)v21);
      v17 = dword_C0CD4 - 1;
      goto LABEL_53;
    }
    v153 = 1;
    goto LABEL_14;
  }
  v74 = sub_21500(v21, v22, v23, v24, v25, v26, a3, a4, a5, a6, v28, v29, a9, a10);
  v27 = (int *)v74;
  if ( !v74 )
  {
LABEL_51:
    sub_4B7A0(v20);
    goto LABEL_52;
  }
  v75 = (char *)v74;
  v76 = (size_t)v21;
  do
  {
    while ( 1 )
    {
      v22 = (__int64)v75;
      v77 = sub_4BA60(v20, v75, v76);
      if ( v77 > 0 )
        break;
      if ( v77 != -1 || __readfsdword(0xFFFFFFC0) != 4 )
        goto LABEL_51;
    }
    v75 += v77;
    v76 -= v77;
  }
  while ( v76 );
  sub_4B7A0(v20);
  v36 = *v27;
  v37 = *v27 != -1794895138;
  if ( *v27 != -569244523 && v36 != -1794895138 )
  {
    sub_21B70(v27);
    v17 = dword_C0CD4 - 1;
    goto LABEL_53;
  }
LABEL_14:
  v38 = sub_21500((u32 *)&qword_C8, v22, v30, v31, v32, v33, a3, a4, a5, a6, v34, v35, a9, a10);
  v41 = v38;
  if ( !v38 )
    goto LABEL_52;
  *(_QWORD *)v38 = v27;
  v42 = v37;
  *(_QWORD *)(v14 + 16) = v38;
  *(_QWORD *)(v38 + 16) = v21;
  *(_DWORD *)(v38 + 8) = v153;
  v43 = v27[1];
  *(_DWORD *)(v41 + 24) = v37;
  *(_QWORD *)(v41 + 32) = 0LL;
  if ( v36 != -1794895138 )
  {
    v43 = _byteswap_ulong(v43);
    if ( v43 > 0x1FFFF )
    {
LABEL_66:
      v71 = 0LL;
      goto LABEL_67;
    }
    v43 = (unsigned __int16)v43;
    *(_DWORD *)(v41 + 40) = _byteswap_ulong(v27[2]);
    *(_QWORD *)(v41 + 48) = (char *)v27 + _byteswap_ulong(v27[3]);
    *(_QWORD *)(v41 + 56) = (char *)v27 + _byteswap_ulong(v27[4]);
    v44 = _byteswap_ulong(v27[5]);
    *(_DWORD *)(v41 + 88) = v44;
    v45 = v44;
    if ( v44 > 2 )
    {
      v46 = v27[6];
      *(_DWORD *)(v41 + 104) = v37;
      v47 = (__int64)v27 + _byteswap_ulong(v46);
      *(_QWORD *)(v41 + 96) = v47;
      if ( (_WORD)v43 )
      {
        v141 = _byteswap_ulong(v27[9]);
        if ( v141 )
        {
          v139 = _byteswap_ulong(v27[7]);
          v48 = _byteswap_ulong(v27[8]);
          goto LABEL_21;
        }
      }
LABEL_63:
      *(_DWORD *)(v41 + 64) = 0;
      *(_QWORD *)(v41 + 72) = 0LL;
      *(_QWORD *)(v41 + 80) = 0LL;
      goto LABEL_64;
    }
LABEL_62:
    *(_QWORD *)(v41 + 96) = 0LL;
    *(_DWORD *)(v41 + 104) = v37;
    if ( v43 )
      goto LABEL_66;
    goto LABEL_63;
  }
  if ( v43 > 0x1FFFF )
    goto LABEL_66;
  v45 = v27[5];
  v43 = (unsigned __int16)v43;
  *(_DWORD *)(v41 + 40) = v27[2];
  *(_QWORD *)(v41 + 48) = (char *)v27 + (unsigned int)v27[3];
  v67 = (unsigned int)v27[4];
  *(_DWORD *)(v41 + 88) = v45;
  *(_QWORD *)(v41 + 56) = (char *)v27 + v67;
  if ( v45 <= 2 )
    goto LABEL_62;
  v73 = (unsigned int)v27[6];
  *(_DWORD *)(v41 + 104) = v37;
  v47 = (__int64)v27 + v73;
  *(_QWORD *)(v41 + 96) = v47;
  if ( !(_WORD)v43 )
    goto LABEL_63;
  v141 = v27[9];
  if ( !v141 )
    goto LABEL_63;
  v48 = (unsigned int)v27[8];
  v139 = v27[7];
LABEL_21:
  v49 = 8LL;
  v148 = v45;
  v50 = (char *)v27 + v48;
  v51 = v139;
  v52 = sub_22260(v139, 8uLL, a3, a4, a5, a6, v39, v40, a9, a10, v42, v47, (u32 *)v139, a14);
  if ( !v52 )
    goto LABEL_66;
  v55 = 0LL;
  v56 = (u32 *)v139;
  v57 = v148;
  if ( v139 )
  {
    v143 = v148;
    do
    {
      v49 = *(unsigned int *)&v50[8 * v55];
      v59 = *(unsigned int *)&v50[8 * v55 + 4];
      v60 = (char *)v27 + v59;
      if ( v36 != -1794895138 )
      {
        v49 = _byteswap_ulong(v49);
        v60 = (char *)v27 + _byteswap_ulong(v59);
      }
      if ( !(_DWORD)v49 || v60[(unsigned int)(v49 - 1)] )
        goto LABEL_84;
      if ( *v60 == 80 )
      {
        v58 = 0LL;
        if ( v60[1] == 82 && v60[2] == 73 )
        {
          v49 = (unsigned __int8)v60[3];
          LOBYTE(v57) = (_BYTE)v49 == 100;
          LOBYTE(v51) = (_BYTE)v49 == 105;
          v61 = v51 | v57;
          LOBYTE(v51) = (_BYTE)v49 == 111;
          v149 = v61;
          v62 = v61 | v51;
          v63 = v62;
          v151 = v62;
          LOBYTE(v62) = (_BYTE)v49 == 117;
          v51 = v63 | v62;
          v57 = v49 & 0xFFFFFFDF;
          if ( (v49 & 0xDF) == 88 || (_BYTE)v51 )
          {
            v64 = v60[4];
            switch ( v64 )
            {
              case '8':
                if ( v60[5] )
                {
                  v58 = 0LL;
                }
                else if ( (_BYTE)v49 == 100 )
                {
                  v58 = "d";
                }
                else if ( v149 )
                {
                  v58 = "i";
                }
                else if ( v151 )
                {
                  v58 = (char *)"o";
                }
                else if ( (_BYTE)v51 )
                {
                  v58 = (char *)&unk_A6D62;
                }
                else if ( (_BYTE)v49 == 120 )
                {
                  v58 = (char *)"x";
                }
                else
                {
                  if ( (_BYTE)v49 != 88 )
                    goto LABEL_384;
                  v58 = "X";
                }
                break;
              case '1':
                v58 = 0LL;
                if ( v60[5] == 54 && !v60[6] )
                {
                  if ( (_BYTE)v49 == 100 )
                  {
                    v58 = "d";
                  }
                  else if ( v149 )
                  {
                    v58 = "i";
                  }
                  else if ( v151 )
                  {
                    v58 = (char *)"o";
                  }
                  else if ( (_BYTE)v51 )
                  {
                    v58 = (char *)&unk_A6D62;
                  }
                  else if ( (_BYTE)v49 == 120 )
                  {
                    v58 = (char *)"x";
                  }
                  else
                  {
                    if ( (_BYTE)v49 != 88 )
                      goto LABEL_384;
                    v58 = "X";
                  }
                }
                break;
              case '3':
                v58 = 0LL;
                if ( v60[5] == 50 && !v60[6] )
                {
                  if ( (_BYTE)v49 == 100 )
                  {
                    v58 = "d";
                  }
                  else if ( v149 )
                  {
                    v58 = "i";
                  }
                  else if ( v151 )
                  {
                    v58 = (char *)"o";
                  }
                  else if ( (_BYTE)v51 )
                  {
                    v58 = (char *)&unk_A6D62;
                  }
                  else if ( (_BYTE)v49 == 120 )
                  {
                    v58 = (char *)"x";
                  }
                  else
                  {
                    if ( (_BYTE)v49 != 88 )
                      goto LABEL_384;
                    v58 = "X";
                  }
                }
                break;
              case '6':
                v58 = 0LL;
                if ( v60[5] == 52 && !v60[6] )
                {
                  if ( (_BYTE)v49 == 100 )
                  {
                    v58 = "ld";
                  }
                  else if ( v149 )
                  {
                    v58 = "li";
                  }
                  else if ( v151 )
                  {
                    v58 = "lo";
                  }
                  else if ( (_BYTE)v51 )
                  {
                    v58 = "lu";
                  }
                  else if ( (_BYTE)v49 == 120 )
                  {
                    v58 = "lx";
                  }
                  else
                  {
                    if ( (_BYTE)v49 != 88 )
                      goto LABEL_384;
                    v58 = "lX";
                  }
                }
                break;
              case 'L':
                v58 = 0LL;
                if ( v60[5] == 69 && v60[6] == 65 && v60[7] == 83 && v60[8] == 84 )
                {
                  v94 = v60[9];
                  v57 = v94;
                  if ( v94 == 56 )
                  {
                    if ( v60[10] )
                    {
                      v58 = 0LL;
                    }
                    else if ( (_BYTE)v49 == 100 )
                    {
                      v58 = "d";
                    }
                    else if ( v149 )
                    {
                      v58 = "i";
                    }
                    else if ( v151 )
                    {
                      v58 = (char *)"o";
                    }
                    else if ( (_BYTE)v51 )
                    {
                      v58 = (char *)&unk_A6D62;
                    }
                    else if ( (_BYTE)v49 == 120 )
                    {
                      v58 = (char *)"x";
                    }
                    else
                    {
                      if ( (_BYTE)v49 != 88 )
                        goto LABEL_384;
                      v58 = "X";
                    }
                  }
                  else if ( v94 == 49 )
                  {
                    v58 = 0LL;
                    if ( v60[10] == 54 && !v60[11] )
                    {
                      if ( (_BYTE)v49 == 100 )
                      {
                        v58 = "d";
                      }
                      else if ( v149 )
                      {
                        v58 = "i";
                      }
                      else if ( v151 )
                      {
                        v58 = (char *)"o";
                      }
                      else if ( (_BYTE)v51 )
                      {
                        v58 = (char *)&unk_A6D62;
                      }
                      else if ( (_BYTE)v49 == 120 )
                      {
                        v58 = (char *)"x";
                      }
                      else
                      {
                        if ( (_BYTE)v49 != 88 )
                          goto LABEL_384;
                        v58 = "X";
                      }
                    }
                  }
                  else
                  {
                    v95 = v94 == 51;
                    v58 = 0LL;
                    if ( v95 )
                    {
                      if ( v60[10] == 50 && !v60[11] )
                      {
                        if ( (_BYTE)v49 == 100 )
                        {
                          v58 = "d";
                        }
                        else if ( v149 )
                        {
                          v58 = "i";
                        }
                        else if ( v151 )
                        {
                          v58 = (char *)"o";
                        }
                        else if ( (_BYTE)v51 )
                        {
                          v58 = (char *)&unk_A6D62;
                        }
                        else if ( (_BYTE)v49 == 120 )
                        {
                          v58 = (char *)"x";
                        }
                        else
                        {
                          if ( (_BYTE)v49 != 88 )
                            goto LABEL_384;
                          v58 = "X";
                        }
                      }
                    }
                    else if ( (_BYTE)v57 == 54 && v60[10] == 52 && !v60[11] )
                    {
                      if ( (_BYTE)v49 == 100 )
                      {
                        v58 = "ld";
                      }
                      else if ( v149 )
                      {
                        v58 = "li";
                      }
                      else if ( v151 )
                      {
                        v58 = "lo";
                      }
                      else if ( (_BYTE)v51 )
                      {
                        v58 = "lu";
                      }
                      else if ( (_BYTE)v49 == 120 )
                      {
                        v58 = "lx";
                      }
                      else
                      {
                        if ( (_BYTE)v49 != 88 )
                          goto LABEL_384;
                        v58 = "lX";
                      }
                    }
                  }
                }
                break;
              case 'F':
                v58 = 0LL;
                if ( v60[5] == 65 && v60[6] == 83 && v60[7] == 84 )
                {
                  v96 = v60[8];
                  v57 = v96;
                  if ( v96 == 56 )
                  {
                    if ( v60[9] )
                    {
                      v58 = 0LL;
                    }
                    else if ( (_BYTE)v49 == 100 )
                    {
                      v58 = "d";
                    }
                    else if ( v149 )
                    {
                      v58 = "i";
                    }
                    else if ( v151 )
                    {
                      v58 = (char *)"o";
                    }
                    else if ( (_BYTE)v51 )
                    {
                      v58 = (char *)&unk_A6D62;
                    }
                    else if ( (_BYTE)v49 == 120 )
                    {
                      v58 = (char *)"x";
                    }
                    else
                    {
                      if ( (_BYTE)v49 != 88 )
                        goto LABEL_384;
                      v58 = "X";
                    }
                  }
                  else if ( v96 == 49 )
                  {
                    v58 = 0LL;
                    if ( v60[9] == 54 && !v60[10] )
                    {
                      if ( (_BYTE)v49 == 100 )
                      {
                        v58 = "ld";
                      }
                      else if ( v149 )
                      {
                        v58 = "li";
                      }
                      else if ( v151 )
                      {
                        v58 = "lo";
                      }
                      else if ( (_BYTE)v51 )
                      {
                        v58 = "lu";
                      }
                      else if ( (_BYTE)v49 == 120 )
                      {
                        v58 = "lx";
                      }
                      else
                      {
                        if ( (_BYTE)v49 != 88 )
                          goto LABEL_384;
                        v58 = "lX";
                      }
                    }
                  }
                  else
                  {
                    v95 = v96 == 51;
                    v58 = 0LL;
                    if ( v95 )
                    {
                      if ( v60[9] == 50 && !v60[10] )
                      {
                        if ( (_BYTE)v49 == 100 )
                        {
                          v58 = "ld";
                        }
                        else if ( v149 )
                        {
                          v58 = "li";
                        }
                        else if ( v151 )
                        {
                          v58 = "lo";
                        }
                        else if ( (_BYTE)v51 )
                        {
                          v58 = "lu";
                        }
                        else if ( (_BYTE)v49 == 120 )
                        {
                          v58 = "lx";
                        }
                        else
                        {
                          if ( (_BYTE)v49 != 88 )
                            goto LABEL_384;
                          v58 = "lX";
                        }
                      }
                    }
                    else if ( (_BYTE)v57 == 54 && v60[9] == 52 && !v60[10] )
                    {
                      if ( (_BYTE)v49 == 100 )
                      {
                        v58 = "ld";
                      }
                      else if ( v149 )
                      {
                        v58 = "li";
                      }
                      else if ( v151 )
                      {
                        v58 = "lo";
                      }
                      else if ( (_BYTE)v51 )
                      {
                        v58 = "lu";
                      }
                      else if ( (_BYTE)v49 == 120 )
                      {
                        v58 = "lx";
                      }
                      else
                      {
                        if ( (_BYTE)v49 != 88 )
                          goto LABEL_384;
                        v58 = "lX";
                      }
                    }
                  }
                }
                break;
              case 'M':
                v58 = 0LL;
                if ( v60[5] == 65 && v60[6] == 88 )
                {
                  if ( v60[7] )
                  {
                    v58 = 0LL;
                  }
                  else if ( (_BYTE)v49 == 100 )
                  {
                    v58 = "ld";
                  }
                  else if ( v149 )
                  {
                    v58 = "li";
                  }
                  else if ( v151 )
                  {
                    v58 = "lo";
                  }
                  else if ( (_BYTE)v51 )
                  {
                    v58 = "lu";
                  }
                  else if ( (_BYTE)v49 == 120 )
                  {
                    v58 = "lx";
                  }
                  else
                  {
                    if ( (_BYTE)v49 != 88 )
                      goto LABEL_384;
                    v58 = "lX";
                  }
                }
                break;
              default:
                v95 = v64 == 80;
                v58 = 0LL;
                if ( v95 && v60[5] == 84 && v60[6] == 82 )
                {
                  if ( v60[7] )
                  {
                    v58 = 0LL;
                  }
                  else if ( (_BYTE)v49 == 100 )
                  {
                    v58 = "ld";
                  }
                  else if ( v149 )
                  {
                    v58 = "li";
                  }
                  else if ( v151 )
                  {
                    v58 = "lo";
                  }
                  else if ( (_BYTE)v51 )
                  {
                    v58 = "lu";
                  }
                  else if ( (_BYTE)v49 == 120 )
                  {
                    v58 = "lx";
                  }
                  else
                  {
                    if ( (_BYTE)v49 != 88 )
                      goto LABEL_384;
                    v58 = "lX";
                  }
                }
                break;
            }
          }
        }
      }
      else if ( *v60 == 73 )
      {
        v58 = 0LL;
        if ( !v60[1] )
          v58 = "I";
      }
      else
      {
        v58 = 0LL;
      }
      *(_QWORD *)(v52 + 8 * v55++) = v58;
    }
    while ( v139 != v55 );
    v57 = v143;
  }
  v78 = (unsigned int)v27[10];
  v79 = (unsigned int)v27[11];
  if ( v36 == -1794895138 )
  {
    v80 = (__int64)v27 + v78;
    v152 = (char *)v27 + v78;
  }
  else
  {
    v79 = _byteswap_ulong(v79);
    v80 = (__int64)v27 + _byteswap_ulong(v78);
    v152 = (char *)v80;
  }
  v154 = 0;
  v150 = (char *)v27 + v79;
  v144 = v27;
  v163 = v14;
  v165 = 4LL * v57;
  v155 = v165;
  v159 = v21;
  v81 = v52;
  v161 = v41;
  v82 = 0LL;
  do
  {
    for ( i = 0LL; ; i = 1LL )
    {
      if ( v36 == -1794895138 )
      {
        if ( i )
          v89 = *(unsigned int *)&v150[4 * v82];
        else
          v89 = *(unsigned int *)&v152[4 * v82];
        v85 = (__int64)v144 + v89;
        v86 = *(_DWORD *)(v85 + 8) != -1;
      }
      else
      {
        if ( i )
          v84 = *(_DWORD *)&v150[4 * v82];
        else
          v84 = *(_DWORD *)&v152[4 * v82];
        v85 = (__int64)v144 + _byteswap_ulong(v84);
        v86 = *(_DWORD *)(v85 + 8) != -1;
      }
      v87 = 0LL;
      if ( v86 )
      {
        v157 = i;
        v49 = 0LL;
        for ( j = (unsigned int *)(v85 + 4); ; j += 2 )
        {
          v92 = j[1];
          v85 = *j;
          v93 = v49 + v85;
          if ( v36 != -1794895138 )
          {
            v85 = _byteswap_ulong(v85);
            v92 = _byteswap_ulong(v92);
            v93 = (unsigned int)v85 + v49;
          }
          if ( v92 == -1 )
            break;
          if ( v92 >= v139 )
          {
            v52 = v81;
            v27 = v144;
            v41 = v161;
            v21 = v159;
            v14 = v163;
LABEL_84:
            v71 = 0LL;
            sub_21B70(v52);
            goto LABEL_67;
          }
          v91 = *(_QWORD *)(v81 + 8LL * v92);
          if ( !v91 )
            goto LABEL_100;
          v49 = strlen(v91) + v93;
        }
        i = v157;
        v87 = v93;
      }
      v173[i] = v87;
      if ( i == 1 )
        break;
    }
    ++v154;
    v155 += v173[0] + v173[1];
LABEL_100:
    ++v82;
  }
  while ( v141 > (unsigned int)v82 );
  v88 = v81;
  v27 = v144;
  v41 = v161;
  v21 = v159;
  v14 = v163;
  if ( !v154 )
  {
    *(_DWORD *)(v161 + 64) = 0;
    *(_QWORD *)(v161 + 72) = 0LL;
    *(_QWORD *)(v161 + 80) = 0LL;
    goto LABEL_103;
  }
  v145 = v88;
  v97 = sub_21500((u32 *)(v155 + 32LL * v154), v49, v85, v80, v56, v88, a3, a4, a5, a6, v53, v54, a9, a10);
  v71 = v97;
  if ( !v97 )
    goto LABEL_67;
  *(_QWORD *)(v161 + 32) = v97;
  v98 = 16LL * v154;
  v158 = 0;
  v167 = v71;
  v162 = v71 + v98;
  v169 = v71 + v98 + v98;
  v99 = (char *)(v169 + v165);
  v170 = v163;
  v168 = v159;
  v100 = v27;
  v101 = v145;
  v140 = v41;
  v102 = 0LL;
  do
  {
    v103 = 0;
    v104 = *(_DWORD *)(v140 + 24);
    while ( v104 )
    {
      if ( v103 )
      {
        v105 = (char *)v100 + _byteswap_ulong(*(_DWORD *)&v150[4 * v102]);
        v106 = *((_DWORD *)v105 + 2);
        if ( v106 == -1 )
          goto LABEL_208;
        goto LABEL_228;
      }
      v105 = (char *)v100 + _byteswap_ulong(*(_DWORD *)&v152[4 * v102]);
      v106 = *((_DWORD *)v105 + 2);
      if ( v106 != -1 )
        goto LABEL_228;
LABEL_249:
      v103 = 1;
    }
    if ( !v103 )
    {
      v105 = (char *)v100 + *(unsigned int *)&v152[4 * v102];
      v106 = *((_DWORD *)v105 + 2);
      if ( v106 != -1 )
        goto LABEL_228;
      v103 = 1;
    }
    v105 = (char *)v100 + *(unsigned int *)&v150[4 * v102];
    v106 = *((_DWORD *)v105 + 2);
    if ( v106 == -1 )
      goto LABEL_208;
LABEL_228:
    for ( k = v105 + 4; ; k += 8 )
    {
      v122 = _byteswap_ulong(v106);
      if ( v104 )
        v106 = v122;
      if ( v106 == -1 )
        break;
      if ( !*(_QWORD *)(v101 + 8LL * v106) )
        goto LABEL_234;
      v106 = *((_DWORD *)k + 3);
    }
LABEL_208:
    if ( v103 != 1 )
      goto LABEL_249;
    v156 = v102;
    v107 = v99;
    v146 = 0;
    v108 = 16LL * v158;
    v160 = (_QWORD *)(v108 + v162);
    v164 = (_QWORD *)(v167 + v108);
    if ( v104 )
    {
LABEL_210:
      if ( v146 )
      {
        v109 = _byteswap_ulong(*(_DWORD *)&v150[4 * v156]);
        v166 = v160;
      }
      else
      {
        v109 = _byteswap_ulong(*(_DWORD *)&v152[4 * v156]);
        v166 = v164;
      }
      v110 = (unsigned int *)((char *)v100 + v109);
      v111 = (char *)v100 + _byteswap_ulong(*v110);
      v112 = _byteswap_ulong(v110[1]);
      if ( v110[2] != -1 )
        goto LABEL_219;
LABEL_213:
      *v166 = v112;
      v166[1] = v111;
      goto LABEL_214;
    }
    while ( 1 )
    {
      if ( v146 )
      {
        v110 = (unsigned int *)((char *)v100 + *(unsigned int *)&v150[4 * v156]);
        v166 = v160;
      }
      else
      {
        v110 = (unsigned int *)((char *)v100 + *(unsigned int *)&v152[4 * v156]);
        v166 = v164;
      }
      v111 = (char *)v100 + *v110;
      v112 = v110[1];
      if ( v110[2] == -1 )
        goto LABEL_213;
LABEL_219:
      v171 = v100;
      v113 = v107;
      v166[1] = v107;
      v114 = v110 + 1;
      while ( 1 )
      {
        v117 = *v114;
        v118 = v114[1];
        if ( v104 )
        {
          v117 = _byteswap_ulong(v117);
          v118 = _byteswap_ulong(v118);
        }
        if ( v117 )
        {
          v119 = v111;
          v120 = v113;
          v113 += v117;
          v111 += v117;
          memcpy(v120, v119, v117);
        }
        if ( v118 == -1 )
          break;
        v114 += 2;
        v115 = *(const void **)(v101 + 8LL * v118);
        v116 = strlen((__int64)v115);
        memcpy(v113, v115, v116);
        v113 += v116;
        v104 = *(_DWORD *)(v140 + 24);
      }
      v107 = v113;
      v100 = v171;
      *v166 = &v107[-v166[1]];
LABEL_214:
      if ( v146 == 1 )
        break;
      v146 = 1;
      v104 = *(_DWORD *)(v140 + 24);
      if ( v104 )
        goto LABEL_210;
    }
    v99 = v107;
    ++v158;
    v102 = v156;
LABEL_234:
    ++v102;
  }
  while ( v141 > (unsigned int)v102 );
  v123 = v101;
  v124 = v100;
  v41 = v140;
  v21 = v168;
  if ( v154 != v158 )
LABEL_384:
    JUMPOUT(0x927FLL);
  if ( *(_DWORD *)(v140 + 88) )
  {
    v125 = *(_QWORD *)(v140 + 96);
    v126 = 0;
    do
    {
      v127 = *(_DWORD *)(v125 + 4LL * v126);
      if ( *(_DWORD *)(v140 + 104) )
        v127 = _byteswap_ulong(v127);
      *(_DWORD *)(v169 + 4LL * v126++) = v127;
    }
    while ( *(_DWORD *)(v140 + 88) > v126 );
  }
  v147 = v123;
  v128 = 0;
  v142 = v124;
  v129 = (unsigned __int8 **)(v167 + 8);
  do
  {
    v130 = sub_11AA0(*v129);
    v131 = *(_DWORD *)(v140 + 88);
    v132 = v130 % v131;
    v133 = v130 % (v131 - 2);
    v134 = (int *)(v169 + 4LL * (v130 % v131));
    for ( l = v133 + 1; *v134; v134 = (int *)(v169 + 4LL * v136) )
    {
      v136 = v132 + l - v131;
      if ( v131 - l > v132 )
        v136 = v132 + l;
      v132 = v136;
    }
    v129 += 2;
    v137 = v128 + *(_DWORD *)(v140 + 40) + 1;
    ++v128;
    *v134 = v137;
  }
  while ( v154 != v128 );
  *(_QWORD *)(v140 + 96) = v169;
  *(_DWORD *)(v140 + 104) = 0;
  v27 = v142;
  v88 = v147;
  v14 = v170;
  *(_DWORD *)(v140 + 64) = v154;
  *(_QWORD *)(v140 + 72) = v167;
  *(_QWORD *)(v140 + 80) = v162;
LABEL_103:
  sub_21B70(v88);
LABEL_64:
  *(_QWORD *)(v41 + 112) = 0LL;
  *(_QWORD *)(v41 + 120) = 0LL;
  v68 = sub_D1E0(v14, a2, (unsigned __int8 *)&unk_A6E65, 0LL, (u32 *)v172, a14, a3, a4, a5, a6, v39, v40, a9, a10);
  if ( v68 != -1 )
  {
    sub_11980(v68, (_BYTE **)(v41 + 184), (unsigned __int64 *)(v41 + 192), a3, a4, a5, a6, v69, v70, a9, a10);
    v17 = dword_C0CD4 - 1;
    goto LABEL_53;
  }
  v71 = *(_QWORD *)(v41 + 32);
LABEL_67:
  sub_21B70(v71);
  if ( v153 )
    munmap(v27, (size_t)v21);
  else
    sub_21B70(v27);
  sub_21B70(v41);
  v72 = dword_C0CD4;
  *(_QWORD *)(v14 + 16) = 0LL;
  v17 = v72 - 1;
LABEL_53:
  *(_DWORD *)(v14 + 8) = 1;
LABEL_54:
  dword_C0CD4 = v17;
  if ( !v17 )
  {
    qword_C0CD8 = 0LL;
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedExchange((volatile __int32 *)&dword_C0CD0, 0) > 1 )
        v66 = sys_futex(&dword_C0CD0, 129, 1u, 0LL, a13, a14);
    }
    else
    {
      --dword_C0CD0;
    }
  }
  return v175 - __readfsqword(0x28u);
}
// FF44: control flows out of bounds to 927F
// EA4B: variable 'v30' is possibly undefined
// EA4B: variable 'v31' is possibly undefined
// EA4B: variable 'v32' is possibly undefined
// EA4B: variable 'v33' is possibly undefined
// EA4B: variable 'v34' is possibly undefined
// EA4B: variable 'v35' is possibly undefined
// EB34: variable 'v39' is possibly undefined
// EB34: variable 'v40' is possibly undefined
// EB34: variable 'a14' is possibly undefined
// ED64: variable 'a13' is possibly undefined
// EE37: variable 'v69' is possibly undefined
// EE37: variable 'v70' is possibly undefined
// EF13: variable 'v23' is possibly undefined
// EF13: variable 'v24' is possibly undefined
// EF13: variable 'v25' is possibly undefined
// EF13: variable 'v26' is possibly undefined
// EF13: variable 'v28' is possibly undefined
// EF13: variable 'v29' is possibly undefined
// F596: variable 'v80' is possibly undefined
// F596: variable 'v56' is possibly undefined
// F596: variable 'v53' is possibly undefined
// F596: variable 'v54' is possibly undefined
// C8: using guessed type __int64;
// 9230: using guessed type __int64 __fastcall sub_9230(_QWORD, _QWORD);
// 9260: using guessed type __int64 __fastcall sub_9260(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// C0CD4: using guessed type int dword_C0CD4;
// C0CD8: using guessed type __int64 qword_C0CD8;

//----- (000000000000FF90) ----------------------------------------------------
__int64 __fastcall sub_FF90(_QWORD *a1, _QWORD *a2)
{
  return sub_9150(*a1, *a2, off_BDB00);
}
// 9150: using guessed type __int64 __fastcall sub_9150(_QWORD, _QWORD, _QWORD);
// BDB00: using guessed type void **off_BDB00[6];

//----- (000000000000FFB0) ----------------------------------------------------
__int64 __fastcall sub_FFB0(__int64 a1, int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  void *v10; // rsp
  double v11; // xmm4_8
  double v12; // xmm5_8
  int *v13; // rax
  __int64 v14; // rcx
  u32 *v15; // r8
  u32 v16; // er9
  double v17; // xmm4_8
  double v18; // xmm5_8
  int *v19; // r15
  unsigned int v20; // eax
  __int64 v21; // rdx
  __int64 v22; // rsi
  __int64 v23; // rdx
  __int64 v24; // rcx
  u32 *v25; // r8
  __int64 v26; // r9
  char *v27; // r12
  __int64 v28; // rax
  char v29; // al
  unsigned __int8 v31; // al
  _BYTE *v32; // rbx
  __int64 v33; // rdx
  _BYTE *v34; // rdi
  unsigned __int8 v35; // al
  _WORD *v36; // rdx
  __int64 v37; // rax
  u32 *v38; // r8
  u32 v39; // er9
  double v40; // xmm4_8
  double v41; // xmm5_8
  __int64 v42; // rdx
  __int64 v43; // r11
  size_t v44; // r10
  __int64 v45; // r13
  __int64 v46; // rcx
  __int64 v47; // rsi
  __int64 v48; // rax
  __int64 v49; // rsi
  _QWORD *v50; // r13
  void *v51; // rax
  size_t v52; // rdi
  __int64 v53; // r9
  size_t v54; // r10
  void *v55; // rax
  __int64 v56; // rbx
  __int64 v57; // r13
  __int64 v58; // rax
  __int64 v59; // r8
  _QWORD *v60; // rax
  __int64 v61; // r8
  __int64 v62; // rdi
  char v63[8]; // [rsp+0h] [rbp-220h] BYREF
  __int64 v64; // [rsp+8h] [rbp-218h]
  __int64 v65; // [rsp+10h] [rbp-210h]
  size_t v66; // [rsp+18h] [rbp-208h]
  __int64 v67; // [rsp+20h] [rbp-200h]
  __int64 v68; // [rsp+28h] [rbp-1F8h]
  size_t v69; // [rsp+30h] [rbp-1F0h]
  size_t v70; // [rsp+38h] [rbp-1E8h]
  __int64 v71; // [rsp+40h] [rbp-1E0h]
  __int64 v72; // [rsp+48h] [rbp-1D8h]
  char v73[408]; // [rsp+50h] [rbp-1D0h] BYREF
  unsigned __int64 v74; // [rsp+1E8h] [rbp-38h]

  v74 = __readfsqword(0x28u);
  v10 = alloca(a2 + 22LL);
  strcpy((char *)sub_91D0(v63, a1, a2), "/locale.alias");
  v13 = (int *)sub_140F0(v63, "rce", a3, a4, a5, a6, v11, v12, a9, a10);
  if ( !v13 )
    return 0LL;
  v19 = v13;
  v20 = *v13;
  v72 = 0LL;
  v21 = v20;
  BYTE1(v21) = BYTE1(v20) | 0x80;
  *v19 = v21;
  if ( (v20 & 0x10) != 0 )
  {
    sub_137F0(v19, (__int64)"rce", v21, v14, v15, v16);
  }
  else
  {
    do
    {
      v22 = 400LL;
      if ( !sub_17160(v73, 400, v19, a3, a4, a5, a6, v17, v18, a9, a10) )
        break;
      v27 = v73;
      v28 = sub_9210(v73, 10LL);
      v23 = (unsigned __int8)v73[0];
      v24 = v28;
      v22 = __readfsqword(0xFFFFFFF8);
      v29 = v73[0];
      if ( (*(_BYTE *)(v22 + 2LL * (unsigned __int8)v73[0] + 1) & 0x20) != 0 )
      {
        do
        {
          v23 = (unsigned __int8)*++v27;
          v29 = v23;
        }
        while ( (*(_BYTE *)(v22 + 2 * v23 + 1) & 0x20) != 0 );
      }
      if ( v29 && v29 != 35 )
      {
        v31 = v27[1];
        v32 = v27 + 1;
        if ( v31 )
        {
          while ( 1 )
          {
            v33 = v31;
            v34 = v32;
            v31 = *++v32;
            if ( (*(_BYTE *)(v22 + 2 * v33 + 1) & 0x20) != 0 )
              break;
            if ( !v31 )
              goto LABEL_21;
          }
          *v34 = 0;
        }
LABEL_21:
        v23 = v31;
        if ( (*(_BYTE *)(v22 + 2LL * v31 + 1) & 0x20) != 0 )
        {
          do
          {
            v23 = (unsigned __int8)*++v32;
            v31 = v23;
          }
          while ( (*(_BYTE *)(v22 + 2 * v23 + 1) & 0x20) != 0 );
        }
        if ( v31 )
        {
          v35 = v32[1];
          v36 = v32 + 1;
          if ( v35 )
          {
            while ( (*(_BYTE *)(v22 + 2LL * v35 + 1) & 0x20) == 0 )
            {
              v35 = *((_BYTE *)v36 + 1);
              v36 = (_WORD *)((char *)v36 + 1);
              if ( !v35 )
                goto LABEL_30;
            }
            if ( v35 == 10 )
              *v36 = 2560;
            else
              *(_BYTE *)v36 = 0;
          }
LABEL_30:
          v71 = qword_C0CF0;
          if ( qword_C0CF0 >= (unsigned __int64)qword_C0CE8 )
          {
            if ( qword_C0CE8 )
            {
              v57 = 2 * qword_C0CE8;
              v22 = 32 * qword_C0CE8;
            }
            else
            {
              v22 = 1600LL;
              v57 = 100LL;
            }
            v70 = v24;
            v58 = sub_21DF0(
                    (const char *)qword_C1B00,
                    v22,
                    (__int64)v36,
                    v24,
                    v25,
                    v26,
                    a3,
                    a4,
                    a5,
                    a6,
                    v17,
                    v18,
                    a9,
                    a10);
            if ( !v58 )
              break;
            qword_C1B00 = v58;
            v24 = v70;
            qword_C0CE8 = v57;
          }
          v68 = v24;
          v70 = strlen((__int64)v27) + 1;
          v37 = strlen((__int64)v32);
          v42 = v70;
          v43 = qword_C0D00;
          v44 = v37 + 1;
          v45 = qword_C1B08;
          v70 += qword_C0D00;
          v69 = v37 + 1 + v70;
          v46 = v68;
          if ( v69 <= qword_C0CF8 )
          {
            v49 = qword_C1B00;
            v26 = qword_C1B08;
          }
          else
          {
            v47 = v42 + v44;
            v65 = v68;
            v64 = qword_C0D00;
            if ( v42 + v44 < 0x400 )
              v47 = 1024LL;
            v66 = v37 + 1;
            v67 = v42;
            v22 = v47 + qword_C0CF8;
            v68 = v22;
            v48 = sub_21DF0((const char *)qword_C1B08, v22, v42, 1024LL, v38, v39, a3, a4, a5, a6, v40, v41, a9, a10);
            v26 = v48;
            if ( !v48 )
              break;
            v49 = qword_C1B00;
            v42 = v67;
            v44 = v66;
            v46 = v65;
            v43 = v64;
            if ( v48 != v45 && v71 )
            {
              v59 = v48;
              v60 = (_QWORD *)qword_C1B00;
              v61 = v59 - v45;
              v62 = qword_C1B00 + 16 * v71;
              do
              {
                *v60 += v61;
                v60[1] += v61;
                v60 += 2;
              }
              while ( (_QWORD *)v62 != v60 );
            }
            qword_C1B08 = v26;
            qword_C0CF8 = v68;
          }
          v67 = v46;
          v66 = v44;
          v68 = v26;
          v50 = (_QWORD *)(v49 + 16 * v71);
          v51 = memcpy((void *)(v26 + v43), v27, v42);
          v52 = v70;
          v53 = v68;
          v22 = (__int64)v32;
          v54 = v66;
          *v50 = v51;
          v55 = memcpy((void *)(v53 + v52), v32, v54);
          v56 = v71;
          ++v72;
          v50[1] = v55;
          v24 = v67;
          qword_C0D00 = v69;
          qword_C0CF0 = v56 + 1;
        }
      }
      if ( !v24 )
      {
        do
        {
          v22 = 400LL;
          if ( !sub_17160(v73, 400, v19, a3, a4, a5, a6, v17, v18, a9, a10) )
            break;
          v22 = 10LL;
        }
        while ( !sub_9210(v73, 10LL) );
      }
    }
    while ( (*(_BYTE *)v19 & 0x10) == 0 );
    sub_137F0(v19, v22, v23, v24, v25, v26);
    if ( v72 )
      sub_12340((void *)qword_C1B00, qword_C0CF0, 0x10uLL, (int (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_FF90);
  }
  return v72;
}
// 1001D: variable 'v11' is possibly undefined
// 1001D: variable 'v12' is possibly undefined
// 10063: variable 'v17' is possibly undefined
// 10063: variable 'v18' is possibly undefined
// 100CE: variable 'v23' is possibly undefined
// 100CE: variable 'v24' is possibly undefined
// 100CE: variable 'v25' is possibly undefined
// 100CE: variable 'v26' is possibly undefined
// 102C1: variable 'v38' is possibly undefined
// 102C1: variable 'v39' is possibly undefined
// 102C1: variable 'v40' is possibly undefined
// 102C1: variable 'v41' is possibly undefined
// 10450: variable 'v14' is possibly undefined
// 10450: variable 'v15' is possibly undefined
// 10450: variable 'v16' is possibly undefined
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// 9210: using guessed type __int64 __fastcall sub_9210(_QWORD, _QWORD);
// C0CE8: using guessed type __int64 qword_C0CE8;
// C0CF0: using guessed type __int64 qword_C0CF0;
// C0CF8: using guessed type __int64 qword_C0CF8;
// C0D00: using guessed type __int64 qword_C0D00;
// C1B00: using guessed type __int64 qword_C1B00;
// C1B08: using guessed type __int64 qword_C1B08;

//----- (0000000000010460) ----------------------------------------------------
u32 *__fastcall sub_10460(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14)
{
  unsigned __int64 v16; // r15
  char *v17; // rsi
  char v18; // al
  char v19; // dl
  char *v20; // rax
  unsigned __int64 v21; // rdi
  char v22; // dl
  char *v23; // rax
  char v24; // dl
  u32 *v25; // r8
  unsigned __int64 v27; // r14
  _QWORD *v28; // r13
  int v29; // eax
  signed __int64 v30; // rax
  __int64 v31; // [rsp+8h] [rbp-40h]

  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C0D08, 1, 0) )
      sub_1C7D0((volatile __int32 *)&dword_C0D08, a2, 1LL, a12, a13, a14);
  }
  else
  {
    _EDX = 1;
    __asm { cmpxchg cs:dword_C0D08, edx }
  }
  if ( !qword_C0CE0 )
    qword_C0CE0 = (__int64)"/usr/share/locale";
  v16 = qword_C0CF0;
  if ( qword_C0CF0 )
    goto LABEL_24;
LABEL_6:
  while ( 1 )
  {
    v17 = (char *)qword_C0CE0;
    v18 = 0;
    v19 = *(_BYTE *)qword_C0CE0;
    if ( !*(_BYTE *)qword_C0CE0 )
      break;
    while ( 1 )
    {
      v20 = v17 + 1;
      v21 = (unsigned __int64)v17;
      if ( v19 != 58 )
        break;
      do
      {
        v21 = (unsigned __int64)v20;
        v22 = *v20++;
      }
      while ( v22 == 58 );
      if ( v22 )
        break;
      v17 = (char *)v21;
LABEL_14:
      v19 = *v17;
      v18 = 1;
      if ( !*v17 )
        goto LABEL_15;
    }
    v23 = (char *)(v21 + 1);
    do
    {
      v24 = *v23;
      v17 = v23++;
    }
    while ( v24 && v24 != 58 );
    if ( (unsigned __int64)v17 <= v21 )
      goto LABEL_14;
    qword_C0CE0 = (__int64)v17;
    if ( sub_FFB0(v21, (int)v17 - (int)v21, a3, a4, a5, a6, a7, a8, a9, a10) )
    {
      v16 = qword_C0CF0;
      if ( qword_C0CF0 )
      {
LABEL_24:
        v27 = 0LL;
        v31 = qword_C1B00;
        while ( 1 )
        {
          v28 = (_QWORD *)(v31 + 16 * ((v27 + v16) >> 1));
          v29 = sub_9150(a1, *v28, off_BDB00);
          if ( v29 >= 0 )
          {
            if ( !v29 )
            {
              v25 = (u32 *)v28[1];
              goto LABEL_18;
            }
            v27 = ((v27 + v16) >> 1) + 1;
          }
          else
          {
            v16 = (v27 + v16) >> 1;
          }
          if ( v16 <= v27 )
            goto LABEL_6;
        }
      }
    }
  }
LABEL_15:
  if ( v18 )
    qword_C0CE0 = (__int64)v17;
  v25 = 0LL;
LABEL_18:
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedExchange((volatile __int32 *)&dword_C0D08, 0) > 1 )
      v30 = sys_futex(&dword_C0D08, 129, 1u, 0LL, v25, a14);
  }
  else
  {
    --dword_C0D08;
  }
  return v25;
}
// 1054D: variable 'v25' is possibly undefined
// 1056F: variable 'a7' is possibly undefined
// 1056F: variable 'a8' is possibly undefined
// 10647: variable 'a14' is possibly undefined
// 9150: using guessed type __int64 __fastcall sub_9150(_QWORD, _QWORD, _QWORD);
// BDB00: using guessed type void **off_BDB00[6];
// C0CE0: using guessed type __int64 qword_C0CE0;
// C0CF0: using guessed type __int64 qword_C0CF0;
// C1B00: using guessed type __int64 qword_C1B00;

//----- (0000000000010650) ----------------------------------------------------
_QWORD *__fastcall sub_10650(_QWORD *a1, char *a2, size_t a3, int a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, void *a10, int a11)
{
  char v12; // r14
  size_t v13; // r13
  __int64 v14; // rbp
  int v15; // er12
  __int64 v16; // rbx
  size_t v17; // rbp
  __int64 v18; // r13
  size_t v19; // rbp
  __int64 v20; // rbx
  size_t v21; // rbp
  __int64 v22; // r14
  __int64 v23; // r13
  char *v24; // rax
  char *v25; // rbp
  size_t v26; // rbx
  __int64 i; // r14
  __int64 v28; // rax
  _BYTE *v29; // rax
  _BYTE *v30; // rax
  void *v31; // rdi
  _QWORD *v32; // r12
  _QWORD *v33; // r13
  int v34; // eax
  size_t v35; // rbx
  __int64 v36; // r12
  __int64 v37; // r14
  __int64 v38; // rax
  _QWORD *v39; // rax
  __int64 v40; // r14
  size_t v41; // rbp
  __int64 v42; // rax
  _BOOL4 v43; // eax
  __int64 v44; // r13
  size_t v45; // rbx
  __int64 v46; // rbp
  __int64 v47; // rax
  int v48; // er14
  __int64 v49; // rbp
  int v50; // ebx
  int v51; // er13
  char *v52; // r14
  unsigned __int64 v55; // r15
  int v56; // eax
  _QWORD *v57; // rax
  size_t v59; // [rsp+0h] [rbp-78h]
  int v60; // [rsp+8h] [rbp-70h]
  _QWORD *v63; // [rsp+30h] [rbp-48h]

  v12 = a4;
  v13 = a3 + 2;
  v60 = a5;
  v14 = strlen(a5);
  v15 = v12 & 4;
  if ( (v12 & 4) != 0 )
    v16 = strlen(a6) + 1;
  else
    v16 = 0LL;
  v17 = v13 + v14;
  v18 = 0LL;
  if ( (a4 & 2) != 0 )
    v18 = strlen(a7) + 1;
  v19 = v16 + v17;
  v20 = 0LL;
  if ( (a4 & 1) != 0 )
    v20 = strlen(a8) + 1;
  v21 = v18 + v19;
  v22 = 0LL;
  if ( (a4 & 8) != 0 )
    v22 = strlen(a9) + 1;
  v23 = strlen((__int64)a10);
  v24 = (char *)sub_21500(v23 + v22 + v20 + v21);
  v25 = v24;
  if ( !v24 )
    return 0LL;
  memcpy(v24, a2, a3);
  if ( a3 )
  {
    v26 = a3;
    for ( i = (__int64)v25; ; i = (__int64)(v29 + 1) )
    {
      v28 = strlen(i);
      v26 += ~v28;
      if ( !v26 )
        break;
      v29 = (_BYTE *)(i + v28);
      *v29 = 58;
    }
  }
  v25[a3 - 1] = 47;
  v30 = (_BYTE *)sub_90F0(&v25[a3]);
  if ( v15 )
  {
    *v30 = 95;
    v30 = (_BYTE *)sub_90F0(v30 + 1);
  }
  v31 = v30 + 1;
  if ( (a4 & 2) != 0 )
  {
    *v30 = 46;
    v30 = (_BYTE *)sub_90F0(v31);
    v31 = v30 + 1;
  }
  if ( (a4 & 1) != 0 )
  {
    *v30 = 46;
    v30 = (_BYTE *)sub_90F0(v31);
    v31 = v30 + 1;
  }
  if ( (a4 & 8) != 0 )
  {
    *v30 = 64;
    v30 = (_BYTE *)sub_90F0(v31);
    v31 = v30 + 1;
  }
  *v30 = 47;
  memcpy(v31, a10, v23 + 1);
  v63 = (_QWORD *)*a1;
  if ( *a1 )
  {
    v32 = (_QWORD *)*a1;
    v33 = 0LL;
    while ( 1 )
    {
      if ( *v32 )
      {
        v34 = sub_91B0(*v32, v25);
        if ( !v34 )
          goto LABEL_57;
        if ( v34 < 0 )
          goto LABEL_29;
        v33 = v32;
      }
      v32 = (_QWORD *)v32[3];
      if ( !v32 )
        goto LABEL_29;
    }
  }
  v33 = 0LL;
LABEL_29:
  if ( a11 )
  {
    v35 = a3;
    v36 = 0LL;
    v37 = (__int64)a2;
    if ( a3 )
    {
      do
      {
        ++v36;
        v38 = strlen(v37);
        v37 += v38 + 1;
        v35 += ~v38;
      }
      while ( v35 );
      v39 = (_QWORD *)sub_21500(
                        8
                      * (1 << ((((((a4 & 0x55) + ((a4 >> 1) & 0x55)) & 0x33)
                               + (((int)((a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555)) >> 2) & 0x33)
                               + ((int)((((a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555)) & 0x3333)
                                      + (((int)((a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555)) >> 2) & 0xFFFFF333)) >> 4)) & 0xF)
                             + ((unsigned __int16)(((((a4 & 0x5555) + ((a4 >> 1) & 0xD555)) & 0x3333)
                                                  + (((int)((a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555)) >> 2) & 0xF333)
                                                  + ((int)((((a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555)) & 0x3333)
                                                         + (((int)((a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555)) >> 2) & 0xFFFFF333)) >> 4)) & 0xF0F) >> 8)))
                      * v36
                      + 40);
      v32 = v39;
      if ( v39 )
      {
        v40 = (__int64)a2;
        *v39 = v25;
        v41 = a3;
        do
        {
          ++v35;
          v42 = strlen(v40);
          v40 += v42 + 1;
          v41 += ~v42;
        }
        while ( v41 );
        v43 = 1;
        if ( v35 == 1 )
          v43 = (a4 & 3) == 3;
        goto LABEL_37;
      }
    }
    else
    {
      v57 = (_QWORD *)sub_21500(40LL);
      v32 = v57;
      if ( v57 )
      {
        *v57 = v25;
        v43 = 1;
LABEL_37:
        *((_DWORD *)v32 + 2) = v43;
        v32[2] = 0LL;
        if ( v33 )
        {
          v32[3] = v33[3];
          v33[3] = v32;
        }
        else
        {
          v32[3] = v63;
          *a1 = v32;
        }
        if ( a3 )
        {
          v44 = (__int64)a2;
          v45 = a3;
          v46 = 0LL;
          do
          {
            ++v46;
            v47 = strlen(v44);
            v44 += v47 + 1;
            v45 += ~v47;
          }
          while ( v45 );
          v48 = a4 - (v46 == 1);
        }
        else
        {
          v48 = a4;
        }
        v49 = 0LL;
        v50 = ~a4;
        if ( v48 >= 0 )
        {
          v59 = a3;
          v51 = v48;
          v52 = &a2[a3];
          do
          {
            if ( (v50 & v51) == 0 )
            {
              while ( v59 )
              {
                v55 = (unsigned __int64)a2;
                while ( 1 )
                {
                  ++v49;
                  v56 = strlen(v55);
                  v32[v49 + 3] = sub_10650((_DWORD)a1, v55, v56 + 1, v51, v60, a6, a7, a8, a9, a10, 1);
                  if ( !v55 )
                    break;
                  if ( v55 < (unsigned __int64)v52 )
                  {
                    v55 += strlen(v55) + 1;
                    if ( v55 < (unsigned __int64)v52 )
                      continue;
                  }
                  goto LABEL_46;
                }
              }
            }
LABEL_46:
            ;
          }
          while ( v51-- != 0 );
        }
        v32[v49 + 4] = 0LL;
        return v32;
      }
    }
    v32 = 0LL;
    sub_21B70(v25);
    return v32;
  }
  v32 = 0LL;
LABEL_57:
  sub_21B70(v25);
  return v32;
}
// 90F0: using guessed type __int64 __fastcall sub_90F0(_QWORD);
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (0000000000010B60) ----------------------------------------------------
_DWORD *__fastcall sub_10B60(unsigned __int8 *a1, unsigned __int64 a2)
{
  unsigned __int8 *v2; // rbp
  unsigned __int8 *v4; // rdx
  unsigned __int8 *v5; // r8
  int v6; // esi
  __int64 v7; // rdi
  __int64 v8; // rcx
  __int64 v9; // rax
  unsigned __int8 *v10; // rcx
  _DWORD *v11; // r8
  unsigned __int64 v12; // rax
  __int64 v13; // rsi
  unsigned __int8 v14; // dl
  _DWORD *v16; // rax
  _DWORD *v17; // rax

  if ( a2 )
  {
    v2 = a1;
    v4 = a1;
    v5 = &a1[a2];
    v6 = 1;
    v7 = 0LL;
    do
    {
      v8 = *v4;
      if ( (byte_971A0[2 * v8] & 8) != 0 )
      {
        ++v7;
        if ( (unsigned int)(v8 - 48) >= 0xA )
          v6 = 0;
      }
      ++v4;
    }
    while ( v5 != v4 );
    if ( v6 )
    {
      v16 = (_DWORD *)sub_21500(v7 + 4);
      v11 = v16;
      if ( v16 )
      {
        *v16 = 7304041;
        v10 = (unsigned __int8 *)v16 + 3;
        goto LABEL_10;
      }
    }
    else
    {
      v9 = sub_21500(v7 + 1);
      v10 = (unsigned __int8 *)v9;
      if ( v9 )
      {
        v11 = (_DWORD *)v9;
LABEL_10:
        v12 = 0LL;
        while ( 1 )
        {
          while ( 1 )
          {
            v13 = v2[v12];
            v14 = v2[v12];
            if ( (byte_971A0[2 * v13 + 1] & 4) == 0 )
              break;
            *v10++ = dword_962A0[v13];
LABEL_12:
            if ( a2 <= ++v12 )
              goto LABEL_16;
          }
          if ( (unsigned int)(unsigned __int8)v13 - 48 > 9 )
            goto LABEL_12;
          ++v12;
          *v10++ = v14;
          if ( a2 <= v12 )
            goto LABEL_16;
        }
      }
    }
    return 0LL;
  }
  v17 = (_DWORD *)sub_21500(4LL);
  v11 = v17;
  if ( !v17 )
    return 0LL;
  *v17 = 7304041;
  v10 = (unsigned __int8 *)v17 + 3;
LABEL_16:
  *v10 = 0;
  return v11;
}
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);

//----- (0000000000010C80) ----------------------------------------------------
__int64 __fastcall sub_10C80(unsigned __int8 *a1, unsigned __int8 **a2, _QWORD *a3, unsigned __int8 **a4, _QWORD *a5, _QWORD *a6)
{
  unsigned __int8 j; // al
  unsigned __int8 *i; // rbx
  unsigned __int8 *v10; // rdx
  unsigned int v11; // er12
  unsigned __int8 *v13; // rdi
  unsigned __int8 *v14; // r15
  _DWORD *v15; // rax
  int v16; // eax
  _DWORD *v18; // [rsp+0h] [rbp-48h]
  unsigned __int8 **v19; // [rsp+8h] [rbp-40h]

  *a3 = 0LL;
  *a4 = 0LL;
  *a5 = 0LL;
  *a6 = 0LL;
  *a2 = a1;
  j = *a1;
  if ( *a1 == 95 || !j )
  {
LABEL_15:
    v11 = 0;
    goto LABEL_16;
  }
  for ( i = a1; ; ++i )
  {
    if ( j == 46 || j == 64 )
    {
      if ( a1 == i )
        goto LABEL_15;
      j = *i;
      v11 = 0;
LABEL_11:
      if ( j != 46 )
        goto LABEL_12;
      goto LABEL_30;
    }
    j = i[1];
    v10 = i + 1;
    if ( !j || j == 95 )
      break;
  }
  if ( a1 == v10 )
    goto LABEL_15;
  if ( j != 95 )
  {
    ++i;
    v11 = 0;
    goto LABEL_11;
  }
  i += 2;
  *v10 = 0;
  *a4 = i;
  for ( j = v10[1]; (j & 0xBF) != 0; j = *++i )
  {
    if ( j == 46 )
      break;
  }
  v11 = 4;
  if ( j != 46 )
    goto LABEL_12;
LABEL_30:
  v13 = i + 1;
  *i = 0;
  *a5 = i + 1;
  j = i[1];
  if ( (j & 0xBF) != 0 )
  {
    ++i;
    do
      v14 = i++;
    while ( (*i & 0xBF) != 0 );
    if ( v13 == i )
    {
      v11 |= 2u;
    }
    else
    {
      v19 = a4;
      v15 = sub_10B60(v13, i - v13);
      *a6 = v15;
      if ( !v15 )
        return (unsigned int)-1;
      v18 = v15;
      v16 = sub_91B0(*a5, v15);
      a4 = v19;
      if ( v16 )
      {
        j = v14[1];
        v11 |= 3u;
      }
      else
      {
        v11 |= 2u;
        sub_21B70(v18);
        j = v14[1];
        a4 = v19;
      }
    }
  }
  else
  {
    v11 |= 2u;
    ++i;
  }
LABEL_12:
  if ( j == 64 )
  {
    *i = 0;
    *a3 = i + 1;
    if ( i[1] )
      v11 |= 8u;
  }
LABEL_16:
  if ( *a4 && !**a4 )
    v11 &= 0xFFFFFFFB;
  if ( *a5 && !*(_BYTE *)*a5 )
    v11 &= 0xFFFFFFFD;
  return v11;
}
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (0000000000010E70) ----------------------------------------------------
void __fastcall sub_10E70(int *a1)
{
  int v1; // eax

  if ( a1 )
  {
    v1 = *a1;
    if ( *a1 != 2 )
    {
      if ( v1 != 3 )
      {
        if ( v1 != 1 )
        {
          sub_21B70(a1);
          return;
        }
        goto LABEL_8;
      }
      sub_10E70(*((int **)a1 + 3));
    }
    sub_10E70(*((int **)a1 + 2));
LABEL_8:
    sub_10E70(*((int **)a1 + 1));
    sub_21B70(a1);
  }
}
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (0000000000010ED0) ----------------------------------------------------
__int64 __fastcall sub_10ED0(_BYTE **a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  u32 *v9; // r8
  int v10; // er14
  __int64 v11; // r13
  char *v12; // rdx
  char *v13; // rbp
  char *v14; // rbx
  u32 v15; // eax
  u32 v16; // er9
  int v17; // esi
  char v18; // al
  __int64 v19; // rsi
  char *v20; // rdi
  int v21; // er8
  unsigned int v22; // er12
  __int64 v24; // rax
  unsigned int v25; // eax
  __int64 v26; // r15
  __int64 v27; // rax
  char *v28; // r8
  __int64 v29; // rax
  signed __int64 v30; // rbx
  void *v31; // rax
  char *v32; // rax
  char *v33; // r15
  __int64 v34; // rdx
  char *v35; // r9
  _BYTE *v36; // rsi
  char v37; // di
  char *v38; // [rsp+8h] [rbp-790h]
  int v39; // [rsp+18h] [rbp-780h]
  int v40; // [rsp+1Ch] [rbp-77Ch]
  char *v41; // [rsp+28h] [rbp-770h]
  __int64 v43; // [rsp+38h] [rbp-760h]
  char v44[1600]; // [rsp+50h] [rbp-748h] BYREF
  char v45[200]; // [rsp+690h] [rbp-108h] BYREF
  unsigned __int64 v46; // [rsp+758h] [rbp-40h]

  v9 = 0LL;
  v10 = -2;
  v11 = 200LL;
  v12 = v44;
  v46 = __readfsqword(0x28u);
  v45[0] = 0;
  v39 = 0;
  v13 = v45;
  v14 = v45;
  v38 = v44;
  while ( 1 )
  {
    v15 = byte_8FFD0[(_QWORD)v9];
    v16 = v15;
    if ( v15 == -4 )
      goto LABEL_11;
    if ( v10 == -2 )
    {
      v36 = *a1;
      do
      {
        v37 = *v36;
        if ( !*v36 )
        {
          v10 = 0;
          *a1 = v36;
          v17 = 0;
          goto LABEL_7;
        }
        ++v36;
      }
      while ( v37 == 32 || v37 == 9 );
      if ( (unsigned __int8)(v37 - 10) <= 0x72u )
        __asm { jmp     r11 }
      v10 = 257;
      *a1 = v36;
      v17 = 2;
    }
    else
    {
      if ( v10 <= 0 )
      {
        v17 = 0;
        v10 = 0;
        goto LABEL_7;
      }
      v17 = byte_8FEC0[v10];
    }
    v16 = v15 + v17;
LABEL_7:
    if ( v16 <= 0x38 && byte_8FE20[v16] == v17 )
    {
      v18 = byte_8FE60[v16];
      v9 = (u32 *)v18;
      if ( v18 > 0 )
      {
        v19 = v43;
        v10 = -2;
        *((_QWORD *)v12 + 1) = v43;
        v12 += 8;
        v39 = (v39 == 0) + v39 - 1;
        v20 = v14;
        goto LABEL_32;
      }
      v21 = -v18;
LABEL_27:
      v26 = v21;
      v19 = byte_8FDE8[v21];
      v27 = *(_QWORD *)&v12[8 * (1 - byte_8FDE8[v21])];
      if ( (unsigned int)v21 <= 0xD )
        __asm { jmp     rdi }
      v28 = &v12[-8 * v19];
      v20 = &v14[-v19];
      *((_QWORD *)v28 + 1) = v27;
      v16 = v14[-v19];
      v12 = v28 + 8;
      v29 = byte_8FDF8[v26] - 16;
      LODWORD(v19) = v16 + byte_8FFCB[v29];
      if ( (unsigned int)v19 <= 0x38 && (v19 = (int)v19, (_BYTE)v16 == byte_8FE20[(int)v19]) )
      {
        v18 = byte_8FE60[(int)v19];
        v9 = (u32 *)v18;
      }
      else
      {
        v19 = (__int64)&off_8FFC7;
        v18 = *((_BYTE *)&off_8FFC7 + v29);
        v9 = (u32 *)v18;
      }
      goto LABEL_32;
    }
LABEL_11:
    v21 = byte_8FEA0[(_QWORD)v9];
    if ( v21 )
      goto LABEL_27;
    if ( v39 == 3 )
    {
      if ( v10 > 0 )
      {
        v10 = -2;
        goto LABEL_22;
      }
      if ( !v10 )
      {
LABEL_15:
        v22 = 1;
        goto LABEL_16;
      }
    }
LABEL_22:
    while ( 1 )
    {
      if ( v15 != -4 )
      {
        v25 = v15 + 1;
        if ( v25 <= 0x38 && byte_8FE20[v25] == 1 )
        {
          v18 = byte_8FE60[v25];
          v9 = (u32 *)v18;
          if ( v18 > 0 )
            break;
        }
      }
      if ( v14 == v13 )
        goto LABEL_15;
      v24 = *--v14;
      v12 -= 8;
      v15 = byte_8FFD0[v24];
    }
    v19 = v43;
    v39 = 3;
    v12 += 8;
    v20 = v14;
    *(_QWORD *)v12 = v43;
LABEL_32:
    v20[1] = v18;
    v14 = v20 + 1;
    if ( v20 + 1 >= &v13[v11 - 1] )
      break;
LABEL_41:
    if ( (_DWORD)v9 == 9 )
    {
      v22 = 0;
      goto LABEL_16;
    }
  }
  v30 = v14 - v13;
  v40 = (int)v9;
  if ( v11 <= 9999 )
  {
    v11 *= 2LL;
    if ( v11 > 10000 )
      v11 = 10000LL;
    v31 = (void *)sub_21500(
                    (u32 *)(9 * v11 + 7),
                    v19,
                    (__int64)v12,
                    (__int64)byte_8FE20,
                    v9,
                    v16,
                    a2,
                    a3,
                    a4,
                    a5,
                    a6,
                    a7,
                    a8,
                    a9);
    if ( v31 )
    {
      v32 = (char *)memcpy(v31, v13, v30 + 1);
      v33 = &v32[(v11 + 7) & 0xFFFFFFFFFFFFFFF8LL];
      v41 = v32;
      memcpy(v33, v38, 8 * (v30 + 1));
      v34 = 8 * (v30 + 1);
      v35 = v41;
      v9 = (u32 *)v40;
      if ( v13 != v45 )
      {
        sub_21B70(v13);
        v35 = v41;
        v9 = (u32 *)v40;
        v34 = 8 * (v30 + 1);
      }
      v14 = &v35[v30];
      v12 = &v33[v34 - 8];
      if ( v14 >= &v35[v11 - 1] )
      {
        v13 = v35;
        v22 = 1;
        goto LABEL_17;
      }
      v38 = v33;
      v13 = v35;
      goto LABEL_41;
    }
  }
  v22 = 2;
LABEL_16:
  if ( v13 == v45 )
    return v22;
LABEL_17:
  sub_21B70(v13);
  return v22;
}
// 10F72: conditional instruction was optimized away because of 'er14.4==101'
// 10FB9: variable 'v43' is possibly undefined
// 111DA: variable 'a6' is possibly undefined
// 111DA: variable 'a7' is possibly undefined
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// 8FFC7: using guessed type void *__ptr32 off_8FFC7;

//----- (0000000000011980) ----------------------------------------------------
unsigned __int64 __fastcall sub_11980(__int64 a1, _BYTE **a2, unsigned __int64 *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  __int64 v12; // r13
  __int64 v13; // rax
  char *v14; // rbx
  unsigned __int8 v15; // al
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // rax
  double v18; // xmm4_8
  double v19; // xmm5_8
  char *v21; // [rsp+8h] [rbp-50h] BYREF
  _BYTE *v22[3]; // [rsp+10h] [rbp-48h] BYREF
  unsigned __int64 v23; // [rsp+28h] [rbp-30h]

  v23 = __readfsqword(0x28u);
  if ( !a1 )
    goto LABEL_12;
  v12 = sub_9120(a1, "plural=");
  v13 = sub_9120(a1, "nplurals=");
  if ( !v12 )
    goto LABEL_12;
  if ( !v13 )
    goto LABEL_12;
  v14 = (char *)(v13 + 9);
  v15 = *(_BYTE *)(v13 + 9);
  if ( !v15 )
    goto LABEL_12;
  v16 = __readfsqword(0xFFFFFFF8);
  while ( (*(_BYTE *)(v16 + 2LL * v15 + 1) & 0x20) != 0 )
  {
    v15 = *++v14;
    if ( !v15 )
      goto LABEL_12;
  }
  if ( (unsigned __int8)(v15 - 48) <= 9u
    && (v17 = sub_129A0(v14, (unsigned __int8 **)&v21, 0xAu), v21 != v14)
    && (*a3 = v17, v22[0] = (_BYTE *)(v12 + 7), !(unsigned int)sub_10ED0(v22, a4, a5, a6, a7, v18, v19, a10, a11)) )
  {
    *a2 = v22[1];
  }
  else
  {
LABEL_12:
    *a2 = &unk_BAD60;
    *a3 = 2LL;
  }
  return v23 - __readfsqword(0x28u);
}
// 11A48: variable 'v18' is possibly undefined
// 11A48: variable 'v19' is possibly undefined
// 9120: using guessed type __int64 __fastcall sub_9120(_QWORD, _QWORD);

//----- (0000000000011AA0) ----------------------------------------------------
unsigned __int64 __fastcall sub_11AA0(unsigned __int8 *a1)
{
  unsigned __int64 result; // rax
  unsigned __int8 *v2; // rdi
  __int64 v3; // rdx

  result = *a1;
  v2 = a1 + 1;
  if ( !(_BYTE)result )
    return 0LL;
  while ( 1 )
  {
    v3 = *v2;
    if ( !(_BYTE)v3 )
      break;
    while ( 1 )
    {
      ++v2;
      result = v3 + 16 * result;
      if ( (result & 0xF0000000) == 0 )
        break;
      result = ((unsigned __int64)((unsigned int)result & 0xF0000000) >> 24) ^ result & 0xFFFFFFFF0FFFFFFFLL;
      v3 = *v2;
      if ( !(_BYTE)v3 )
        return result;
    }
  }
  return result;
}

//----- (0000000000011B00) ----------------------------------------------------
__int64 __fastcall sub_11B00(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7)
{
  return sub_5CF30(a1, 0, a3, a4, a5, a6, a7);
}

//----- (0000000000011B10) ----------------------------------------------------
__int64 __fastcall sub_11B10(int sig)
{
  signed __int64 v1; // rax
  pid_t v2; // edi
  signed __int64 v3; // rax
  int v4; // er8
  unsigned __int64 v5; // rax
  sigset_t *v6; // r9
  signed __int64 v7; // rax
  unsigned int v8; // er8
  sigset_t v10; // [rsp+0h] [rbp-118h] BYREF
  sigset_t nset; // [rsp+80h] [rbp-98h] BYREF
  unsigned __int64 v12; // [rsp+108h] [rbp-10h]

  v12 = __readfsqword(0x28u);
  nset.__val[0] = 0xFFFFFFFE7FFFFFFFLL;
  nset.__val[1] = -1LL;
  nset.__val[2] = -1LL;
  nset.__val[3] = -1LL;
  nset.__val[4] = -1LL;
  nset.__val[5] = -1LL;
  nset.__val[6] = -1LL;
  nset.__val[7] = -1LL;
  nset.__val[8] = -1LL;
  nset.__val[9] = -1LL;
  nset.__val[10] = -1LL;
  nset.__val[11] = -1LL;
  nset.__val[12] = -1LL;
  nset.__val[13] = -1LL;
  nset.__val[14] = -1LL;
  nset.__val[15] = -1LL;
  v1 = sys_rt_sigprocmask(0, &nset, &v10, 8uLL);
  v2 = sys_getpid();
  v3 = sys_gettid();
  v5 = sys_tgkill(v2, v3, v4);
  if ( v5 > 0xFFFFFFFFFFFFF000LL )
    __writefsdword(0xFFFFFFC0, -(int)v5);
  v7 = sys_rt_sigprocmask(2, v6, 0LL, 8uLL);
  return v8;
}
// 11C31: variable 'v4' is possibly undefined
// 11C53: variable 'v6' is possibly undefined
// 11C68: variable 'v8' is possibly undefined

//----- (0000000000011CA0) ----------------------------------------------------
void *__fastcall sub_11CA0(__int64 *a1, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbp
  unsigned __int64 v4; // rbx
  char *v5; // r13
  char **v6; // r15
  unsigned __int64 v7; // rax
  __int64 v8; // r14
  char *v9; // r12
  char *v10; // rax
  char *v11; // rax
  unsigned __int64 v12; // rax
  int v13; // eax
  __int64 v14; // rax
  int v15; // eax
  char **v16; // rcx
  char *v17; // rsi
  __int64 v19; // [rsp+0h] [rbp-68h]
  __int64 (__fastcall *v20)(char *, char *, __int64); // [rsp+8h] [rbp-60h]
  char **v21; // [rsp+10h] [rbp-58h]
  char *v22; // [rsp+20h] [rbp-48h]

  v3 = a3 >> 1;
  v4 = a3 - (a3 >> 1);
  v22 = a2;
  v5 = &a2[(a3 >> 1) * *a1];
  if ( a3 >> 1 != 1 )
    sub_11CA0(a1, a2, a3 >> 1);
  if ( v4 > 1 )
  {
    sub_11CA0(a1, v5, v4);
    v6 = (char **)a1[4];
    v7 = a1[1];
    v19 = *a1;
    v8 = a1[3];
    v20 = (__int64 (__fastcall *)(char *, char *, __int64))a1[2];
    if ( v7 != 2 )
    {
      if ( v7 <= 2 )
      {
        if ( v7 )
          goto LABEL_7;
        goto LABEL_30;
      }
      if ( v7 == 3 )
        goto LABEL_14;
      goto LABEL_37;
    }
    goto LABEL_45;
  }
  v6 = (char **)a1[4];
  v8 = a1[3];
  v19 = *a1;
  v12 = a1[1];
  v20 = (__int64 (__fastcall *)(char *, char *, __int64))a1[2];
  if ( v12 == 2 )
  {
    if ( v4 )
    {
      v4 = 1LL;
LABEL_45:
      v9 = a2;
      while ( 1 )
      {
        v21 = v6;
        v6 = (char **)((char *)v6 + v19);
        v15 = v20(v9, v5, v8);
        v16 = v21;
        if ( v15 <= 0 )
        {
          v17 = v9;
          --v3;
          v9 += v19;
        }
        else
        {
          v17 = v5;
          --v4;
          v5 += v19;
        }
        if ( v6 > (char **)((char *)v6 - v19) )
        {
          do
          {
            *v16 = *(char **)v17;
            v17 += 8;
            ++v16;
          }
          while ( v6 > v16 );
        }
        if ( !v3 )
          return memcpy(v22, (const void *)a1[4], v19 * (a3 - v4));
        if ( !v4 )
          goto LABEL_52;
      }
    }
  }
  else if ( v12 > 2 )
  {
    if ( v12 == 3 )
    {
      if ( v4 )
      {
        v4 = 1LL;
LABEL_14:
        v9 = a2;
        while ( 1 )
        {
          if ( (int)v20(*(char **)v9, *(char **)v5, v8) > 0 )
          {
            v11 = *(char **)v5;
            --v4;
            v5 += 8;
          }
          else
          {
            v11 = *(char **)v9;
            --v3;
            v9 += 8;
          }
          *v6++ = v11;
          if ( !v3 )
            return memcpy(v22, (const void *)a1[4], v19 * (a3 - v4));
          if ( !v4 )
            goto LABEL_52;
        }
      }
    }
    else if ( v4 )
    {
LABEL_37:
      v9 = a2;
      while ( 1 )
      {
        if ( (int)v20(v9, v5, v8) > 0 )
        {
          --v4;
          v14 = sub_91D0(v6, v5, v19);
          v5 += v19;
        }
        else
        {
          --v3;
          v14 = sub_91D0(v6, v9, v19);
          v9 += v19;
        }
        v6 = (char **)v14;
        if ( !v3 )
          return memcpy(v22, (const void *)a1[4], v19 * (a3 - v4));
        if ( !v4 )
          goto LABEL_52;
      }
    }
  }
  else if ( v12 )
  {
    if ( v4 )
    {
LABEL_7:
      v9 = a2;
      while ( 1 )
      {
        if ( (int)v20(v9, v5, v8) > 0 )
        {
          v10 = *(char **)v5;
          --v4;
          v5 += 8;
        }
        else
        {
          v10 = *(char **)v9;
          --v3;
          v9 += 8;
        }
        *v6++ = v10;
        if ( !v3 )
          return memcpy(v22, (const void *)a1[4], v19 * (a3 - v4));
        if ( !v4 )
          goto LABEL_52;
      }
    }
  }
  else if ( v4 )
  {
    v4 = 1LL;
LABEL_30:
    v9 = a2;
    while ( 1 )
    {
      if ( (int)v20(v9, v5, v8) > 0 )
      {
        v13 = *(_DWORD *)v5;
        --v4;
        v5 += 4;
      }
      else
      {
        v13 = *(_DWORD *)v9;
        --v3;
        v9 += 4;
      }
      *(_DWORD *)v6 = v13;
      v6 = (char **)((char *)v6 + 4);
      if ( !v3 )
        return memcpy(v22, (const void *)a1[4], v19 * (a3 - v4));
      if ( !v4 )
        goto LABEL_52;
    }
  }
  v9 = a2;
LABEL_52:
  memcpy(v6, v9, v3 * v19);
  return memcpy(v22, (const void *)a1[4], v19 * (a3 - v4));
}
// 11F9A: conditional instruction was optimized away because of 'rbp.8!=0'
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);

//----- (0000000000011FF0) ----------------------------------------------------
unsigned __int64 __fastcall sub_11FF0(void *a1, unsigned __int64 a2, unsigned __int64 a3, int (__fastcall *a4)(_QWORD, _QWORD, _QWORD), __int64 a5)
{
  unsigned __int64 v8; // r12
  void *v9; // rsp
  int v11; // eax
  __int64 v12; // rax
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // r15
  char *v15; // rdx
  unsigned __int64 v16; // rax
  char *v17; // rsi
  char *v18; // rbx
  char *v19; // r12
  unsigned __int64 v20; // r13
  char *v21; // rdi
  unsigned __int64 v22; // rax
  void **v23; // rdx
  __int64 v24; // rax
  __int64 v25; // rdx
  __int64 v26; // [rsp+0h] [rbp-90h] BYREF
  __int64 v27; // [rsp+8h] [rbp-88h]
  void *v28; // [rsp+10h] [rbp-80h]
  unsigned __int64 v29; // [rsp+18h] [rbp-78h]
  void *v30; // [rsp+20h] [rbp-70h]
  unsigned __int64 v31; // [rsp+28h] [rbp-68h]
  unsigned __int64 v32; // [rsp+30h] [rbp-60h] BYREF
  __int64 v33; // [rsp+38h] [rbp-58h]
  int (__fastcall *v34)(_QWORD, _QWORD, _QWORD); // [rsp+40h] [rbp-50h]
  __int64 v35; // [rsp+48h] [rbp-48h]
  __int64 *v36; // [rsp+50h] [rbp-40h]
  unsigned __int64 v37; // [rsp+58h] [rbp-38h]

  v30 = a1;
  v29 = a2;
  v37 = __readfsqword(0x28u);
  if ( a3 > 0x20 )
  {
    v8 = a3 + 16 * v29;
    if ( v8 <= 0x3FF )
      goto LABEL_3;
  }
  else
  {
    a2 *= a3;
    v8 = a2;
    if ( a2 <= 0x3FF )
    {
LABEL_3:
      v27 = 0LL;
      v9 = alloca(v8 + 8);
      v36 = &v26;
      goto LABEL_4;
    }
  }
  v11 = dword_C0D40;
  if ( !dword_C0D40 )
  {
    v24 = sub_49C90(85, a2, a3);
    v25 = 0x1FFFFFFFFFFFFFFFLL;
    if ( v24 != -1 )
      v25 = v24 / 4;
    qword_C0D38 = v25;
    v11 = sub_49C90(30, a2, v25);
    dword_C0D40 = v11;
  }
  if ( v8 / v11 > qword_C0D38
    || (LODWORD(v31) = __readfsdword(0xFFFFFFC0), v12 = sub_21500(v8), v27 = v12, __writefsdword(0xFFFFFFC0, v31), !v12) )
  {
    sub_5D2F0((char *)v30, v29, a3, a4, a5);
    return v37 - __readfsqword(0x28u);
  }
  v36 = (__int64 *)v12;
LABEL_4:
  v32 = a3;
  v33 = 4LL;
  v34 = a4;
  v35 = a5;
  if ( a3 <= 0x20 )
  {
    if ( (((unsigned __int8)a3 | (unsigned __int8)v30) & 3) == 0 )
    {
      if ( a3 == 4 )
      {
        v33 = 0LL;
      }
      else if ( a3 != 8 || ((unsigned __int8)v30 & 7) != 0 )
      {
        if ( (((unsigned __int8)a3 | (unsigned __int8)v30) & 7) == 0 )
          v33 = 2LL;
      }
      else
      {
        v33 = 1LL;
      }
    }
    if ( v29 > 1 )
      sub_11CA0((__int64 *)&v32, (char *)v30, v29);
    goto LABEL_8;
  }
  v13 = v29;
  v14 = (unsigned __int64)&v36[v29];
  v28 = (void *)(v14 + 8 * v29);
  if ( v14 >= (unsigned __int64)v28 )
  {
    v17 = (char *)&v36[v29];
  }
  else
  {
    v15 = (char *)v30;
    v16 = (unsigned __int64)&v36[v29];
    do
    {
      v16 += 8LL;
      *(_QWORD *)(v16 - 8) = v15;
      v15 += a3;
    }
    while ( (unsigned __int64)v28 > v16 );
    v17 = (char *)&v36[v13];
  }
  v32 = 8LL;
  v33 = 3LL;
  if ( v29 > 1 )
  {
    sub_11CA0((__int64 *)&v32, v17, v29);
    goto LABEL_21;
  }
  if ( v29 )
  {
LABEL_21:
    v31 = 0LL;
    v18 = (char *)v30;
    do
    {
      v19 = *(char **)(v14 + 8 * v31);
      if ( v19 != v18 )
      {
        memcpy(v28, v18, a3);
        v20 = v31;
        v21 = v18;
        while ( 1 )
        {
          v22 = (v19 - (_BYTE *)v30) / a3;
          *(_QWORD *)(v14 + 8 * v20) = v21;
          v20 = v22;
          memcpy(v21, v19, a3);
          v23 = (void **)(v14 + 8 * v20);
          v21 = v19;
          if ( *v23 == v18 )
            break;
          v19 = (char *)*v23;
        }
        *v23 = v19;
        memcpy(v19, v28, a3);
      }
      ++v31;
      v18 += a3;
    }
    while ( v29 > v31 );
  }
LABEL_8:
  sub_21B70(v27);
  return v37 - __readfsqword(0x28u);
}
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// C0D38: using guessed type __int64 qword_C0D38;
// C0D40: using guessed type int dword_C0D40;

//----- (0000000000012340) ----------------------------------------------------
unsigned __int64 __fastcall sub_12340(void *a1, unsigned __int64 a2, unsigned __int64 a3, int (__fastcall *a4)(_QWORD, _QWORD, _QWORD))
{
  return sub_11FF0(a1, a2, a3, a4, 0LL);
}

//----- (0000000000012350) ----------------------------------------------------
_WORD *__fastcall sub_12350(_BYTE *a1)
{
  _QWORD *v1; // rbx
  _WORD *v2; // r12
  __int16 v3; // ax
  __int64 v5; // rax
  __int16 v6; // bp
  __int64 v7; // r14
  __int64 v8; // r15

  v1 = qword_C1270;
  if ( !qword_C1270 || !*a1 )
    return 0LL;
  v2 = *(_WORD **)qword_C1270;
  if ( a1[1] )
  {
    v5 = strlen((__int64)a1);
    v6 = *(_WORD *)a1;
    v7 = v5;
    v8 = v5 - 2;
    if ( v2 )
    {
      while ( v6 != *v2 || (unsigned int)sub_9130(v2 + 1, a1 + 2, v8) || *((_BYTE *)v2 + v7) != 61 )
      {
        v2 = (_WORD *)v1[1];
        ++v1;
        if ( !v2 )
          return v2;
      }
      v2 = (_WORD *)((char *)v2 + v7 + 1);
    }
  }
  else
  {
    HIBYTE(v3) = 61;
    if ( v2 )
    {
      while ( 1 )
      {
        LOBYTE(v3) = *a1;
        if ( v3 == *v2 )
          break;
        v2 = (_WORD *)v1[1];
        ++v1;
        if ( !v2 )
          return v2;
      }
      ++v2;
    }
  }
  return v2;
}
// 9130: using guessed type __int64 __fastcall sub_9130(_QWORD, _QWORD, _QWORD);

//----- (0000000000012430) ----------------------------------------------------
void __fastcall __noreturn sub_12430(unsigned int a1, __int64 a2, char a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  _QWORD **v16; // rbx
  _QWORD *v18; // r14
  __int64 v19; // rax
  __int64 v20; // r15
  _QWORD *v21; // rax
  __int64 v22; // rdx
  __int64 v23; // rdx
  __int64 v24; // rdi
  signed __int64 v25; // rax
  _QWORD *v26; // rax
  void (**v27)(void); // rbx
  signed __int64 v28; // rax
  signed __int64 v29; // rax

  v16 = (_QWORD **)a2;
  while ( 1 )
  {
    _RDX = 1LL;
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C0D68, 1, 0) )
        sub_1C7D0((volatile __int32 *)&dword_C0D68, a2, 1LL, a4, a5, a6);
    }
    else
    {
      __asm { cmpxchg cs:dword_C0D68, edx }
    }
LABEL_4:
    v18 = *v16;
    if ( !*v16 )
    {
      byte_C0D44 = 1;
      if ( __readfsdword(0x18u) )
      {
        if ( _InterlockedExchange((volatile __int32 *)&dword_C0D68, 0) > 1 )
          v29 = sys_futex(&dword_C0D68, 129, 1u, 0LL, a5, a6);
      }
      else
      {
        --dword_C0D68;
      }
      if ( a3 )
      {
        v27 = (void (**)(void))&off_C0308;
        if ( &off_C0308 < (void **)qword_C0310 )
        {
          do
            (*v27++)();
          while ( v27 < qword_C0310 );
        }
      }
      sub_49B40(a1);
    }
    while ( 1 )
    {
      v19 = v18[1];
      if ( !v19 )
        break;
      a5 = (u32 *)(v19 - 1);
      v20 = qword_C0D60;
      v18[1] = v19 - 1;
      if ( __readfsdword(0x18u) )
      {
        if ( _InterlockedExchange((volatile __int32 *)&dword_C0D68, 0) > 1 )
        {
          a2 = 129LL;
          v25 = sys_futex(&dword_C0D68, 129, 1u, 0LL, a5, a6);
        }
      }
      else
      {
        --dword_C0D68;
      }
      v21 = &v18[4 * (_QWORD)a5];
      v22 = v21[2];
      switch ( v22 )
      {
        case 3LL:
          ((void (*)(void))(__readfsqword(0x30u) ^ __ROR8__(v21[3], 17)))();
          break;
        case 4LL:
          v23 = v21[3];
          v24 = v21[4];
          v21[2] = 0LL;
          a2 = a1;
          ((void (__fastcall *)(__int64, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v23, 17)))(v24, a1);
          break;
        case 2LL:
          a2 = v21[4];
          ((void (__fastcall *)(_QWORD, __int64))(__readfsqword(0x30u) ^ __ROR8__(v21[3], 17)))(a1, a2);
          break;
      }
      _RDX = 1LL;
      if ( __readfsdword(0x18u) )
      {
        if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C0D68, 1, 0) )
          sub_1C7D0((volatile __int32 *)&dword_C0D68, a2, 1LL, a4, a5, a6);
      }
      else
      {
        __asm { cmpxchg cs:dword_C0D68, edx }
      }
      if ( qword_C0D60 != v20 )
        goto LABEL_4;
    }
    v26 = (_QWORD *)*v18;
    *v16 = (_QWORD *)*v18;
    if ( v26 )
      sub_21B70((__int64)v18, a7, a8, a9, a10, a11, a12, a13, a14, a2, _RDX, a4, a5, a6);
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedExchange((volatile __int32 *)&dword_C0D68, 0) > 1 )
      {
        a2 = 129LL;
        v28 = sys_futex(&dword_C0D68, 129, 1u, 0LL, a5, a6);
      }
    }
    else
    {
      --dword_C0D68;
    }
  }
}
// 124F5: variable 'a5' is possibly undefined
// 12588: variable 'a4' is possibly undefined
// 12588: variable 'a6' is possibly undefined
// 125DE: variable 'a11' is possibly undefined
// 125DE: variable 'a12' is possibly undefined
// 125DE: variable '_RDX' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);
// C0308: using guessed type void *off_C0308;
// C0D44: using guessed type char byte_C0D44;
// C0D60: using guessed type __int64 qword_C0D60;

//----- (00000000000126E0) ----------------------------------------------------
void __fastcall __noreturn sub_126E0(unsigned int a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, u32 *a13, __int64 a14)
{
  sub_12430(a1, (__int64)&off_BE048, 1, 1uLL, a13, a14, a2, a3, a4, a5, a6, a7, a8, a9);
}
// BE048: using guessed type void *off_BE048;

//----- (0000000000012700) ----------------------------------------------------
_QWORD *__fastcall sub_12700(_QWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, u32 *a13, __int64 a14)
{
  _QWORD *v15; // rbp
  _QWORD *v16; // rsi
  _QWORD *v17; // rdi
  __int64 i; // rax
  __int64 v19; // rcx
  _QWORD *v20; // rax
  _QWORD *v21; // r8
  _QWORD *result; // rax
  _QWORD *v23; // rax

  if ( byte_C0D44 )
    return 0LL;
  v15 = (_QWORD *)*a1;
  if ( !*a1 )
    sub_CF00((__int64)"l != NULL", (__int64)"cxa_atexit.c", 0x70u, "__new_exitfn", a2, a3, a4, a5, a6, a7, a8, a9);
  v16 = (_QWORD *)*a1;
  v17 = 0LL;
LABEL_4:
  for ( i = v16[1]; ; --i )
  {
    if ( !i )
    {
      v20 = (_QWORD *)*v16;
      v16[1] = 0LL;
      v17 = v16;
      if ( v20 )
      {
        v16 = v20;
        goto LABEL_4;
      }
      goto LABEL_16;
    }
    v19 = 4 * (i - 1);
    if ( v16[v19 + 2] )
      break;
  }
  if ( i != 32 )
  {
    v16[1] = i + 1;
    v21 = &v16[4 * i + 2];
LABEL_12:
    *v21 = 1LL;
    result = v21;
    ++qword_C0D60;
    return result;
  }
  v16 = v17;
  if ( v17 )
  {
LABEL_16:
    v16[1] = 1LL;
    v21 = v16 + 2;
    goto LABEL_12;
  }
  v23 = (_QWORD *)sub_22260(1uLL, 0x410uLL, a2, a3, a4, a5, a6, a7, a8, a9, i - 1, v19 * 8, a13, a14);
  v16 = v23;
  if ( v23 )
  {
    *v23 = v15;
    *a1 = v23;
    goto LABEL_16;
  }
  return 0LL;
}
// C0D44: using guessed type char byte_C0D44;
// C0D60: using guessed type __int64 qword_C0D60;

//----- (0000000000012970) ----------------------------------------------------
__int64 __fastcall sub_12970(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, u32 *a13, __int64 a14)
{
  _QWORD *v16; // rax
  u32 v17; // er9
  __int64 v18; // rdi
  __int64 v19; // r8
  signed __int64 v21; // rax
  void **v22; // rcx

  v22 = &off_BE048;
  if ( !a1 )
    sub_CF00(
      (__int64)"func != NULL",
      (__int64)"cxa_atexit.c",
      0x29u,
      "__internal_atexit",
      a4,
      a5,
      a6,
      a7,
      a8,
      a9,
      a10,
      a11);
  if ( __readfsdword(0x18u) )
  {
    _RDX = 1LL;
    if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C0D68, 1, 0) )
      sub_1C7D0((volatile __int32 *)&dword_C0D68, a2, 1LL, (__int64)&off_BE048, a13, a14);
  }
  else
  {
    _RDX = 1LL;
    __asm { cmpxchg cs:dword_C0D68, edx }
  }
  v16 = sub_12700(&off_BE048, a4, a5, a6, a7, a8, a9, a10, a11, a2, _RDX, (__int64)v22, a13, a14);
  if ( !v16 )
  {
    if ( !__readfsdword(0x18u) )
    {
      --dword_C0D68;
      LODWORD(v19) = -1;
      return (unsigned int)v19;
    }
    v19 = 0xFFFFFFFFLL;
    if ( _InterlockedExchange((volatile __int32 *)&dword_C0D68, 0) <= 1 )
      return (unsigned int)v19;
    goto LABEL_11;
  }
  v16[2] = a2;
  v18 = __ROL8__(__readfsqword(0x30u) ^ a1, 17);
  v16[3] = a3;
  v16[1] = v18;
  *v16 = 4LL;
  LODWORD(v19) = __readfsdword(0x18u);
  if ( (_DWORD)v19 )
  {
    v19 = 0LL;
    if ( _InterlockedExchange((volatile __int32 *)&dword_C0D68, 0) <= 1 )
      return (unsigned int)v19;
LABEL_11:
    v21 = sys_futex(&dword_C0D68, 129, 1u, 0LL, (u32 *)v19, v17);
    return (unsigned int)v19;
  }
  --dword_C0D68;
  return (unsigned int)v19;
}
// 1285E: variable 'a8' is possibly undefined
// 1285E: variable 'a9' is possibly undefined
// 1285E: variable '_RDX' is possibly undefined
// 1285E: variable 'v22' is possibly undefined
// 1285E: variable 'a13' is possibly undefined
// 1285E: variable 'a14' is possibly undefined
// 128A8: variable 'v19' is possibly undefined
// 12909: variable 'v17' is possibly undefined
// BE048: using guessed type void *off_BE048;

//----- (00000000000129A0) ----------------------------------------------------
unsigned __int64 __fastcall sub_129A0(char *a1, unsigned __int8 **a2, unsigned int a3)
{
  unsigned __int64 v3; // r8
  unsigned __int8 *v4; // r13
  signed int v5; // esi
  __int64 v6; // rcx
  char *v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rdx
  unsigned __int8 *v10; // rbx
  __int64 v11; // rdx
  int v12; // eax
  unsigned __int64 v13; // rdi
  unsigned __int8 *v14; // rcx
  unsigned __int64 v15; // r8
  int v16; // er9
  unsigned __int8 v17; // al
  __int64 v19; // rax
  unsigned __int8 v21; // [rsp+Ah] [rbp-46h]
  int v22; // [rsp+Ch] [rbp-44h]

  v3 = __readfsqword(0xFFFFFFA8);
  v4 = (unsigned __int8 *)a1;
  v5 = a3;
  if ( a3 == 1 || a3 > 0x24 )
  {
    v15 = 0LL;
    __writefsdword(0xFFFFFFC0, 0x16u);
    return v15;
  }
  v6 = *(_QWORD *)(v3 + 104);
  v7 = a1;
  v8 = *a1;
  if ( (*(_BYTE *)(v6 + 2 * v8 + 1) & 0x20) != 0 )
  {
    do
    {
      v9 = *++v7;
      LOBYTE(v8) = v9;
    }
    while ( (*(_BYTE *)(v6 + 2 * v9 + 1) & 0x20) != 0 );
  }
  if ( !(_BYTE)v8 )
  {
    if ( a2 )
      goto LABEL_42;
    return 0LL;
  }
  if ( (_BYTE)v8 == 45 )
  {
    v11 = (unsigned __int8)v7[1];
    v10 = (unsigned __int8 *)(v7 + 1);
    v22 = 1;
    if ( (_BYTE)v11 != 48 )
      goto LABEL_8;
LABEL_35:
    if ( (v5 & 0xFFFFFFEF) == 0 )
    {
      if ( dword_968A0[(char)v10[1]] == 88 )
      {
        v11 = v10[2];
        v12 = 14;
        v10 += 2;
        v5 = 16;
        goto LABEL_10;
      }
      if ( !v5 )
      {
        v5 = 8;
        v11 = 48LL;
        v13 = 0x1FFFFFFFFFFFFFFFLL;
        v21 = 7;
        goto LABEL_12;
      }
    }
    if ( v5 == 10 )
    {
      v13 = 0x1999999999999999LL;
      v11 = 48LL;
      v21 = 5;
    }
    else
    {
      v19 = v5 - 2;
      v13 = qword_A3820[v19];
      v11 = 48LL;
      v21 = *((_BYTE *)&off_A37E0 + v19);
    }
    goto LABEL_12;
  }
  v22 = 0;
  v10 = (unsigned __int8 *)&v7[(_BYTE)v8 == 43];
  v11 = *v10;
  if ( (_BYTE)v11 == 48 )
    goto LABEL_35;
LABEL_8:
  if ( !v5 || v5 == 10 )
  {
    v12 = 8;
    v5 = 10;
  }
  else
  {
    v12 = v5 - 2;
  }
LABEL_10:
  v13 = qword_A3820[v12];
  v21 = *((_BYTE *)&off_A37E0 + v12);
  if ( !(_BYTE)v11 || !v10 )
  {
    v14 = v10;
    goto LABEL_39;
  }
LABEL_12:
  v14 = v10;
  v15 = 0LL;
  v16 = 0;
  do
  {
    v17 = v11 - 48;
    if ( (unsigned __int8)(v11 - 48) > 9u )
    {
      if ( (byte_971A0[2 * v11 + 1] & 4) == 0 )
        break;
      v17 = dword_968A0[v11] - 55;
    }
    if ( v17 >= v5 )
      break;
    if ( v13 < v15 || v13 == v15 && v17 > v21 )
    {
      v16 = 1;
      v11 = *++v14;
      if ( !(_BYTE)v11 )
        break;
    }
    else
    {
      v15 = v17 + v5 * v15;
      v11 = *++v14;
      if ( !(_BYTE)v11 )
        break;
    }
  }
  while ( v14 );
  if ( v10 == v14 )
  {
LABEL_39:
    if ( a2 )
    {
      if ( v14 - v4 > 1 && dword_968A0[(char)*(v14 - 1)] == 88 && *(v14 - 2) == 48 )
      {
        *a2 = v14 - 1;
        return 0LL;
      }
LABEL_42:
      v15 = 0LL;
      *a2 = v4;
      return v15;
    }
    return 0LL;
  }
  if ( a2 )
    *a2 = v14;
  if ( v16 )
  {
    v15 = -1LL;
    __writefsdword(0xFFFFFFC0, 0x22u);
  }
  else if ( v22 )
  {
    v15 = -(__int64)v15;
  }
  return v15;
}
// 12A65: conditional instruction was optimized away because of 'r14.8==0'
// 12B00: conditional instruction was optimized away because of 'rbp.8==0'
// 12D5C: conditional instruction was optimized away because of 'r14.8==0'
// A37E0: using guessed type void *off_A37E0;

//----- (0000000000012E90) ----------------------------------------------------
unsigned __int64 __fastcall sub_12E90(unsigned __int64 a1, unsigned __int64 a2, char *a3, char *a4)
{
  unsigned __int64 v4; // r12
  __int64 v7; // rax
  __int64 v8; // r9
  unsigned __int64 v9; // r13
  __int64 v10; // rbp
  unsigned __int64 v11; // r8
  char v12; // di
  _BYTE *v13; // rax
  unsigned __int64 v14; // rsi
  char v15; // dl
  char *v16; // r10
  _BYTE *v17; // rcx
  __int64 v18; // rdx
  __int64 v19; // rax
  bool v20; // cc
  char *v22; // r14
  unsigned __int64 v23; // r11
  signed __int64 v24; // r10
  unsigned __int64 v25; // rsi
  _BYTE *v26; // rdx
  char *v27; // rcx
  char v28; // al
  _BYTE *v29; // rdx
  char *v30; // rcx
  char v31; // al
  signed __int64 v32; // r11
  __int64 v34; // [rsp+10h] [rbp-48h]
  unsigned __int64 v35; // [rsp+18h] [rbp-40h]

  v4 = a2;
  if ( !a4 )
    return v4;
  v7 = strlen((__int64)a3);
  if ( a2 <= a1 )
    goto LABEL_17;
  v8 = v7 - 1;
  v34 = v7 - 3;
  v9 = a1 + v7 - 3;
  v10 = 2 - v7;
  v11 = a1 - 1;
  while ( 2 )
  {
    if ( a1 > v4 - 1 )
      return v4;
    v12 = *a3;
    v13 = (_BYTE *)(v4 + v34);
    while ( 1 )
    {
      v14 = (unsigned __int64)&v13[v10];
      if ( v13[1] == v12 )
        break;
LABEL_6:
      if ( --v13 == (_BYTE *)v9 )
        return v4;
    }
    v15 = a3[1];
    if ( v15 )
    {
      v16 = a3 + 2;
      v17 = v13;
      while ( *v17 == v15 )
      {
        v15 = *v16;
        --v17;
        ++v16;
        if ( !v15 )
          goto LABEL_12;
      }
      goto LABEL_6;
    }
LABEL_12:
    if ( a1 > v14 )
      return v4;
    v18 = *a4;
    v19 = (int)v18 + 1;
    v20 = (__int64)(v4 - v14) <= v19;
    if ( v4 - v14 != v19 )
    {
      v4 = v14 + v18 + 1;
      if ( v20 )
        v4 = v14;
LABEL_16:
      if ( v4 <= a1 )
      {
LABEL_17:
        if ( v4 < a1 )
          v4 = a1;
        return v4;
      }
      continue;
    }
    break;
  }
  v22 = a4;
  v23 = v14 - 1;
  v35 = v14 - 1;
  v24 = a4[1];
  if ( !(_BYTE)v24 )
    goto LABEL_31;
LABEL_21:
  ++v22;
  if ( (unsigned __int8)v24 <= 0x7Eu )
  {
    while ( a1 <= v23 )
    {
      v25 = v23;
      while ( v12 )
      {
        v29 = (_BYTE *)(v25 + v8);
        v30 = a3 + 1;
        v31 = *a3;
        while ( *v29 == v31 )
        {
          v31 = *v30;
          --v29;
          ++v30;
          if ( !v31 )
            goto LABEL_42;
        }
        if ( --v25 == v11 )
        {
          v32 = v23 - v11;
LABEL_40:
          if ( v24 >= v32 )
            return v4;
          goto LABEL_41;
        }
      }
LABEL_42:
      v32 = v23 - v25;
      if ( a1 > v25 )
        goto LABEL_40;
      if ( v32 != v24 )
      {
LABEL_41:
        v4 = v35;
        goto LABEL_16;
      }
LABEL_30:
      v24 = v22[1];
      v23 = v25 - 1;
      if ( (_BYTE)v24 )
        goto LABEL_21;
LABEL_31:
      v24 = *v22;
      if ( (unsigned __int8)v24 > 0x7Eu )
        goto LABEL_22;
    }
  }
  else
  {
LABEL_22:
    if ( a1 <= v23 )
    {
      v25 = v23;
      if ( v12 )
      {
        do
        {
          v26 = (_BYTE *)(v25 + v8);
          v27 = a3 + 1;
          v28 = *a3;
          while ( *v26 == v28 )
          {
            v28 = *v27;
            --v26;
            ++v27;
            if ( !v28 )
              goto LABEL_29;
          }
          --v25;
        }
        while ( v11 != v25 );
      }
      else
      {
LABEL_29:
        if ( a1 <= v25 )
          goto LABEL_30;
      }
    }
  }
  return v4;
}
// 12FFF: conditional instruction was optimized away because of 'di.1!=0'

//----- (00000000000130A0) ----------------------------------------------------
__int64 sub_130A0(__int64 *a1, unsigned __int64 a2, ...)
{
  __m128 v2; // xmm0
  __m128i v3; // xmm2
  __m128 v4; // xmm3
  __va_list_tag va[1]; // [rsp+0h] [rbp-D8h] BYREF
  unsigned __int64 v7; // [rsp+18h] [rbp-C0h]
  __int128 v8; // [rsp+50h] [rbp-88h]
  __int128 v9; // [rsp+60h] [rbp-78h]
  __int128 v10; // [rsp+70h] [rbp-68h]
  __int128 v11; // [rsp+80h] [rbp-58h]
  __int128 v12; // [rsp+90h] [rbp-48h]
  __int128 v13; // [rsp+A0h] [rbp-38h]
  __int128 v14; // [rsp+B0h] [rbp-28h]
  __int128 v15; // [rsp+C0h] [rbp-18h]

  va_start(va, a2);
  *(double *)&v8 = va_arg(va, double);
  v2.m128_u64[0] = v8;
  *(double *)&v9 = va_arg(va, double);
  *(double *)&v10 = va_arg(va, double);
  v3.m128i_i64[0] = v10;
  *(double *)&v11 = va_arg(va, double);
  v4.m128_u64[0] = v11;
  *(double *)&v12 = va_arg(va, double);
  *(double *)&v13 = va_arg(va, double);
  *(double *)&v14 = va_arg(va, double);
  *(double *)&v15 = va_arg(va, double);
  va_end(va);
  va_start(va, a2);
  v7 = __readfsqword(0x28u);
  return sub_16D00(
           a1,
           a2,
           (__m128i *)va,
           0,
           v2,
           *(double *)&v9,
           v3,
           v4,
           *(double *)&v12,
           *(double *)&v13,
           *(double *)&v14,
           *(double *)&v15);
}
// 13135: variable 'v2' is possibly undefined
// 13135: variable 'v3' is possibly undefined
// 13135: variable 'v4' is possibly undefined

//----- (0000000000013160) ----------------------------------------------------
unsigned __int64 __fastcall sub_13160(__int64 a1, _BYTE *a2, unsigned int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  const char *v11; // r12
  const char *v12; // r13
  const char *v13; // rax
  char v15[1032]; // [rsp+0h] [rbp-428h] BYREF
  unsigned __int64 v16; // [rsp+408h] [rbp-20h]

  v16 = __readfsqword(0x28u);
  if ( !a2 || (v11 = a2, v12 = ": ", !*a2) )
  {
    v12 = (const char *)&unk_A6E65;
    v11 = (const char *)&unk_A6E65;
  }
  v13 = (const char *)sub_23140(a3, v15, 1024LL, a4, a5, a6, a7, a8, a9, a10, a11);
  sub_13580((_QWORD *)a1, (__int64)"%s%s%s\n", v11, v12, v13);
  return v16 - __readfsqword(0x28u);
}

//----- (0000000000013200) ----------------------------------------------------
__int64 __fastcall perror(char *a1)
{
  double v1; // xmm0_8
  double v2; // xmm1_8
  double v3; // xmm2_8
  double v4; // xmm3_8
  double v5; // xmm4_8
  double v6; // xmm5_8
  double v7; // xmm6_8
  double v8; // xmm7_8
  void *v10; // rdi
  unsigned int v11; // er12
  unsigned int v13; // edi
  int v14; // eax
  __int64 v15; // rax
  double v16; // xmm4_8
  double v17; // xmm5_8
  int *v18; // r13
  __int64 v19; // rdx
  __int64 v20; // rcx
  u32 *v21; // r8
  u32 v22; // er9
  unsigned int a1a; // [rsp+Ch] [rbp-1Ch]

  v10 = stderr;
  v11 = __readfsdword(0xFFFFFFC0);
  if ( *((_DWORD *)stderr + 48) )
    return sub_13160((__int64)v10, a1, v11, v1, v2, v3, v4, v5, v6, v7, v8);
  v13 = sub_16CC0(stderr);
  if ( v13 == -1 || (v14 = sub_4AF10(v13), v14 == -1) )
  {
LABEL_4:
    v10 = stderr;
    return sub_13160((__int64)v10, a1, v11, v1, v2, v3, v4, v5, v6, v7, v8);
  }
  a1a = v14;
  v15 = fdopen(v14, "w+");
  v18 = (int *)v15;
  if ( !v15 )
  {
    close(a1a);
    goto LABEL_4;
  }
  sub_13160(v15, a1, v11, v1, v2, v3, v4, v16, v17, v7, v8);
  if ( (*(_BYTE *)v18 & 0x20) != 0 )
    *(_DWORD *)stderr |= 0x20u;
  return sub_137F0(v18, (__int64)a1, v19, v20, v21, v22);
}
// 1323B: variable 'v1' is possibly undefined
// 1323B: variable 'v2' is possibly undefined
// 1323B: variable 'v3' is possibly undefined
// 1323B: variable 'v4' is possibly undefined
// 1323B: variable 'v5' is possibly undefined
// 1323B: variable 'v6' is possibly undefined
// 1323B: variable 'v7' is possibly undefined
// 1323B: variable 'v8' is possibly undefined
// 13285: variable 'v16' is possibly undefined
// 13285: variable 'v17' is possibly undefined
// 132A7: variable 'v19' is possibly undefined
// 132A7: variable 'v20' is possibly undefined
// 132A7: variable 'v21' is possibly undefined
// 132A7: variable 'v22' is possibly undefined

//----- (00000000000132C0) ----------------------------------------------------
__int64 __fastcall sub_132C0(__int64 a1)
{
  __int64 result; // rax

  result = sub_4B740();
  if ( (_DWORD)result )
  {
    if ( __readfsdword(0xFFFFFFC0) == 21 )
      result = (unsigned int)-((unsigned int)sub_4B770(a1) != 0);
    else
      result = 0xFFFFFFFFLL;
  }
  return result;
}
// 4B740: using guessed type __int64 sub_4B740(void);
// 4B770: using guessed type __int64 __fastcall sub_4B770(_QWORD);

//----- (0000000000013300) ----------------------------------------------------
__int64 __fastcall sub_13300(__int64 a1, __int64 a2, __m128i *a3, unsigned int a4, __m128 a5, double a6, __m128i a7, __m128 a8, double a9, double a10, double a11, double a12)
{
  unsigned __int64 v14; // rbx
  _BOOL4 v15; // eax
  __int64 v16; // rdx
  __int64 v17; // rcx
  u32 *v18; // r8
  __int64 v19; // r9
  double v20; // xmm4_8
  double v21; // xmm5_8
  void *v22; // rsp
  u32 *v23; // r8
  u32 v24; // er9
  double v25; // xmm4_8
  double v26; // xmm5_8
  __int64 result; // rax
  __int64 v28; // rax
  __int64 v29; // r8
  __int64 v30; // r9
  double v31; // xmm4_8
  double v32; // xmm5_8
  __int64 v33; // r12
  unsigned int v34; // eax
  u32 *v35; // r8
  u32 v36; // er9
  double v37; // xmm4_8
  double v38; // xmm5_8
  _BYTE v39[4]; // [rsp+0h] [rbp-50h] BYREF
  unsigned int v40; // [rsp+4h] [rbp-4Ch]
  __int64 v41; // [rsp+8h] [rbp-48h] BYREF
  __int64 v42[8]; // [rsp+10h] [rbp-40h] BYREF

  v41 = a2;
  v42[1] = __readfsqword(0x28u);
  if ( *(int *)(a1 + 192) <= 0 )
    return sub_61370(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
  v14 = strlen(a2) + 1;
  if ( v14 > 0x3FFFFFFFFFFFFFFFLL )
  {
    __writefsdword(0xFFFFFFC0, 0x4Bu);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v15 = sub_1C780(4 * v14);
    if ( 4 * v14 <= 0x1000 || v15 )
    {
      v42[0] = 0LL;
      v22 = alloca(4 * v14 + 8);
      if ( (unsigned int)sub_49010(
                           (__int64)v39,
                           &v41,
                           (void **)v14,
                           v42,
                           *(double *)a5.m128_u64,
                           a6,
                           *(double *)a7.m128i_i64,
                           *(double *)a8.m128_u64,
                           v20,
                           v21,
                           a11,
                           a12,
                           (__int64)v18,
                           v19) == -1 )
        return 0xFFFFFFFFLL;
      result = sub_66830((_QWORD *)a1, (__int64)v39, a3, a4, v23, v24, a5, a6, a7, a8, v25, v26, a11, a12);
    }
    else
    {
      v28 = sub_21500(
              (u32 *)(4 * v14),
              a2,
              v16,
              v17,
              v18,
              v19,
              *(double *)a5.m128_u64,
              a6,
              *(double *)a7.m128i_i64,
              *(double *)a8.m128_u64,
              v20,
              v21,
              a11,
              a12);
      v33 = v28;
      if ( !v28 )
        return 0xFFFFFFFFLL;
      v42[0] = 0LL;
      v34 = sub_49010(
              v28,
              &v41,
              (void **)v14,
              v42,
              *(double *)a5.m128_u64,
              a6,
              *(double *)a7.m128i_i64,
              *(double *)a8.m128_u64,
              v31,
              v32,
              a11,
              a12,
              v29,
              v30);
      if ( v34 != -1 )
        v34 = sub_66830((_QWORD *)a1, v33, a3, a4, v35, v36, a5, a6, a7, a8, v37, v38, a11, a12);
      v40 = v34;
      sub_21B70(v33);
      result = v40;
    }
  }
  return result;
}
// 133A6: variable 'v20' is possibly undefined
// 133A6: variable 'v21' is possibly undefined
// 133A6: variable 'v18' is possibly undefined
// 133A6: variable 'v19' is possibly undefined
// 133EC: variable 'v23' is possibly undefined
// 133EC: variable 'v24' is possibly undefined
// 133EC: variable 'v25' is possibly undefined
// 133EC: variable 'v26' is possibly undefined
// 13420: variable 'v16' is possibly undefined
// 13420: variable 'v17' is possibly undefined
// 13443: variable 'v31' is possibly undefined
// 13443: variable 'v32' is possibly undefined
// 13443: variable 'v29' is possibly undefined
// 13443: variable 'v30' is possibly undefined
// 13459: variable 'v35' is possibly undefined
// 13459: variable 'v36' is possibly undefined
// 13459: variable 'v37' is possibly undefined
// 13459: variable 'v38' is possibly undefined
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (0000000000013480) ----------------------------------------------------
__int64 __fastcall sub_13480(_QWORD *a1, __int64 a2, __m128i *a3, __int64 a4, __m128 a5, double a6, __m128i a7, __m128 a8, double a9, double a10, double a11, double a12, __int64 a13, u32 a14)
{
  _QWORD *v15; // rbx
  __int64 v16; // rdx
  unsigned __int64 v18; // rbp
  u32 *v20; // r8
  u32 v21; // er9
  __int64 v22; // rdi
  int v23; // eax
  signed __int64 v25; // rax
  int v26; // [rsp+Ch] [rbp-1Ch]

  v15 = a1;
  if ( !a1 )
    v15 = stderr;
  v16 = *(_DWORD *)v15 & 0x8000;
  if ( (*(_DWORD *)v15 & 0x8000) == 0 )
  {
    _RDI = v15[17];
    v18 = __readfsqword(0x10u);
    if ( *(_QWORD *)(_RDI + 8) != v18 )
    {
      if ( __readfsdword(0x18u) )
      {
        if ( (_DWORD)v16 != _InterlockedCompareExchange((volatile signed __int32 *)_RDI, 1, v16) )
        {
          v26 = a4;
          sub_1C7D0((volatile __int32 *)_RDI, a2, v16, a4, (u32 *)((char *)&dword_0 + 1), a14);
          LODWORD(a4) = v26;
        }
      }
      else
      {
        _EDX = 1;
        __asm { cmpxchg [rdi], edx }
      }
      _RDI = v15[17];
      *(_QWORD *)(_RDI + 8) = v18;
    }
    ++*(_DWORD *)(_RDI + 4);
  }
  v20 = (u32 *)(unsigned int)sub_13300((__int64)v15, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
  if ( (*(_DWORD *)v15 & 0x8000) == 0 )
  {
    v22 = v15[17];
    v23 = *(_DWORD *)(v22 + 4) - 1;
    *(_DWORD *)(v22 + 4) = v23;
    if ( !v23 )
    {
      *(_QWORD *)(v22 + 8) = 0LL;
      if ( __readfsdword(0x18u) )
      {
        if ( _InterlockedExchange((volatile __int32 *)v22, 0) > 1 )
          v25 = sys_futex((u32 *)v22, 129, 1u, 0LL, v20, v21);
      }
      else
      {
        --*(_DWORD *)v22;
      }
    }
  }
  return (unsigned int)v20;
}
// 134E6: variable 'a9' is possibly undefined
// 134E6: variable 'a10' is possibly undefined
// 13523: variable 'v20' is possibly undefined
// 13579: variable 'v21' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);

//----- (0000000000013580) ----------------------------------------------------
__int64 sub_13580(_QWORD *a1, __int64 a2, ...)
{
  __m128 v2; // xmm0
  __m128i v3; // xmm2
  __m128 v4; // xmm3
  __va_list_tag va[1]; // [rsp+0h] [rbp-D8h] BYREF
  unsigned __int64 v7; // [rsp+18h] [rbp-C0h]
  __int64 v8; // [rsp+30h] [rbp-A8h]
  __int64 v9; // [rsp+38h] [rbp-A0h]
  __int64 v10; // [rsp+40h] [rbp-98h]
  __int64 v11; // [rsp+48h] [rbp-90h]
  __int128 v12; // [rsp+50h] [rbp-88h]
  __int128 v13; // [rsp+60h] [rbp-78h]
  __int128 v14; // [rsp+70h] [rbp-68h]
  __int128 v15; // [rsp+80h] [rbp-58h]
  __int128 v16; // [rsp+90h] [rbp-48h]
  __int128 v17; // [rsp+A0h] [rbp-38h]
  __int128 v18; // [rsp+B0h] [rbp-28h]
  __int128 v19; // [rsp+C0h] [rbp-18h]

  va_start(va, a2);
  v8 = va_arg(va, _QWORD);
  v9 = va_arg(va, _QWORD);
  v10 = va_arg(va, _QWORD);
  v11 = va_arg(va, _QWORD);
  *(double *)&v12 = va_arg(va, double);
  v2.m128_u64[0] = v12;
  *(double *)&v13 = va_arg(va, double);
  *(double *)&v14 = va_arg(va, double);
  v3.m128i_i64[0] = v14;
  *(double *)&v15 = va_arg(va, double);
  v4.m128_u64[0] = v15;
  *(double *)&v16 = va_arg(va, double);
  *(double *)&v17 = va_arg(va, double);
  *(double *)&v18 = va_arg(va, double);
  *(double *)&v19 = va_arg(va, double);
  va_end(va);
  va_start(va, a2);
  v7 = __readfsqword(0x28u);
  return sub_13480(
           a1,
           a2,
           (__m128i *)va,
           0LL,
           v2,
           *(double *)&v13,
           v3,
           v4,
           *(double *)&v16,
           *(double *)&v17,
           *(double *)&v18,
           *(double *)&v19,
           v10,
           v11);
}
// 13615: variable 'v2' is possibly undefined
// 13615: variable 'v3' is possibly undefined
// 13615: variable 'v4' is possibly undefined

//----- (00000000000137F0) ----------------------------------------------------
__int64 __fastcall sub_137F0(int *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  int v7; // eax
  __int64 v8; // rdx
  unsigned int v9; // er12
  __int64 v10; // rdi
  __int64 v12; // rbx
  _QWORD *v13; // rbx
  u32 *v15; // r8
  u32 v16; // er9
  unsigned __int64 v19; // rbx
  signed __int64 v21; // rax
  signed __int64 v22; // rax

  v7 = *a1;
  if ( (*a1 & 0x2000) != 0 )
  {
    sub_19CF0();
    v7 = *a1;
    if ( (BYTE1(*a1) & 0x80u) != 0 )
      goto LABEL_23;
  }
  else
  {
    LODWORD(v8) = *a1 & 0x8000;
    if ( (v7 & 0x8000) != 0 )
      goto LABEL_3;
  }
  _RDI = *((_QWORD *)a1 + 17);
  v19 = __readfsqword(0x10u);
  if ( *(_QWORD *)(_RDI + 8) != v19 )
  {
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedCompareExchange((volatile signed __int32 *)_RDI, 1, 0) )
        sub_1C7D0(_RDI);
    }
    else
    {
      _EDX = 1;
      __asm { cmpxchg [rdi], edx }
    }
    _RDI = *((_QWORD *)a1 + 17);
    v7 = *a1;
    *(_QWORD *)(_RDI + 8) = v19;
  }
  ++*(_DWORD *)(_RDI + 4);
LABEL_23:
  v8 = (unsigned __int16)v7 & 0x8000;
  if ( (v7 & 0x2000) != 0 )
  {
    v9 = sub_18D60(a1, a2, v8);
    LODWORD(v8) = *a1 & 0x8000;
    goto LABEL_4;
  }
LABEL_3:
  v9 = v7 << 26 >> 31;
LABEL_4:
  if ( !(_DWORD)v8 )
  {
    v10 = *((_QWORD *)a1 + 17);
    if ( (*(_DWORD *)(v10 + 4))-- == 1 )
    {
      *(_QWORD *)(v10 + 8) = 0LL;
      if ( __readfsdword(0x18u) )
      {
        if ( _InterlockedExchange((volatile __int32 *)v10, 0) > 1 )
          v22 = sys_futex((u32 *)v10, 129, 1u, 0LL, a5, a6);
      }
      else
      {
        --*(_DWORD *)v10;
      }
    }
  }
  v12 = *((_QWORD *)a1 + 27);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v12 - (_QWORD)&unk_BFAE0) )
    sub_17140();
  (*(void (__fastcall **)(int *, _QWORD))(v12 + 16))(a1, 0LL);
  if ( a1[48] <= 0 )
  {
    if ( *((_QWORD *)a1 + 9) )
      sub_1A100(a1);
  }
  else
  {
    v13 = (_QWORD *)*((_QWORD *)a1 + 19);
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C14E8, 1, 0) )
        sub_1C7D0(&dword_C14E8);
    }
    else
    {
      _EDX = 1;
      __asm { cmpxchg cs:dword_C14E8, edx }
    }
    sub_51660(*v13);
    sub_51660(v13[7]);
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedExchange((volatile __int32 *)&dword_C14E8, 0) > 1 )
        v21 = sys_futex(&dword_C14E8, 129, 1u, 0LL, v15, v16);
    }
    else
    {
      --dword_C14E8;
    }
  }
  if ( a1 != (int *)&unk_BE440 && a1 != (int *)&unk_BE260 && a1 != (int *)&unk_BE080 )
    sub_21B70(a1);
  return v9;
}
// 13A1A: variable 'v15' is possibly undefined
// 13A1A: variable 'v16' is possibly undefined
// 13A65: variable 'a5' is possibly undefined
// 13A65: variable 'a6' is possibly undefined
// 17140: using guessed type __int64 sub_17140(void);
// 18D60: using guessed type __int64 __fastcall sub_18D60(_QWORD, _QWORD, _QWORD);
// 19CF0: using guessed type __int64 sub_19CF0(void);
// 1A100: using guessed type __int64 __fastcall sub_1A100(_QWORD);
// 1C7D0: using guessed type __int64 __fastcall sub_1C7D0(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// 51660: using guessed type __int64 __fastcall sub_51660(_QWORD);
// C0308: using guessed type void *off_C0308;

//----- (0000000000013A80) ----------------------------------------------------
__int64 __fastcall fdopen(int a1, char *a2)
{
  double v2; // xmm0_8
  double v3; // xmm1_8
  double v4; // xmm2_8
  double v5; // xmm3_8
  double v6; // xmm4_8
  double v7; // xmm5_8
  double v8; // xmm6_8
  double v9; // xmm7_8
  char v10; // al
  __int64 v11; // r15
  int v13; // er12
  char *v14; // rdx
  int v15; // er13
  char v16; // al
  __int64 v17; // rsi
  unsigned int v18; // eax
  __int64 v19; // rcx
  u32 *v20; // r8
  u32 v21; // er9
  double v22; // xmm4_8
  double v23; // xmm5_8
  __int64 v24; // rdx
  char v25; // r14
  __int64 v26; // rax
  __int64 v27; // rbp
  _QWORD *v28; // rcx
  __int64 v29; // rdx
  __int64 v30; // rcx
  u32 *v31; // r8
  u32 v32; // er9
  void *v33; // rax
  double v34; // xmm4_8
  double v35; // xmm5_8
  int v36; // eax
  __int64 v37; // rbx

  v10 = *a2;
  if ( *a2 == 'r' )
  {
    v13 = 8;
  }
  else if ( v10 == 'w' )
  {
    v13 = 4;
  }
  else
  {
    if ( v10 != 97 )
    {
LABEL_4:
      __writefsdword(0xFFFFFFC0, 0x16u);
      return 0LL;
    }
    v13 = 4100;
  }
  v14 = a2 + 4;
  v15 = 0;
  while ( 1 )
  {
    v16 = *++a2;
    if ( v16 == 43 )
      break;
    if ( v16 == 109 )
    {
      v15 = 1;
    }
    else if ( !v16 )
    {
      goto LABEL_13;
    }
    if ( a2 == v14 )
      goto LABEL_13;
  }
  v13 &= 0x1000u;
LABEL_13:
  v17 = 3LL;
  v18 = sub_4AD80(a1, 3u, (unsigned __int64)v14, v2, v3, v4, v5, v6, v7, v8, v9);
  if ( v18 == -1 )
    return 0LL;
  v24 = v18 & 3;
  if ( (v18 & 3) != 0 )
  {
    if ( (_DWORD)v24 == 1 && (v13 & 4) == 0 )
      goto LABEL_4;
  }
  else if ( (v13 & 8) == 0 )
  {
    goto LABEL_4;
  }
  v25 = 0;
  if ( (v13 & 0x1000) != 0 && (v18 & 0x400) == 0 )
  {
    BYTE1(v18) |= 4u;
    v17 = 4LL;
    if ( (unsigned int)sub_4AD80(a1, 4u, v18, v2, v3, v4, v5, v22, v23, v8, v9) == -1 )
      return 0LL;
    v25 = 1;
  }
  v26 = sub_21500((u32 *)&off_1D8, v17, v24, v19, v20, v21, v2, v3, v4, v5, v22, v23, v8, v9);
  v27 = v26;
  if ( !v26 )
    return 0LL;
  v28 = (_QWORD *)(v26 + 240);
  v11 = v26;
  *(_QWORD *)(v26 + 136) = v26 + 224;
  if ( v15 && (v13 & 8) != 0 )
  {
    sub_1AD10(v26, 0, 0, v28, (__int64)&unk_BFBA0);
    v33 = &unk_BFDE0;
  }
  else
  {
    sub_1AD10(v26, 0, 0, v28, (__int64)&unk_BFD20);
    v33 = &unk_BFF60;
  }
  *(_QWORD *)(v27 + 216) = v33;
  sub_18B30(v27, 0LL, v29, v30, v31, v32);
  v36 = *(_DWORD *)v27;
  *(_DWORD *)(v27 + 112) = a1;
  *(_DWORD *)v27 = v13 | v36 & 0xFFFFEFB3;
  if ( v25 )
  {
    if ( (v13 & 0x1004) == 4100 )
    {
      v37 = *(_QWORD *)(v27 + 216);
      if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v37 - (_QWORD)&unk_BFAE0) )
        sub_17140(v2, v3, v4, v5, v34, v35, v8, v9);
      if ( (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(v37 + 128))(v27, 0LL, 2LL) == -1
        && __readfsdword(0xFFFFFFC0) != 29 )
      {
        return 0LL;
      }
    }
  }
  return v11;
}
// 13B07: variable 'v2' is possibly undefined
// 13B07: variable 'v3' is possibly undefined
// 13B07: variable 'v4' is possibly undefined
// 13B07: variable 'v5' is possibly undefined
// 13B07: variable 'v6' is possibly undefined
// 13B07: variable 'v7' is possibly undefined
// 13B07: variable 'v8' is possibly undefined
// 13B07: variable 'v9' is possibly undefined
// 13B3C: variable 'v24' is possibly undefined
// 13B3C: variable 'v19' is possibly undefined
// 13B3C: variable 'v20' is possibly undefined
// 13B3C: variable 'v21' is possibly undefined
// 13B3C: variable 'v22' is possibly undefined
// 13B3C: variable 'v23' is possibly undefined
// 13B98: variable 'v29' is possibly undefined
// 13B98: variable 'v30' is possibly undefined
// 13B98: variable 'v31' is possibly undefined
// 13B98: variable 'v32' is possibly undefined
// 13CC7: variable 'v34' is possibly undefined
// 13CC7: variable 'v35' is possibly undefined
// 1D8: using guessed type void *;
// C0308: using guessed type void *off_C0308;

//----- (0000000000013CE0) ----------------------------------------------------
__int64 __fastcall sub_13CE0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v15; // rdx
  unsigned __int64 v17; // rbp
  __int64 v19; // rbp
  u32 *v20; // r8
  u32 v21; // er9
  __int64 v22; // rdi
  int v23; // eax
  signed __int64 v25; // rax

  if ( !a1 )
    return sub_1B030(1, a2, a7, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6);
  v15 = *(_DWORD *)a1 & 0x8000;
  if ( (*(_DWORD *)a1 & 0x8000) == 0 )
  {
    _RDI = *(_QWORD *)(a1 + 136);
    v17 = __readfsqword(0x10u);
    if ( *(_QWORD *)(_RDI + 8) != v17 )
    {
      if ( __readfsdword(0x18u) )
      {
        if ( (_DWORD)v15 != _InterlockedCompareExchange((volatile signed __int32 *)_RDI, 1, v15) )
          sub_1C7D0((volatile __int32 *)_RDI, a2, v15, 1LL, a5, a6);
      }
      else
      {
        _EDX = 1;
        __asm { cmpxchg [rdi], edx }
      }
      _RDI = *(_QWORD *)(a1 + 136);
      *(_QWORD *)(_RDI + 8) = v17;
    }
    ++*(_DWORD *)(_RDI + 4);
  }
  v19 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v19 - (_QWORD)&unk_BFAE0) )
    sub_17140(a7, a8, a9, a10, a11, a12, a13, a14);
  v20 = (u32 *)(unsigned int)-((*(unsigned int (__fastcall **)(__int64))(v19 + 96))(a1) != 0);
  if ( (*(_DWORD *)a1 & 0x8000) == 0 )
  {
    v22 = *(_QWORD *)(a1 + 136);
    v23 = *(_DWORD *)(v22 + 4) - 1;
    *(_DWORD *)(v22 + 4) = v23;
    if ( !v23 )
    {
      *(_QWORD *)(v22 + 8) = 0LL;
      if ( __readfsdword(0x18u) )
      {
        if ( _InterlockedExchange((volatile __int32 *)v22, 0) > 1 )
          v25 = sys_futex((u32 *)v22, 129, 1u, 0LL, v20, v21);
      }
      else
      {
        --*(_DWORD *)v22;
      }
    }
  }
  return (unsigned int)v20;
}
// 13DB8: variable 'a11' is possibly undefined
// 13DB8: variable 'a12' is possibly undefined
// 13DA8: variable 'v20' is possibly undefined
// 13DF9: variable 'v21' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (0000000000013E10) ----------------------------------------------------
u32 *__fastcall sub_13E10(u32 *a1, int a2, int *a3)
{
  int v5; // edx
  int v6; // ecx
  unsigned __int64 v8; // r13
  int v10; // er13
  __int64 v11; // rax
  u32 v12; // er9
  int v13; // edx
  u32 *v14; // r8
  int v15; // er13
  __int64 v16; // rdi
  int v17; // eax
  int v19; // er13
  signed __int64 v20; // rax

  if ( a2 > 0 )
  {
    if ( a2 == 1 )
    {
      *(_BYTE *)a1 = 0;
      v14 = a1;
    }
    else
    {
      v5 = *a3;
      v6 = v5 & 0x8000;
      if ( (v5 & 0x8000) == 0 )
      {
        _RDI = *((_QWORD *)a3 + 17);
        v8 = __readfsqword(0x10u);
        if ( *(_QWORD *)(_RDI + 8) != v8 )
        {
          _EDX = 1;
          if ( __readfsdword(0x18u) )
          {
            if ( v6 != _InterlockedCompareExchange((volatile signed __int32 *)_RDI, 1, v6) )
              sub_1C7D0(_RDI);
          }
          else
          {
            __asm { cmpxchg [rdi], edx }
          }
          _RDI = *((_QWORD *)a3 + 17);
          v5 = *a3;
          *(_QWORD *)(_RDI + 8) = v8;
        }
        ++*(_DWORD *)(_RDI + 4);
      }
      *a3 = v5 & 0xFFFFFFDF;
      v10 = v5 & 0x20;
      v11 = sub_14470(a3, a1, a2 - 1, 10LL, 1LL);
      v13 = *a3;
      v14 = 0LL;
      if ( v11 && ((v13 & 0x20) == 0 || __readfsdword(0xFFFFFFC0) == 11) )
      {
        *((_BYTE *)a1 + v11) = 0;
        v14 = a1;
        v19 = *a3 | v10;
        *a3 = v19;
        if ( (v19 & 0x8000) == 0 )
        {
LABEL_11:
          v16 = *((_QWORD *)a3 + 17);
          v17 = *(_DWORD *)(v16 + 4) - 1;
          *(_DWORD *)(v16 + 4) = v17;
          if ( !v17 )
          {
            *(_QWORD *)(v16 + 8) = 0LL;
            if ( __readfsdword(0x18u) )
            {
              if ( _InterlockedExchange((volatile __int32 *)v16, 0) > 1 )
                v20 = sys_futex((u32 *)v16, 129, 1u, 0LL, v14, v12);
            }
            else
            {
              --*(_DWORD *)v16;
            }
          }
          return v14;
        }
      }
      else
      {
        v15 = v13 | v10;
        *a3 = v15;
        if ( (v15 & 0x8000) == 0 )
          goto LABEL_11;
      }
    }
    return v14;
  }
  return 0LL;
}
// 13EF4: variable 'v14' is possibly undefined
// 13F8D: variable 'v12' is possibly undefined
// 14470: using guessed type __int64 __fastcall sub_14470(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1C7D0: using guessed type __int64 __fastcall sub_1C7D0(_QWORD);

//----- (00000000000140F0) ----------------------------------------------------
__int64 __fastcall sub_140F0(const char *a1, _BYTE *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  __int64 v10; // rax
  __int64 v11; // rbx
  __int64 v12; // r13
  __int64 v13; // rdx
  __int64 v14; // rcx
  u32 *v15; // r8
  u32 v16; // er9
  double v17; // xmm4_8
  double v18; // xmm5_8
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // r8
  u32 v22; // er9
  void *v23; // rax

  v10 = sub_21500(472LL);
  if ( !v10 )
    return 0LL;
  v11 = v10;
  *(_QWORD *)(v10 + 136) = v10 + 224;
  v12 = v10;
  sub_1AD10(v10, 0, 0, (_QWORD *)(v10 + 240), (__int64)&unk_BFD20);
  *(_QWORD *)(v11 + 216) = &unk_BFF60;
  sub_18B30(v11, 0LL, v13, v14, v15, v16);
  if ( sub_18F00(v11, a1, a2, a3, a4, a5, a6, v17, v18, a9, a10) )
  {
    if ( (*(_BYTE *)(v11 + 116) & 1) != 0 && (*(_BYTE *)v11 & 8) != 0 )
    {
      v23 = &unk_BFDE0;
      if ( *(int *)(v11 + 192) > 0 )
        v23 = &unk_BFBA0;
      *(_QWORD *)(v11 + 216) = v23;
      *(_QWORD *)(*(_QWORD *)(v11 + 160) + 224LL) = &unk_BFBA0;
    }
    return v12;
  }
  sub_19CF0(v11, (__int64)a1, v19, v20, v21, v22);
  sub_21B70(v11);
  return 0LL;
}
// 14057: variable 'v13' is possibly undefined
// 14057: variable 'v14' is possibly undefined
// 14057: variable 'v15' is possibly undefined
// 14057: variable 'v16' is possibly undefined
// 14068: variable 'v17' is possibly undefined
// 14068: variable 'v18' is possibly undefined
// 140C6: variable 'v19' is possibly undefined
// 140C6: variable 'v20' is possibly undefined
// 140C6: variable 'v21' is possibly undefined
// 140C6: variable 'v22' is possibly undefined
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (0000000000014100) ----------------------------------------------------
unsigned __int64 __fastcall fwrite(char *a1, unsigned __int64 a2, unsigned __int64 a3, void *a4)
{
  u32 *v4; // r8
  u32 v5; // er9
  double v6; // xmm0_8
  double v7; // xmm1_8
  double v8; // xmm2_8
  double v9; // xmm3_8
  double v10; // xmm4_8
  double v11; // xmm5_8
  double v12; // xmm6_8
  double v13; // xmm7_8
  unsigned __int64 v14; // r12
  __int64 v18; // rdx
  unsigned __int64 v20; // r15
  int v22; // eax
  __int64 v23; // r15
  u32 *v24; // r8
  u32 v25; // er9
  __int64 v26; // rdi
  bool v27; // zf
  signed __int64 v29; // rax

  v14 = a3 * a2;
  if ( !(a3 * a2) )
    return v14;
  v18 = *(_DWORD *)a4 & 0x8000;
  if ( (*(_DWORD *)a4 & 0x8000) == 0 )
  {
    _RDI = *((_QWORD *)a4 + 17);
    v20 = __readfsqword(0x10u);
    if ( *(_QWORD *)(_RDI + 8) != v20 )
    {
      if ( __readfsdword(0x18u) )
      {
        if ( (_DWORD)v18 != _InterlockedCompareExchange((volatile signed __int32 *)_RDI, 1, v18) )
          sub_1C7D0((volatile __int32 *)_RDI, a2, v18, 1LL, v4, v5);
      }
      else
      {
        _EDX = 1;
        __asm { cmpxchg [rdi], edx }
      }
      _RDI = *((_QWORD *)a4 + 17);
      *(_QWORD *)(_RDI + 8) = v20;
    }
    ++*(_DWORD *)(_RDI + 4);
  }
  v22 = *((_DWORD *)a4 + 48);
  if ( !v22 )
  {
    *((_DWORD *)a4 + 48) = -1;
    goto LABEL_10;
  }
  if ( v22 == -1 )
  {
LABEL_10:
    v23 = *((_QWORD *)a4 + 27);
    if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v23 - (_QWORD)&unk_BFAE0) )
      sub_17140(v6, v7, v8, v9, v10, v11, v12, v13);
    v24 = (u32 *)(*(__int64 (__fastcall **)(void *, char *, unsigned __int64))(v23 + 56))(a4, a1, v14);
    LOBYTE(v25) = (u32 *)((char *)v24 + 1) == 0LL;
    if ( (*(_DWORD *)a4 & 0x8000) != 0 )
      goto LABEL_16;
    v26 = *((_QWORD *)a4 + 17);
    v27 = (*(_DWORD *)(v26 + 4))-- == 1;
    if ( !v27 )
      goto LABEL_16;
    goto LABEL_14;
  }
  if ( (*(_DWORD *)a4 & 0x8000) != 0 )
    return 0LL;
  v26 = *((_QWORD *)a4 + 17);
  v27 = (*(_DWORD *)(v26 + 4))-- == 1;
  if ( !v27 )
    return 0LL;
  v25 = 0;
  v24 = 0LL;
LABEL_14:
  *(_QWORD *)(v26 + 8) = 0LL;
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedExchange((volatile __int32 *)v26, 0) > 1 )
      v29 = sys_futex((u32 *)v26, 129, 1u, 0LL, v24, v25);
  }
  else
  {
    --*(_DWORD *)v26;
  }
LABEL_16:
  if ( (u32 *)v14 == v24 || (_BYTE)v25 )
    v14 = a3;
  else
    v14 = (unsigned __int64)v24 / a2;
  return v14;
}
// 14288: variable 'v6' is possibly undefined
// 14288: variable 'v7' is possibly undefined
// 14288: variable 'v8' is possibly undefined
// 14288: variable 'v9' is possibly undefined
// 14288: variable 'v10' is possibly undefined
// 14288: variable 'v11' is possibly undefined
// 14288: variable 'v12' is possibly undefined
// 14288: variable 'v13' is possibly undefined
// 14200: variable 'v24' is possibly undefined
// 14205: variable 'v25' is possibly undefined
// 14279: variable 'v4' is possibly undefined
// 14279: variable 'v5' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (0000000000014470) ----------------------------------------------------
_BYTE *__fastcall sub_14470(__int64 a1, _BYTE *a2, unsigned __int64 a3, unsigned int a4, int a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  unsigned __int64 v13; // r15
  _BYTE *v15; // r14
  signed __int64 v16; // rbx
  __int64 v17; // rax
  void *v18; // rcx
  const void *v19; // r13
  int v20; // eax
  _BYTE *result; // rax
  size_t v22; // rbp
  void *v23; // [rsp+0h] [rbp-50h]

  v13 = a3;
  if ( !*(_DWORD *)(a1 + 192) )
    *(_DWORD *)(a1 + 192) = -1;
  if ( !a3 )
    return 0LL;
  v15 = a2;
  while ( 1 )
  {
    while ( 1 )
    {
      v19 = *(const void **)(a1 + 8);
      v16 = *(_QWORD *)(a1 + 16) - (_QWORD)v19;
      if ( v16 > 0 )
        break;
      v20 = sub_1A330(a1, a6, a7, a8, a9, a10, a11, a12, a13);
      if ( v20 == -1 )
        return (_BYTE *)(v15 - a2);
      if ( a4 == v20 )
      {
        if ( a5 <= 0 )
        {
          if ( a5 )
            sub_1AF00(a1, a4, a6, a7, a8, a9, a10, a11, a12, a13);
        }
        else
        {
          *v15++ = a4;
        }
        return (_BYTE *)(v15 - a2);
      }
      --v13;
      *v15++ = v20;
      if ( !v13 )
        return (_BYTE *)(v15 - a2);
    }
    if ( v16 > v13 )
      v16 = v13;
    v17 = sub_9110(*(_QWORD *)(a1 + 8), a4, v16);
    v18 = (void *)v17;
    if ( v17 )
      break;
    v13 -= v16;
    memcpy(v15, v19, v16);
    v15 += v16;
    *(_QWORD *)(a1 + 8) += v16;
    if ( !v13 )
      return (_BYTE *)(v15 - a2);
  }
  v22 = v17 - (_QWORD)v19;
  if ( a5 >= 0 )
  {
    v18 = (void *)(v17 + 1);
    v22 -= (a5 == 0) - 1LL;
  }
  v23 = v18;
  memcpy(v15, v19, v22);
  result = (_BYTE *)(v22 + v15 - a2);
  *(_QWORD *)(a1 + 8) = v23;
  return result;
}
// 14422: conditional instruction was optimized away because of '%var_40.8==0'
// 14377: variable 'a10' is possibly undefined
// 14377: variable 'a11' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);
// 9110: using guessed type __int64 __fastcall sub_9110(_QWORD, _QWORD, _QWORD);

//----- (0000000000014480) ----------------------------------------------------
__int64 __fastcall sub_14480(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14)
{
  unsigned __int64 v14; // r12
  __int64 v16; // rax
  int v17; // ecx
  __int64 v18; // rdx
  int v19; // er12
  double v20; // xmm4_8
  double v21; // xmm5_8
  signed __int64 v23; // rax
  __int64 *v24; // rdx
  unsigned int v25; // [rsp+Ch] [rbp-5Ch] BYREF
  signed __int64 (__fastcall *v26)(__int64, __int64, __int64, __int64, u32 *, u32); // [rsp+10h] [rbp-58h]
  __int64 v27; // [rsp+18h] [rbp-50h]
  unsigned __int64 v28; // [rsp+38h] [rbp-30h]

  v28 = __readfsqword(0x28u);
  v27 = 0LL;
  v26 = sub_146E0;
  v14 = __readfsqword(0x10u);
  if ( qword_C1198 != v14 )
  {
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C1190, 1, 0) )
        sub_1C7D0((volatile __int32 *)&dword_C1190, a2, 1LL, a12, a13, a14);
    }
    else
    {
      _EDX = 1;
      __asm { cmpxchg cs:dword_C1190, edx }
    }
    qword_C1198 = v14;
  }
  v16 = qword_C11A0;
  v17 = dword_C1194;
  if ( !qword_C11A0 )
  {
LABEL_10:
    v19 = -1;
    goto LABEL_11;
  }
  if ( qword_C11A0 != a1 )
  {
    while ( 1 )
    {
      v18 = v16;
      v16 = *(_QWORD *)(v16 + 232);
      if ( !v16 )
        goto LABEL_10;
      if ( a1 == v16 )
      {
        v24 = (__int64 *)(v18 + 232);
        goto LABEL_22;
      }
    }
  }
  v24 = &qword_C11A0;
LABEL_22:
  v19 = 0;
  *v24 = *(_QWORD *)(v16 + 232);
LABEL_11:
  dword_C1194 = v17;
  if ( !v17 )
  {
    qword_C1198 = 0LL;
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedExchange((volatile __int32 *)&dword_C1190, 0) > 1 )
        v23 = sys_futex(&dword_C1190, 129, 1u, 0LL, a13, a14);
    }
    else
    {
      --dword_C1190;
    }
  }
  if ( v19 == -1 || (sub_4B7A0(*(_DWORD *)(a1 + 112)) & 0x80000000) != 0LL )
    return 0xFFFFFFFFLL;
  while ( (unsigned int)sub_49A80(*(_DWORD *)(a1 + 224), (int *)&v25, 0, a3, a4, a5, a6, v20, v21, a9, a10) == -1 )
  {
    if ( __readfsdword(0xFFFFFFC0) != 4 )
      return 0xFFFFFFFFLL;
  }
  return v25;
}
// 145DA: variable 'v20' is possibly undefined
// 145DA: variable 'v21' is possibly undefined
// 14691: variable 'a13' is possibly undefined
// 14691: variable 'a14' is possibly undefined
// 90B0: using guessed type __int64 __fastcall sub_90B0(_QWORD, _QWORD);
// 90C0: using guessed type __int64 __fastcall sub_90C0(_QWORD, _QWORD);
// 9160: using guessed type __int64 __fastcall sub_9160(_QWORD, _QWORD, _QWORD);
// C1194: using guessed type int dword_C1194;
// C1198: using guessed type __int64 qword_C1198;
// C11A0: using guessed type __int64 qword_C11A0;

//----- (00000000000146E0) ----------------------------------------------------
signed __int64 __fastcall sub_146E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  bool v6; // zf
  signed __int64 result; // rax

  v6 = dword_C1194 == 1;
  result = (unsigned int)--dword_C1194;
  if ( v6 )
  {
    qword_C1198 = 0LL;
    if ( __readfsdword(0x18u) )
    {
      result = (unsigned int)_InterlockedExchange((volatile __int32 *)&dword_C1190, result);
      if ( (int)result > 1 )
        result = sys_futex(&dword_C1190, 129, 1u, 0LL, a5, a6);
    }
    else
    {
      --dword_C1190;
    }
  }
  return result;
}
// C1194: using guessed type int dword_C1194;
// C1198: using guessed type __int64 qword_C1198;

//----- (0000000000014740) ----------------------------------------------------
__int64 __fastcall sub_14740(__int64 a1, __int64 a2, char *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  char v11; // al
  int v13; // er15
  int v14; // esi
  int v15; // er13
  __int64 result; // rax
  double v17; // xmm4_8
  double v18; // xmm5_8
  int v19; // er14
  __int64 v20; // rdx
  __int64 v21; // rcx
  u32 *v22; // r8
  u32 v23; // er9
  double v24; // xmm4_8
  double v25; // xmm5_8
  unsigned __int64 v26; // r14
  __int64 v28; // r14
  __int64 v29; // rsi
  int *v30; // rcx
  u32 *v31; // r8
  __int64 v32; // r9
  char v33; // bp
  unsigned int *v34; // rbp
  unsigned int v35; // eax
  __int64 v36; // rax
  bool v37; // zf
  __int32 v38; // eax
  signed __int64 v39; // rax
  int v40; // [rsp+14h] [rbp-F4h]
  int v41[2]; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v42[4]; // [rsp+50h] [rbp-B8h] BYREF
  _OWORD v43[5]; // [rsp+70h] [rbp-98h] BYREF
  unsigned __int64 v44; // [rsp+C8h] [rbp-40h]

  v44 = __readfsqword(0x28u);
  v11 = *a3;
  if ( !*a3 )
    goto LABEL_6;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  do
  {
    ++a3;
    switch ( v11 )
    {
      case 'r':
        v15 = 1;
        break;
      case 'w':
        v14 = 1;
        break;
      case 'e':
        v13 = 1;
        break;
      default:
        goto LABEL_6;
    }
    v11 = *a3;
  }
  while ( *a3 );
  if ( v15 == v14 )
  {
LABEL_6:
    __writefsdword(0xFFFFFFC0, 0x16u);
    return 0LL;
  }
  if ( *(_DWORD *)(a1 + 112) != -1 || (sub_4AF70(v41, (int)sub_80000) & 0x80000000) != 0LL )
    return 0LL;
  v40 = v15 ^ 1;
  sub_4A130(v43);
  v19 = v41[v15];
  if ( v19 != v15 )
    goto LABEL_13;
  v19 = sub_4AD80(v15, 0x406u, 0LL, a4, a5, a6, a7, v17, v18, a10, a11);
  if ( v19 >= 0 )
  {
    sub_4B7A0(v41[v15]);
    v41[v15] = v19;
LABEL_13:
    if ( !(unsigned int)sub_4A230((__int64)v43, (unsigned int)v19, v15, a4, a5, a6, a7, v17, v18, a10, a11) )
    {
      v26 = __readfsqword(0x10u);
      if ( qword_C1198 != v26 )
      {
        if ( __readfsdword(0x18u) )
        {
          if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C1190, 1, 0) )
            sub_1C7D0((volatile __int32 *)&dword_C1190, 1LL, v20, v21, v22, v23);
        }
        else
        {
          _ESI = 1;
          __asm { cmpxchg cs:dword_C1190, esi }
        }
        qword_C1198 = v26;
      }
      v28 = qword_C11A0;
      ++dword_C1194;
      if ( qword_C11A0 )
      {
        while ( 1 )
        {
          v29 = *(unsigned int *)(v28 + 112);
          if ( v15 != (_DWORD)v29 )
          {
            if ( (unsigned int)sub_4A1C0((__int64)v43, v29, v20, a4, a5, a6, a7, v24, v25, a10, a11) )
              break;
          }
          v28 = *(_QWORD *)(v28 + 232);
          if ( !v28 )
            goto LABEL_22;
        }
        v33 = 0;
      }
      else
      {
LABEL_22:
        v42[2] = a2;
        v33 = 0;
        v42[0] = (__int64)"sh";
        v29 = (__int64)"/bin/sh";
        v42[1] = (__int64)"-c";
        v42[3] = 0LL;
        if ( !(unsigned int)sub_4A300(
                              (pid_t *)(a1 + 224),
                              (__int64)"/bin/sh",
                              (__int64)v43,
                              0LL,
                              (__int64)v42,
                              (__int64)qword_C1270,
                              a4,
                              a5,
                              a6,
                              a7,
                              v24,
                              v25,
                              a10,
                              a11) )
        {
          sub_4B7A0(v41[v15]);
          v30 = v41;
          v34 = (unsigned int *)&v41[v40];
          if ( !v13 )
          {
            v29 = 2LL;
            sub_4AD80(*v34, 2u, 0LL, a4, a5, a6, a7, v24, v25, a10, a11);
          }
          v35 = *v34;
          v33 = 1;
          *(_DWORD *)(a1 + 112) = v35;
          v36 = qword_C11A0;
          qword_C11A0 = a1;
          *(_QWORD *)(a1 + 232) = v36;
        }
      }
      v37 = dword_C1194 == 1;
      v38 = --dword_C1194;
      if ( v37 )
      {
        qword_C1198 = 0LL;
        LODWORD(v20) = __readfsdword(0x18u);
        if ( (_DWORD)v20 )
        {
          if ( _InterlockedExchange((volatile __int32 *)&dword_C1190, v38) > 1 )
          {
            v29 = 129LL;
            v39 = sys_futex(&dword_C1190, 129, 1u, 0LL, v31, v32);
          }
        }
        else
        {
          --dword_C1190;
        }
      }
      sub_4A150((__int64)v43, v29, v20, (unsigned __int64)v30, v31, v32, a4, a5, a6, a7, v24, v25, a10, a11);
      if ( v33 )
      {
        result = a1;
        *(_DWORD *)a1 = *(_DWORD *)a1 & 0xFFFFFFF3 | (v15 == 0 ? 4 : 8);
        return result;
      }
    }
  }
  sub_4B7A0(v41[v15]);
  sub_4B7A0(v41[v40]);
  __writefsdword(0xFFFFFFC0, 0xCu);
  return 0LL;
}
// 14851: variable 'v17' is possibly undefined
// 14851: variable 'v18' is possibly undefined
// 148DC: variable 'v20' is possibly undefined
// 148DC: variable 'v24' is possibly undefined
// 148DC: variable 'v25' is possibly undefined
// 149D6: variable 'v30' is possibly undefined
// 149D6: variable 'v31' is possibly undefined
// 149D6: variable 'v32' is possibly undefined
// 14AD4: variable 'v21' is possibly undefined
// 14AD4: variable 'v22' is possibly undefined
// 14AD4: variable 'v23' is possibly undefined
// 90B0: using guessed type __int64 __fastcall sub_90B0(_QWORD, _QWORD);
// 9160: using guessed type __int64 __fastcall sub_9160(_QWORD, _QWORD, _QWORD);
// C1194: using guessed type int dword_C1194;
// C1198: using guessed type __int64 qword_C1198;
// C11A0: using guessed type __int64 qword_C11A0;

//----- (0000000000014B20) ----------------------------------------------------
__int64 __fastcall sub_14B20(__int64 a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // r12

  v2 = sub_21500(256LL);
  if ( !v2 )
    return 0LL;
  v3 = v2;
  *(_QWORD *)(v2 + 136) = v2 + 240;
  sub_1AA50(v2, 0LL);
  *(_QWORD *)(v3 + 216) = &unk_BFAE0;
  sub_18B30(v3);
  if ( sub_14740(v3, a1, a2) )
    return v3;
  sub_19CF0(v3);
  sub_21B70(v3);
  return 0LL;
}
// 14740: using guessed type __int64 __fastcall sub_14740(_QWORD, _QWORD, _QWORD);
// 18B30: using guessed type __int64 __fastcall sub_18B30(_QWORD);
// 19CF0: using guessed type __int64 __fastcall sub_19CF0(_QWORD);
// 1AA50: using guessed type __int64 __fastcall sub_1AA50(_QWORD, _QWORD);
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (0000000000014BC0) ----------------------------------------------------
__int64 __fastcall puts(char *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  __int64 v11; // rax
  u32 v12; // er9
  double v13; // xmm4_8
  double v14; // xmm5_8
  _QWORD *v15; // rbp
  __int64 v16; // rbx
  __int64 v17; // rdx
  unsigned __int64 v19; // r13
  _DWORD *v21; // rdi
  int v22; // eax
  __int64 v23; // r8
  __int64 v24; // r13
  double v25; // xmm4_8
  double v26; // xmm5_8
  _BYTE *v27; // rax
  unsigned __int64 v28; // rbx
  __int64 v29; // rdi
  int v30; // eax
  signed __int64 v32; // rax

  v11 = strlen((__int64)a1);
  v15 = off_BE610;
  v16 = v11;
  v17 = *(_DWORD *)off_BE610 & 0x8000;
  if ( (*(_DWORD *)off_BE610 & 0x8000) != 0 )
  {
    v21 = off_BE610;
    v22 = *((_DWORD *)off_BE610 + 48);
    if ( v22 )
      goto LABEL_7;
LABEL_10:
    v21[48] = -1;
    goto LABEL_11;
  }
  _R8 = *((_QWORD *)off_BE610 + 17);
  v19 = __readfsqword(0x10u);
  if ( *(_QWORD *)(_R8 + 8) == v19 )
  {
    v21 = off_BE610;
  }
  else
  {
    if ( __readfsdword(0x18u) )
    {
      if ( (_DWORD)v17 != _InterlockedCompareExchange((volatile signed __int32 *)_R8, 1, v17) )
        sub_1C7D0((volatile __int32 *)_R8, a2, v17, 1LL, (u32 *)_R8, v12);
    }
    else
    {
      _EDX = 1;
      __asm { cmpxchg [r8], edx }
    }
    _R8 = v15[17];
    v21 = off_BE610;
    *(_QWORD *)(_R8 + 8) = v19;
  }
  v22 = v21[48];
  ++*(_DWORD *)(_R8 + 4);
  if ( !v22 )
    goto LABEL_10;
LABEL_7:
  if ( v22 != -1 )
  {
LABEL_8:
    v23 = 0xFFFFFFFFLL;
    goto LABEL_18;
  }
LABEL_11:
  v24 = *((_QWORD *)v21 + 27);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v24 - (_QWORD)&unk_BFAE0) )
  {
    sub_17140(a3, a4, a5, a6, v13, v14, a9, a10);
    v21 = off_BE610;
  }
  if ( v16 != (*(__int64 (__fastcall **)(_DWORD *, char *, __int64))(v24 + 56))(v21, a1, v16) )
    goto LABEL_8;
  v27 = (_BYTE *)*((_QWORD *)off_BE610 + 5);
  if ( (unsigned __int64)v27 >= *((_QWORD *)off_BE610 + 6) )
  {
    if ( (unsigned int)sub_1A150((__int64)off_BE610, 10LL, a3, a4, a5, a6, v25, v26, a9, a10) == -1 )
      goto LABEL_8;
  }
  else
  {
    *((_QWORD *)off_BE610 + 5) = v27 + 1;
    *v27 = 10;
  }
  v28 = v16 + 1;
  v23 = 0x7FFFFFFFLL;
  if ( v28 <= 0x7FFFFFFF )
    v23 = v28;
LABEL_18:
  if ( (*(_DWORD *)v15 & 0x8000) == 0 )
  {
    v29 = v15[17];
    v30 = *(_DWORD *)(v29 + 4) - 1;
    *(_DWORD *)(v29 + 4) = v30;
    if ( !v30 )
    {
      *(_QWORD *)(v29 + 8) = 0LL;
      if ( __readfsdword(0x18u) )
      {
        if ( _InterlockedExchange((volatile __int32 *)v29, 0) > 1 )
          v32 = sys_futex((u32 *)v29, 129, 1u, 0LL, (u32 *)v23, v12);
      }
      else
      {
        --*(_DWORD *)v29;
      }
    }
  }
  return (unsigned int)v23;
}
// 14D20: variable 'v13' is possibly undefined
// 14D20: variable 'v14' is possibly undefined
// 14D09: variable 'v23' is possibly undefined
// 14D3D: variable 'v25' is possibly undefined
// 14D3D: variable 'v26' is possibly undefined
// 14D65: variable 'v12' is possibly undefined
// BE610: using guessed type void *off_BE610;
// C0308: using guessed type void *off_C0308;

//----- (0000000000014DA0) ----------------------------------------------------
__int64 __fastcall sub_14DA0(__int64 a1, void *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, __int64 a14)
{
  int v14; // eax
  __int64 *v16; // rax
  unsigned __int64 v17; // rdx
  unsigned __int64 v18; // rcx
  __int64 v19; // r14
  __int64 v20; // rax
  __int64 v21; // rax
  _QWORD *v22; // rbp
  int v23; // edx
  __int64 v24; // rcx
  unsigned __int64 v26; // r12
  unsigned __int64 v28; // r13
  __int64 v29; // rdi
  int v30; // eax
  __int64 result; // rax
  __int64 v32; // rbp
  double v33; // xmm4_8
  double v34; // xmm5_8
  _QWORD *v35; // rax
  __int64 v36; // rdx
  size_t v37; // rdx
  __int64 v38; // r8
  __int64 v39; // rax
  __int64 v40; // rax
  __int64 v41; // rdx
  __int64 v42; // r11
  __int64 *v43; // rcx
  __int64 v44; // rsi
  int v45; // eax
  char *v46; // r8
  char *v47; // rsi
  unsigned int **v48; // rdx
  int v49; // edx
  __int64 v50; // rdx
  __int64 v51; // rax
  char *v52; // rsi
  __int64 v53; // rax
  __int64 v54; // r9
  unsigned int *v55; // rsi
  int v56; // eax
  unsigned int **v57; // rdx
  __int64 v58; // rdi
  __int64 v59; // rdi
  signed __int64 v60; // rax
  _QWORD *v61; // [rsp+0h] [rbp-98h]
  __int64 v62; // [rsp+0h] [rbp-98h]
  __int64 v63; // [rsp+0h] [rbp-98h]
  char *v64; // [rsp+0h] [rbp-98h]
  __int64 v65; // [rsp+0h] [rbp-98h]
  __int64 v66; // [rsp+8h] [rbp-90h]
  __int64 v67; // [rsp+8h] [rbp-90h]
  __int64 v68; // [rsp+8h] [rbp-90h]
  __int64 *v69; // [rsp+18h] [rbp-80h]
  _QWORD *v70; // [rsp+20h] [rbp-78h]
  __int64 v71; // [rsp+28h] [rbp-70h]
  void *v72; // [rsp+38h] [rbp-60h] BYREF
  char v73[24]; // [rsp+40h] [rbp-58h] BYREF
  unsigned __int64 v74; // [rsp+58h] [rbp-40h]

  v74 = __readfsqword(0x28u);
  v14 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 0x10) != 0 )
    return 0xFFFFFFFFLL;
  if ( (v14 & 4) != 0 )
  {
    *(_DWORD *)a1 = v14 | 0x20;
    __writefsdword(0xFFFFFFC0, 9u);
    return 0xFFFFFFFFLL;
  }
  v16 = *(__int64 **)(a1 + 160);
  if ( *v16 < (unsigned __int64)v16[1] )
    return *(unsigned int *)*v16;
  v17 = *(_QWORD *)(a1 + 8);
  v18 = *(_QWORD *)(a1 + 16);
  v19 = *(_QWORD *)(a1 + 152);
  if ( v17 < v18 )
  {
    v54 = v16[6];
    v55 = (unsigned int *)v16[11];
    v72 = *(void **)(a1 + 8);
    v16[12] = (__int64)v55;
    *v16 = v54;
    v16[2] = v54;
    v56 = sub_169E0(v19, (__int64)(v16 + 11), v17, v18, &v72, v54, v16[7], v16 + 1);
    a2 = v72;
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 8);
    v57 = *(unsigned int ***)(a1 + 160);
    *(_QWORD *)(a1 + 8) = a2;
    if ( *v57 < v57[1] )
      return **v57;
    if ( v56 == 2 )
    {
LABEL_20:
      __writefsdword(0xFFFFFFC0, 0x54u);
      *(_DWORD *)a1 |= 0x20u;
      return 0xFFFFFFFFLL;
    }
    sub_9050(*(_QWORD *)(a1 + 56), a2, *(_QWORD *)(a1 + 16) - (_QWORD)a2);
    v20 = *(_QWORD *)(a1 + 56);
    v17 = v20 + *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 24) = v20;
    *(_QWORD *)(a1 + 16) = v17;
    *(_QWORD *)(a1 + 8) = v20;
  }
  else
  {
    v20 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 16) = v20;
    *(_QWORD *)(a1 + 8) = v20;
    *(_QWORD *)(a1 + 24) = v20;
  }
  if ( !v20 )
  {
    v59 = *(_QWORD *)(a1 + 72);
    if ( v59 )
    {
      sub_21B70(v59, a3, a4, a5, a6, a7, a8, a9, a10, (__int64)a2, v17, v18, a13, a14);
      *(_DWORD *)a1 &= 0xFFFFFEFF;
    }
    sub_1A500((int *)a1, (__int64)a2, a3, a4, a5, a6, a7, a8, a9, a10);
    v20 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 16) = v20;
    *(_QWORD *)(a1 + 8) = v20;
    *(_QWORD *)(a1 + 24) = v20;
  }
  *(_QWORD *)(a1 + 48) = v20;
  *(_QWORD *)(a1 + 40) = v20;
  *(_QWORD *)(a1 + 32) = v20;
  v21 = *(_QWORD *)(a1 + 160);
  if ( !*(_QWORD *)(v21 + 48) )
  {
    v58 = *(_QWORD *)(v21 + 64);
    if ( v58 )
    {
      sub_21B70(v58, a3, a4, a5, a6, a7, a8, a9, a10, (__int64)a2, v17, v18, a13, a14);
      *(_DWORD *)a1 &= 0xFFFFFEFF;
    }
    sub_6AD40(a1, (__int64)a2, a3, a4, a5, a6, a7, a8, a9, a10);
  }
  if ( (*(_DWORD *)a1 & 0x202) == 0 )
    goto LABEL_23;
  v22 = off_BE610;
  v23 = *(_DWORD *)off_BE610;
  v61 = off_BE610;
  v24 = (unsigned __int16)*(_DWORD *)off_BE610 & 0x8000;
  if ( (*(_DWORD *)off_BE610 & 0x8000) != 0 )
  {
    if ( (*(_DWORD *)off_BE610 & 0x288) != 640 )
    {
LABEL_23:
      v28 = (char *)&off_C0308 - (char *)&unk_BFAE0;
      goto LABEL_24;
    }
    v28 = (char *)&off_C0308 - (char *)&unk_BFAE0;
    goto LABEL_67;
  }
  _RDI = *((_QWORD *)off_BE610 + 17);
  v26 = __readfsqword(0x10u);
  if ( *(_QWORD *)(_RDI + 8) != v26 )
  {
    _EDX = 1;
    if ( __readfsdword(0x18u) )
    {
      if ( (_DWORD)v24 != _InterlockedCompareExchange((volatile signed __int32 *)_RDI, 1, *(_DWORD *)off_BE610 & 0x8000) )
        sub_1C7D0((volatile __int32 *)_RDI, (__int64)a2, 1LL, v24, a13, a14);
    }
    else
    {
      __asm { cmpxchg [rdi], edx }
    }
    _RDI = v22[17];
    v22 = off_BE610;
    *(_QWORD *)(_RDI + 8) = v26;
    v23 = *(_DWORD *)v22;
  }
  ++*(_DWORD *)(_RDI + 4);
  v28 = (char *)&off_C0308 - (char *)&unk_BFAE0;
  if ( (v23 & 0x288) == 640 )
  {
LABEL_67:
    v68 = v22[27];
    if ( v68 - (__int64)&unk_BFAE0 >= v28 )
    {
      sub_17140(a3, a4, a5, a6, a7, a8, a9, a10);
      v22 = off_BE610;
    }
    (*(void (__fastcall **)(_QWORD *, __int64))(v68 + 24))(v22, 0xFFFFFFFFLL);
  }
  if ( (*(_DWORD *)v61 & 0x8000) != 0 )
    goto LABEL_23;
  v29 = v61[17];
  v30 = *(_DWORD *)(v29 + 4) - 1;
  *(_DWORD *)(v29 + 4) = v30;
  if ( v30 )
    goto LABEL_23;
  *(_QWORD *)(v29 + 8) = 0LL;
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedExchange((volatile __int32 *)v29, 0) > 1 )
    {
      v60 = sys_futex((u32 *)v29, 129, 1u, 0LL, a13, a14);
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  --*(_DWORD *)v29;
LABEL_24:
  v32 = 0LL;
  sub_1A060((int *)a1, a3, a4, a5, a6, a7, a8, a9, a10);
  v35 = *(_QWORD **)(a1 + 160);
  v36 = v35[6];
  *v35 = v36;
  v35[2] = v36;
  v35[1] = v36;
  v35[5] = v36;
  v35[4] = v36;
  v35[3] = v36;
  while ( 1 )
  {
    v39 = *(_QWORD *)(a1 + 216);
    if ( v39 - (__int64)&unk_BFAE0 >= v28 )
    {
      v63 = *(_QWORD *)(a1 + 216);
      sub_17140(a3, a4, a5, a6, v33, v34, a9, a10);
      v39 = v63;
    }
    v40 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(v39 + 112))(
            a1,
            *(_QWORD *)(a1 + 16),
            *(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 16));
    if ( v40 <= 0 )
      break;
    v41 = *(_QWORD *)(a1 + 144);
    v42 = v40 + *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v42;
    if ( v41 != -1 )
      *(_QWORD *)(a1 + 144) = v40 + v41;
    v43 = *(__int64 **)(a1 + 160);
    v44 = *(_QWORD *)(a1 + 8);
    v43[12] = v43[11];
    *(_QWORD *)(a1 + 24) = v44;
    if ( v32 )
    {
      v71 = (__int64)(v43 + 11);
      v50 = 16 - v32;
      v70 = v43 + 1;
      v69 = v43;
      if ( 16 - v32 > (unsigned __int64)v40 )
        v50 = v40;
      v64 = &v73[v32];
      v67 = v50;
      v51 = sub_91D0(&v73[v32], v44, v50);
      v32 += v67;
      v45 = sub_169E0(v19, v71, (__int64)v73, v51, &v72, v69[1], v69[7], v70);
      if ( v32 )
      {
        v46 = (char *)v72;
        v52 = (char *)((_BYTE *)v72 - v64);
        if ( (_BYTE *)v72 - v64 < 0 )
          v52 = 0LL;
        v47 = &v52[*(_QWORD *)(a1 + 8)];
        goto LABEL_37;
      }
    }
    else
    {
      v45 = sub_169E0(v19, (__int64)(v43 + 11), v44, v42, &v72, v43[1], v43[7], v43 + 1);
    }
    v46 = (char *)v72;
    v32 = 0LL;
    v47 = (char *)v72;
LABEL_37:
    v48 = *(unsigned int ***)(a1 + 160);
    *(_QWORD *)(a1 + 8) = v47;
    if ( v48[1] != v48[6] )
      return **v48;
    if ( v45 == 2 )
      goto LABEL_20;
    if ( v45 != 1 )
      sub_CF00(
        (__int64)"status == __codecvt_partial",
        (__int64)&unk_900A0,
        0x122u,
        "_IO_wfile_underflow",
        a3,
        a4,
        a5,
        a6,
        v33,
        v34,
        a9,
        a10);
    if ( v32 )
    {
      if ( v46 != v73 )
      {
        v32 -= v46 - v73;
        sub_9050(v73, v46, v32);
      }
      if ( v32 == 16 )
        goto LABEL_20;
      v38 = *(_QWORD *)(a1 + 24);
LABEL_28:
      *(_QWORD *)(a1 + 16) = v38;
      *(_QWORD *)(a1 + 8) = v38;
    }
    else
    {
      v37 = *(_QWORD *)(a1 + 16) - (_QWORD)v47;
      if ( (unsigned __int64)v47 <= *(_QWORD *)(a1 + 24) )
      {
        v62 = *(_QWORD *)(a1 + 24);
        if ( v37 > 0xF )
          goto LABEL_20;
        v66 = *(_QWORD *)(a1 + 16) - (_QWORD)v47;
        memcpy(v73, v47, v37);
        v38 = v62;
        v32 = v66;
        goto LABEL_28;
      }
      v65 = *(_QWORD *)(a1 + 16) - (_QWORD)v47;
      sub_9050(*(_QWORD *)(a1 + 24), v47, v37);
      v53 = *(_QWORD *)(a1 + 24);
      *(_QWORD *)(a1 + 16) -= v65;
      *(_QWORD *)(a1 + 8) = v53;
    }
  }
  v49 = *(_DWORD *)a1;
  if ( !(v32 | v40) )
  {
    result = 0xFFFFFFFFLL;
    *(_QWORD *)(a1 + 144) = -1LL;
    *(_DWORD *)a1 = v49 | 0x10;
    return result;
  }
  *(_DWORD *)a1 = v49 | 0x20;
  if ( v32 )
  {
    __writefsdword(0xFFFFFFC0, 0x54u);
    return 0xFFFFFFFFLL;
  }
  return 0xFFFFFFFFLL;
}
// 14F90: variable 'a7' is possibly undefined
// 14F90: variable 'a8' is possibly undefined
// 15164: variable 'v33' is possibly undefined
// 15164: variable 'v34' is possibly undefined
// 152E9: variable 'v17' is possibly undefined
// 152E9: variable 'v18' is possibly undefined
// 152E9: variable 'a13' is possibly undefined
// 152E9: variable 'a14' is possibly undefined
// 9050: using guessed type __int64 __fastcall sub_9050(_QWORD, _QWORD, _QWORD);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// BE610: using guessed type void *off_BE610;
// C0308: using guessed type void *off_C0308;

//----- (0000000000015430) ----------------------------------------------------
__int64 __fastcall sub_15430(__int64 a1, char a2)
{
  __int64 *v2; // r12
  int v3; // eax
  _QWORD *v4; // rsi
  __int64 v5; // rax
  __int64 v6; // rdx
  _QWORD *v7; // rax
  __int64 v8; // r9
  int v9; // eax
  __int64 result; // rax
  __int64 v11[5]; // [rsp+0h] [rbp-28h] BYREF

  v2 = *(__int64 **)(a1 + 152);
  v11[1] = __readfsqword(0x28u);
  v3 = sub_16AD0(v2);
  if ( a2 == 1 || v3 <= 0 )
  {
    v6 = *(_QWORD *)(a1 + 24);
    v11[0] = v6;
    while ( 1 )
    {
      v7 = *(_QWORD **)(a1 + 160);
      v8 = v7[2];
      v7[12] = v7[11];
      v9 = sub_169E0((__int64)v2, (__int64)(v7 + 11), v6, *(_QWORD *)(a1 + 8), v11, v8, v7[7], v7 + 1);
      if ( v9 == 2 )
        break;
      if ( v9 != 1 )
      {
        v4 = *(_QWORD **)(a1 + 160);
        v5 = v4[1];
        goto LABEL_8;
      }
      v6 = *(_QWORD *)(a1 + 24);
    }
    *(_DWORD *)a1 |= 0x20u;
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v4 = *(_QWORD **)(a1 + 160);
    v5 = v4[1] + 4 * ((*(_QWORD *)(a1 + 8) - *(_QWORD *)(a1 + 24)) / v3);
    v4[1] = v5;
LABEL_8:
    *v4 = v5;
    result = 0LL;
  }
  return result;
}

//----- (0000000000015520) ----------------------------------------------------
__int64 __fastcall sub_15520(__int64 a1, __int64 a2, unsigned int a3, int a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  unsigned __int64 *v15; // rax
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rdx
  __int64 v19; // rbp
  __int64 result; // rax
  __int64 v21; // r14
  unsigned __int64 v22; // rbx
  double v23; // xmm4_8
  double v24; // xmm5_8
  __int64 v25; // rax
  int v26; // edx
  __int64 v27; // rcx
  __int64 v28; // rsi
  __int64 v29; // rax
  __int64 v30; // rsi
  __int64 v31; // rcx
  __int64 v32; // r14
  __int64 v33; // r14
  double v34; // xmm4_8
  double v35; // xmm5_8
  __int64 v36; // rcx
  __int64 v37; // rax
  __int64 (__fastcall *v38)(__int64, __int64, __int64); // rax
  __int64 v39; // rdx
  __int64 v40; // rsi
  __int64 v41; // rax
  __int64 v42; // r8
  __int64 v43; // rdx
  __int64 v44; // rax
  __int64 v45; // rdx
  __int64 v46; // rcx
  _QWORD *v47; // rax
  __int64 v48; // rdx
  __int64 v49; // rdi
  __int64 v50; // rax
  _QWORD *v51; // rax
  __int64 v52; // rdx
  __int64 *v53; // r13
  int v54; // eax
  __int64 v55; // rax
  double v56; // xmm4_8
  double v57; // xmm5_8
  __int64 v58; // r14
  __int64 v59; // rdx
  _QWORD *v60; // rdx
  __int64 v61; // rcx
  int v62; // edx
  unsigned __int64 v63; // rbp
  unsigned __int64 v64; // rbx
  int v65; // edi
  __int64 v66; // r13
  __int64 v67; // rax
  unsigned __int64 v68; // r13
  unsigned __int64 v69; // r14
  __int64 *v70; // r12
  int v71; // eax
  u32 *v72; // r8
  u32 v73; // er9
  __int64 v74; // rcx
  __int64 v75; // rbx
  __int64 v76; // rax
  __int64 *v77; // rsi
  __int64 v78; // rcx
  __int64 v79; // rdx
  __int64 v80; // rax
  __int64 v81; // r8
  __int64 v82; // r8
  int v83; // eax
  __int64 v84; // rcx
  _QWORD *v85; // rbp
  __int64 v86; // r13
  __int64 v87; // rbx
  __int64 v88; // rbx
  __int64 v89; // rax
  __int64 v90; // rax
  __int64 v91; // rbp
  _QWORD *v92; // rax
  __int64 v93; // rdx
  double v94; // xmm4_8
  double v95; // xmm5_8
  __int64 v96; // rsi
  __int64 v97; // rbx
  __int64 v98; // r14
  __int64 v99; // rdx
  unsigned __int64 v100; // rcx
  u32 *v101; // r8
  double v102; // xmm4_8
  double v103; // xmm5_8
  __int64 v104; // rdx
  __int64 v105; // [rsp-10h] [rbp-118h]
  int v106; // [rsp+8h] [rbp-100h]
  __int64 v107; // [rsp+8h] [rbp-100h]
  __int64 v108; // [rsp+8h] [rbp-100h]
  __int64 v109; // [rsp+10h] [rbp-F8h]
  unsigned __int64 v110; // [rsp+10h] [rbp-F8h]
  __int64 v111; // [rsp+10h] [rbp-F8h]
  __int64 v112; // [rsp+10h] [rbp-F8h]
  __int64 v113; // [rsp+10h] [rbp-F8h]
  __int64 v114; // [rsp+18h] [rbp-F0h]
  __int64 v115; // [rsp+20h] [rbp-E8h] BYREF
  __int64 v116; // [rsp+28h] [rbp-E0h] BYREF
  __int64 v117[3]; // [rsp+30h] [rbp-D8h] BYREF
  int v118; // [rsp+48h] [rbp-C0h]
  __int64 v119; // [rsp+60h] [rbp-A8h]
  unsigned __int64 v120; // [rsp+C8h] [rbp-40h]

  v120 = __readfsqword(0x28u);
  v15 = *(unsigned __int64 **)(a1 + 160);
  if ( !a4 )
  {
    if ( v15[6] )
    {
      v62 = *(_DWORD *)a1;
      v63 = v15[4];
      v64 = v15[3];
      v65 = *(_DWORD *)a1 & 0x1000;
      if ( v63 > v64 && v65 )
      {
        v66 = *(_QWORD *)(a1 + 216);
        if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v66 - (_QWORD)&unk_BFAE0) )
          sub_17140(a7, a8, a9, a10, a11, a12, a13, a14);
        a2 = 0LL;
        v67 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(v66 + 128))(a1, 0LL, 2LL);
        if ( v67 == -1 )
          return -1LL;
        *(_QWORD *)(a1 + 144) = v67;
        v62 = *(_DWORD *)a1;
        v15 = *(unsigned __int64 **)(a1 + 160);
      }
      v68 = *v15;
      v69 = v15[1];
      if ( (v62 & 0x100) != 0 )
      {
        if ( v68 < v69 )
        {
LABEL_64:
          __writefsdword(0xFFFFFFC0, 0x16u);
          return -1LL;
        }
        v68 = v15[8];
        v69 = v15[10];
        v110 = v68;
      }
      else
      {
        v110 = v15[2];
      }
      v70 = *(__int64 **)(a1 + 152);
      v71 = sub_16AD0(v70);
      if ( v63 > v64 )
      {
        v85 = *(_QWORD **)(a1 + 160);
        v86 = v85[3];
        v87 = v85[4] - v86;
        if ( v71 <= 0 )
        {
          v113 = v85[4];
          v116 = v85[3];
          v115 = sub_21500(
                   (u32 *)(v113 - v86),
                   a2,
                   (unsigned int)v71,
                   v113,
                   v72,
                   v73,
                   a7,
                   a8,
                   a9,
                   a10,
                   a11,
                   a12,
                   a13,
                   a14);
          v98 = v115;
          v117[0] = v85[12];
          if ( (unsigned int)sub_168F0(v70, (__int64)v117, v86, v113, &v116, v115, v115 + v87, &v115) )
          {
            sub_21B70(v98, a7, a8, a9, a10, v102, v103, a13, a14, (__int64)v117, v99, v100, v101, v105);
            return 0xFFFFFFFFLL;
          }
          v88 = v115 - v98;
          sub_21B70(v98, a7, a8, a9, a10, v102, v103, a13, a14, (__int64)v117, v99, v100, v101, v105);
        }
        else
        {
          v88 = v71 * (v87 >> 2);
        }
        v89 = *(_QWORD *)(a1 + 40);
        if ( v65 )
          v90 = v89 - *(_QWORD *)(a1 + 32);
        else
          v90 = v89 - *(_QWORD *)(a1 + 16);
        v75 = v90 + v88;
      }
      else
      {
        v74 = *(_QWORD *)(a1 + 16);
        if ( v71 <= 0 )
        {
          v104 = *(_QWORD *)(a1 + 24);
          v117[0] = *(_QWORD *)(*(_QWORD *)(a1 + 160) + 96LL);
          v75 = (int)sub_16B00((__int64)v70, (__int64)v117, v104, v74, (__int64)(v68 - v110) >> 2)
              - (*(_QWORD *)(a1 + 16)
               - *(_QWORD *)(a1 + 24));
        }
        else
        {
          v75 = -(v71 * ((__int64)(v69 - v68) >> 2)) - (v74 - *(_QWORD *)(a1 + 8));
        }
      }
    }
    else
    {
      v75 = 0LL;
    }
    v76 = *(_QWORD *)(a1 + 144);
    if ( v76 == -1 )
    {
      v91 = *(_QWORD *)(a1 + 216);
      if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v91 - (_QWORD)&unk_BFAE0) )
        sub_17140(a7, a8, a9, a10, a11, a12, a13, a14);
      v76 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(v91 + 128))(a1, 0LL, 1LL);
      if ( v76 == -1 )
        return -1LL;
    }
    result = v75 + v76;
    if ( result >= 0 )
      return result;
    goto LABEL_64;
  }
  v17 = v15[4];
  v18 = v15[3];
  v19 = a2;
  if ( v15[2] == v15[1] && v17 == v18 )
  {
    v106 = 1;
  }
  else
  {
    v106 = 0;
    if ( v17 > v18 )
      goto LABEL_4;
  }
  if ( (*(_DWORD *)a1 & 0x800) == 0 )
  {
    if ( !v15[6] )
      goto LABEL_36;
    goto LABEL_6;
  }
LABEL_4:
  a5 = (u32 *)(unsigned int)sub_6AE60((int *)a1);
  result = 0xFFFFFFFFLL;
  if ( (_DWORD)a5 )
    return result;
  v15 = *(unsigned __int64 **)(a1 + 160);
  if ( !v15[6] )
  {
LABEL_36:
    v49 = v15[2];
    if ( v49 )
    {
      sub_21B70(v49, a7, a8, a9, a10, a11, a12, a13, a14, a2, v18, v17, a5, a6);
      *(_DWORD *)a1 &= 0xFFFFFEFF;
    }
    sub_1A500((int *)a1, a2, a7, a8, a9, a10, a11, a12, a13, a14);
    v50 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 40) = v50;
    *(_QWORD *)(a1 + 32) = v50;
    *(_QWORD *)(a1 + 48) = v50;
    *(_QWORD *)(a1 + 24) = v50;
    *(_QWORD *)(a1 + 8) = v50;
    *(_QWORD *)(a1 + 16) = v50;
    v51 = *(_QWORD **)(a1 + 160);
    v52 = v51[6];
    v51[4] = v52;
    v51[3] = v52;
    v51[5] = v52;
    v51[2] = v52;
    *v51 = v52;
    v51[1] = v52;
    if ( a3 == 1 )
      goto LABEL_39;
LABEL_7:
    if ( a3 == 2 )
    {
      v21 = *(_QWORD *)(a1 + 216);
      v22 = (char *)&off_C0308 - (char *)&unk_BFAE0;
      if ( v21 - (__int64)&unk_BFAE0 >= (unsigned __int64)((char *)&off_C0308 - (char *)&unk_BFAE0) )
        sub_17140(a7, a8, a9, a10, a11, a12, a13, a14);
      if ( (*(unsigned int (__fastcall **)(__int64, __int64 *))(v21 + 144))(a1, v117) || (v118 & 0xF000) != 0x8000 )
        goto LABEL_44;
      v19 = v119 + a2;
      a3 = 0;
    }
    goto LABEL_13;
  }
LABEL_6:
  if ( a3 != 1 )
    goto LABEL_7;
LABEL_39:
  v53 = *(__int64 **)(a1 + 152);
  v54 = sub_16AD0(v53);
  if ( v54 <= 0 )
  {
    v77 = *(__int64 **)(a1 + 160);
    v78 = *(_QWORD *)(a1 + 16);
    v79 = *(_QWORD *)(a1 + 24);
    v80 = v77[12];
    v81 = *v77;
    v77 += 11;
    v82 = v81 - *(v77 - 9);
    *v77 = v80;
    v83 = sub_16B00((__int64)v53, (__int64)v77, v79, v78, v82 >> 2);
    v84 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 8) = v84 + v83;
    *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8LL) = **(_QWORD **)(a1 + 160);
    v19 -= *(_QWORD *)(a1 + 16) - v84 - v83;
  }
  else
  {
    v19 = a2
        - ((__int64)(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 8LL) - **(_QWORD **)(a1 + 160)) >> 2) * v54
        - (*(_QWORD *)(a1 + 16)
         - *(_QWORD *)(a1 + 8));
  }
  v55 = *(_QWORD *)(a1 + 144);
  if ( v55 == -1 )
    goto LABEL_43;
  v19 += v55;
  a3 = 0;
LABEL_13:
  sub_6AEE0((int *)a1);
  v25 = *(_QWORD *)(a1 + 144);
  v26 = *(_DWORD *)a1;
  if ( v25 == -1
    || !*(_QWORD *)(a1 + 24)
    || (v26 & 0x100) != 0
    || (v27 = *(_QWORD *)(a1 + 56), v28 = v25 + v27 - *(_QWORD *)(a1 + 16), v25 <= v19)
    || v19 < v28 )
  {
    v22 = (char *)&off_C0308 - (char *)&unk_BFAE0;
    if ( (v26 & 4) != 0 )
      goto LABEL_44;
    v29 = *(_QWORD *)(a1 + 64);
    v30 = v19 & (*(_QWORD *)(a1 + 56) - v29);
    v31 = v19 - v30;
    if ( v29 - *(_QWORD *)(a1 + 56) < v19 - v30 )
    {
      v30 = v19;
      v31 = 0LL;
    }
    v32 = *(_QWORD *)(a1 + 216);
    if ( v22 <= v32 - (__int64)&unk_BFAE0 )
    {
      v112 = v31;
      sub_17140(a7, a8, a9, a10, v23, v24, a13, a14);
      v31 = v112;
    }
    v109 = v31;
    v33 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v32 + 128))(a1, v30, 0LL);
    if ( v33 >= 0 )
    {
      v36 = v109;
      if ( !v109 )
      {
        v42 = 0LL;
        v43 = 0LL;
        goto LABEL_30;
      }
      v37 = *(_QWORD *)(a1 + 216);
      if ( v22 <= v37 - (__int64)&unk_BFAE0 )
      {
        v114 = v109;
        v111 = *(_QWORD *)(a1 + 216);
        sub_17140(a7, a8, a9, a10, v34, v35, a13, a14);
        v36 = v114;
        v37 = v111;
      }
      v38 = *(__int64 (__fastcall **)(__int64, __int64, __int64))(v37 + 112);
      v39 = v36;
      v40 = *(_QWORD *)(a1 + 56);
      if ( !v106 )
        v39 = *(_QWORD *)(a1 + 64) - v40;
      v107 = v36;
      v41 = v38(a1, v40, v39);
      v36 = v107;
      v42 = v41;
      v43 = v41;
      if ( v107 <= v41 )
      {
LABEL_30:
        v44 = *(_QWORD *)(a1 + 56);
        v108 = v42;
        *(_QWORD *)(a1 + 24) = v44;
        v45 = v44 + v43;
        v46 = v44 + v36;
        *(_QWORD *)(a1 + 40) = v44;
        *(_QWORD *)(a1 + 32) = v44;
        *(_QWORD *)(a1 + 48) = v44;
        v47 = *(_QWORD **)(a1 + 160);
        *(_QWORD *)(a1 + 16) = v45;
        v48 = v47[6];
        *(_QWORD *)(a1 + 8) = v46;
        v47[2] = v48;
        *v47 = v48;
        v47[1] = v48;
        v47[4] = v48;
        v47[3] = v48;
        v47[5] = v48;
        if ( !(unsigned int)sub_15430(a1, 1) )
        {
          *(_DWORD *)a1 &= 0xFFFFFFEF;
          result = v19;
          *(_QWORD *)(a1 + 144) = v108 + v33;
          return result;
        }
        goto LABEL_44;
      }
      if ( v41 == -1 )
      {
        v19 = v107;
        a3 = 1;
      }
      else
      {
        a3 = 1;
        v19 = v107 - v41;
      }
LABEL_44:
      sub_1BB30((int *)a1);
      v58 = *(_QWORD *)(a1 + 216);
      if ( v58 - (__int64)&unk_BFAE0 >= v22 )
        sub_17140(a7, a8, a9, a10, v56, v57, a13, a14);
      result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v58 + 128))(a1, v19, a3);
      if ( result != -1 )
      {
        v59 = *(_QWORD *)(a1 + 56);
        *(_DWORD *)a1 &= 0xFFFFFFEF;
        *(_QWORD *)(a1 + 144) = result;
        *(_QWORD *)(a1 + 24) = v59;
        *(_QWORD *)(a1 + 8) = v59;
        *(_QWORD *)(a1 + 16) = v59;
        *(_QWORD *)(a1 + 40) = v59;
        *(_QWORD *)(a1 + 32) = v59;
        *(_QWORD *)(a1 + 48) = v59;
        v60 = *(_QWORD **)(a1 + 160);
        v61 = v60[6];
        v60[2] = v61;
        *v60 = v61;
        v60[1] = v61;
        v60[4] = v61;
        v60[3] = v61;
        v60[5] = v61;
      }
      return result;
    }
    return -1LL;
  }
  *(_QWORD *)(a1 + 24) = v27;
  *(_QWORD *)(a1 + 40) = v27;
  *(_QWORD *)(a1 + 32) = v27;
  *(_QWORD *)(a1 + 8) = v27 + v19 - v28;
  v92 = *(_QWORD **)(a1 + 160);
  *(_QWORD *)(a1 + 48) = v27;
  v93 = v92[6];
  v92[2] = v93;
  *v92 = v93;
  v92[1] = v93;
  v92[4] = v93;
  v92[3] = v93;
  v92[5] = v93;
  if ( (unsigned int)sub_15430(a1, 0) )
  {
LABEL_43:
    v22 = (char *)&off_C0308 - (char *)&unk_BFAE0;
    goto LABEL_44;
  }
  v96 = *(_QWORD *)(a1 + 144);
  *(_DWORD *)a1 &= 0xFFFFFFEF;
  if ( v96 >= 0 )
  {
    v97 = *(_QWORD *)(a1 + 216);
    if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v97 - (_QWORD)&unk_BFAE0) )
    {
      sub_17140(a7, a8, a9, a10, v94, v95, a13, a14);
      v96 = *(_QWORD *)(a1 + 144);
    }
    (*(void (__fastcall **)(__int64, __int64, _QWORD))(v97 + 128))(a1, v96, 0LL);
  }
  return v19;
}
// 15CE0: variable 'a11' is possibly undefined
// 15CE0: variable 'a12' is possibly undefined
// 15CCA: variable 'v23' is possibly undefined
// 15CCA: variable 'v24' is possibly undefined
// 15C0A: variable 'v34' is possibly undefined
// 15C0A: variable 'v35' is possibly undefined
// 157E1: variable 'v18' is possibly undefined
// 157E1: variable 'v17' is possibly undefined
// 157E1: variable 'a6' is possibly undefined
// 15BD0: variable 'v56' is possibly undefined
// 15BD0: variable 'v57' is possibly undefined
// 15DC8: variable 'v94' is possibly undefined
// 15DC8: variable 'v95' is possibly undefined
// 15CF8: variable 'v72' is possibly undefined
// 15CF8: variable 'v73' is possibly undefined
// 15D4D: variable 'v102' is possibly undefined
// 15D4D: variable 'v103' is possibly undefined
// 15D4D: variable 'v99' is possibly undefined
// 15D4D: variable 'v100' is possibly undefined
// 15D4D: variable 'v101' is possibly undefined
// 15D4D: variable 'v105' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (0000000000015DE0) ----------------------------------------------------
__int64 __fastcall sub_15DE0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 result; // rax

  if ( (unsigned int)sub_17BF0(a1, a2, a3, a4, a5, a6, a7, a8, a9) == -1 )
    result = 0xFFFFFFFFLL;
  else
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 224LL) + 32LL))(a1);
  return result;
}

//----- (0000000000015E20) ----------------------------------------------------
__int64 __fastcall sub_15E20(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, unsigned __int64 a12, u32 *a13)
{
  __int64 *v14; // rax
  unsigned int *v15; // rdx
  __int64 v16; // rbp
  unsigned __int64 v17; // rdx
  __int64 v18; // r9
  unsigned int *v19; // rcx
  unsigned int **v20; // rax
  __int64 result; // rax
  __int64 v22; // rdi
  __int64 v23[5]; // [rsp+0h] [rbp-28h] BYREF

  v23[1] = __readfsqword(0x28u);
  if ( (*(_DWORD *)a1 & 4) != 0 )
  {
    *(_DWORD *)a1 |= 0x20u;
    __writefsdword(0xFFFFFFC0, 9u);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v14 = *(__int64 **)(a1 + 160);
    v15 = (unsigned int *)*v14;
    if ( *v14 < (unsigned __int64)v14[1] )
      return *v15;
    v16 = *(_QWORD *)(a1 + 152);
    v17 = *(_QWORD *)(a1 + 8);
    if ( v17 < *(_QWORD *)(a1 + 16) )
    {
      v18 = v14[6];
      v23[0] = *(_QWORD *)(a1 + 8);
      if ( v18 )
        goto LABEL_5;
LABEL_10:
      v22 = v14[8];
      if ( v22 )
      {
        sub_21B70(v22, a3, a4, a5, a6, a7, a8, a9, a10, a2, v17, a12, a13, v18);
        *(_DWORD *)a1 &= 0xFFFFFEFF;
      }
      sub_6AD40(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
      v14 = *(__int64 **)(a1 + 160);
      v17 = *(_QWORD *)(a1 + 8);
      v18 = v14[6];
LABEL_5:
      v19 = (unsigned int *)v14[11];
      *v14 = v18;
      v14[2] = v18;
      v14[12] = (__int64)v19;
      sub_169E0(v16, (__int64)(v14 + 11), v17, *(_QWORD *)(a1 + 16), v23, v18, v14[7], v14 + 1);
      *(_QWORD *)(a1 + 8) = v23[0];
      v20 = *(unsigned int ***)(a1 + 160);
      v15 = *v20;
      if ( *v20 >= v20[1] )
      {
        __writefsdword(0xFFFFFFC0, 0x54u);
        result = 0xFFFFFFFFLL;
        *(_DWORD *)a1 |= 0x20u;
        return result;
      }
      return *v15;
    }
    if ( (unsigned int)sub_187F0(a1, a3, a4, a5, a6, a7, a8, a9, a10) != -1 )
    {
      v14 = *(__int64 **)(a1 + 160);
      v17 = *(_QWORD *)(a1 + 8);
      v18 = v14[6];
      v23[0] = v17;
      if ( v18 )
        goto LABEL_5;
      goto LABEL_10;
    }
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 15F2F: variable 'a7' is possibly undefined
// 15F2F: variable 'a8' is possibly undefined
// 15F2F: variable 'a12' is possibly undefined
// 15F2F: variable 'a13' is possibly undefined

//----- (0000000000015F90) ----------------------------------------------------
__int64 __fastcall sub_15F90(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  char *v11; // r9
  char *v12; // r12
  __int64 v14; // r14
  _QWORD *v15; // r13
  __int64 *v16; // r8
  char *v17; // rax
  int v18; // er15
  double v19; // xmm4_8
  double v20; // xmm5_8
  __int64 result; // rax
  _QWORD *v22; // rdx
  int v23; // eax
  __int64 v24; // rcx
  __int64 v25; // rcx
  __int64 *v26; // [rsp+8h] [rbp-80h]
  __int64 v27; // [rsp+20h] [rbp-68h] BYREF
  char *v28; // [rsp+28h] [rbp-60h] BYREF
  char v29[16]; // [rsp+30h] [rbp-58h] BYREF
  char v30; // [rsp+40h] [rbp-48h] BYREF
  unsigned __int64 v31; // [rsp+48h] [rbp-40h]

  v31 = __readfsqword(0x28u);
  if ( a3 )
  {
    v11 = *(char **)(a1 + 40);
    v12 = *(char **)(a1 + 32);
    v14 = a3;
    v15 = *(_QWORD **)(a1 + 152);
    if ( *(char **)(a1 + 48) == v11 && v11 != v12 )
    {
      result = sub_18D30(a1, *(_QWORD *)(a1 + 32), v11 - v12, a4, a5, a6, a7, a8, a9, a10, a11);
      if ( (_DWORD)result == -1 )
        return result;
      v11 = *(char **)(a1 + 40);
      v12 = *(char **)(a1 + 32);
    }
    v16 = &v27;
    while ( 1 )
    {
      if ( (unsigned __int64)(v11 - v12) <= 0xF )
      {
        v12 = v29;
        v17 = &v30;
        v28 = v29;
        v11 = v29;
      }
      else
      {
        v28 = v11;
        v17 = *(char **)(a1 + 64);
      }
      v26 = v16;
      v18 = sub_168F0(v15, *(_QWORD *)(a1 + 160) + 88LL, a2, a2 + 4 * v14, v16, (__int64)v11, (__int64)v17, &v28);
      result = sub_18D30(a1, (unsigned __int64)v12, v28 - v12, a4, a5, a6, a7, v19, v20, a10, a11);
      if ( (_DWORD)result == -1 )
        break;
      v16 = v26;
      v14 -= (v27 - a2) >> 2;
      if ( v18 && (v27 == a2 || v18 != 1) )
      {
        v22 = *(_QWORD **)(a1 + 160);
        v25 = v22[6];
        result = (unsigned int)-(v14 != 0);
        v22[2] = v25;
        *v22 = v25;
        v22[1] = v25;
        v22[4] = v25;
        v22[3] = v25;
        if ( (*(_DWORD *)a1 & 0x202) != 0 )
          goto LABEL_15;
        goto LABEL_14;
      }
      if ( !v14 )
        goto LABEL_13;
      v11 = *(char **)(a1 + 40);
      v12 = *(char **)(a1 + 32);
      a2 = v27;
    }
  }
  else
  {
LABEL_13:
    v22 = *(_QWORD **)(a1 + 160);
    v23 = *(_DWORD *)a1;
    v24 = v22[6];
    v22[2] = v24;
    *v22 = v24;
    v22[1] = v24;
    v22[4] = v24;
    v22[3] = v24;
    result = v23 & 0x202;
    if ( (_DWORD)result )
    {
      v22[5] = v24;
      result = 0LL;
    }
    else
    {
LABEL_14:
      v25 = v22[7];
LABEL_15:
      v22[5] = v25;
    }
  }
  return result;
}
// 1604A: variable 'v19' is possibly undefined
// 1604A: variable 'v20' is possibly undefined

//----- (0000000000016190) ----------------------------------------------------
__int64 __fastcall sub_16190(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  int v11; // edx
  unsigned int v12; // er12
  __int64 *v13; // rax
  __int64 v14; // rcx
  __int64 v15; // r9
  __int64 v16; // rsi
  __int64 v17; // r8
  __int64 v18; // rdi
  __int64 v19; // rsi
  __int64 *v20; // rax
  unsigned int *v21; // rdx
  bool v22; // al
  __int64 result; // rax
  bool v24; // al
  bool v25; // zf

  v11 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 8) != 0 )
  {
    *(_DWORD *)a1 = v11 | 0x20;
    __writefsdword(0xFFFFFFC0, 9u);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v12 = a2;
    if ( (v11 & 0x800) != 0 )
      goto LABEL_7;
    v13 = *(__int64 **)(a1 + 160);
    if ( v13[3] )
    {
      v14 = *v13;
      v15 = v13[7];
      if ( *v13 == v15 )
      {
        v16 = *(_QWORD *)(a1 + 56);
        v14 = v13[6];
        *(_QWORD *)(a1 + 16) = v16;
        v17 = v14;
        v18 = v16;
        *v13 = v14;
        v13[1] = v14;
      }
      else
      {
        v16 = *(_QWORD *)(a1 + 8);
        v17 = v13[1];
        v18 = *(_QWORD *)(a1 + 16);
      }
    }
    else
    {
      sub_6AD40(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
      sub_6AEE0((int *)a1);
      v13 = *(__int64 **)(a1 + 160);
      v25 = *(_QWORD *)(a1 + 32) == 0LL;
      v14 = v13[6];
      v13[2] = v14;
      *v13 = v14;
      v13[1] = v14;
      if ( v25 )
      {
        sub_1A500((int *)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
        v13 = *(__int64 **)(a1 + 160);
        v16 = *(_QWORD *)(a1 + 56);
        v11 = *(_DWORD *)a1;
        v14 = *v13;
        v15 = v13[7];
        *(_QWORD *)(a1 + 16) = v16;
        v18 = v16;
        v17 = v13[1];
      }
      else
      {
        v15 = v13[7];
        v16 = *(_QWORD *)(a1 + 8);
        v17 = v14;
        v18 = *(_QWORD *)(a1 + 16);
        v11 = *(_DWORD *)a1;
      }
    }
    v13[4] = v14;
    v13[3] = v14;
    v13[5] = v15;
    *v13 = v17;
    v13[2] = v17;
    *(_QWORD *)(a1 + 40) = v16;
    *(_QWORD *)(a1 + 32) = v16;
    v19 = *(_QWORD *)(a1 + 64);
    *(_QWORD *)(a1 + 8) = v18;
    *(_QWORD *)(a1 + 48) = v19;
    *(_QWORD *)(a1 + 24) = v18;
    *(_DWORD *)a1 = v11 | 0x800;
    if ( (v11 & 0x202) != 0 )
    {
      v13[5] = v14;
      if ( v12 != -1 )
      {
LABEL_8:
        v20 = *(__int64 **)(a1 + 160);
        v21 = (unsigned int *)v20[4];
        if ( v21 == (unsigned int *)v20[7] )
        {
          if ( *(int *)(a1 + 192) <= 0 )
            v24 = (unsigned int)sub_18D30(
                                  a1,
                                  *(_QWORD *)(a1 + 32),
                                  *(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32),
                                  a3,
                                  a4,
                                  a5,
                                  a6,
                                  a7,
                                  a8,
                                  a9,
                                  a10) == -1;
          else
            v24 = (unsigned int)sub_15F90(a1, v20[3], ((__int64)v21 - v20[3]) >> 2, a3, a4, a5, a6, a7, a8, a9, a10) == -1;
          if ( v24 )
            return (unsigned int)-1;
          v20 = *(__int64 **)(a1 + 160);
          v21 = (unsigned int *)v20[4];
        }
        v20[4] = (__int64)(v21 + 1);
        *v21 = v12;
        if ( (*(_DWORD *)a1 & 2) == 0 )
        {
          if ( (*(_DWORD *)a1 & 0x200) == 0 )
            return v12;
          if ( v12 != 10 )
            return v12;
        }
        if ( *(int *)(a1 + 192) <= 0 )
          v22 = (unsigned int)sub_18D30(
                                a1,
                                *(_QWORD *)(a1 + 32),
                                *(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32),
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                a9,
                                a10) == -1;
        else
          v22 = (unsigned int)sub_15F90(a1, v20[3], ((__int64)v21 - v20[3] + 4) >> 2, a3, a4, a5, a6, a7, a8, a9, a10) == -1;
        if ( !v22 )
          return v12;
        return (unsigned int)-1;
      }
    }
    else
    {
LABEL_7:
      if ( v12 != -1 )
        goto LABEL_8;
    }
    if ( *(int *)(a1 + 192) <= 0 )
      result = sub_18D30(
                 a1,
                 *(_QWORD *)(a1 + 32),
                 *(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32),
                 a3,
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 a9,
                 a10);
    else
      result = sub_15F90(
                 a1,
                 *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL),
                 (__int64)(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 32LL) - *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL)) >> 2,
                 a3,
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 a9,
                 a10);
  }
  return result;
}
// 16272: variable 'a7' is possibly undefined
// 16272: variable 'a8' is possibly undefined

//----- (0000000000016460) ----------------------------------------------------
__int64 __fastcall sub_16460(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 *v9; // rax
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rsi
  __int64 v12; // rbp
  __int64 v13; // r12
  __int64 *v14; // r13
  int v15; // eax
  double v16; // xmm4_8
  double v17; // xmm5_8
  __int64 v18; // rsi
  __int64 v19; // rbp
  __int64 *v21; // rsi
  __int64 v22; // rcx
  __int64 v23; // rdx
  __int64 v24; // rax
  __int64 v25; // r8
  __int64 v26; // r8
  int v27; // eax
  __int64 v28; // rdx
  __int64 v29; // rcx
  __int64 v30; // rdx

  v9 = *(__int64 **)(a1 + 160);
  v10 = v9[4];
  v11 = v9[3];
  if ( v10 > v11 )
  {
    if ( *(int *)(a1 + 192) <= 0 )
    {
      if ( (unsigned int)sub_18D30(
                           a1,
                           *(_QWORD *)(a1 + 32),
                           *(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32),
                           a2,
                           a3,
                           a4,
                           a5,
                           a6,
                           a7,
                           a8,
                           a9) )
        return 0xFFFFFFFFLL;
    }
    else if ( (unsigned int)sub_15F90(a1, v11, (__int64)(v10 - v11) >> 2, a2, a3, a4, a5, a6, a7, a8, a9) )
    {
      return 0xFFFFFFFFLL;
    }
    v9 = *(__int64 **)(a1 + 160);
  }
  v12 = *v9;
  v13 = v9[1];
  if ( *v9 == v13 )
  {
LABEL_12:
    *(_QWORD *)(a1 + 144) = -1LL;
    return 0LL;
  }
  v14 = *(__int64 **)(a1 + 152);
  v15 = sub_16AD0(v14);
  if ( v15 <= 0 )
  {
    v21 = *(__int64 **)(a1 + 160);
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_QWORD *)(a1 + 24);
    v24 = v21[12];
    v25 = *v21;
    v21 += 11;
    v26 = v25 - *(v21 - 9);
    *v21 = v24;
    v27 = sub_16B00((__int64)v14, (__int64)v21, v23, v22, v26 >> 2);
    v28 = *(_QWORD *)(a1 + 24);
    v29 = v28 + v27;
    v30 = v28 - *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 8) = v29;
    v18 = v30 + v27;
  }
  else
  {
    v18 = ((v12 - v13) >> 2) * v15;
  }
  v19 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v19 - (_QWORD)&unk_BFAE0) )
    sub_17140(a2, a3, a4, a5, v16, v17, a8, a9);
  if ( (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v19 + 128))(a1, v18, 1LL) != -1 )
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8LL) = **(_QWORD **)(a1 + 160);
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 8);
    goto LABEL_12;
  }
  if ( __readfsdword(0xFFFFFFC0) == 29 )
    goto LABEL_12;
  return 0xFFFFFFFFLL;
}
// 165E5: variable 'v16' is possibly undefined
// 165E5: variable 'v17' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (0000000000016600) ----------------------------------------------------
unsigned __int64 __fastcall sub_16600(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  unsigned __int64 v15; // rbp
  _QWORD *v16; // r14
  int v17; // eax
  __int64 v18; // rdi
  int v19; // er15
  unsigned __int64 v20; // rbx
  __int64 v21; // rax
  __int64 v22; // rdx
  __int64 v23; // rsi
  _DWORD *v25; // rax
  __int64 v26; // rax

  if ( !a3 )
    return 0LL;
  v15 = a3;
  v16 = *(_QWORD **)(a1 + 160);
  v17 = *(_DWORD *)a1 & 0xA00;
  v18 = v16[4];
  if ( v17 == 2560 )
  {
    v20 = (v16[7] - v18) >> 2;
    if ( a3 > v20 )
    {
      v19 = 0;
    }
    else
    {
      v25 = (_DWORD *)(a2 + 4 * a3);
      do
      {
        if ( a2 >= (unsigned __int64)v25 )
        {
          v19 = 0;
          goto LABEL_15;
        }
        --v25;
      }
      while ( *v25 != 10 );
      v19 = 1;
      v20 = ((__int64)((__int64)v25 - a2) >> 2) + 1;
    }
  }
  else
  {
    v19 = 0;
    v20 = (v16[5] - v18) >> 2;
  }
  if ( v20 )
  {
LABEL_15:
    if ( a3 <= v20 )
      v20 = a3;
    v26 = 0LL;
    if ( v20 > 0x14 )
    {
      v16[4] = sub_49000(v18, a2, v20);
      a2 += 4 * v20;
    }
    else
    {
      do
      {
        *(_DWORD *)(v18 + 4 * v26) = *(_DWORD *)(a2 + 4 * v26);
        ++v26;
      }
      while ( v20 != v26 );
      a2 += 4 * v20;
      v16[4] = 4 * v20 + v18;
    }
    a3 = v15 - v20;
    if ( v15 == v20 )
      goto LABEL_6;
  }
  v15 += sub_6ABD0(a1, a2, a3, a7, a8, a9, a10, a11, a12, a13, a14, a4, a5, a6) - a3;
LABEL_6:
  if ( v19 )
  {
    v21 = *(_QWORD *)(a1 + 160);
    v22 = *(_QWORD *)(v21 + 32);
    v23 = *(_QWORD *)(v21 + 24);
    if ( v22 != v23 )
      sub_15F90(a1, v23, (v22 - v23) >> 2, a7, a8, a9, a10, a11, a12, a13, a14);
  }
  return v15;
}
// 1665C: variable 'a11' is possibly undefined
// 1665C: variable 'a12' is possibly undefined
// 1665C: variable 'a4' is possibly undefined
// 1665C: variable 'a5' is possibly undefined
// 1665C: variable 'a6' is possibly undefined

//----- (0000000000016780) ----------------------------------------------------
__int64 __fastcall sub_16780(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 result; // rax
  __int64 v15; // rbp
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rcx
  __int64 v19; // rax
  __int64 v20; // rdx
  __int64 v21; // rax
  __m128i v22; // [rsp+0h] [rbp-48h] BYREF
  __int64 v23; // [rsp+10h] [rbp-38h]
  __int64 v24; // [rsp+18h] [rbp-30h]
  unsigned __int64 v25; // [rsp+28h] [rbp-20h]

  v25 = __readfsqword(0x28u);
  result = *(unsigned int *)(a1 + 192);
  if ( (int)a2 < 0 )
  {
    if ( (_DWORD)result )
      return result;
    result = 0xFFFFFFFFLL;
LABEL_7:
    *(_DWORD *)(a1 + 192) = result;
    return result;
  }
  if ( !(_DWORD)result && (_DWORD)a2 )
  {
    v15 = *(_QWORD *)(a1 + 160);
    *(_QWORD *)(a1 + 152) = v15 + 104;
    v16 = *(_QWORD *)(v15 + 8);
    *(_QWORD *)(v15 + 88) = 0LL;
    *(_QWORD *)v15 = v16;
    *(_QWORD *)(v15 + 32) = *(_QWORD *)(v15 + 24);
    *(_QWORD *)(*(_QWORD *)(a1 + 160) + 96LL) = 0LL;
    sub_49450(&v22, a2, a7, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6);
    if ( v22.m128i_i64[1] != 1 )
      sub_CF00("fcts.towc_nsteps == 1", "iofwide.c", 80LL, "_IO_fwide");
    if ( v24 != 1 )
      sub_CF00("fcts.tomb_nsteps == 1", "iofwide.c", 81LL, "_IO_fwide");
    v17 = v22.m128i_i64[0];
    v18 = v23;
    *(_QWORD *)(v15 + 128) = 1LL;
    *(_DWORD *)(v15 + 136) = 1;
    *(_QWORD *)(v15 + 104) = v17;
    v19 = *(_QWORD *)(a1 + 160);
    *(_QWORD *)(v15 + 160) = v18;
    *(_QWORD *)(v15 + 184) = 9LL;
    v20 = v19 + 88;
    v21 = *(_QWORD *)(v19 + 224);
    *(_QWORD *)(v15 + 144) = v20;
    *(_DWORD *)(v15 + 192) = 1;
    *(_QWORD *)(v15 + 200) = v20;
    *(_QWORD *)(a1 + 216) = v21;
    result = 1LL;
    goto LABEL_7;
  }
  return result;
}
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000168F0) ----------------------------------------------------
__int64 __fastcall sub_168F0(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5, __int64 a6, __int64 a7, _QWORD *a8)
{
  _QWORD *v10; // r13
  bool v11; // zf
  __int64 (__fastcall *v12)(_QWORD *, _QWORD *, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD); // rbp
  int v13; // eax
  char v15[8]; // [rsp+8h] [rbp-50h] BYREF
  __int64 v16[9]; // [rsp+10h] [rbp-48h] BYREF

  v10 = (_QWORD *)a1[7];
  v16[1] = __readfsqword(0x28u);
  a1[8] = a6;
  v11 = *v10 == 0LL;
  v12 = (__int64 (__fastcall *)(_QWORD *, _QWORD *, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD))v10[5];
  v16[0] = a3;
  a1[9] = a7;
  a1[12] = a2;
  if ( !v11 )
    v12 = (__int64 (__fastcall *)(_QWORD *, _QWORD *, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v12, 17));
  sub_4F2B0((__int64)v12);
  v13 = v12(v10, a1 + 8, v16, a4, 0LL, v15, 0LL, 0LL);
  *a5 = v16[0];
  *a8 = a1[8];
  if ( v13 == 5 )
    return 1LL;
  if ( v13 > 5 )
    return (unsigned int)(v13 != 7) + 1;
  return 2 * (unsigned int)((v13 & 0xFFFFFFFB) != 0);
}

//----- (00000000000169E0) ----------------------------------------------------
__int64 __fastcall sub_169E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5, __int64 a6, __int64 a7, _QWORD *a8)
{
  _QWORD *v10; // r13
  bool v11; // zf
  __int64 (__fastcall *v12)(_QWORD *, __int64, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD); // rbp
  int v13; // eax
  char v15[8]; // [rsp+8h] [rbp-50h] BYREF
  __int64 v16[9]; // [rsp+10h] [rbp-48h] BYREF

  v10 = *(_QWORD **)a1;
  v16[1] = __readfsqword(0x28u);
  *(_QWORD *)(a1 + 8) = a6;
  v11 = *v10 == 0LL;
  v12 = (__int64 (__fastcall *)(_QWORD *, __int64, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD))v10[5];
  v16[0] = a3;
  *(_QWORD *)(a1 + 16) = a7;
  *(_QWORD *)(a1 + 40) = a2;
  if ( !v11 )
    v12 = (__int64 (__fastcall *)(_QWORD *, __int64, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v12, 17));
  sub_4F2B0((__int64)v12);
  v13 = v12(v10, a1 + 8, v16, a4, 0LL, v15, 0LL, 0LL);
  *a5 = v16[0];
  *a8 = *(_QWORD *)(a1 + 8);
  if ( v13 == 5 )
    return 1LL;
  if ( v13 > 5 )
    return (unsigned int)(v13 != 7) + 1;
  return 2 * (unsigned int)((v13 & 0xFFFFFFFB) != 0);
}

//----- (0000000000016AD0) ----------------------------------------------------
__int64 __fastcall sub_16AD0(__int64 *a1)
{
  __int64 v1; // rdx
  __int64 result; // rax

  v1 = *a1;
  if ( *(_DWORD *)(*a1 + 88) )
    return 0xFFFFFFFFLL;
  result = *(unsigned int *)(v1 + 76);
  if ( *(_DWORD *)(v1 + 72) != (_DWORD)result )
    result = 0LL;
  return result;
}

//----- (0000000000016B00) ----------------------------------------------------
__int64 __fastcall sub_16B00(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  signed __int64 v5; // r8
  _QWORD *v8; // r14
  void (__fastcall *v9)(_QWORD *, __int64, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD); // r12
  void *v10; // rsp
  bool v11; // zf
  _BYTE v13[8]; // [rsp+0h] [rbp-50h] BYREF
  __int64 v14; // [rsp+8h] [rbp-48h] BYREF
  char v15[8]; // [rsp+10h] [rbp-40h] BYREF
  unsigned __int64 v16; // [rsp+18h] [rbp-38h]

  v5 = 4 * a5;
  v8 = *(_QWORD **)a1;
  v16 = __readfsqword(0x28u);
  v14 = a3;
  *(_QWORD *)(a1 + 40) = a2;
  v9 = (void (__fastcall *)(_QWORD *, __int64, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD))v8[5];
  v10 = alloca(v5);
  *(_QWORD *)(a1 + 8) = v13;
  v11 = *v8 == 0LL;
  *(_QWORD *)(a1 + 16) = &v13[v5];
  if ( !v11 )
    v9 = (void (__fastcall *)(_QWORD *, __int64, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v9, 17));
  sub_4F2B0((__int64)v9);
  v9(v8, a1 + 8, &v14, a4, 0LL, v15, 0LL, 0LL);
  return v14 - a3;
}

//----- (0000000000016BC0) ----------------------------------------------------
__int64 __fastcall sub_16BC0(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  unsigned int v6; // edx
  __int64 v7; // rcx
  unsigned __int64 v9; // rbp
  unsigned int v12; // ecx
  unsigned int v13; // er8
  int v14; // eax
  u32 *v15; // r8
  signed __int64 v17; // rax

  v6 = *a1;
  if ( *((char *)a1 + 116) < 0 )
  {
    v7 = (unsigned __int16)v6 & 0x8000;
    if ( (v6 & 0x8000) == 0 )
    {
      v9 = __readfsqword(0x10u);
      _RDI = *((_QWORD *)a1 + 17);
      if ( v9 == *(_QWORD *)(_RDI + 8) )
      {
        v14 = *(_DWORD *)(_RDI + 4);
        v15 = (u32 *)((v6 >> 4) & 1);
      }
      else
      {
        _EDX = 1;
        if ( __readfsdword(0x18u) )
        {
          if ( (_DWORD)v7 != _InterlockedCompareExchange((volatile signed __int32 *)_RDI, 1, v7) )
            sub_1C7D0((volatile __int32 *)_RDI, a2, 1LL, v7, a5, a6);
        }
        else
        {
          __asm { cmpxchg [rdi], edx }
        }
        v12 = *a1;
        _RDI = *((_QWORD *)a1 + 17);
        v13 = *a1;
        *(_QWORD *)(_RDI + 8) = v9;
        v14 = *(_DWORD *)(_RDI + 4);
        v15 = (u32 *)((v13 >> 4) & 1);
        if ( (v12 & 0x8000) != 0 )
        {
          *(_DWORD *)(_RDI + 4) = v14 + 1;
          return (unsigned int)v15;
        }
      }
      if ( !v14 )
      {
        *(_QWORD *)(_RDI + 8) = 0LL;
        if ( __readfsdword(0x18u) )
        {
          if ( _InterlockedExchange((volatile __int32 *)_RDI, 0) > 1 )
            v17 = sys_futex((u32 *)_RDI, 129, 1u, 0LL, v15, a6);
        }
        else
        {
          --*(_DWORD *)_RDI;
        }
      }
      return (unsigned int)v15;
    }
  }
  return (v6 >> 4) & 1;
}
// 16C54: variable 'v15' is possibly undefined
// 16CB1: variable 'a6' is possibly undefined

//----- (0000000000016CC0) ----------------------------------------------------
__int64 __fastcall sub_16CC0(_DWORD *a1)
{
  __int64 result; // rax

  if ( (*a1 & 0x2000) == 0 || (result = (unsigned int)a1[28], (int)result < 0) )
  {
    __writefsdword(0xFFFFFFC0, 9u);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000016CF0) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall sub_16CF0(__int64 a1)
{
  return sub_137F0(a1);
}
// 137F0: using guessed type __int64 __fastcall sub_137F0(_QWORD);

//----- (0000000000016D00) ----------------------------------------------------
__int64 __fastcall sub_16D00(__int64 *a1, unsigned __int64 a2, __m128i *a3, unsigned int a4, __m128 a5, double a6, __m128i a7, __m128 a8, double a9, double a10, double a11, double a12)
{
  __int64 v14; // rax
  unsigned __int64 v15; // rbp
  double v16; // xmm4_8
  double v17; // xmm5_8
  __int64 v18; // rdx
  __int64 v19; // rcx
  u32 *v20; // r8
  u32 v21; // er9
  int v22; // er12
  double v23; // xmm4_8
  double v24; // xmm5_8
  size_t v25; // rbp
  unsigned __int64 v26; // r13
  void *v27; // r14
  __int64 v28; // rax
  void *v30; // rax
  int v31[8]; // [rsp+0h] [rbp-138h] BYREF
  __int64 v32; // [rsp+20h] [rbp-118h]
  __int64 v33; // [rsp+28h] [rbp-110h]
  __int64 v34; // [rsp+30h] [rbp-108h]
  void *v35; // [rsp+38h] [rbp-100h]
  __int64 v36; // [rsp+88h] [rbp-B0h]
  void *v37; // [rsp+D8h] [rbp-60h]
  __int64 (__fastcall *v38)(_QWORD); // [rsp+E0h] [rbp-58h]
  __int64 (__fastcall *v39)(_QWORD); // [rsp+E8h] [rbp-50h]
  unsigned __int64 v40; // [rsp+F8h] [rbp-40h]

  v40 = __readfsqword(0x28u);
  v14 = sub_21500(100LL);
  if ( !v14 )
    return (unsigned int)-1;
  v15 = v14;
  v36 = 0LL;
  sub_1AD10((__int64)v31, 0x8000, -1, 0LL, 0LL);
  v37 = &unk_C0020;
  sub_1C580((__int64)v31, v15, 100LL, v15);
  v31[0] &= 0xFFFFFFFE;
  v38 = sub_21500;
  v39 = sub_21B70;
  v22 = sub_61370((__int64)v31, a2, a3, a4, a5, a6, a7, a8, v16, v17, a11, a12);
  if ( v22 < 0 )
  {
    sub_21B70(v35);
    return (unsigned int)v22;
  }
  v25 = v33 - v32;
  v26 = v33 - v32 + 1;
  v27 = v35;
  if ( (unsigned __int64)(v34 - v32) >> 1 > v26 && (v30 = (void *)sub_21500(v33 - v32 + 1), (*a1 = (__int64)v30) != 0) )
  {
    memcpy(v30, v27, v25);
    sub_21B70(v27);
    v28 = *a1;
    if ( !*a1 )
      goto LABEL_9;
  }
  else
  {
    v28 = sub_21DF0(
            (const char *)v27,
            v26,
            v18,
            v19,
            v20,
            v21,
            *(double *)a5.m128_u64,
            a6,
            *(double *)a7.m128i_i64,
            *(double *)a8.m128_u64,
            v23,
            v24,
            a11,
            a12);
    *a1 = v28;
    if ( !v28 )
    {
LABEL_9:
      v28 = (__int64)v35;
      *a1 = (__int64)v35;
      goto LABEL_5;
    }
  }
LABEL_5:
  *(_BYTE *)(v28 + v25) = 0;
  return (unsigned int)v22;
}
// 16DC0: variable 'v16' is possibly undefined
// 16DC0: variable 'v17' is possibly undefined
// 16DFB: variable 'v18' is possibly undefined
// 16DFB: variable 'v19' is possibly undefined
// 16DFB: variable 'v20' is possibly undefined
// 16DFB: variable 'v21' is possibly undefined
// 16DFB: variable 'v23' is possibly undefined
// 16DFB: variable 'v24' is possibly undefined
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (0000000000016EA0) ----------------------------------------------------
unsigned __int64 sub_16EA0(char a1, _BYTE *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, ...)
{
  int v10; // edi
  __int64 v11; // r14
  struct iovec *v12; // r13
  _BYTE *v13; // rbx
  char v14; // r12
  char v15; // dl
  _BYTE *v16; // rax
  void *v17; // rcx
  size_t v18; // rdx
  unsigned __int64 v19; // r8
  __int64 *v20; // rdx
  __int64 v21; // rax
  __int64 v22; // r14
  __int64 v23; // rsi
  void *v24; // rsp
  struct iovec *v25; // rax
  struct iovec *v26; // r12
  __int64 v27; // r9
  unsigned __int64 v29; // r13
  _DWORD *v30; // rax
  __int64 v31; // r15
  _DWORD *v32; // rdi
  size_t v33; // rdx
  void *v34; // rsi
  _BYTE *v35; // rax
  unsigned int *v36; // rdi
  struct iovec v37; // [rsp-Eh] [rbp-B0h] BYREF
  struct iovec *v38; // [rsp+2h] [rbp-A0h]
  void *v39; // [rsp+1Ah] [rbp-88h]
  __va_list_tag va[1]; // [rsp+22h] [rbp-80h] BYREF
  unsigned __int64 v41; // [rsp+3Ah] [rbp-68h]
  __int64 v42; // [rsp+52h] [rbp-50h]
  __int64 v43; // [rsp+5Ah] [rbp-48h]
  __int64 v44; // [rsp+62h] [rbp-40h]
  __int64 v45; // [rsp+6Ah] [rbp-38h]

  va_start(va, a10);
  v42 = va_arg(va, _QWORD);
  v43 = va_arg(va, _QWORD);
  v44 = va_arg(va, _QWORD);
  v45 = va_arg(va, _QWORD);
  va_end(va);
  va_start(va, a10);
  v10 = a1 & 1;
  v11 = 0LL;
  v12 = 0LL;
  v13 = a2;
  v14 = *a2;
  v41 = __readfsqword(0x28u);
  if ( !v14 )
  {
    if ( !v10 )
      return v41 - __readfsqword(0x28u);
LABEL_28:
    exit();
  }
  while ( 1 )
  {
    v15 = v14;
    v16 = v13;
    do
    {
      if ( v15 == 37 && v16[1] == 115 )
        break;
      v16 = (_BYTE *)sub_9100(v16 + 1, 37LL);
      v15 = *v16;
    }
    while ( *v16 );
    if ( v14 == 37 && v13[1] == 115 )
    {
      if ( va[0].gp_offset > 0x2F )
      {
        v20 = (__int64 *)va[0].overflow_arg_area;
        va[0].overflow_arg_area = (char *)va[0].overflow_arg_area + 8;
      }
      else
      {
        v20 = (__int64 *)((char *)va[0].reg_save_area + va[0].gp_offset);
        va[0].gp_offset += 8;
      }
      v13 += 2;
      v39 = (void *)*v20;
      v21 = strlen((__int64)v39);
      v17 = v39;
      v18 = v21;
    }
    else
    {
      v17 = v13;
      v18 = v16 - v13;
      v13 = v16;
    }
    LODWORD(v19) = v11 + 1;
    v37.iov_base = v17;
    v37.iov_len = v18;
    v38 = v12;
    v14 = *v13;
    if ( !*v13 )
      break;
    v11 = (int)v19;
    v12 = &v37;
  }
  v19 = (int)v19;
  v22 = 16 * v11;
  v23 = 0LL;
  v24 = alloca(16LL * (int)v19 + 16);
  v25 = (struct iovec *)((char *)&v37 + v22);
  v26 = &v37;
  while ( 1 )
  {
    v25->iov_base = v17;
    v25->iov_len = v18;
    v23 += v18;
    if ( v25 == &v37 )
      break;
    v17 = v12->iov_base;
    v18 = v12->iov_len;
    --v25;
    v12 = (struct iovec *)v12[1].iov_base;
  }
  while ( sys_writev(2uLL, &v37, v19) == -4 )
    ;
  if ( v10 )
  {
    v29 = -(__int64)off_BF078 & ((unsigned __int64)off_BF078 + v27);
    v30 = mmap(0LL, v29, 3uLL, 0x22u, 0xFFFFFFFFuLL, 0LL);
    v31 = (__int64)v30;
    if ( v30 != (_DWORD *)-1LL )
    {
      *v30 = v29;
      v32 = v30 + 1;
      do
      {
        v33 = v26->iov_len;
        v34 = v26->iov_base;
        ++v26;
        v35 = (_BYTE *)sub_91D0(v32, v34, v33);
        v32 = v35;
      }
      while ( (struct iovec *)((char *)&v37 + v22 + 16) != v26 );
      *v35 = 0;
      v36 = (unsigned int *)_InterlockedExchange64(&qword_C0D10, v31);
      if ( v36 )
        munmap(v36, *v36);
    }
    goto LABEL_28;
  }
  return v41 - __readfsqword(0x28u);
}
// 1702E: variable 'v19' is possibly undefined
// 17095: variable 'v27' is possibly undefined
// 9100: using guessed type __int64 __fastcall sub_9100(_QWORD, _QWORD);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// BF078: using guessed type Elf64_Rela *off_BF078;
// C0D10: using guessed type __int64 qword_C0D10;

//----- (0000000000017110) ----------------------------------------------------
void __fastcall __noreturn sub_17110(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  while ( 1 )
    sub_16EA0(1, "%s", a2, a3, a4, a5, a6, a7, a8, a9, a1);
}
// 17135: variable 'a6' is possibly undefined
// 17135: variable 'a7' is possibly undefined

//----- (0000000000017140) ----------------------------------------------------
void __fastcall sub_17140(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  if ( !sub_858E0 )
    sub_17110((__int64)"Fatal error: glibc detected an invalid stdio handle\n", a1, a2, a3, a4, a5, a6, a7, a8);
}
// 858E0: using guessed type __int64 __fastcall sub_858E0();

//----- (0000000000017160) ----------------------------------------------------
_BYTE *__fastcall sub_17160(_BYTE *a1, int a2, int *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  char v12; // r12
  int v13; // er12
  _BYTE *v14; // rax
  int v15; // edx
  _BYTE *v16; // r8

  if ( a2 <= 0 )
    return 0LL;
  if ( a2 == 1 )
  {
    *a1 = 0;
    v16 = a1;
  }
  else
  {
    v12 = *a3;
    *a3 &= 0xFFFFFFDF;
    v13 = v12 & 0x20;
    v14 = sub_14470((__int64)a3, a1, a2 - 1, 0xAu, 1, a4, a5, a6, a7, a8, a9, a10, a11);
    v15 = *a3;
    v16 = 0LL;
    if ( v14 )
    {
      if ( (v15 & 0x20) == 0 || (v16 = 0LL, __readfsdword(0xFFFFFFC0) == 11) )
      {
        v14[(_QWORD)a1] = 0;
        v16 = a1;
        v15 = *a3;
      }
    }
    *a3 = v15 | v13;
  }
  return v16;
}

//----- (0000000000017200) ----------------------------------------------------
__int64 __fastcall sub_17200(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 v9; // rbp
  __int64 result; // rax

  v9 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v9 - (_QWORD)&unk_BFAE0) )
    sub_17140(a2, a3, a4, a5, a6, a7, a8, a9);
  result = (*(__int64 (__fastcall **)(__int64))(v9 + 128))(a1);
  if ( result < 0 )
    return -1LL;
  *(_QWORD *)(a1 + 144) = result;
  return result;
}
// C0308: using guessed type void *off_C0308;

//----- (0000000000017270) ----------------------------------------------------
unsigned __int64 __fastcall sub_17270(__int64 a1)
{
  return sub_4B7A0(*(_DWORD *)(a1 + 112));
}

//----- (0000000000017280) ----------------------------------------------------
int *__fastcall sub_17280(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  int *result; // rax
  __int64 v12; // rax

  result = sub_1A870((int *)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
  if ( result )
  {
    v12 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 48) = v12;
    *(_QWORD *)(a1 + 40) = v12;
    *(_QWORD *)(a1 + 32) = v12;
    *(_QWORD *)(a1 + 24) = v12;
    *(_QWORD *)(a1 + 8) = v12;
    *(_QWORD *)(a1 + 16) = v12;
    result = (int *)a1;
  }
  return result;
}

//----- (00000000000172C0) ----------------------------------------------------
__int64 __fastcall sub_172C0(__int64 a1, unsigned __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  unsigned __int64 v12; // r13
  __int64 v14; // r12
  unsigned __int64 v16; // rax
  __int64 v17; // rax
  int v18; // edi
  __int64 v19; // r12
  __int64 v20; // rax
  int v21; // edx
  __int64 v23; // rdx
  __int64 v24; // rsi
  __int64 v25; // rax

  v12 = (char *)&off_C0308 - (char *)&unk_BFAE0;
  v14 = *(_QWORD *)(a1 + 216);
  v16 = v14 - (_QWORD)&unk_BFAE0;
  if ( (*(_DWORD *)a1 & 0x1000) != 0 )
  {
    *(_QWORD *)(a1 + 144) = -1LL;
LABEL_3:
    if ( v16 >= v12 )
      sub_17140(a4, a5, a6, a7, a8, a9, a10, a11);
    v17 = (*(__int64 (__fastcall **)(__int64, unsigned __int64, __int64))(v14 + 120))(a1, a2, a3);
    v18 = *(unsigned __int16 *)(a1 + 128);
    v19 = v17;
    if ( v17 && (_WORD)v18 )
      *(_WORD *)(a1 + 128) = sub_1B000(v18 - 1, a2, v17) + 1;
    v20 = *(_QWORD *)(a1 + 56);
    v21 = *(_DWORD *)(a1 + 192);
    *(_QWORD *)(a1 + 24) = v20;
    *(_QWORD *)(a1 + 8) = v20;
    *(_QWORD *)(a1 + 16) = v20;
    *(_QWORD *)(a1 + 40) = v20;
    *(_QWORD *)(a1 + 32) = v20;
    if ( v21 > 0 || (*(_DWORD *)a1 & 0x202) == 0 )
      v20 = *(_QWORD *)(a1 + 64);
    *(_QWORD *)(a1 + 48) = v20;
    return v19;
  }
  v23 = *(_QWORD *)(a1 + 16);
  v24 = *(_QWORD *)(a1 + 32);
  if ( v23 == v24 )
    goto LABEL_3;
  if ( v16 >= v12 )
  {
    sub_17140(a4, a5, a6, a7, a8, a9, a10, a11);
    v24 = *(_QWORD *)(a1 + 32);
    v23 = *(_QWORD *)(a1 + 16);
  }
  v25 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v14 + 128))(a1, v24 - v23, 1LL);
  v19 = 0LL;
  if ( v25 != -1 )
  {
    v14 = *(_QWORD *)(a1 + 216);
    *(_QWORD *)(a1 + 144) = v25;
    v16 = v14 - (_QWORD)&unk_BFAE0;
    goto LABEL_3;
  }
  return v19;
}
// 173F0: variable 'a8' is possibly undefined
// 173F0: variable 'a9' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (0000000000017420) ----------------------------------------------------
__int64 __fastcall sub_17420(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14)
{
  int v14; // eax
  unsigned __int8 *v16; // rdx
  _QWORD *v17; // rbp
  int v18; // edx
  _QWORD *v19; // r15
  __int64 v20; // rcx
  unsigned __int64 v22; // r12
  unsigned __int64 v24; // r13
  __int64 v25; // rdi
  int v26; // eax
  double v27; // xmm4_8
  double v28; // xmm5_8
  __int64 v29; // rbp
  __int64 v30; // rsi
  __int64 v31; // rax
  __int64 v32; // rdx
  __int64 result; // rax
  int v34; // edx
  bool v35; // zf
  __int64 v36; // rdi
  signed __int64 v37; // rax
  __int64 v38; // [rsp+0h] [rbp-40h]

  v14 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 0x10) != 0 )
    return 0xFFFFFFFFLL;
  if ( (v14 & 4) != 0 )
  {
    *(_DWORD *)a1 = v14 | 0x20;
    __writefsdword(0xFFFFFFC0, 9u);
    return 0xFFFFFFFFLL;
  }
  v16 = *(unsigned __int8 **)(a1 + 8);
  if ( (unsigned __int64)v16 < *(_QWORD *)(a1 + 16) )
    return *v16;
  if ( *(_QWORD *)(a1 + 56) )
  {
    if ( (v14 & 0x202) == 0 )
      goto LABEL_17;
  }
  else
  {
    v36 = *(_QWORD *)(a1 + 72);
    if ( v36 )
    {
      sub_21B70(v36, a3, a4, a5, a6, a7, a8, a9, a10, a2, (__int64)v16, a12, a13, a14);
      *(_DWORD *)a1 &= 0xFFFFFEFF;
    }
    sub_1A500((int *)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
    if ( (*(_DWORD *)a1 & 0x202) == 0 )
      goto LABEL_17;
  }
  v17 = off_BE610;
  v18 = *(_DWORD *)off_BE610;
  v19 = off_BE610;
  v20 = *(_DWORD *)off_BE610 & 0x8000;
  if ( (*(_DWORD *)off_BE610 & 0x8000) != 0 )
  {
    if ( (*(_DWORD *)off_BE610 & 0x288) == 640 )
    {
      v24 = (char *)&off_C0308 - (char *)&unk_BFAE0;
LABEL_33:
      v38 = v17[27];
      if ( v38 - (__int64)&unk_BFAE0 >= v24 )
      {
        sub_17140(a3, a4, a5, a6, a7, a8, a9, a10);
        v17 = off_BE610;
      }
      (*(void (__fastcall **)(_QWORD *, __int64))(v38 + 24))(v17, 0xFFFFFFFFLL);
      goto LABEL_12;
    }
LABEL_17:
    v24 = (char *)&off_C0308 - (char *)&unk_BFAE0;
    goto LABEL_18;
  }
  _RDI = *((_QWORD *)off_BE610 + 17);
  v22 = __readfsqword(0x10u);
  if ( *(_QWORD *)(_RDI + 8) != v22 )
  {
    _EDX = 1;
    if ( __readfsdword(0x18u) )
    {
      if ( (_DWORD)v20 != _InterlockedCompareExchange((volatile signed __int32 *)_RDI, 1, v20) )
        sub_1C7D0((volatile __int32 *)_RDI, a2, 1LL, v20, a13, a14);
    }
    else
    {
      __asm { cmpxchg [rdi], edx }
    }
    _RDI = v17[17];
    v17 = off_BE610;
    *(_QWORD *)(_RDI + 8) = v22;
    v18 = *(_DWORD *)v17;
  }
  ++*(_DWORD *)(_RDI + 4);
  v24 = (char *)&off_C0308 - (char *)&unk_BFAE0;
  if ( (v18 & 0x288) == 640 )
    goto LABEL_33;
LABEL_12:
  if ( (*(_DWORD *)v19 & 0x8000) != 0 )
    goto LABEL_17;
  v25 = v19[17];
  v26 = *(_DWORD *)(v25 + 4) - 1;
  *(_DWORD *)(v25 + 4) = v26;
  if ( v26 )
    goto LABEL_17;
  *(_QWORD *)(v25 + 8) = 0LL;
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedExchange((volatile __int32 *)v25, 0) > 1 )
    {
      v37 = sys_futex((u32 *)v25, 129, 1u, 0LL, a13, a14);
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  --*(_DWORD *)v25;
LABEL_18:
  sub_1A060((int *)a1, a3, a4, a5, a6, a7, a8, a9, a10);
  v29 = *(_QWORD *)(a1 + 216);
  v30 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 8) = v30;
  *(_QWORD *)(a1 + 24) = v30;
  *(_QWORD *)(a1 + 16) = v30;
  *(_QWORD *)(a1 + 48) = v30;
  *(_QWORD *)(a1 + 40) = v30;
  *(_QWORD *)(a1 + 32) = v30;
  if ( v29 - (__int64)&unk_BFAE0 >= v24 )
  {
    sub_17140(a3, a4, a5, a6, v27, v28, a9, a10);
    v30 = *(_QWORD *)(a1 + 56);
  }
  v31 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v29 + 112))(a1, v30, *(_QWORD *)(a1 + 64) - v30);
  if ( v31 <= 0 )
  {
    *(_QWORD *)(a1 + 144) = -1LL;
    v34 = *(_DWORD *)a1 | 0x10;
    v35 = v31 == 0;
    result = 0xFFFFFFFFLL;
    if ( !v35 )
      v34 = *(_DWORD *)a1 | 0x20;
    *(_DWORD *)a1 = v34;
  }
  else
  {
    v32 = *(_QWORD *)(a1 + 144);
    *(_QWORD *)(a1 + 16) += v31;
    if ( v32 != -1 )
      *(_QWORD *)(a1 + 144) = v32 + v31;
    result = **(unsigned __int8 **)(a1 + 8);
  }
  return result;
}
// 17559: variable 'a7' is possibly undefined
// 17559: variable 'a8' is possibly undefined
// 176A0: variable 'v27' is possibly undefined
// 176A0: variable 'v28' is possibly undefined
// 176BC: variable 'a13' is possibly undefined
// 176BC: variable 'a14' is possibly undefined
// BE610: using guessed type void *off_BE610;
// C0308: using guessed type void *off_C0308;

//----- (0000000000017740) ----------------------------------------------------
unsigned __int64 __fastcall sub_17740(__int64 a1)
{
  unsigned int v2; // edi

  munmap(*(void **)(a1 + 56), *(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56));
  *(_QWORD *)(a1 + 64) = 0LL;
  v2 = *(_DWORD *)(a1 + 112);
  *(_QWORD *)(a1 + 56) = 0LL;
  return sub_4B7A0(v2);
}

//----- (0000000000017780) ----------------------------------------------------
__int64 __fastcall sub_17780(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 v10; // rbp
  unsigned int v11; // eax
  double v12; // xmm4_8
  double v13; // xmm5_8
  unsigned __int64 v14; // rbp
  unsigned int v15; // er12
  unsigned __int64 v16; // r13
  int v17; // ecx
  void *v18; // rax
  off_t v20; // r14
  signed int v21; // eax
  unsigned __int64 v22; // r8
  __int64 v23; // rcx
  unsigned __int64 v24; // rdx
  unsigned __int64 v25; // rsi
  unsigned __int64 v26; // rcx
  __int64 v27; // rax
  __int64 v28; // rdx
  off_t v29; // rax
  unsigned int v30; // edi
  unsigned __int64 v31; // r8
  __int64 v32; // rax
  unsigned __int64 v33; // rax
  _WORD v34[24]; // [rsp+0h] [rbp-C8h] BYREF
  off_t v35; // [rsp+30h] [rbp-98h]
  unsigned __int64 v36; // [rsp+98h] [rbp-30h]

  v10 = *(_QWORD *)(a1 + 216);
  v36 = __readfsqword(0x28u);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v10 - (_QWORD)&unk_BFAE0) )
    sub_17140(a2, a3, a4, a5, a6, a7, a8, a9);
  v11 = (*(__int64 (__fastcall **)(__int64, _WORD *))(v10 + 144))(a1, v34);
  v14 = *(_QWORD *)(a1 + 56);
  v15 = v11;
  v16 = *(_QWORD *)(a1 + 64) - v14;
  if ( !v11 && (v34[12] & 0xF000) == 0x8000 && (v20 = v35) != 0 )
  {
    v21 = (unsigned int)sub_4BBD0(a2, a3, a4, a5, v12, v13, a8, a9);
    v23 = -(__int64)v21;
    v24 = v23 & (v20 + v21 - 1);
    v25 = v23 & (v21 + v16 - 1);
    if ( v24 < v25 )
    {
      munmap((void *)(v14 + v24), v25 - v24);
      v14 = *(_QWORD *)(a1 + 56);
      v20 = v35;
      v26 = v14 + v35;
      *(_QWORD *)(a1 + 64) = v14 + v35;
LABEL_14:
      v27 = *(_QWORD *)(a1 + 144);
      v28 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 24) = v14;
      v29 = v27 - (v28 - *(_QWORD *)(a1 + 8));
      *(_QWORD *)(a1 + 144) = v29;
      if ( v29 >= v20 )
      {
        *(_QWORD *)(a1 + 8) = v26;
        *(_QWORD *)(a1 + 16) = v26;
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v26;
        v30 = *(_DWORD *)(a1 + 112);
        *(_QWORD *)(a1 + 8) = v14 + v29;
        v31 = sub_4AD50(v30, v20, 0);
        v32 = *(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56);
        if ( v32 == v31 )
          *(_QWORD *)(a1 + 144) = v32;
        else
          *(_DWORD *)a1 |= 0x20u;
      }
      return v15;
    }
    if ( v24 <= v25 )
    {
      v26 = v14 + v20;
      *(_QWORD *)(a1 + 64) = v14 + v20;
      goto LABEL_14;
    }
    v33 = sub_4D040(v14, v25, v24, 1uLL, v22);
    v14 = v33;
    if ( v33 != -1LL )
    {
      v20 = v35;
      *(_QWORD *)(a1 + 56) = v33;
      v26 = v33 + v20;
      *(_QWORD *)(a1 + 64) = v33 + v20;
      goto LABEL_14;
    }
    munmap(*(void **)(a1 + 56), *(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56));
  }
  else
  {
    munmap(*(void **)(a1 + 56), *(_QWORD *)(a1 + 64) - v14);
  }
  v17 = *(_DWORD *)(a1 + 192);
  v18 = &unk_BFF60;
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 56) = 0LL;
  v15 = 1;
  *(_QWORD *)(a1 + 24) = 0LL;
  if ( v17 > 0 )
    v18 = &unk_BFD20;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 216) = v18;
  *(_QWORD *)(*(_QWORD *)(a1 + 160) + 224LL) = &unk_BFD20;
  return v15;
}
// 178A6: variable 'v12' is possibly undefined
// 178A6: variable 'v13' is possibly undefined
// 1793A: variable 'v22' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (00000000000179E0) ----------------------------------------------------
unsigned __int64 __fastcall sub_179E0(__int64 a1, off_t a2, unsigned int a3)
{
  return sub_4AD50(*(_DWORD *)(a1 + 112), a2, a3);
}

//----- (00000000000179F0) ----------------------------------------------------
__int64 __fastcall sub_179F0(__int64 a1)
{
  unsigned __int64 v1; // rsi
  __int64 v2; // rax
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 8) - *(_QWORD *)(a1 + 56);
  if ( *(_QWORD *)(a1 + 8) == *(_QWORD *)(a1 + 16)
    || (v1 = sub_4AD50(*(_DWORD *)(a1 + 112), v1, 0), *(_QWORD *)(a1 + 8) - *(_QWORD *)(a1 + 56) == v1) )
  {
    v2 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 144) = v1;
    *(_QWORD *)(a1 + 8) = v2;
    *(_QWORD *)(a1 + 16) = v2;
    result = 0LL;
  }
  else
  {
    *(_DWORD *)a1 |= 0x20u;
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000017A50) ----------------------------------------------------
unsigned __int64 __fastcall sub_17A50(__int64 a1, double xmm0_8_0, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 v9; // rbp
  void *v10; // rax
  void *v11; // rdx
  signed __int64 v13; // rax
  char *v14; // rbp
  unsigned __int64 v15; // rax
  __int64 v16; // rdx
  char *v17; // rax
  bool v18; // zf
  char *v19; // rbp
  _WORD v20[24]; // [rsp+0h] [rbp-B8h] BYREF
  unsigned __int64 a2; // [rsp+30h] [rbp-88h]
  unsigned __int64 v22; // [rsp+98h] [rbp-20h]

  v9 = *(_QWORD *)(a1 + 216);
  v22 = __readfsqword(0x28u);
  if ( v9 - (__int64)&unk_BFAE0 >= (unsigned __int64)((char *)&off_C0308 - (char *)&unk_BFAE0) )
    sub_17140(xmm0_8_0, a3, a4, a5, a6, a7, a8, a9);
  if ( (*(unsigned int (__fastcall **)(__int64, _WORD *))(v9 + 144))(a1, v20) )
    goto LABEL_5;
  if ( (v20[12] & 0xF000) != 0x8000 )
    goto LABEL_5;
  if ( !a2 )
    goto LABEL_5;
  v13 = *(_QWORD *)(a1 + 144);
  if ( (__int64)a2 < v13 && v13 != -1 )
    goto LABEL_5;
  v14 = (char *)mmap(0LL, a2, 1uLL, 1u, *(unsigned int *)(a1 + 112), 0LL);
  if ( v14 == (char *)-1LL )
    goto LABEL_5;
  v15 = sub_4AD50(*(_DWORD *)(a1 + 112), a2, 0);
  if ( a2 != v15 )
  {
    munmap(v14, a2);
    *(_QWORD *)(a1 + 144) = -1LL;
LABEL_5:
    v10 = &unk_BFF60;
    v11 = &unk_BFD20;
    goto LABEL_6;
  }
  sub_1A4A0((int *)a1, (__int64)v14, (__int64)&v14[a2], 0);
  v16 = *(_QWORD *)(a1 + 144);
  *(_QWORD *)(a1 + 24) = v14;
  v17 = &v14[v16];
  v18 = v16 == -1;
  v11 = &unk_BFC60;
  if ( v18 )
    v17 = v14;
  *(_QWORD *)(a1 + 8) = v17;
  v19 = &v14[a2];
  *(_QWORD *)(a1 + 144) = a2;
  v10 = &unk_BFEA0;
  *(_QWORD *)(a1 + 16) = v19;
LABEL_6:
  if ( *(int *)(a1 + 192) > 0 )
    v10 = v11;
  *(_QWORD *)(a1 + 216) = v10;
  *(_QWORD *)(*(_QWORD *)(a1 + 160) + 224LL) = v11;
  return v22 - __readfsqword(0x28u);
}
// C0308: using guessed type void *off_C0308;

//----- (0000000000017BF0) ----------------------------------------------------
__int64 __fastcall sub_17BF0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  double v9; // xmm4_8
  double v10; // xmm5_8
  __int64 v11; // rbx

  sub_17A50(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  v11 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v11 - (_QWORD)&unk_BFAE0) )
    sub_17140(a2, a3, a4, a5, v9, v10, a8, a9);
  return (*(__int64 (__fastcall **)(__int64))(v11 + 32))(a1);
}
// 17C38: variable 'v9' is possibly undefined
// 17C38: variable 'v10' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (0000000000017C50) ----------------------------------------------------
__int64 __fastcall sub_17C50(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  double v12; // xmm4_8
  double v13; // xmm5_8
  __int64 v14; // rbx

  sub_17A50(a1, a4, a5, a6, a7, a8, a9, a10, a11);
  v14 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v14 - (_QWORD)&unk_BFAE0) )
    sub_17140(a4, a5, a6, a7, v12, v13, a10, a11);
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v14 + 64))(a1, a2, a3);
}
// 17CB0: variable 'v12' is possibly undefined
// 17CB0: variable 'v13' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (0000000000017CC0) ----------------------------------------------------
__int64 __fastcall sub_17CC0(__int64 a1, __int64 a2, unsigned int a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rdx
  __int64 v18; // r12
  int v19; // er15
  __int64 v20; // rax
  unsigned __int64 v21; // rbx
  __int64 v22; // rdi
  __int64 v23; // rax
  __int64 v24; // rax
  __int64 v25; // rcx
  double v26; // xmm4_8
  double v27; // xmm5_8
  __int64 v28; // rsi
  int v29; // eax
  __int64 v30; // rdx
  __int64 v31; // rax
  __int64 v32; // rsi
  __int64 v33; // r13
  __int64 v34; // rax
  __int64 v35; // rcx
  double v36; // xmm4_8
  double v37; // xmm5_8
  __int64 v38; // rax
  __int64 (__fastcall *v39)(__int64, __int64, __int64); // rax
  __int64 v40; // rsi
  __int64 v41; // rdx
  __int64 v42; // rax
  __int64 v43; // rdx
  __int64 result; // rax
  double v45; // xmm4_8
  double v46; // xmm5_8
  __int64 v47; // r15
  __int64 v48; // rdx
  unsigned __int64 v49; // rax
  unsigned __int64 v50; // rcx
  int v51; // edx
  __int64 v52; // rbx
  __int64 v53; // rax
  __int64 v54; // rsi
  unsigned __int64 v55; // r12
  __int64 v56; // rbx
  __int64 v57; // rbx
  __int64 v58; // [rsp+0h] [rbp-E8h]
  __int64 v59; // [rsp+0h] [rbp-E8h]
  __int64 v60; // [rsp+0h] [rbp-E8h]
  __int64 v61; // [rsp+0h] [rbp-E8h]
  __int64 v62; // [rsp+8h] [rbp-E0h]
  char v63[24]; // [rsp+10h] [rbp-D8h] BYREF
  int v64; // [rsp+28h] [rbp-C0h]
  __int64 v65; // [rsp+40h] [rbp-A8h]
  unsigned __int64 v66; // [rsp+A8h] [rbp-40h]

  v66 = __readfsqword(0x28u);
  if ( !(_DWORD)a4 )
  {
    if ( *(_QWORD *)(a1 + 56) )
    {
      v49 = *(_QWORD *)(a1 + 40);
      v50 = *(_QWORD *)(a1 + 32);
      v51 = *(_DWORD *)a1 & 0x1000;
      if ( v49 > v50 && v51 )
      {
        v52 = *(_QWORD *)(a1 + 216);
        if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v52 - (_QWORD)&unk_BFAE0) )
          sub_17140(a7, a8, a9, a10, a11, a12, a13, a14);
        v53 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(v52 + 128))(a1, 0LL, 2LL);
        v54 = v53;
        if ( v53 == -1 )
          return -1LL;
        *(_QWORD *)(a1 + 144) = v53;
        v49 = *(_QWORD *)(a1 + 40);
        goto LABEL_56;
      }
      v54 = *(_QWORD *)(a1 + 144);
      if ( v49 > v50 )
      {
        if ( v51 )
        {
LABEL_56:
          v55 = v49 - *(_QWORD *)(a1 + 32);
          goto LABEL_59;
        }
        v55 = v49 - *(_QWORD *)(a1 + 16);
      }
      else
      {
        v55 = *(_QWORD *)(a1 + 8) - *(_QWORD *)(a1 + 16);
      }
    }
    else
    {
      v54 = *(_QWORD *)(a1 + 144);
      v55 = 0LL;
    }
LABEL_59:
    if ( v54 == -1 )
    {
      v56 = *(_QWORD *)(a1 + 216);
      if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v56 - (_QWORD)&unk_BFAE0) )
        sub_17140(a7, a8, a9, a10, a11, a12, a13, a14);
      v54 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(v56 + 128))(a1, 0LL, 1LL);
      if ( v54 == -1 )
        return -1LL;
    }
    result = v54 + v55;
    if ( (__int64)(v54 + v55) >= 0 )
      return result;
    goto LABEL_61;
  }
  v16 = *(_QWORD *)(a1 + 40);
  v17 = *(_QWORD *)(a1 + 32);
  v18 = a2;
  if ( *(_QWORD *)(a1 + 24) == *(_QWORD *)(a1 + 16) && v17 == v16 )
  {
    v19 = 1;
  }
  else
  {
    v19 = 0;
    if ( v17 < v16 )
      goto LABEL_4;
  }
  if ( (*(_DWORD *)a1 & 0x800) == 0 )
  {
    if ( !*(_QWORD *)(a1 + 56) )
      goto LABEL_17;
LABEL_6:
    if ( a3 == 1 )
      goto LABEL_20;
    goto LABEL_7;
  }
LABEL_4:
  if ( (unsigned int)sub_1A060((int *)a1, a7, a8, a9, a10, a11, a12, a13, a14) )
    return -1LL;
  if ( *(_QWORD *)(a1 + 56) )
    goto LABEL_6;
LABEL_17:
  v22 = *(_QWORD *)(a1 + 24);
  if ( v22 )
  {
    sub_21B70(v22, a7, a8, a9, a10, a11, a12, a13, a14, a2, v17, a4, a5, a6);
    *(_DWORD *)a1 &= 0xFFFFFEFF;
  }
  sub_1A500((int *)a1, a2, a7, a8, a9, a10, a11, a12, a13, a14);
  v23 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 40) = v23;
  *(_QWORD *)(a1 + 32) = v23;
  *(_QWORD *)(a1 + 48) = v23;
  *(_QWORD *)(a1 + 24) = v23;
  *(_QWORD *)(a1 + 8) = v23;
  *(_QWORD *)(a1 + 16) = v23;
  if ( a3 == 1 )
  {
LABEL_20:
    v18 = a2 - (*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8));
    v24 = *(_QWORD *)(a1 + 144);
    if ( v24 == -1 )
    {
      v21 = (char *)&off_C0308 - (char *)&unk_BFAE0;
      goto LABEL_44;
    }
    v18 += v24;
    if ( v18 >= 0 )
      goto LABEL_22;
LABEL_61:
    __writefsdword(0xFFFFFFC0, 0x16u);
    return -1LL;
  }
LABEL_7:
  if ( a3 == 2 )
  {
    v20 = *(_QWORD *)(a1 + 216);
    v21 = (char *)&off_C0308 - (char *)&unk_BFAE0;
    if ( v20 - (__int64)&unk_BFAE0 >= (unsigned __int64)((char *)&off_C0308 - (char *)&unk_BFAE0) )
    {
      v60 = *(_QWORD *)(a1 + 216);
      sub_17140(a7, a8, a9, a10, a11, a12, a13, a14);
      v20 = v60;
    }
    if ( (*(unsigned int (__fastcall **)(__int64, char *))(v20 + 144))(a1, v63) || (v64 & 0xF000) != 0x8000 )
      goto LABEL_44;
    v18 = v65 + a2;
LABEL_22:
    a3 = 0;
  }
  sub_1A100((int *)a1);
  v28 = *(_QWORD *)(a1 + 144);
  v29 = *(_DWORD *)a1;
  if ( v28 == -1
    || !*(_QWORD *)(a1 + 24)
    || (v29 & 0x100) != 0
    || (v30 = *(_QWORD *)(a1 + 56), v25 = v28 + v30 - *(_QWORD *)(a1 + 16), v28 <= v18)
    || v18 < v25 )
  {
    v21 = (char *)&off_C0308 - (char *)&unk_BFAE0;
    if ( (v29 & 4) == 0 )
    {
      v31 = *(_QWORD *)(a1 + 64);
      v32 = v18 & (*(_QWORD *)(a1 + 56) - v31);
      v33 = v18 - v32;
      if ( v31 - *(_QWORD *)(a1 + 56) < v18 - v32 )
      {
        v32 = v18;
        v33 = 0LL;
      }
      v34 = *(_QWORD *)(a1 + 216);
      if ( v34 - (__int64)&unk_BFAE0 >= v21 )
      {
        v59 = *(_QWORD *)(a1 + 216);
        sub_17140(a7, a8, a9, a10, v26, v27, a13, a14);
        v34 = v59;
      }
      v35 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, __int64))(v34 + 128))(a1, v32, 0LL, v25);
      if ( v35 >= 0 )
      {
        if ( !v33 )
        {
          v42 = 0LL;
          goto LABEL_41;
        }
        v38 = *(_QWORD *)(a1 + 216);
        if ( v38 - (__int64)&unk_BFAE0 >= v21 )
        {
          v62 = v35;
          v61 = *(_QWORD *)(a1 + 216);
          sub_17140(a7, a8, a9, a10, v36, v37, a13, a14);
          v35 = v62;
          v38 = v61;
        }
        v39 = *(__int64 (__fastcall **)(__int64, __int64, __int64))(v38 + 112);
        v40 = *(_QWORD *)(a1 + 56);
        v41 = v33;
        if ( !v19 )
          v41 = *(_QWORD *)(a1 + 64) - v40;
        v58 = v35;
        v42 = v39(a1, v40, v41);
        if ( v33 <= v42 )
        {
          v35 = v42 + v58;
LABEL_41:
          v43 = *(_QWORD *)(a1 + 56);
          *(_DWORD *)a1 &= 0xFFFFFFEF;
          *(_QWORD *)(a1 + 144) = v35;
          *(_QWORD *)(a1 + 24) = v43;
          *(_QWORD *)(a1 + 8) = v43 + v33;
          *(_QWORD *)(a1 + 16) = v43 + v42;
          *(_QWORD *)(a1 + 40) = v43;
          *(_QWORD *)(a1 + 32) = v43;
          *(_QWORD *)(a1 + 48) = v43;
          return v18;
        }
        v18 = v33;
        a3 = 1;
        if ( v42 != -1 )
        {
          v18 -= v42;
          a3 = 1;
        }
        goto LABEL_44;
      }
      return -1LL;
    }
LABEL_44:
    sub_1BB30((int *)a1);
    v47 = *(_QWORD *)(a1 + 216);
    if ( v47 - (__int64)&unk_BFAE0 >= v21 )
      sub_17140(a7, a8, a9, a10, v45, v46, a13, a14);
    result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v47 + 128))(a1, v18, a3);
    if ( result != -1 )
    {
      v48 = *(_QWORD *)(a1 + 56);
      *(_DWORD *)a1 &= 0xFFFFFFEF;
      *(_QWORD *)(a1 + 144) = result;
      *(_QWORD *)(a1 + 24) = v48;
      *(_QWORD *)(a1 + 8) = v48;
      *(_QWORD *)(a1 + 16) = v48;
      *(_QWORD *)(a1 + 40) = v48;
      *(_QWORD *)(a1 + 32) = v48;
      *(_QWORD *)(a1 + 48) = v48;
    }
    return result;
  }
  *(_QWORD *)(a1 + 24) = v30;
  *(_QWORD *)(a1 + 40) = v30;
  *(_QWORD *)(a1 + 32) = v30;
  *(_QWORD *)(a1 + 8) = v30 + v18 - v25;
  *(_QWORD *)(a1 + 48) = v30;
  *(_DWORD *)a1 = v29 & 0xFFFFFFEF;
  if ( v28 < 0 )
    return v18;
  v57 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v57 - (_QWORD)&unk_BFAE0) )
  {
    sub_17140(a7, a8, a9, a10, v26, v27, a13, a14);
    v28 = *(_QWORD *)(a1 + 144);
  }
  (*(void (__fastcall **)(__int64, __int64, _QWORD))(v57 + 128))(a1, v28, 0LL);
  return v18;
}
// 1824C: variable 'a11' is possibly undefined
// 1824C: variable 'a12' is possibly undefined
// 17DE1: variable 'v17' is possibly undefined
// 17DE1: variable 'a4' is possibly undefined
// 17DE1: variable 'a5' is possibly undefined
// 17DE1: variable 'a6' is possibly undefined
// 18219: variable 'v26' is possibly undefined
// 18219: variable 'v27' is possibly undefined
// 17EDF: variable 'v25' is possibly undefined
// 18269: variable 'v36' is possibly undefined
// 18269: variable 'v37' is possibly undefined
// 18200: variable 'v45' is possibly undefined
// 18200: variable 'v46' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (00000000000182B0) ----------------------------------------------------
unsigned __int64 __fastcall sub_182B0(__int64 a1, struct stat *a2)
{
  return sub_4AA80(1u, *(_DWORD *)(a1 + 112), a2);
}

//----- (00000000000182D0) ----------------------------------------------------
__int64 __fastcall sub_182D0(__int64 a1, const char *a2, __int64 a3)
{
  __int64 v5; // r12
  signed __int64 v6; // rbx
  signed __int64 v7; // rax
  unsigned int v8; // edi
  __int64 result; // rax
  __int64 v10; // rdx

  if ( a3 <= 0 )
  {
    result = 0LL;
  }
  else
  {
    v5 = a3;
    v6 = a3;
    do
    {
      v8 = *(_DWORD *)(a1 + 112);
      if ( (*(_BYTE *)(a1 + 116) & 2) != 0 )
      {
        v7 = sub_4BA90(v8, a2, v6);
        if ( v7 < 0 )
        {
LABEL_7:
          *(_DWORD *)a1 |= 0x20u;
          result = v5 - v6;
          goto LABEL_8;
        }
      }
      else
      {
        v7 = send(v8, a2, v6);
        if ( v7 < 0 )
          goto LABEL_7;
      }
      v6 -= v7;
      a2 += v7;
    }
    while ( v6 > 0 );
    result = v5 - v6;
  }
LABEL_8:
  v10 = *(_QWORD *)(a1 + 144);
  if ( v10 >= 0 )
    *(_QWORD *)(a1 + 144) = result + v10;
  return result;
}

//----- (0000000000018370) ----------------------------------------------------
__int64 __fastcall sub_18370(__int64 a1, __int64 a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  __int64 v11; // r13
  unsigned __int64 v12; // r12
  __int64 v13; // r14
  unsigned __int64 v14; // rbx
  double v15; // xmm4_8
  double v16; // xmm5_8
  __int64 v18; // rax
  __int64 v19; // rbx
  __int64 v20; // r13

  v11 = a2;
  v12 = a3;
  v13 = *(_QWORD *)(a1 + 8);
  v14 = *(_QWORD *)(a1 + 16) - v13;
  if ( v14 >= a3 )
    goto LABEL_6;
  if ( (*(_DWORD *)a1 & 0x100) != 0 )
  {
    v12 = a3 - v14;
    v11 = sub_91D0(a2, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16) - v13);
    sub_1A000(a1);
    v13 = *(_QWORD *)(a1 + 8);
    v14 = *(_QWORD *)(a1 + 16) - v13;
    if ( v12 <= v14 )
    {
      if ( v14 )
        goto LABEL_10;
      return v11 - a2;
    }
  }
  if ( !(unsigned int)sub_17780(a1, a4, a5, a6, a7, a8, a9, a10, a11) )
  {
    v13 = *(_QWORD *)(a1 + 8);
    v14 = *(_QWORD *)(a1 + 16) - v13;
    if ( v14 < v12 )
      *(_DWORD *)a1 |= 0x10u;
LABEL_6:
    if ( v14 )
    {
LABEL_10:
      if ( v12 <= v14 )
        v14 = v12;
      v18 = sub_91D0(v11, v13, v14);
      *(_QWORD *)(a1 + 8) = v14 + v13;
      v11 = v18;
    }
    return v11 - a2;
  }
  v19 = *(_QWORD *)(a1 + 216);
  v20 = v11 - a2;
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v19 - (_QWORD)&unk_BFAE0) )
    sub_17140(a4, a5, a6, a7, v15, v16, a10, a11);
  return v20 + (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(v19 + 64))(a1, a2, v12);
}
// 183A9: variable 'a8' is possibly undefined
// 183A9: variable 'a9' is possibly undefined
// 1847B: variable 'v15' is possibly undefined
// 1847B: variable 'v16' is possibly undefined
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// C0308: using guessed type void *off_C0308;

//----- (0000000000018490) ----------------------------------------------------
__int64 __fastcall sub_18490(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  char *v14; // r14
  __int64 v15; // r13
  size_t v17; // r12
  const void *v18; // rsi
  size_t v19; // rbp
  __int64 v20; // rax
  unsigned __int64 v21; // rcx
  size_t v22; // r15
  __int64 v23; // rbp
  __int64 v24; // rax
  __int64 v25; // rdx
  __int64 v27; // rax
  __int64 v28; // rdi
  int v29; // edx

  v14 = (char *)a2;
  v15 = a3;
  if ( !*(_QWORD *)(a1 + 56) )
  {
    v28 = *(_QWORD *)(a1 + 72);
    if ( v28 )
    {
      sub_21B70(v28, a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);
      *(_DWORD *)a1 &= 0xFFFFFEFF;
    }
    sub_1A500((int *)a1, a2, a7, a8, a9, a10, a11, a12, a13, a14);
  }
  v17 = v15;
  if ( !v15 )
    return v15;
  while ( 2 )
  {
    while ( 2 )
    {
      v18 = *(const void **)(a1 + 8);
      v19 = *(_QWORD *)(a1 + 16) - (_QWORD)v18;
      if ( v19 >= v17 )
      {
LABEL_21:
        memcpy(v14, v18, v17);
        *(_QWORD *)(a1 + 8) += v17;
        return v15;
      }
      while ( !v19 )
      {
        if ( (*(_DWORD *)a1 & 0x100) == 0 )
          goto LABEL_6;
LABEL_20:
        sub_1A000(a1);
        v18 = *(const void **)(a1 + 8);
        v19 = *(_QWORD *)(a1 + 16) - (_QWORD)v18;
        if ( v19 >= v17 )
          goto LABEL_21;
      }
      v17 -= v19;
      v27 = sub_91D0(v14, v18, v19);
      *(_QWORD *)(a1 + 8) += v19;
      v14 = (char *)v27;
      if ( (*(_DWORD *)a1 & 0x100) != 0 )
        goto LABEL_20;
LABEL_6:
      v20 = *(_QWORD *)(a1 + 56);
      if ( !v20 )
      {
        *(_QWORD *)(a1 + 24) = 0LL;
        *(_QWORD *)(a1 + 8) = 0LL;
        *(_QWORD *)(a1 + 16) = 0LL;
        *(_QWORD *)(a1 + 40) = 0LL;
        *(_QWORD *)(a1 + 32) = 0LL;
        *(_QWORD *)(a1 + 48) = 0LL;
        goto LABEL_18;
      }
      v21 = *(_QWORD *)(a1 + 64) - v20;
      if ( v21 > v17 )
      {
        if ( (unsigned int)sub_1A1C0(a1, a7, a8, a9, a10, a11, a12, a13, a14) == -1 )
        {
          v15 -= v17;
          return v15;
        }
        continue;
      }
      break;
    }
    *(_QWORD *)(a1 + 24) = v20;
    *(_QWORD *)(a1 + 8) = v20;
    *(_QWORD *)(a1 + 16) = v20;
    *(_QWORD *)(a1 + 40) = v20;
    *(_QWORD *)(a1 + 32) = v20;
    *(_QWORD *)(a1 + 48) = v20;
    if ( v21 > 0x7F )
    {
      v22 = v17 - v17 % v21;
      goto LABEL_10;
    }
LABEL_18:
    v22 = v17;
LABEL_10:
    v23 = *(_QWORD *)(a1 + 216);
    if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v23 - (_QWORD)&unk_BFAE0) )
      sub_17140(a7, a8, a9, a10, a11, a12, a13, a14);
    v24 = (*(__int64 (__fastcall **)(__int64, char *, size_t))(v23 + 112))(a1, v14, v22);
    if ( v24 > 0 )
    {
      v25 = *(_QWORD *)(a1 + 144);
      v14 += v24;
      v17 -= v24;
      if ( v25 != -1 )
        *(_QWORD *)(a1 + 144) = v25 + v24;
      if ( !v17 )
        return v15;
      continue;
    }
    break;
  }
  v15 -= v17;
  v29 = *(_DWORD *)a1 | 0x10;
  if ( v24 )
    v29 = *(_DWORD *)a1 | 0x20;
  *(_DWORD *)a1 = v29;
  return v15;
}
// 18668: variable 'a11' is possibly undefined
// 18668: variable 'a12' is possibly undefined
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// C0308: using guessed type void *off_C0308;

//----- (00000000000186C0) ----------------------------------------------------
__int64 __fastcall sub_186C0(__int64 a1, __int64 a2, int a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  __int64 v12; // rbp
  __int64 v13; // r12
  __int64 v14; // rax
  __int64 v15; // rcx
  __int64 v16; // rdx
  __int64 v17; // rdx
  __int64 result; // rax

  if ( !a4 )
    return *(_QWORD *)(a1 + 144) - (*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8));
  v12 = a2;
  if ( a3 == 1 )
  {
    v12 = *(_QWORD *)(a1 + 8) - *(_QWORD *)(a1 + 24) + a2;
  }
  else if ( a3 == 2 )
  {
    v12 = *(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56) + a2;
  }
  if ( v12 < 0 )
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    result = -1LL;
  }
  else
  {
    v13 = *(_QWORD *)(a1 + 216);
    if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v13 - (_QWORD)&unk_BFAE0) )
      sub_17140(a5, a6, a7, a8, a9, a10, a11, a12);
    v14 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v13 + 128))(a1, v12, 0LL);
    if ( v14 < 0 )
    {
      result = -1LL;
    }
    else
    {
      v15 = *(_QWORD *)(a1 + 64);
      v16 = *(_QWORD *)(a1 + 56);
      *(_QWORD *)(a1 + 24) = v16;
      if ( v12 > v15 - v16 )
      {
        *(_QWORD *)(a1 + 8) = v15;
        *(_QWORD *)(a1 + 16) = v15;
      }
      else
      {
        v17 = v12 + v16;
        *(_QWORD *)(a1 + 8) = v17;
        *(_QWORD *)(a1 + 16) = v17;
      }
      *(_DWORD *)a1 &= 0xFFFFFFEF;
      *(_QWORD *)(a1 + 144) = v14;
      result = v12;
    }
  }
  return result;
}
// C0308: using guessed type void *off_C0308;

//----- (00000000000187F0) ----------------------------------------------------
__int64 __fastcall sub_187F0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  unsigned __int8 *v9; // rax
  __int64 result; // rax
  double v11; // xmm4_8
  double v12; // xmm5_8
  unsigned __int8 *v13; // rax
  __int64 v14; // rbx

  v9 = *(unsigned __int8 **)(a1 + 8);
  if ( (unsigned __int64)v9 < *(_QWORD *)(a1 + 16) )
    return *v9;
  if ( (unsigned int)sub_17780(a1, a2, a3, a4, a5, a6, a7, a8, a9) )
  {
    v14 = *(_QWORD *)(a1 + 216);
    if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v14 - (_QWORD)&unk_BFAE0) )
      sub_17140(a2, a3, a4, a5, v11, v12, a8, a9);
    result = (*(__int64 (__fastcall **)(__int64))(v14 + 32))(a1);
  }
  else
  {
    v13 = *(unsigned __int8 **)(a1 + 8);
    if ( (unsigned __int64)v13 >= *(_QWORD *)(a1 + 16) )
    {
      *(_DWORD *)a1 |= 0x10u;
      result = 0xFFFFFFFFLL;
    }
    else
    {
      result = *v13;
    }
  }
  return result;
}
// 18873: variable 'v11' is possibly undefined
// 18873: variable 'v12' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (0000000000018880) ----------------------------------------------------
unsigned __int64 __fastcall sub_18880(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  __int64 v11; // r13
  unsigned __int64 v13; // r12
  unsigned __int64 v14; // rdi
  unsigned __int64 v16; // rax
  __int64 v17; // r15
  _BYTE *v18; // rdx
  unsigned __int64 v19; // r14
  _BYTE *v21; // rax
  __int64 v22; // r13
  double v23; // xmm4_8
  double v24; // xmm5_8
  unsigned __int64 v25; // rcx
  unsigned __int64 v26; // r15
  unsigned __int64 v27; // rax
  __int64 v28; // rbx
  _BYTE *v29; // rax

  v11 = 0LL;
  if ( !a3 )
    return v11;
  v13 = a2;
  v14 = a1[5];
  if ( (*(_DWORD *)a1 & 0xA00) == 2560 )
  {
    v21 = (_BYTE *)(a2 + a3);
    v18 = (_BYTE *)(a1[8] - v14);
    if ( a3 <= (unsigned __int64)v18 )
    {
      do
      {
        if ( a2 >= (unsigned __int64)v21 )
        {
          v17 = 0LL;
          goto LABEL_5;
        }
        --v21;
      }
      while ( *v21 != 10 );
      v29 = &v21[-a2];
      v18 = v29 + 1;
      if ( v29 == (_BYTE *)-1LL )
      {
        v19 = a3;
        v17 = 1LL;
        goto LABEL_8;
      }
      v17 = 1LL;
    }
    else
    {
      v17 = 0LL;
      if ( !v18 )
        goto LABEL_13;
    }
LABEL_5:
    if ( a3 <= (unsigned __int64)v18 )
      v18 = (_BYTE *)a3;
    v13 = (unsigned __int64)&v18[a2];
    v19 = a3 - (_QWORD)v18;
    a1[5] = sub_91D0(v14, a2, v18);
LABEL_8:
    if ( !(v19 + v17) )
      return a3 - v19;
    goto LABEL_14;
  }
  v16 = a1[6];
  if ( v16 > v14 )
  {
    v17 = 0LL;
    v18 = (_BYTE *)(v16 - v14);
    if ( v16 != v14 )
      goto LABEL_5;
  }
LABEL_13:
  v19 = a3;
LABEL_14:
  v22 = a1[27];
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v22 - (_QWORD)&unk_BFAE0) )
    sub_17140(a4, a5, a6, a7, a8, a9, a10, a11);
  if ( (*(unsigned int (__fastcall **)(_QWORD *, __int64))(v22 + 24))(a1, 0xFFFFFFFFLL) == -1 )
  {
    v28 = a3 - v19;
    v11 = -1LL;
    if ( v19 )
      v11 = v28;
  }
  else
  {
    v25 = a1[8] - a1[7];
    v26 = v19;
    if ( v25 > 0x7F )
      v26 = v19 - v19 % v25;
    if ( v26 )
    {
      v27 = sub_172C0((__int64)a1, v13, v26, a4, a5, a6, a7, v23, v24, a10, a11);
      if ( v27 < v26 )
        return a3 - v19 + v27;
      v19 -= v27;
    }
    v11 = a3;
    if ( v19 )
      v11 = sub_1A630(a1, (unsigned __int8 *)(v13 + v26), v19, a4, a5, a6, a7, v23, v24, a10, a11) - v19 + a3;
  }
  return v11;
}
// 18A40: variable 'a8' is possibly undefined
// 18A40: variable 'a9' is possibly undefined
// 189A7: variable 'v23' is possibly undefined
// 189A7: variable 'v24' is possibly undefined
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// C0308: using guessed type void *off_C0308;

//----- (0000000000018A70) ----------------------------------------------------
int __fastcall sub_18A70(__int64 a1, char *a2, size_t a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  bool v11; // zf
  unsigned int v12; // edi
  int result; // eax

  v11 = (*(_BYTE *)(a1 + 116) & 2) == 0;
  v12 = *(_DWORD *)(a1 + 112);
  if ( v11 )
    result = sub_4AC10(v12, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
  else
    result = sub_4BA60(v12, a2, a3);
  return result;
}

//----- (0000000000018AA0) ----------------------------------------------------
int *__fastcall sub_18AA0(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  int *result; // rax
  __int64 v12; // rax
  __int64 v13; // rdx

  *(_QWORD *)(a1 + 216) = &unk_BFF60;
  *(_QWORD *)(*(_QWORD *)(a1 + 160) + 224LL) = &unk_BFD20;
  result = sub_1A870((int *)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
  if ( result )
  {
    v12 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 48) = v12;
    *(_QWORD *)(a1 + 40) = v12;
    *(_QWORD *)(a1 + 32) = v12;
    *(_QWORD *)(a1 + 24) = v12;
    *(_QWORD *)(a1 + 8) = v12;
    *(_QWORD *)(a1 + 16) = v12;
    result = (int *)a1;
  }
  else
  {
    v13 = *(_QWORD *)(a1 + 160);
    *(_QWORD *)(a1 + 216) = &unk_BFEA0;
    *(_QWORD *)(v13 + 224) = &unk_BFC60;
  }
  return result;
}

//----- (0000000000018B30) ----------------------------------------------------
unsigned __int64 __fastcall sub_18B30(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  unsigned __int64 result; // rax

  *(_DWORD *)a1 |= 0x240Cu;
  *(_QWORD *)(a1 + 144) = -1LL;
  result = sub_19D10((_QWORD *)a1, a2, a3, a4, a5, a6);
  *(_DWORD *)(a1 + 112) = -1;
  return result;
}

//----- (0000000000018B90) ----------------------------------------------------
int *__fastcall sub_18B90(int *a1, const char *a2, unsigned int a3, unsigned int a4, __int16 a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  __int64 v16; // rsi
  __int64 v17; // rcx
  u32 *v18; // r8
  u32 v19; // er9
  signed int v20; // er12
  double v21; // xmm4_8
  double v22; // xmm5_8
  int v23; // eax
  __int64 v24; // rdx
  __int64 v25; // rbp
  int *result; // rax

  v16 = a3;
  if ( (a1[29] & 2) != 0 )
    v20 = sub_4B910(a2, a3, a4);
  else
    v20 = open(a2, a3, a4);
  if ( v20 < 0 )
    return 0LL;
  v23 = *a1;
  a1[28] = v20;
  v24 = a5 & 0x100C;
  *a1 = v24 | v23 & 0xFFFFEFF3;
  if ( (a5 & 0x1004) != 4100 )
    goto LABEL_8;
  v25 = *((_QWORD *)a1 + 27);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v25 - (_QWORD)&unk_BFAE0) )
    sub_17140(a6, a7, a8, a9, v21, v22, a12, a13);
  v16 = 0LL;
  if ( (*(__int64 (__fastcall **)(int *, _QWORD, __int64))(v25 + 128))(a1, 0LL, 2LL) == -1
    && __readfsdword(0xFFFFFFC0) != 29 )
  {
    sub_4B7A0(v20);
    result = 0LL;
  }
  else
  {
LABEL_8:
    sub_19D10(a1, v16, v24, v17, v18, v19);
    result = a1;
  }
  return result;
}
// 18C70: variable 'v21' is possibly undefined
// 18C70: variable 'v22' is possibly undefined
// 18C24: variable 'v24' is possibly undefined
// 18C24: variable 'v17' is possibly undefined
// 18C24: variable 'v18' is possibly undefined
// 18C24: variable 'v19' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (0000000000018D30) ----------------------------------------------------
__int64 __fastcall sub_18D30(__int64 a1, unsigned __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  __int64 result; // rax

  if ( a3 )
    result = (unsigned int)-(a3 != sub_172C0(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11));
  else
    result = 0LL;
  return result;
}

//----- (0000000000018D60) ----------------------------------------------------
__int64 __fastcall sub_18D60(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  unsigned int v9; // er12
  unsigned int v10; // ebp
  double v11; // xmm4_8
  double v12; // xmm5_8
  __int64 v13; // r12
  _QWORD *v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r8
  u32 v18; // er9

  v9 = *(_DWORD *)(a1 + 112);
  if ( v9 != -1 )
  {
    v10 = 0;
    if ( (*(_DWORD *)a1 & 0x808) == 2048 )
    {
      if ( *(int *)(a1 + 192) <= 0 )
        v10 = sub_18D30(
                a1,
                *(_QWORD *)(a1 + 32),
                *(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32),
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9);
      else
        v10 = sub_15F90(
                a1,
                *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL),
                (__int64)(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 32LL) - *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL)) >> 2,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9);
    }
    v9 = 0;
    sub_1BB30((int *)a1);
    if ( (*(_BYTE *)(a1 + 116) & 0x20) == 0 )
    {
      v13 = *(_QWORD *)(a1 + 216);
      if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v13 - (_QWORD)&unk_BFAE0) )
        sub_17140(a2, a3, a4, a5, v11, v12, a8, a9);
      v9 = (*(__int64 (__fastcall **)(__int64))(v13 + 136))(a1);
    }
    if ( *(int *)(a1 + 192) > 0 )
    {
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 160) + 64LL) )
        sub_6AEE0((int *)a1);
      sub_6A820(a1, 0LL, 0LL, 0);
      v14 = *(_QWORD **)(a1 + 160);
      v14[2] = 0LL;
      *v14 = 0LL;
      v14[1] = 0LL;
      v14[4] = 0LL;
      v14[3] = 0LL;
      v14[5] = 0LL;
    }
    sub_1A4A0((int *)a1, 0LL, 0LL, 0);
    *(_QWORD *)(a1 + 24) = 0LL;
    *(_QWORD *)(a1 + 8) = 0LL;
    *(_QWORD *)(a1 + 16) = 0LL;
    *(_QWORD *)(a1 + 40) = 0LL;
    *(_QWORD *)(a1 + 32) = 0LL;
    *(_QWORD *)(a1 + 48) = 0LL;
    sub_19CF0(a1, 0LL, v15, v16, v17, v18);
    *(_DWORD *)a1 = -72539124;
    *(_DWORD *)(a1 + 112) = -1;
    if ( !v9 )
      v9 = v10;
    *(_QWORD *)(a1 + 144) = -1LL;
  }
  return v9;
}
// 18EF0: variable 'v11' is possibly undefined
// 18EF0: variable 'v12' is possibly undefined
// 18E79: variable 'v15' is possibly undefined
// 18E79: variable 'v16' is possibly undefined
// 18E79: variable 'v17' is possibly undefined
// 18E79: variable 'v18' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (0000000000018F00) ----------------------------------------------------
int *__fastcall sub_18F00(__int64 a1, const char *a2, _BYTE *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  char v11; // al
  int *v13; // r12
  __int16 v15; // r8
  int v16; // er11
  int v17; // ecx
  _BYTE *v18; // r10
  _BYTE *v19; // rbx
  char v20; // al
  unsigned __int8 v21; // al
  __int64 v22; // rax
  __int64 v23; // rbx
  __int64 v24; // r15
  __int64 v25; // r14
  __int64 v26; // rax
  double v27; // xmm4_8
  double v28; // xmm5_8
  _BYTE *v29; // r13
  char v30; // dl
  _BYTE *v31; // rsi
  _BYTE *v32; // rdi
  int v33; // er9
  int v34; // eax
  int v35; // ecx
  int v36; // eax
  __int64 v37; // r14
  __int64 v38; // rax
  int v39; // edx
  double v40; // xmm4_8
  double v41; // xmm5_8
  _QWORD *v42; // rax
  __int64 v43; // rcx
  __int64 v44; // rdx
  __int64 v45; // rax
  __int64 v46; // rbx
  __int64 v47; // rdx
  unsigned int v48; // er12
  __int64 v49[13]; // [rsp+0h] [rbp-68h] BYREF

  v49[5] = __readfsqword(0x28u);
  if ( *(_DWORD *)(a1 + 112) != -1 )
    return 0LL;
  v11 = *a3;
  if ( *a3 == 114 )
  {
    v15 = 8;
    v16 = 0;
    v17 = 0;
  }
  else if ( v11 == 119 )
  {
    v15 = 4;
    v16 = 1;
    v17 = 576;
  }
  else
  {
    if ( v11 != 97 )
    {
      v13 = 0LL;
      __writefsdword(0xFFFFFFC0, 0x16u);
      return v13;
    }
    v15 = 4100;
    v16 = 1;
    v17 = 1088;
  }
  v18 = a3 + 6;
  v19 = a3;
  do
  {
    v20 = *++a3;
    if ( v20 <= 120 )
    {
      if ( v20 <= 97 )
      {
        if ( !v20 )
          break;
        if ( v20 == 43 )
        {
          v15 &= 0x1000u;
          v19 = a3;
          v16 = 2;
        }
      }
      else
      {
        v21 = v20 - 98;
        if ( v21 <= 0x16u )
          __asm { jmp     rax }
      }
    }
  }
  while ( a3 != v18 );
  v13 = sub_18B90((int *)a1, a2, v16 | (unsigned int)v17, 0x1B6u, v15, a4, a5, a6, a7, a8, a9, a10, a11);
  if ( !v13 )
    return 0LL;
  v22 = sub_9120(v19 + 1, ",ccs=");
  v23 = v22;
  if ( !v22 )
    return v13;
  v24 = v22 + 5;
  v25 = sub_9100(v22 + 5, 44LL) - (v22 + 5);
  v26 = sub_21500(v25 + 3);
  v29 = (_BYTE *)v26;
  if ( !v26 )
  {
    v48 = __readfsdword(0xFFFFFFC0);
    sub_18D60(a1, a4, a5, a6, a7, v27, v28, a10, a11);
    __writefsdword(0xFFFFFFC0, v48);
    return 0LL;
  }
  *(_BYTE *)sub_91D0(v26, v24, v25) = 0;
  v30 = *v29;
  if ( !*v29 )
  {
    v32 = v29;
    v35 = 1;
LABEL_34:
    v37 = (unsigned int)(2 - v35) + 1LL;
    if ( v35 > 2 )
      v37 = 1LL;
    v32 = (_BYTE *)(v37 + sub_9190((__int64)v32, 47LL, v37));
    goto LABEL_37;
  }
  v31 = v29;
  v32 = v29;
  v33 = 0;
  do
  {
    v34 = (*(_WORD *)&byte_971A0[2 * v30] >> 3) & 1;
    if ( (unsigned __int8)(v30 - 44) <= 0x33u )
      v34 |= (0x8000000004007uLL >> (v30 - 44)) & 1;
    v35 = v33 + 1;
    if ( (_BYTE)v34 )
    {
      *v32++ = dword_968A0[v30];
    }
    else if ( v30 == 47 )
    {
      if ( v33 == 2 )
        goto LABEL_37;
      v36 = v33 + 2;
      *v32 = 47;
      ++v33;
      ++v32;
      v35 = v36;
    }
    v30 = *++v31;
  }
  while ( v30 );
  if ( v33 <= 1 )
    goto LABEL_34;
LABEL_37:
  *v32 = 0;
  if ( !v29[2] )
  {
    v38 = 0LL;
    do
    {
      v39 = dword_968A0[*(char *)(v23 + v38 + 5)];
      v29[v38++] = v39;
    }
    while ( (_BYTE)v39 );
  }
  if ( (unsigned int)sub_495A0(v49, (__int64)v29) )
  {
    sub_18D60(a1, a4, a5, a6, a7, v40, v41, a10, a11);
    sub_21B70(v29);
    __writefsdword(0xFFFFFFC0, 0x16u);
    return 0LL;
  }
  sub_21B70(v29);
  if ( v49[1] != 1 )
    sub_CF00("fcts.towc_nsteps == 1", "fileops.c", 322LL, "_IO_new_file_fopen");
  if ( v49[3] != 1 )
    sub_CF00("fcts.tomb_nsteps == 1", "fileops.c", 323LL, "_IO_new_file_fopen");
  v42 = *(_QWORD **)(a1 + 160);
  v43 = v49[2];
  v44 = v42[1];
  v42[11] = 0LL;
  *v42 = v44;
  v42[4] = v42[3];
  *(_QWORD *)(*(_QWORD *)(a1 + 160) + 96LL) = 0LL;
  v45 = *(_QWORD *)(a1 + 160);
  v46 = *((_QWORD *)v13 + 20);
  *(_QWORD *)(a1 + 152) = v45 + 104;
  v47 = v49[0];
  *(_QWORD *)(v45 + 128) = 1LL;
  *(_QWORD *)(v45 + 104) = v47;
  *(_DWORD *)(v45 + 136) = 1;
  *(_QWORD *)(v45 + 144) = v46 + 88;
  *(_QWORD *)(v45 + 160) = v43;
  *(_QWORD *)(v45 + 184) = 9LL;
  *(_DWORD *)(v45 + 192) = 1;
  *(_QWORD *)(v45 + 200) = v46 + 88;
  *(_QWORD *)(a1 + 216) = *(_QWORD *)(v45 + 224);
  v13[48] = 1;
  return v13;
}
// 19195: variable 'v40' is possibly undefined
// 19195: variable 'v41' is possibly undefined
// 19350: variable 'v27' is possibly undefined
// 19350: variable 'v28' is possibly undefined
// 9100: using guessed type __int64 __fastcall sub_9100(_QWORD, _QWORD);
// 9120: using guessed type __int64 __fastcall sub_9120(_QWORD, _QWORD);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (00000000000193A0) ----------------------------------------------------
_QWORD *__fastcall sub_193A0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14)
{
  __int64 v14; // rbx

  if ( *(_DWORD *)(a1 + 112) != -1 )
  {
    if ( *(int *)(a1 + 192) <= 0 )
      sub_18D30(a1, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8, a9);
    else
      sub_15F90(
        a1,
        *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL),
        (__int64)(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 32LL) - *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL)) >> 2,
        a2,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9);
    if ( (*(_BYTE *)a1 & 0x40) == 0 )
    {
      v14 = *(_QWORD *)(a1 + 216);
      if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v14 - (_QWORD)&unk_BFAE0) )
        sub_17140(a2, a3, a4, a5, a6, a7, a8, a9);
      a2 = (*(double (__fastcall **)(__int64))(v14 + 136))(a1);
    }
  }
  return sub_1AE70(a1, 0LL, a11, a12, a13, a14, a2, a3, a4, a5, a6, a7, a8, a9);
}
// 19438: variable 'a6' is possibly undefined
// 19438: variable 'a7' is possibly undefined
// 19416: variable 'a11' is possibly undefined
// 19416: variable 'a12' is possibly undefined
// 19416: variable 'a13' is possibly undefined
// 19416: variable 'a14' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (0000000000019440) ----------------------------------------------------
__int64 __fastcall sub_19440(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  int v10; // eax
  __int64 v11; // rdx
  int v12; // ebx
  _BYTE *v13; // rdx
  _BYTE *v15; // rsi
  _BYTE *v16; // rcx
  int v17; // ecx
  int v18; // ecx
  unsigned __int64 v19; // r12
  __int64 v20; // rax

  v10 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 8) == 0 )
  {
    v11 = *(_QWORD *)(a1 + 32);
    v12 = a2;
    if ( (v10 & 0x800) != 0 )
    {
      if ( v11 )
      {
        v13 = *(_BYTE **)(a1 + 40);
        goto LABEL_5;
      }
    }
    else if ( v11 )
    {
      v13 = *(_BYTE **)(a1 + 8);
      goto LABEL_13;
    }
    sub_1A500((int *)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
    v13 = *(_BYTE **)(a1 + 56);
    v10 = *(_DWORD *)a1;
    *(_QWORD *)(a1 + 24) = v13;
    *(_QWORD *)(a1 + 8) = v13;
    *(_QWORD *)(a1 + 16) = v13;
LABEL_13:
    if ( (v10 & 0x100) != 0 )
    {
      v19 = *(_QWORD *)(a1 + 16) - (_QWORD)v13;
      sub_1A100((int *)a1);
      v20 = *(_QWORD *)(a1 + 56) - *(_QWORD *)(a1 + 24);
      if ( *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 56) > v19 )
        v20 = -(__int64)v19;
      v13 = (_BYTE *)(v20 + *(_QWORD *)(a1 + 24));
      v10 = *(_DWORD *)a1;
      *(_QWORD *)(a1 + 24) = v13;
    }
    v15 = *(_BYTE **)(a1 + 64);
    if ( v15 == v13 )
    {
      v13 = *(_BYTE **)(a1 + 56);
      *(_QWORD *)(a1 + 16) = v13;
      v16 = v13;
    }
    else
    {
      v16 = *(_BYTE **)(a1 + 16);
    }
    *(_QWORD *)(a1 + 8) = v16;
    *(_QWORD *)(a1 + 24) = v16;
    v17 = v10;
    BYTE1(v17) = BYTE1(v10) | 8;
    *(_QWORD *)(a1 + 40) = v13;
    *(_DWORD *)a1 = v17;
    v18 = *(_DWORD *)(a1 + 192);
    *(_QWORD *)(a1 + 32) = v13;
    *(_QWORD *)(a1 + 48) = v15;
    if ( v18 <= 0 && (v10 & 0x202) != 0 )
    {
      *(_QWORD *)(a1 + 48) = v13;
      if ( v12 != -1 )
      {
LABEL_6:
        if ( *(_BYTE **)(a1 + 64) != v13 )
          goto LABEL_7;
        if ( *(int *)(a1 + 192) <= 0 )
        {
          if ( (unsigned int)sub_18D30(
                               a1,
                               *(_QWORD *)(a1 + 32),
                               (__int64)&v13[-*(_QWORD *)(a1 + 32)],
                               a3,
                               a4,
                               a5,
                               a6,
                               a7,
                               a8,
                               a9,
                               a10) != -1 )
            goto LABEL_24;
        }
        else if ( (unsigned int)sub_15F90(
                                  a1,
                                  *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL),
                                  (__int64)(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 32LL)
                                          - *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL)) >> 2,
                                  a3,
                                  a4,
                                  a5,
                                  a6,
                                  a7,
                                  a8,
                                  a9,
                                  a10) != -1 )
        {
LABEL_24:
          v13 = *(_BYTE **)(a1 + 40);
LABEL_7:
          *(_QWORD *)(a1 + 40) = v13 + 1;
          *v13 = v12;
          if ( (*(_DWORD *)a1 & 2) == 0 && ((*(_DWORD *)a1 & 0x200) == 0 || v12 != 10)
            || (unsigned int)sub_18D30(
                               a1,
                               *(_QWORD *)(a1 + 32),
                               *(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32),
                               a3,
                               a4,
                               a5,
                               a6,
                               a7,
                               a8,
                               a9,
                               a10) != -1 )
          {
            return (unsigned __int8)v12;
          }
          return 0xFFFFFFFFLL;
        }
        return 0xFFFFFFFFLL;
      }
      return sub_18D30(a1, *(_QWORD *)(a1 + 32), (__int64)&v13[-*(_QWORD *)(a1 + 32)], a3, a4, a5, a6, a7, a8, a9, a10);
    }
LABEL_5:
    if ( v12 != -1 )
      goto LABEL_6;
    return sub_18D30(a1, *(_QWORD *)(a1 + 32), (__int64)&v13[-*(_QWORD *)(a1 + 32)], a3, a4, a5, a6, a7, a8, a9, a10);
  }
  *(_DWORD *)a1 = v10 | 0x20;
  __writefsdword(0xFFFFFFC0, 9u);
  return 0xFFFFFFFFLL;
}
// 19527: variable 'a7' is possibly undefined
// 19527: variable 'a8' is possibly undefined

//----- (0000000000019650) ----------------------------------------------------
__int64 __fastcall sub_19650(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rsi
  __int64 v11; // rsi
  __int64 v12; // rbp

  v9 = *(_QWORD *)(a1 + 40);
  v10 = *(_QWORD *)(a1 + 32);
  if ( v9 > v10 )
  {
    if ( *(int *)(a1 + 192) <= 0 )
    {
      if ( (unsigned int)sub_18D30(a1, v10, v9 - v10, a2, a3, a4, a5, a6, a7, a8, a9) )
        return 0xFFFFFFFFLL;
    }
    else if ( (unsigned int)sub_15F90(
                              a1,
                              *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL),
                              (__int64)(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 32LL)
                                      - *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL)) >> 2,
                              a2,
                              a3,
                              a4,
                              a5,
                              a6,
                              a7,
                              a8,
                              a9) )
    {
      return 0xFFFFFFFFLL;
    }
  }
  v11 = *(_QWORD *)(a1 + 8) - *(_QWORD *)(a1 + 16);
  if ( !v11 )
  {
LABEL_9:
    *(_QWORD *)(a1 + 144) = -1LL;
    return 0LL;
  }
  v12 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v12 - (_QWORD)&unk_BFAE0) )
    sub_17140(a2, a3, a4, a5, a6, a7, a8, a9);
  if ( (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v12 + 128))(a1, v11, 1LL) != -1 )
  {
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 8);
    goto LABEL_9;
  }
  if ( __readfsdword(0xFFFFFFC0) == 29 )
    goto LABEL_9;
  return 0xFFFFFFFFLL;
}
// 19725: variable 'a6' is possibly undefined
// 19725: variable 'a7' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (0000000000019740) ----------------------------------------------------
signed __int64 __fastcall sub_19740(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  bool v6; // zf
  signed __int64 result; // rax
  __int64 v8; // rdi
  int v9; // eax
  signed __int64 v10; // rax

  if ( qword_C11C0 )
  {
    if ( (*(_DWORD *)qword_C11C0 & 0x8000) == 0 )
    {
      v8 = *(_QWORD *)(qword_C11C0 + 136);
      v9 = *(_DWORD *)(v8 + 4) - 1;
      *(_DWORD *)(v8 + 4) = v9;
      if ( !v9 )
      {
        *(_QWORD *)(v8 + 8) = 0LL;
        if ( __readfsdword(0x18u) )
        {
          if ( _InterlockedExchange((volatile __int32 *)v8, 0) > 1 )
            v10 = sys_futex((u32 *)v8, 129, 1u, 0LL, a5, a6);
        }
        else
        {
          --*(_DWORD *)v8;
        }
      }
    }
  }
  v6 = *(&qword_C11D0 + 1) == 1;
  result = --*(&qword_C11D0 + 1);
  if ( v6 )
  {
    qword_C11D8 = 0LL;
    if ( __readfsdword(0x18u) )
    {
      result = (unsigned int)_InterlockedExchange((volatile __int32 *)&qword_C11D0, result);
      if ( (int)result > 1 )
        result = sys_futex(&qword_C11D0, 129, 1u, 0LL, a5, a6);
    }
    else
    {
      --qword_C11D0;
    }
  }
  return result;
}
// 197E4: variable 'a5' is possibly undefined
// 197E4: variable 'a6' is possibly undefined
// C11C0: using guessed type __int64 qword_C11C0;
// C11D8: using guessed type __int64 qword_C11D8;

//----- (0000000000019820) ----------------------------------------------------
__int64 __fastcall sub_19820(_QWORD *a1, __int64 a2)
{
  __int64 v2; // r13
  __int64 v5; // r8
  __int64 v6; // rsi
  __int64 *v7; // rax
  __int64 v8; // r15
  signed __int64 v9; // r13
  unsigned __int64 v10; // r14
  __int64 v11; // rbx
  __int64 **v12; // rdx
  __int64 v13; // rcx
  size_t v14; // rdx
  void *v15; // rdi
  __int64 v17; // rax
  __int64 v18; // r14
  size_t v19; // r9
  const void *v20; // rsi
  void *v21; // rax
  size_t v22; // [rsp+0h] [rbp-58h]
  size_t v23; // [rsp+8h] [rbp-50h]
  size_t v24; // [rsp+8h] [rbp-50h]
  const void *v25; // [rsp+8h] [rbp-50h]
  char *v26; // [rsp+10h] [rbp-48h]
  __int64 v27; // [rsp+10h] [rbp-48h]
  __int64 v28; // [rsp+18h] [rbp-40h]

  v2 = a2;
  v5 = a1[3];
  v6 = a1[11];
  v7 = (__int64 *)a1[12];
  v8 = a1[9];
  v9 = v2 - v5;
  v10 = v6 - v8;
  v11 = v9;
  v12 = (__int64 **)v7;
  if ( !v7 )
  {
    if ( v9 >= 0 )
    {
      a1[10] = v6;
      return 0LL;
    }
    v15 = (void *)a1[11];
    goto LABEL_18;
  }
  do
  {
    v13 = *((int *)v12 + 4);
    v12 = (__int64 **)*v12;
    if ( v11 > v13 )
      v11 = v13;
  }
  while ( v12 );
  v14 = v9 - v11;
  if ( v9 - v11 <= v10 )
  {
    v10 -= v14;
    v15 = (void *)(v8 + v10);
    if ( v11 >= 0 )
    {
      if ( !v14 )
      {
        a1[10] = v15;
        goto LABEL_9;
      }
      v20 = (const void *)(v5 + v11);
      goto LABEL_19;
    }
LABEL_18:
    sub_9050(v15, v11 + v6, -v11);
    v20 = (const void *)a1[3];
    v15 = (void *)(a1[9] + v10 - v11);
    v14 = a2 - (_QWORD)v20;
LABEL_19:
    memcpy(v15, v20, v14);
    v7 = (__int64 *)a1[12];
    v18 = a1[9] + v10;
    v9 = a2 - a1[3];
    goto LABEL_15;
  }
  v28 = a1[11];
  v26 = (char *)a1[3];
  v22 = v14 + 100;
  v17 = sub_21500(v14 + 100);
  if ( v17 )
  {
    v18 = v17 + 100;
    if ( v11 < 0 )
    {
      v25 = v26;
      v27 = v17;
      v21 = (void *)sub_91D0(v17 + 100, v11 + v28, -v11);
      memcpy(v21, v25, v9);
      v19 = v27;
    }
    else
    {
      v23 = v17;
      memcpy((void *)(v17 + 100), &v26[v11], v9 - v11);
      v19 = v23;
    }
    v24 = v19;
    sub_21B70(v8);
    v7 = (__int64 *)a1[12];
    v9 = a2 - a1[3];
    a1[9] = v24;
    a1[11] = v22 + v24;
LABEL_15:
    a1[10] = v18;
    while ( v7 )
    {
LABEL_9:
      *((_DWORD *)v7 + 4) -= v9;
      v7 = (__int64 *)*v7;
    }
    return 0LL;
  }
  return 0xFFFFFFFFLL;
}
// 9050: using guessed type __int64 __fastcall sub_9050(_QWORD, _QWORD, _QWORD);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (0000000000019CF0) ----------------------------------------------------
void __fastcall sub_19CF0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, u32 a6)
{
  unsigned __int64 v7; // r12
  u32 v9; // edx
  int v10; // esi
  u32 *v11; // r8
  unsigned __int64 v13; // r12
  __int64 v15; // rdi
  _QWORD *v16; // rcx
  unsigned __int16 v17; // r8
  _QWORD *v18; // rdx
  int v19; // eax
  int v20; // eax
  signed __int64 v21; // rax
  signed __int64 v22; // rax

  if ( *(char *)a1 >= 0 )
    return;
  v7 = __readfsqword(0x10u);
  if ( v7 != qword_C11D8 )
  {
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedCompareExchange((volatile signed __int32 *)&qword_C11D0, 1, 0) )
        sub_1C7D0(&qword_C11D0);
    }
    else
    {
      _EDX = 1;
      __asm { cmpxchg dword ptr cs:qword_C11D0, edx }
    }
    qword_C11D8 = v7;
  }
  v9 = *(&qword_C11D0 + 1);
  v10 = *(_DWORD *)a1;
  qword_C11C0 = a1;
  ++*(&qword_C11D0 + 1);
  v11 = (u32 *)((unsigned __int16)v10 & 0x8000);
  if ( (v10 & 0x8000) != 0 )
  {
    v16 = off_BE060;
    LOBYTE(v10) = v10 & 0x7F;
    if ( !off_BE060 )
    {
      *(_DWORD *)a1 = v10;
      goto LABEL_27;
    }
  }
  else
  {
    _RDI = *(_QWORD *)(a1 + 136);
    v13 = __readfsqword(0x10u);
    if ( v13 == *(_QWORD *)(_RDI + 8) )
    {
      v16 = off_BE060;
      ++*(_DWORD *)(_RDI + 4);
      LOBYTE(v10) = v10 & 0x7F;
      if ( !v16 )
      {
        *(_DWORD *)a1 = v10;
LABEL_15:
        v19 = *(_DWORD *)(_RDI + 4) - 1;
        *(_DWORD *)(_RDI + 4) = v19;
        if ( !v19 )
        {
          *(_QWORD *)(_RDI + 8) = 0LL;
          if ( !__readfsdword(0x18u) )
          {
            v20 = *(&qword_C11D0 + 1);
            --*(_DWORD *)_RDI;
            v9 = v20 - 1;
            goto LABEL_27;
          }
          if ( _InterlockedExchange((volatile __int32 *)_RDI, 0) > 1 )
            v21 = sys_futex((u32 *)_RDI, 129, 1u, 0LL, v11, a6);
        }
        goto LABEL_26;
      }
    }
    else
    {
      _EDX = 1;
      if ( __readfsdword(0x18u) )
      {
        if ( (_DWORD)v11 != _InterlockedCompareExchange((volatile signed __int32 *)_RDI, 1, (signed __int32)v11) )
          sub_1C7D0(_RDI);
      }
      else
      {
        __asm { cmpxchg [rdi], edx }
      }
      v10 = *(_DWORD *)a1;
      v15 = *(_QWORD *)(a1 + 136);
      v16 = off_BE060;
      v17 = v10;
      ++*(_DWORD *)(v15 + 4);
      LOBYTE(v10) = v10 & 0x7F;
      *(_QWORD *)(v15 + 8) = v13;
      v11 = (u32 *)(v17 & 0x8000);
      if ( !v16 )
        goto LABEL_13;
    }
  }
  v18 = (_QWORD *)v16[13];
  if ( (_QWORD *)a1 == v16 )
  {
    off_BE060 = (void *)v16[13];
  }
  else
  {
    while ( v18 )
    {
      if ( (_QWORD *)a1 == v18 )
      {
        v16[13] = *(_QWORD *)(a1 + 104);
        *(_DWORD *)a1 = v10;
        if ( !(_DWORD)v11 )
          goto LABEL_14;
        goto LABEL_26;
      }
      v16 = v18;
      v18 = (_QWORD *)v18[13];
    }
  }
LABEL_13:
  *(_DWORD *)a1 = v10;
  if ( !(_DWORD)v11 )
  {
LABEL_14:
    _RDI = *(_QWORD *)(a1 + 136);
    goto LABEL_15;
  }
LABEL_26:
  v9 = *(&qword_C11D0 + 1) - 1;
LABEL_27:
  qword_C11C0 = 0LL;
  *(&qword_C11D0 + 1) = v9;
  if ( !v9 )
  {
    qword_C11D8 = 0LL;
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedExchange((volatile __int32 *)&qword_C11D0, 0) > 1 )
        v22 = sys_futex(&qword_C11D0, 129, 1u, 0LL, v11, a6);
    }
    else
    {
      --qword_C11D0;
    }
  }
}
// 19B90: variable 'a6' is possibly undefined
// 19C98: variable 'v11' is possibly undefined
// 90B0: using guessed type __int64 __fastcall sub_90B0(_QWORD, _QWORD);
// 9160: using guessed type __int64 __fastcall sub_9160(_QWORD, _QWORD, _QWORD);
// 1C7D0: using guessed type __int64 __fastcall sub_1C7D0(_QWORD);
// BE060: using guessed type void *off_BE060;
// C11C0: using guessed type __int64 qword_C11C0;
// C11D8: using guessed type __int64 qword_C11D8;

//----- (0000000000019D10) ----------------------------------------------------
unsigned __int64 __fastcall sub_19D10(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  int v6; // eax
  unsigned __int64 v8; // r12
  int v10; // ecx
  u32 v11; // edx
  __int64 v12; // rcx
  unsigned __int64 v14; // r12
  int v16; // eax
  void *v17; // rdx
  int v18; // eax
  void *v19; // rax
  void *v21; // rax
  signed __int64 v22; // rax
  int v23; // eax
  signed __int64 v24; // rax
  unsigned __int64 v25; // [rsp+28h] [rbp-20h]

  v25 = __readfsqword(0x28u);
  v6 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 0x80u) != 0 )
    return v25 - __readfsqword(0x28u);
  LOBYTE(v6) = v6 | 0x80;
  *(_DWORD *)a1 = v6;
  v8 = __readfsqword(0x10u);
  if ( qword_C11D8 != v8 )
  {
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedCompareExchange((volatile signed __int32 *)&qword_C11D0, 1, 0) )
        sub_1C7D0((volatile __int32 *)&qword_C11D0, a2, 1LL, a4, a5, a6);
    }
    else
    {
      _EDX = 1;
      __asm { cmpxchg dword ptr cs:qword_C11D0, edx }
    }
    qword_C11D8 = v8;
  }
  v10 = *(_DWORD *)a1;
  qword_C11C0 = (__int64)a1;
  v11 = ++*(&qword_C11D0 + 1);
  v12 = (unsigned __int16)v10 & 0x8000;
  if ( (_DWORD)v12 )
  {
    v19 = off_BE060;
    off_BE060 = a1;
    a1[13] = v19;
    goto LABEL_15;
  }
  _RDI = a1[17];
  v14 = __readfsqword(0x10u);
  if ( *(_QWORD *)(_RDI + 8) == v14 )
  {
    v21 = off_BE060;
    ++*(_DWORD *)(_RDI + 4);
    off_BE060 = a1;
    a1[13] = v21;
  }
  else
  {
    _EDX = 1;
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedCompareExchange((volatile signed __int32 *)_RDI, 1, 0) )
        sub_1C7D0((volatile __int32 *)_RDI, a2, 1LL, v12, a5, a6);
    }
    else
    {
      __asm { cmpxchg [rdi], edx }
    }
    _RDI = a1[17];
    v16 = *(_DWORD *)a1;
    v17 = off_BE060;
    ++*(_DWORD *)(_RDI + 4);
    *(_QWORD *)(_RDI + 8) = v14;
    off_BE060 = a1;
    a1[13] = v17;
    if ( (v16 & 0x8000) != 0 )
      goto LABEL_28;
  }
  v18 = *(_DWORD *)(_RDI + 4) - 1;
  *(_DWORD *)(_RDI + 4) = v18;
  v11 = *(&qword_C11D0 + 1);
  if ( v18 )
    goto LABEL_15;
  *(_QWORD *)(_RDI + 8) = 0LL;
  if ( !__readfsdword(0x18u) )
  {
    --*(_DWORD *)_RDI;
    v11 = *(&qword_C11D0 + 1);
    goto LABEL_15;
  }
  v23 = _InterlockedExchange((volatile __int32 *)_RDI, 0);
  v11 = *(&qword_C11D0 + 1);
  if ( v23 > 1 )
  {
    v24 = sys_futex((u32 *)_RDI, 129, 1u, 0LL, a5, a6);
LABEL_28:
    v11 = *(&qword_C11D0 + 1);
  }
LABEL_15:
  qword_C11C0 = 0LL;
  *(&qword_C11D0 + 1) = v11 - 1;
  if ( v11 == 1 )
  {
    qword_C11D8 = 0LL;
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedExchange((volatile __int32 *)&qword_C11D0, 0) > 1 )
        v22 = sys_futex(&qword_C11D0, 129, 1u, 0LL, a5, a6);
    }
    else
    {
      --qword_C11D0;
    }
  }
  return v25 - __readfsqword(0x28u);
}
// 19F68: variable 'a5' is possibly undefined
// 19F68: variable 'a6' is possibly undefined
// 90B0: using guessed type __int64 __fastcall sub_90B0(_QWORD, _QWORD);
// 9160: using guessed type __int64 __fastcall sub_9160(_QWORD, _QWORD, _QWORD);
// BE060: using guessed type void *off_BE060;
// C11C0: using guessed type __int64 qword_C11C0;
// C11D8: using guessed type __int64 qword_C11D8;

//----- (000000000001A000) ----------------------------------------------------
__int64 __fastcall sub_1A000(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rdx
  __int64 v3; // rdx
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 88);
  *(_DWORD *)a1 &= 0xFFFFFEFF;
  *(_QWORD *)(a1 + 16) = v2;
  v3 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 88) = v1;
  result = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 72) = v3;
  *(_QWORD *)(a1 + 24) = result;
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

//----- (000000000001A060) ----------------------------------------------------
__int64 __fastcall sub_1A060(int *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  unsigned __int64 v9; // rax
  __int64 v10; // rbp
  __int64 result; // rax
  int v12; // edx

  v9 = *((_QWORD *)a1 + 5);
  if ( v9 <= *((_QWORD *)a1 + 4) )
  {
LABEL_6:
    v12 = *a1;
    if ( (*a1 & 0x100) != 0 )
    {
      *((_QWORD *)a1 + 3) = *((_QWORD *)a1 + 10);
    }
    else
    {
      *((_QWORD *)a1 + 3) = *((_QWORD *)a1 + 7);
      if ( *((_QWORD *)a1 + 2) < v9 )
        *((_QWORD *)a1 + 2) = v9;
    }
    BYTE1(v12) &= 0xF7u;
    *((_QWORD *)a1 + 1) = v9;
    *a1 = v12;
    *((_QWORD *)a1 + 6) = v9;
    *((_QWORD *)a1 + 4) = v9;
    return 0LL;
  }
  v10 = *((_QWORD *)a1 + 27);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v10 - (_QWORD)&unk_BFAE0) )
    sub_17140(a2, a3, a4, a5, a6, a7, a8, a9);
  result = (*(__int64 (__fastcall **)(int *, __int64))(v10 + 24))(a1, 0xFFFFFFFFLL);
  if ( (_DWORD)result != -1 )
  {
    v9 = *((_QWORD *)a1 + 5);
    goto LABEL_6;
  }
  return result;
}
// C0308: using guessed type void *off_C0308;

//----- (000000000001A100) ----------------------------------------------------
__int64 __fastcall sub_1A100(int *a1)
{
  int v1; // eax
  __int64 v3; // rdi
  __int64 v4; // rax
  __int64 result; // rax

  v1 = *a1;
  v3 = *((_QWORD *)a1 + 9);
  if ( (v1 & 0x100) != 0 )
  {
    BYTE1(v1) &= 0xFEu;
    *((_QWORD *)a1 + 1) = v3;
    *a1 = v1;
    *((_QWORD *)a1 + 2) = *((_QWORD *)a1 + 11);
    v4 = *((_QWORD *)a1 + 3);
    *((_QWORD *)a1 + 3) = v3;
    v3 = v4;
  }
  result = sub_21B70(v3);
  *((_QWORD *)a1 + 9) = 0LL;
  *((_QWORD *)a1 + 11) = 0LL;
  *((_QWORD *)a1 + 10) = 0LL;
  return result;
}
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (000000000001A150) ----------------------------------------------------
__int64 __fastcall sub_1A150(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  __int64 v10; // rbx

  if ( !*(_DWORD *)(a1 + 192) )
    *(_DWORD *)(a1 + 192) = -1;
  v10 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 > (unsigned __int64)(v10 - (_QWORD)&unk_BFAE0) )
    return (*(__int64 (__fastcall **)(__int64, __int64, double, double, double, double, double, double, double, double))(v10 + 24))(
             a1,
             a2,
             a3,
             a4,
             a5,
             a6,
             a7,
             a8,
             a9,
             a10);
  sub_17140(a3, a4, a5, a6, a7, a8, a9, a10);
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(v10 + 24))(a1, (unsigned int)a2);
}
// C0308: using guessed type void *off_C0308;

//----- (000000000001A1C0) ----------------------------------------------------
__int64 __fastcall sub_1A1C0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  int v10; // eax
  unsigned __int8 *v11; // rax
  unsigned __int64 v12; // rdx
  int v13; // eax
  unsigned __int64 v14; // rcx
  __int64 v15; // rdx
  __int64 v16; // rbx
  __int64 v18; // rdi
  int v19; // eax
  __int64 v20; // rax

  v10 = *(_DWORD *)(a1 + 192);
  if ( v10 )
  {
    if ( v10 != -1 )
      return 0xFFFFFFFFLL;
  }
  else
  {
    *(_DWORD *)(a1 + 192) = -1;
  }
  if ( (*(_DWORD *)a1 & 0x800) != 0 && (unsigned int)sub_1A060((int *)a1, a2, a3, a4, a5, a6, a7, a8, a9) == -1 )
    return 0xFFFFFFFFLL;
  v11 = *(unsigned __int8 **)(a1 + 8);
  v12 = *(_QWORD *)(a1 + 16);
  if ( (unsigned __int64)v11 < v12 )
    return *v11;
  v13 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 0x100) != 0 )
  {
    BYTE1(v13) &= 0xFEu;
    v14 = *(_QWORD *)(a1 + 88);
    *(_QWORD *)(a1 + 88) = v12;
    *(_DWORD *)a1 = v13;
    v15 = *(_QWORD *)(a1 + 24);
    v11 = *(unsigned __int8 **)(a1 + 72);
    *(_QWORD *)(a1 + 16) = v14;
    *(_QWORD *)(a1 + 72) = v15;
    *(_QWORD *)(a1 + 24) = v11;
    *(_QWORD *)(a1 + 8) = v11;
    if ( v14 > (unsigned __int64)v11 )
      return *v11;
  }
  if ( !*(_QWORD *)(a1 + 96) )
  {
    v18 = *(_QWORD *)(a1 + 72);
    if ( v18 )
    {
      v19 = *(_DWORD *)a1;
      if ( (*(_DWORD *)a1 & 0x100) != 0 )
      {
        BYTE1(v19) &= 0xFEu;
        *(_QWORD *)(a1 + 8) = v18;
        *(_DWORD *)a1 = v19;
        *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 88);
        v20 = *(_QWORD *)(a1 + 24);
        *(_QWORD *)(a1 + 24) = v18;
        v18 = v20;
      }
      sub_21B70(v18);
      *(_QWORD *)(a1 + 72) = 0LL;
      *(_QWORD *)(a1 + 88) = 0LL;
      *(_QWORD *)(a1 + 80) = 0LL;
    }
    goto LABEL_9;
  }
  if ( (unsigned int)sub_19820((_QWORD *)a1, *(_QWORD *)(a1 + 16)) )
    return 0xFFFFFFFFLL;
LABEL_9:
  v16 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v16 - (_QWORD)&unk_BFAE0) )
    sub_17140(a2, a3, a4, a5, a6, a7, a8, a9);
  return (*(__int64 (__fastcall **)(__int64))(v16 + 32))(a1);
}
// 1A320: variable 'a6' is possibly undefined
// 1A320: variable 'a7' is possibly undefined
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// C0308: using guessed type void *off_C0308;

//----- (000000000001A330) ----------------------------------------------------
__int64 __fastcall sub_1A330(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  int v10; // eax
  unsigned __int8 *v11; // rax
  unsigned __int64 v12; // rdx
  int v13; // eax
  unsigned __int64 v14; // rcx
  __int64 v15; // rdx
  __int64 v16; // rbx
  __int64 v18; // rdi
  int v19; // eax
  __int64 v20; // rax

  v10 = *(_DWORD *)(a1 + 192);
  if ( v10 )
  {
    if ( v10 != -1 )
      return 0xFFFFFFFFLL;
  }
  else
  {
    *(_DWORD *)(a1 + 192) = -1;
  }
  if ( (*(_DWORD *)a1 & 0x800) != 0 && (unsigned int)sub_1A060((int *)a1, a2, a3, a4, a5, a6, a7, a8, a9) == -1 )
    return 0xFFFFFFFFLL;
  v11 = *(unsigned __int8 **)(a1 + 8);
  v12 = *(_QWORD *)(a1 + 16);
  if ( (unsigned __int64)v11 < v12 )
    goto LABEL_19;
  v13 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 0x100) == 0 )
    goto LABEL_8;
  BYTE1(v13) &= 0xFEu;
  v14 = *(_QWORD *)(a1 + 88);
  *(_QWORD *)(a1 + 88) = v12;
  *(_DWORD *)a1 = v13;
  v15 = *(_QWORD *)(a1 + 24);
  v11 = *(unsigned __int8 **)(a1 + 72);
  *(_QWORD *)(a1 + 16) = v14;
  *(_QWORD *)(a1 + 72) = v15;
  *(_QWORD *)(a1 + 24) = v11;
  if ( v14 > (unsigned __int64)v11 )
  {
LABEL_19:
    *(_QWORD *)(a1 + 8) = v11 + 1;
    return *v11;
  }
  *(_QWORD *)(a1 + 8) = v11;
LABEL_8:
  if ( !*(_QWORD *)(a1 + 96) )
  {
    v18 = *(_QWORD *)(a1 + 72);
    if ( v18 )
    {
      v19 = *(_DWORD *)a1;
      if ( (*(_DWORD *)a1 & 0x100) != 0 )
      {
        BYTE1(v19) &= 0xFEu;
        *(_QWORD *)(a1 + 8) = v18;
        *(_DWORD *)a1 = v19;
        *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 88);
        v20 = *(_QWORD *)(a1 + 24);
        *(_QWORD *)(a1 + 24) = v18;
        v18 = v20;
      }
      sub_21B70(v18);
      *(_QWORD *)(a1 + 72) = 0LL;
      *(_QWORD *)(a1 + 88) = 0LL;
      *(_QWORD *)(a1 + 80) = 0LL;
    }
    goto LABEL_10;
  }
  if ( (unsigned int)sub_19820((_QWORD *)a1, *(_QWORD *)(a1 + 16)) )
    return 0xFFFFFFFFLL;
LABEL_10:
  v16 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v16 - (_QWORD)&unk_BFAE0) )
    sub_17140(a2, a3, a4, a5, a6, a7, a8, a9);
  return (*(__int64 (__fastcall **)(__int64))(v16 + 40))(a1);
}
// 1A490: variable 'a6' is possibly undefined
// 1A490: variable 'a7' is possibly undefined
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// C0308: using guessed type void *off_C0308;

//----- (000000000001A4A0) ----------------------------------------------------
__int64 __fastcall sub_1A4A0(int *a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v7; // rdi
  int v8; // eax
  int v9; // edx
  __int64 result; // rax
  unsigned int v11; // edx

  v7 = *((_QWORD *)a1 + 7);
  v8 = *a1;
  if ( v7 && (v8 & 1) == 0 )
  {
    sub_21B70(v7);
    v8 = *a1;
  }
  v9 = v8;
  result = v8 | 1u;
  *((_QWORD *)a1 + 7) = a2;
  v11 = v9 & 0xFFFFFFFE;
  *((_QWORD *)a1 + 8) = a3;
  if ( a4 )
    result = v11;
  *a1 = result;
  return result;
}
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (000000000001A500) ----------------------------------------------------
void __fastcall sub_1A500(int *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  int v10; // eax
  __int64 v12; // rbp
  __int64 v13; // rdx
  unsigned __int64 v14; // rcx
  u32 *v15; // r8
  __int64 v16; // r9
  double v17; // xmm4_8
  double v18; // xmm5_8
  __int64 v19; // rdi
  int *v20; // r12
  __int64 v21; // rbp

  if ( !*((_QWORD *)a1 + 7) )
  {
    v10 = *a1;
    if ( (*a1 & 2) != 0 && a1[48] <= 0 )
    {
      v20 = a1 + 33;
      v21 = (__int64)a1 + 131;
LABEL_10:
      *((_QWORD *)a1 + 7) = v21;
      *((_QWORD *)a1 + 8) = v20;
      *a1 = v10 | 1;
      return;
    }
    v12 = *((_QWORD *)a1 + 27);
    if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v12 - (_QWORD)&unk_BFAE0) )
      sub_17140(a3, a4, a5, a6, a7, a8, a9, a10);
    if ( (*(unsigned int (__fastcall **)(int *))(v12 + 104))(a1) == -1 )
    {
      v19 = *((_QWORD *)a1 + 7);
      v10 = *a1;
      v20 = a1 + 33;
      v21 = (__int64)a1 + 131;
      if ( v19 )
      {
        if ( (v10 & 1) == 0 )
        {
          sub_21B70(v19, a3, a4, a5, a6, v17, v18, a9, a10, a2, v13, v14, v15, v16);
          v10 = *a1;
        }
      }
      goto LABEL_10;
    }
  }
}
// 1A5A0: variable 'v17' is possibly undefined
// 1A5A0: variable 'v18' is possibly undefined
// 1A5A0: variable 'v13' is possibly undefined
// 1A5A0: variable 'v14' is possibly undefined
// 1A5A0: variable 'v15' is possibly undefined
// 1A5A0: variable 'v16' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (000000000001A5C0) ----------------------------------------------------
__int64 sub_1A5C0()
{
  return 0xFFFFFFFFLL;
}
// 1A5C0: using guessed type __int64 __fastcall sub_1A5C0();

//----- (000000000001A5D0) ----------------------------------------------------
__int64 __fastcall sub_1A5D0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 v9; // rbp
  __int64 result; // rax
  unsigned __int8 *v11; // rax

  v9 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v9 - (_QWORD)&unk_BFAE0) )
    sub_17140(a2, a3, a4, a5, a6, a7, a8, a9);
  result = (*(__int64 (__fastcall **)(__int64))(v9 + 32))(a1);
  if ( (_DWORD)result != -1 )
  {
    v11 = *(unsigned __int8 **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = v11 + 1;
    result = *v11;
  }
  return result;
}
// C0308: using guessed type void *off_C0308;

//----- (000000000001A630) ----------------------------------------------------
unsigned __int64 __fastcall sub_1A630(_QWORD *a1, unsigned __int8 *a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  unsigned __int64 v12; // r13
  unsigned __int64 i; // rbp
  __int64 v15; // rbx
  unsigned __int64 v16; // rdi
  unsigned __int64 v17; // rbx
  unsigned __int64 v18; // rbx
  unsigned __int8 *v19; // rsi
  __int64 j; // rax

  if ( !a3 )
    return 0LL;
  v12 = a3;
  for ( i = a3; ; --i )
  {
    v16 = a1[5];
    v17 = a1[6];
    if ( v16 < v17 )
    {
      v18 = v17 - v16;
      if ( i <= v18 )
        v18 = i;
      if ( v18 <= 0x14 )
      {
        if ( v18 )
        {
          for ( j = 0LL; j != v18; ++j )
            *(_BYTE *)(v16 + j) = a2[j];
          a2 += v18;
          a1[5] = v18 + v16;
        }
      }
      else
      {
        v19 = a2;
        a2 += v18;
        a1[5] = sub_91D0(v16, v19, v18);
      }
      i -= v18;
    }
    if ( !i )
      break;
    v15 = a1[27];
    if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v15 - (_QWORD)&unk_BFAE0) )
      sub_17140(a4, a5, a6, a7, a8, a9, a10, a11);
    if ( (*(unsigned int (__fastcall **)(_QWORD *, _QWORD))(v15 + 24))(a1, *a2) == -1 )
    {
      v12 -= i;
      return v12;
    }
    ++a2;
  }
  return v12;
}
// 1A700: variable 'a8' is possibly undefined
// 1A700: variable 'a9' is possibly undefined
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// C0308: using guessed type void *off_C0308;

//----- (000000000001A7C0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1A7C0(__int64 a1, __int64 a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  unsigned __int64 v11; // r14
  unsigned __int64 v12; // r12
  unsigned __int64 v14; // rsi
  unsigned __int64 v15; // rbx
  unsigned __int64 v16; // rbx
  __int64 v17; // rax
  __int64 i; // rax

  v11 = a3;
  v12 = a3;
  while ( 1 )
  {
    v14 = *(_QWORD *)(a1 + 8);
    v15 = *(_QWORD *)(a1 + 16);
    if ( v14 < v15 )
    {
      v16 = v15 - v14;
      if ( v11 <= v16 )
        v16 = v11;
      if ( v16 <= 0x14 )
      {
        if ( v16 )
        {
          for ( i = 0LL; i != v16; ++i )
            *(_BYTE *)(a2 + i) = *(_BYTE *)(v14 + i);
          a2 += v16;
          *(_QWORD *)(a1 + 8) = v16 + v14;
        }
      }
      else
      {
        v17 = sub_91D0(a2, v14, v16);
        *(_QWORD *)(a1 + 8) += v16;
        a2 = v17;
      }
      v11 -= v16;
    }
    if ( !v11 )
      break;
    if ( (unsigned int)sub_1A1C0(a1, a4, a5, a6, a7, a8, a9, a10, a11) == -1 )
    {
      v12 -= v11;
      return v12;
    }
  }
  return v12;
}
// 1A7F0: variable 'a8' is possibly undefined
// 1A7F0: variable 'a9' is possibly undefined
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);

//----- (000000000001A870) ----------------------------------------------------
int *__fastcall sub_1A870(int *a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  __int64 v11; // r12
  __int64 v14; // r13
  unsigned __int64 v15; // rcx
  u32 *v16; // r8
  __int64 v17; // r9
  double v18; // xmm4_8
  double v19; // xmm5_8
  int v20; // eax
  __int64 v21; // rdi
  int v22; // edx
  __int64 v23; // rdx
  int *v24; // rbp
  int *result; // rax

  v11 = a2;
  v14 = *((_QWORD *)a1 + 27);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v14 - (_QWORD)&unk_BFAE0) )
    sub_17140(a4, a5, a6, a7, a8, a9, a10, a11);
  if ( (*(unsigned int (__fastcall **)(int *))(v14 + 96))(a1) != -1 )
  {
    v20 = *a1;
    v21 = *((_QWORD *)a1 + 7);
    v22 = *a1;
    if ( a2 && a3 )
    {
      v23 = v22 & 0xFFFFFFFD;
      v24 = (int *)(a2 + a3);
      *a1 = v23;
      if ( !v21 || (v20 & 1) != 0 )
        goto LABEL_8;
    }
    else
    {
      v23 = v22 | 2u;
      v24 = a1 + 33;
      v11 = (__int64)a1 + 131;
      *a1 = v23;
      if ( !v21 || (v20 & 1) != 0 )
        goto LABEL_8;
    }
    sub_21B70(v21, a4, a5, a6, a7, v18, v19, a10, a11, a2, v23, v15, v16, v17);
    LODWORD(v23) = *a1;
LABEL_8:
    *((_QWORD *)a1 + 7) = v11;
    result = a1;
    *((_QWORD *)a1 + 8) = v24;
    *a1 = v23 | 1;
    *((_QWORD *)a1 + 6) = 0LL;
    *((_QWORD *)a1 + 5) = 0LL;
    *((_QWORD *)a1 + 4) = 0LL;
    *((_QWORD *)a1 + 2) = 0LL;
    *((_QWORD *)a1 + 1) = 0LL;
    *((_QWORD *)a1 + 3) = 0LL;
    return result;
  }
  return 0LL;
}
// 1A94C: variable 'v18' is possibly undefined
// 1A94C: variable 'v19' is possibly undefined
// 1A94C: variable 'v15' is possibly undefined
// 1A94C: variable 'v16' is possibly undefined
// 1A94C: variable 'v17' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (000000000001A970) ----------------------------------------------------
__int64 __fastcall sub_1A970(__int64 a1, __int64 a2, unsigned int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  __int64 v11; // rbx

  v11 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 > (unsigned __int64)(v11 - (_QWORD)&unk_BFAE0) )
    return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(v11 + 72))(a1, a2, 0LL, a3);
  sub_17140(a4, a5, a6, a7, a8, a9, a10, a11);
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(v11 + 72))(a1, a2, 0LL, a3);
}
// C0308: using guessed type void *off_C0308;

//----- (000000000001A9E0) ----------------------------------------------------
__int64 __fastcall sub_1A9E0(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v15; // rax
  __int64 v16; // rdx
  unsigned __int64 v17; // rcx
  u32 *v18; // r8
  __int64 v19; // r9
  double v20; // xmm4_8
  double v21; // xmm5_8
  __int64 v22; // rdi
  __int64 v23; // rbp
  __int64 v24; // r12
  unsigned int v25; // eax

  v15 = sub_21500((u32 *)&stru_1FF0.r_addend, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
  if ( !v15 )
    return 0xFFFFFFFFLL;
  v22 = *((_QWORD *)a1 + 7);
  v23 = v15;
  v24 = v15 + 0x2000;
  v25 = *a1;
  if ( v22 )
  {
    if ( (v25 & 1) == 0 )
    {
      sub_21B70(v22, a7, a8, a9, a10, v20, v21, a13, a14, a2, v16, v17, v18, v19);
      v25 = *a1;
    }
  }
  *((_QWORD *)a1 + 7) = v23;
  *((_QWORD *)a1 + 8) = v24;
  *a1 = v25 & 0xFFFFFFFE;
  return 1LL;
}
// 1AA30: variable 'v20' is possibly undefined
// 1AA30: variable 'v21' is possibly undefined
// 1AA30: variable 'v16' is possibly undefined
// 1AA30: variable 'v17' is possibly undefined
// 1AA30: variable 'v18' is possibly undefined
// 1AA30: variable 'v19' is possibly undefined
// 1FF0: using guessed type Elf64_Rela;

//----- (000000000001AA50) ----------------------------------------------------
_QWORD *__fastcall sub_1AA50(__int64 a1, int a2)
{
  int v2; // edx
  _QWORD *result; // rax

  v2 = dword_C11BC;
  *(_DWORD *)(a1 + 116) = 0;
  *(_DWORD *)a1 = a2 | 0xFBAD0000;
  if ( v2 )
    *(_DWORD *)(a1 + 116) = 128;
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_WORD *)(a1 + 128) = 0;
  result = *(_QWORD **)(a1 + 136);
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 104) = 0LL;
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_QWORD *)(a1 + 88) = 0LL;
  *(_QWORD *)(a1 + 96) = 0LL;
  if ( result )
  {
    *result = 0LL;
    result[1] = 0LL;
  }
  *(_DWORD *)(a1 + 192) = -1;
  *(_QWORD *)(a1 + 160) = -1LL;
  *(_QWORD *)(a1 + 168) = 0LL;
  return result;
}
// C11BC: using guessed type int dword_C11BC;

//----- (000000000001AD10) ----------------------------------------------------
_QWORD *__fastcall sub_1AD10(__int64 a1, int a2, int a3, _QWORD *a4, __int64 a5)
{
  _QWORD *result; // rax

  *(_DWORD *)(a1 + 116) = 0;
  *(_DWORD *)a1 = a2 | 0xFBAD0000;
  if ( dword_C11BC )
    *(_DWORD *)(a1 + 116) = 128;
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_WORD *)(a1 + 128) = 0;
  result = *(_QWORD **)(a1 + 136);
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 104) = 0LL;
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_QWORD *)(a1 + 88) = 0LL;
  *(_QWORD *)(a1 + 96) = 0LL;
  if ( result )
  {
    *result = 0LL;
    result[1] = 0LL;
  }
  *(_DWORD *)(a1 + 192) = a3;
  if ( a3 < 0 )
  {
    *(_QWORD *)(a1 + 160) = -1LL;
  }
  else
  {
    *(_QWORD *)(a1 + 160) = a4;
    a4[6] = 0LL;
    a4[7] = 0LL;
    a4[2] = 0LL;
    *a4 = 0LL;
    a4[1] = 0LL;
    a4[3] = 0LL;
    a4[4] = 0LL;
    a4[5] = 0LL;
    a4[8] = 0LL;
    a4[9] = 0LL;
    a4[10] = 0LL;
    a4[28] = a5;
  }
  *(_QWORD *)(a1 + 168) = 0LL;
  return result;
}
// C11BC: using guessed type int dword_C11BC;

//----- (000000000001AE60) ----------------------------------------------------
__int64 sub_1AE60()
{
  return 0LL;
}
// 1AE60: using guessed type __int64 __fastcall sub_1AE60();

//----- (000000000001AE70) ----------------------------------------------------
_QWORD *__fastcall sub_1AE70(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v15; // rdi
  _QWORD *result; // rax
  __int64 v17; // rdi

  v15 = *(_QWORD *)(a1 + 56);
  if ( v15 && (*(_BYTE *)a1 & 1) == 0 )
  {
    sub_21B70(v15, a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);
    *(_QWORD *)(a1 + 64) = 0LL;
    *(_QWORD *)(a1 + 56) = 0LL;
  }
  for ( result = *(_QWORD **)(a1 + 96); result; result = (_QWORD *)*result )
    result[1] = 0LL;
  v17 = *(_QWORD *)(a1 + 72);
  if ( v17 )
  {
    result = sub_21B70(v17, a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);
    *(_QWORD *)(a1 + 72) = 0LL;
  }
  if ( *(char *)a1 < 0 )
    JUMPOUT(0x19C08LL);
  return result;
}
// 19A25: control flows out of bounds to 19C08
// 19B43: control flows out of bounds to 19BA1
// 19A58: control flows out of bounds to 19CA0
// 19A93: control flows out of bounds to 19B48
// 19AAD: control flows out of bounds to 19C48
// 19AC2: control flows out of bounds to 19CC6
// 19AFD: control flows out of bounds to 19B70
// 19B0B: control flows out of bounds to 19B98
// 19B35: control flows out of bounds to 19B77
// 1AEA9: variable 'a11' is possibly undefined
// 1AEA9: variable 'a12' is possibly undefined
// 1AEA9: variable 'a3' is possibly undefined
// 1AEA9: variable 'a4' is possibly undefined
// 1AEA9: variable 'a5' is possibly undefined
// 1AEA9: variable 'a6' is possibly undefined
// 9160: using guessed type __int64 __fastcall sub_9160(_QWORD, _QWORD, _QWORD);
// BE060: using guessed type void *off_BE060;
// C11C0: using guessed type __int64 qword_C11C0;
// C11D8: using guessed type __int64 qword_C11D8;

//----- (000000000001AEF0) ----------------------------------------------------
__int64 sub_1AEF0()
{
  return -1LL;
}
// 1AEF0: using guessed type __int64 __fastcall sub_1AEF0();

//----- (000000000001AF00) ----------------------------------------------------
__int64 __fastcall sub_1AF00(__int64 a1, unsigned __int8 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  unsigned __int64 v10; // rax
  __int64 v11; // rbp
  __int64 result; // rax

  v10 = *(_QWORD *)(a1 + 8);
  if ( v10 > *(_QWORD *)(a1 + 24) && *(_BYTE *)(v10 - 1) == a2 )
  {
    *(_QWORD *)(a1 + 8) = v10 - 1;
    result = a2;
LABEL_6:
    *(_DWORD *)a1 &= 0xFFFFFFEF;
    return result;
  }
  v11 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v11 - (_QWORD)&unk_BFAE0) )
    sub_17140(a3, a4, a5, a6, a7, a8, a9, a10);
  result = (*(__int64 (__fastcall **)(__int64))(v11 + 48))(a1);
  if ( (_DWORD)result != -1 )
    goto LABEL_6;
  return result;
}
// C0308: using guessed type void *off_C0308;

//----- (000000000001B000) ----------------------------------------------------
__int64 __fastcall sub_1B000(int a1, unsigned __int64 a2, int a3)
{
  _BYTE *v3; // rax

  v3 = (_BYTE *)(a2 + a3);
  do
  {
    if ( (unsigned __int64)v3 <= a2 )
      return (unsigned int)(a3 + a1);
    --v3;
  }
  while ( *v3 != 10 );
  return (unsigned int)(a2 + a3 - (_DWORD)v3 - 1);
}

//----- (000000000001B030) ----------------------------------------------------
__int64 __fastcall sub_1B030(int a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14)
{
  unsigned __int64 v15; // rbx
  u32 v17; // eax
  int *v18; // rbx
  unsigned int v19; // er14
  unsigned __int64 v20; // r12
  __int64 v21; // r15
  __int64 v22; // rdi
  int v23; // eax
  __int64 v24; // rdx
  signed __int64 v28; // rax
  signed __int64 v29; // rax

  v15 = __readfsqword(0x10u);
  if ( qword_C11D8 != v15 )
  {
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedCompareExchange((volatile signed __int32 *)&qword_C11D0, 1, 0) )
        sub_1C7D0((volatile __int32 *)&qword_C11D0, a2, 1LL, a12, a13, a14);
    }
    else
    {
      _EDX = 1;
      __asm { cmpxchg dword ptr cs:qword_C11D0, edx }
    }
    qword_C11D8 = v15;
  }
  v17 = *(&qword_C11D0 + 1);
  v18 = (int *)off_BE060;
  v19 = 0;
  ++*(&qword_C11D0 + 1);
  if ( off_BE060 )
  {
    v20 = __readfsqword(0x10u);
    while ( 1 )
    {
      qword_C11C0 = (__int64)v18;
      if ( a1 )
      {
        v24 = *v18 & 0x8000;
        if ( (*v18 & 0x8000) == 0 )
        {
          _RDI = *((_QWORD *)v18 + 17);
          if ( *(_QWORD *)(_RDI + 8) != v20 )
          {
            if ( __readfsdword(0x18u) )
            {
              if ( (_DWORD)v24 != _InterlockedCompareExchange((volatile signed __int32 *)_RDI, 1, v24) )
                sub_1C7D0((volatile __int32 *)_RDI, a2, v24, 1LL, a13, a14);
            }
            else
            {
              _EDX = 1;
              __asm { cmpxchg [rdi], edx }
            }
            _RDI = *((_QWORD *)v18 + 17);
            *(_QWORD *)(_RDI + 8) = v20;
          }
          ++*(_DWORD *)(_RDI + 4);
        }
      }
      if ( v18[48] > 0 )
      {
        if ( *(_QWORD *)(*((_QWORD *)v18 + 20) + 32LL) > *(_QWORD *)(*((_QWORD *)v18 + 20) + 24LL) )
          goto LABEL_8;
      }
      else if ( *((_QWORD *)v18 + 5) > *((_QWORD *)v18 + 4) )
      {
LABEL_8:
        v21 = *((_QWORD *)v18 + 27);
        if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v21 - (_QWORD)&unk_BFAE0) )
          sub_17140(a3, a4, a5, a6, a7, a8, a9, a10);
        a2 = 0xFFFFFFFFLL;
        if ( (*(unsigned int (__fastcall **)(int *, __int64))(v21 + 24))(v18, 0xFFFFFFFFLL) == -1 )
          v19 = -1;
        goto LABEL_12;
      }
LABEL_12:
      if ( a1 )
      {
        if ( (*v18 & 0x8000) == 0 )
        {
          v22 = *((_QWORD *)v18 + 17);
          v23 = *(_DWORD *)(v22 + 4) - 1;
          *(_DWORD *)(v22 + 4) = v23;
          if ( !v23 )
          {
            *(_QWORD *)(v22 + 8) = 0LL;
            if ( __readfsdword(0x18u) )
            {
              if ( _InterlockedExchange((volatile __int32 *)v22, 0) > 1 )
              {
                a2 = 129LL;
                v29 = sys_futex((u32 *)v22, 129, 1u, 0LL, a13, a14);
              }
            }
            else
            {
              --*(_DWORD *)v22;
            }
          }
        }
      }
      qword_C11C0 = 0LL;
      v18 = (int *)*((_QWORD *)v18 + 13);
      if ( !v18 )
      {
        v17 = *(&qword_C11D0 + 1) - 1;
        break;
      }
    }
  }
  *(&qword_C11D0 + 1) = v17;
  if ( !v17 )
  {
    qword_C11D8 = 0LL;
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedExchange((volatile __int32 *)&qword_C11D0, 0) > 1 )
        v28 = sys_futex(&qword_C11D0, 129, 1u, 0LL, a13, a14);
    }
    else
    {
      --qword_C11D0;
    }
  }
  return v19;
}
// 1B280: variable 'a7' is possibly undefined
// 1B280: variable 'a8' is possibly undefined
// 1B2AE: variable 'a13' is possibly undefined
// 1B2AE: variable 'a14' is possibly undefined
// 90B0: using guessed type __int64 __fastcall sub_90B0(_QWORD, _QWORD);
// 9160: using guessed type __int64 __fastcall sub_9160(_QWORD, _QWORD, _QWORD);
// BE060: using guessed type void *off_BE060;
// C0308: using guessed type void *off_C0308;
// C11C0: using guessed type __int64 qword_C11C0;
// C11D8: using guessed type __int64 qword_C11D8;

//----- (000000000001BB30) ----------------------------------------------------
void __fastcall sub_1BB30(int *a1)
{
  __int64 v2; // rdi
  int v3; // eax
  __int64 v4; // rax

  if ( *((_QWORD *)a1 + 12) )
    *((_QWORD *)a1 + 12) = 0LL;
  v2 = *((_QWORD *)a1 + 9);
  if ( v2 )
  {
    v3 = *a1;
    if ( (*a1 & 0x100) != 0 )
    {
      BYTE1(v3) &= 0xFEu;
      *((_QWORD *)a1 + 1) = v2;
      *a1 = v3;
      *((_QWORD *)a1 + 2) = *((_QWORD *)a1 + 11);
      v4 = *((_QWORD *)a1 + 3);
      *((_QWORD *)a1 + 3) = v2;
      v2 = v4;
    }
    sub_21B70(v2);
    *((_QWORD *)a1 + 9) = 0LL;
    *((_QWORD *)a1 + 11) = 0LL;
    *((_QWORD *)a1 + 10) = 0LL;
  }
}
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (000000000001BBA0) ----------------------------------------------------
__int64 __fastcall sub_1BBA0(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  int v14; // er13
  unsigned __int64 v15; // r12
  const void *v16; // r14
  int v17; // eax
  size_t v19; // r15
  __int64 v20; // rax
  __int64 v21; // r13
  __int64 v22; // rdx
  unsigned __int64 v23; // rcx
  u32 *v24; // r8
  __int64 v25; // r9
  double v26; // xmm4_8
  double v27; // xmm5_8
  unsigned __int64 v28; // rcx
  __int64 v29; // rax
  __int64 v30; // rdx

  v14 = *(_DWORD *)a1;
  v15 = a1[1];
  v16 = (const void *)a1[3];
  v17 = *(_DWORD *)a1 & 0x100;
  if ( v15 <= (unsigned __int64)v16 )
  {
    if ( v17 )
    {
      v19 = a1[2] - (_QWORD)v16;
      v20 = sub_21500((u32 *)(2 * v19), a2, a3, 2 * v19, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
      v21 = v20;
      if ( v20 )
      {
        v15 = v20 + v19;
        memcpy((void *)(v20 + v19), v16, v19);
        sub_21B70((__int64)v16, a7, a8, a9, a10, v26, v27, a13, a14, (__int64)v16, v22, v23, v24, v25);
        a1[3] = v21;
        a1[10] = v15;
        a1[2] = 2 * v19 + v21;
        goto LABEL_3;
      }
      return 0xFFFFFFFFLL;
    }
    v29 = a1[9];
    if ( v29 )
    {
      v28 = a1[1];
      v15 = a1[11];
      goto LABEL_14;
    }
    goto LABEL_15;
  }
  if ( v17 )
  {
LABEL_3:
    a1[1] = v15 - 1;
    *(_BYTE *)(v15 - 1) = a2;
    return (unsigned __int8)a2;
  }
  if ( *(unsigned __int8 *)(v15 - 1) == (_DWORD)a2 )
  {
    a1[1] = v15 - 1;
    return (unsigned __int8)a2;
  }
  if ( !a1[9] )
  {
LABEL_15:
    v29 = sub_21500((u32 *)&qword_80, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
    if ( v29 )
    {
      v28 = v15;
      a1[10] = v29 + 128;
      v15 = v29 + 128;
      goto LABEL_14;
    }
    return 0xFFFFFFFFLL;
  }
  if ( !(unsigned int)sub_19820(a1, a1[1]) )
  {
    v28 = a1[1];
    v14 = *(_DWORD *)a1;
    v15 = a1[11];
    v29 = a1[9];
LABEL_14:
    v30 = a1[2];
    a1[2] = v15;
    *(_DWORD *)a1 = v14 | 0x100;
    a1[11] = v30;
    a1[3] = v29;
    a1[9] = v28;
    goto LABEL_3;
  }
  return 0xFFFFFFFFLL;
}
// 1BC4B: variable 'v26' is possibly undefined
// 1BC4B: variable 'v27' is possibly undefined
// 1BC4B: variable 'v22' is possibly undefined
// 1BC4B: variable 'v23' is possibly undefined
// 1BC4B: variable 'v24' is possibly undefined
// 1BC4B: variable 'v25' is possibly undefined
// 80: using guessed type __int64 qword_80;

//----- (000000000001BD30) ----------------------------------------------------
__int64 sub_1BD30()
{
  return -1LL;
}
// 1BD30: using guessed type __int64 __fastcall sub_1BD30();

//----- (000000000001BD40) ----------------------------------------------------
__int64 sub_1BD40()
{
  return 0xFFFFFFFFLL;
}
// 1BD40: using guessed type __int64 __fastcall sub_1BD40();

//----- (000000000001BD50) ----------------------------------------------------
__int64 sub_1BD50()
{
  return -1LL;
}
// 1BD50: using guessed type __int64 __fastcall sub_1BD50();

//----- (000000000001BD60) ----------------------------------------------------
__int64 sub_1BD60()
{
  return 0LL;
}
// 1BD60: using guessed type __int64 __fastcall sub_1BD60();

//----- (000000000001BD70) ----------------------------------------------------
__int64 sub_1BD70()
{
  return 0xFFFFFFFFLL;
}
// 1BD70: using guessed type __int64 __fastcall sub_1BD70();

//----- (000000000001BD80) ----------------------------------------------------
void sub_1BD80()
{
  ;
}

//----- (000000000001BEB0) ----------------------------------------------------
__int64 __fastcall sub_1BEB0(int *a1)
{
  unsigned __int8 *v1; // rax
  unsigned __int8 *v2; // rdx
  int v3; // ecx
  __int64 result; // rax

  v1 = (unsigned __int8 *)*((_QWORD *)a1 + 5);
  v2 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  if ( v1 > v2 )
  {
    *((_QWORD *)a1 + 2) = v1;
    v2 = v1;
  }
  v3 = *a1;
  if ( (*a1 & 0xC00) == 3072 )
  {
    BYTE1(v3) &= 0xF7u;
    *((_QWORD *)a1 + 1) = v1;
    *a1 = v3;
    *((_QWORD *)a1 + 5) = *((_QWORD *)a1 + 6);
  }
  else
  {
    v1 = (unsigned __int8 *)*((_QWORD *)a1 + 1);
  }
  if ( v1 >= v2 )
    result = 0xFFFFFFFFLL;
  else
    result = *v1;
  return result;
}

//----- (000000000001BF10) ----------------------------------------------------
__int64 __fastcall sub_1BF10(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14)
{
  int v14; // eax
  _BYTE *v15; // rdx
  const void *v16; // r14
  size_t v17; // r12
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // r15
  void *v20; // rax
  __int64 v21; // r13
  __int64 v22; // rdx
  unsigned __int64 v23; // rcx
  u32 *v24; // r8
  __int64 v25; // r9
  double v26; // xmm4_8
  double v27; // xmm5_8
  __int64 v28; // rax
  __int64 v29; // rdx
  __int64 v30; // rax
  __int64 result; // rax
  __int64 v32; // rax

  v14 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 8) != 0 )
    return (unsigned int)-((_DWORD)a2 != -1);
  if ( (*(_DWORD *)a1 & 0xC00) == 1024 )
  {
    BYTE1(v14) |= 8u;
    v15 = *(_BYTE **)(a1 + 8);
    *(_DWORD *)a1 = v14;
    v32 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 40) = v15;
    *(_QWORD *)(a1 + 8) = v32;
  }
  else
  {
    v15 = *(_BYTE **)(a1 + 40);
  }
  v16 = *(const void **)(a1 + 56);
  v17 = *(_QWORD *)(a1 + 64) - (_QWORD)v16;
  v18 = (unsigned __int64)&v15[-*(_QWORD *)(a1 + 32)];
  if ( v17 + ((_DWORD)a2 == -1) <= v18 )
  {
    if ( (*(_BYTE *)a1 & 1) != 0 )
      return 0xFFFFFFFFLL;
    v19 = 2 * v17 + 100;
    if ( v17 > v19 )
      return 0xFFFFFFFFLL;
    v20 = (void *)sub_21500((u32 *)(2 * v17 + 100), a2, (__int64)v15, v18, a13, a14, a3, a4, a5, a6, a7, a8, a9, a10);
    v21 = (__int64)v20;
    if ( !v20 )
      return 0xFFFFFFFFLL;
    if ( v16 )
    {
      memcpy(v20, v16, v17);
      sub_21B70((__int64)v16, a3, a4, a5, a6, v26, v27, a9, a10, (__int64)v16, v22, v23, v24, v25);
      *(_QWORD *)(a1 + 56) = 0LL;
    }
    sub_9190(v21 + v17, 0LL, v19 - v17);
    sub_1A4A0((int *)a1, v21, v21 + v19, 1);
    v28 = *(_QWORD *)(a1 + 24);
    v29 = *(_QWORD *)(a1 + 40);
    *(_QWORD *)(a1 + 32) = v21;
    v15 = (_BYTE *)(v21 + v29 - (_QWORD)v16);
    *(_QWORD *)(a1 + 24) = v21 + v28 - (_QWORD)v16;
    v30 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 40) = v15;
    *(_QWORD *)(a1 + 8) = v21 + v30 - (_QWORD)v16;
    *(_QWORD *)(a1 + 16) = v21 + *(_QWORD *)(a1 + 16) - (_QWORD)v16;
    *(_QWORD *)(a1 + 48) = *(_QWORD *)(a1 + 64);
  }
  if ( (_DWORD)a2 != -1 )
  {
    *(_QWORD *)(a1 + 40) = v15 + 1;
    *v15 = a2;
    v15 = *(_BYTE **)(a1 + 40);
  }
  result = (unsigned int)a2;
  if ( *(_QWORD *)(a1 + 16) < (unsigned __int64)v15 )
    *(_QWORD *)(a1 + 16) = v15;
  return result;
}
// 1BFB0: variable 'v26' is possibly undefined
// 1BFB0: variable 'v27' is possibly undefined
// 1BFB0: variable 'v22' is possibly undefined
// 1BFB0: variable 'v23' is possibly undefined
// 1BFB0: variable 'v24' is possibly undefined
// 1BFB0: variable 'v25' is possibly undefined

//----- (000000000001C0B0) ----------------------------------------------------
__int64 __fastcall sub_1C0B0(__int64 a1, __int64 a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, u32 *a13, u32 a14)
{
  const void *v14; // r13
  __int64 v15; // rdx
  unsigned int v16; // er12
  __int64 v18; // r14
  void *v19; // rax
  __int64 v20; // r15
  __int64 v21; // rcx
  __int64 v22; // rdx
  unsigned __int64 v23; // rcx
  u32 *v24; // r8
  __int64 v25; // r9
  double v26; // xmm4_8
  double v27; // xmm5_8
  __int64 v28; // r14
  double v29; // xmm4_8
  double v30; // xmm5_8
  __int64 v31; // rax
  __int64 v32; // rax
  __int64 v34; // [rsp+8h] [rbp-50h]
  size_t v35; // [rsp+18h] [rbp-40h]

  v14 = *(const void **)(a1 + 56);
  v15 = *(_QWORD *)(a1 + 64) - (_QWORD)v14;
  if ( v15 >= a2 )
    return 0;
  v16 = *(_DWORD *)a1 & 1;
  if ( !v16 )
  {
    v18 = *(_QWORD *)(a1 + 48);
    v35 = *(_QWORD *)(a1 + 64) - (_QWORD)v14;
    v34 = *(_QWORD *)(a1 + 32);
    v19 = (void *)sub_21500((u32 *)(a2 + 100), a2, v15, a2 + 100, a13, a14, a4, a5, a6, a7, a8, a9, a10, a11);
    v20 = (__int64)v19;
    if ( v19 )
    {
      v21 = a2 + 100;
      if ( v14 )
      {
        memcpy(v19, v14, v35);
        sub_21B70((__int64)v14, a4, a5, a6, a7, v26, v27, a10, a11, (__int64)v14, v22, v23, v24, v25);
        *(_QWORD *)(a1 + 56) = 0LL;
        v21 = a2 + 100;
      }
      v28 = v18 - v34;
      sub_1A4A0((int *)a1, v20, v20 + v21, 1);
      if ( a3 )
      {
        v31 = *(_QWORD *)(a1 + 32);
        *(_QWORD *)(a1 + 24) = v20;
        *(_QWORD *)(a1 + 32) = v20 + v31 - (_QWORD)v14;
        *(_QWORD *)(a1 + 40) = v20 + *(_QWORD *)(a1 + 40) - (_QWORD)v14;
        *(_QWORD *)(a1 + 48) = v20 + *(_QWORD *)(a1 + 48) - (_QWORD)v14;
        *(_QWORD *)(a1 + 8) = v20 + *(_QWORD *)(a1 + 8) - (_QWORD)v14;
        *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 64);
        if ( a2 >= v28 )
        {
          sub_9190(v20 + v28, 0LL, a2 - v28);
          return v16;
        }
      }
      else
      {
        v32 = *(_QWORD *)(a1 + 24);
        *(_QWORD *)(a1 + 32) = v20;
        *(_QWORD *)(a1 + 24) = v20 + v32 - (_QWORD)v14;
        *(_QWORD *)(a1 + 8) = v20 + *(_QWORD *)(a1 + 8) - (_QWORD)v14;
        *(_QWORD *)(a1 + 16) = v20 + *(_QWORD *)(a1 + 16) - (_QWORD)v14;
        *(_QWORD *)(a1 + 40) = v20 + *(_QWORD *)(a1 + 40) - (_QWORD)v14;
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a1 + 64);
        if ( a2 >= v28 )
        {
          v16 = 0;
          sub_9190(v20 + v28, 0LL, a2 - v28);
          return v16;
        }
      }
      sub_CF00(
        (__int64)"offset >= oldend",
        (__int64)"strops.c",
        0xDEu,
        "enlarge_userbuf",
        a4,
        a5,
        a6,
        a7,
        v29,
        v30,
        a10,
        a11);
    }
  }
  return 1;
}
// 1C14B: variable 'v26' is possibly undefined
// 1C14B: variable 'v27' is possibly undefined
// 1C14B: variable 'v22' is possibly undefined
// 1C14B: variable 'v23' is possibly undefined
// 1C14B: variable 'v24' is possibly undefined
// 1C14B: variable 'v25' is possibly undefined
// 1C26C: variable 'v29' is possibly undefined
// 1C26C: variable 'v30' is possibly undefined

//----- (000000000001C280) ----------------------------------------------------
__int64 __fastcall sub_1C280(__int64 a1, __int64 a2, int a3, int a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  int v16; // edx
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // r15
  __int64 v21; // r12
  __int64 v22; // r12
  __int64 v23; // rax
  __int64 v24; // r12
  __int64 v25; // rax
  bool v26; // dl

  v16 = *(_DWORD *)a1;
  v17 = *(_QWORD *)(a1 + 40);
  v18 = *(_QWORD *)(a1 + 32);
  if ( a4 )
  {
    if ( v17 <= v18 && (v16 & 0x800) == 0 )
    {
      v19 = *(_QWORD *)(a1 + 24);
      goto LABEL_36;
    }
  }
  else
  {
    a4 = *(_DWORD *)a1 & 0x400;
    if ( (v16 & 0x400) != 0 )
    {
      if ( (v16 & 0x800) != 0 )
      {
        a4 = 2;
      }
      else
      {
        if ( v17 <= v18 )
        {
          if ( *(_QWORD *)(a1 + 16) >= v17 )
            v17 = *(_QWORD *)(a1 + 16);
          LOBYTE(a4) = 1;
          v19 = *(_QWORD *)(a1 + 24);
          v20 = v17 - v19;
LABEL_8:
          if ( a3 )
          {
            v21 = v20;
            if ( a3 == 1 )
              v21 = *(_QWORD *)(a1 + 8) - v19;
            if ( -v21 > a2 || 0x7FFFFFFFFFFFFFFFLL - v21 < a2 )
              goto LABEL_50;
            v22 = a2 + v21;
          }
          else
          {
            if ( a2 < 0 )
              goto LABEL_50;
            v22 = a2;
          }
          if ( v22 > v20 )
          {
            if ( (unsigned int)sub_1C0B0(a1, v22, 1, a7, a8, a9, a10, a11, a12, a13, a14, v19, a5, a6) )
              return -1LL;
            v19 = *(_QWORD *)(a1 + 24);
            v17 = v19 + v20;
          }
          v19 += v22;
          *(_QWORD *)(a1 + 16) = v17;
          *(_QWORD *)(a1 + 8) = v19;
          goto LABEL_16;
        }
        a4 = 1;
      }
    }
    else if ( v17 <= v18 && (v16 & 0x800) == 0 )
    {
      v19 = *(_QWORD *)(a1 + 24);
      return *(_QWORD *)(a1 + 8) - v19;
    }
  }
  if ( (v16 & 0x100) != 0 )
    v19 = *(_QWORD *)(a1 + 80);
  else
    v19 = *(_QWORD *)(a1 + 56);
  BYTE1(v16) &= 0xF7u;
  *(_QWORD *)(a1 + 24) = v19;
  *(_QWORD *)(a1 + 16) = v17;
  *(_QWORD *)(a1 + 8) = v17;
  *(_DWORD *)a1 = v16;
  if ( !a4 )
    return *(_QWORD *)(a1 + 8) - v19;
LABEL_36:
  if ( *(_QWORD *)(a1 + 16) >= v17 )
    v17 = *(_QWORD *)(a1 + 16);
  v22 = -1LL;
  v20 = v17 - v19;
  if ( (a4 & 1) != 0 )
    goto LABEL_8;
LABEL_16:
  if ( (a4 & 2) == 0 )
    return v22;
  if ( a3 )
  {
    if ( a3 == 1 )
    {
      v23 = *(_QWORD *)(a1 + 32);
      v24 = *(_QWORD *)(a1 + 40) - v23;
      v25 = v23 - *(_QWORD *)(a1 + 40);
      v26 = a2 > 0x7FFFFFFFFFFFFFFFLL - v24;
    }
    else
    {
      v24 = v20;
      v25 = -v20;
      v26 = a2 > 0x7FFFFFFFFFFFFFFFLL - v20;
    }
  }
  else
  {
    v26 = 0;
    v25 = 0LL;
    v24 = 0LL;
  }
  if ( a2 < v25 || v26 )
  {
LABEL_50:
    v22 = -1LL;
    __writefsdword(0xFFFFFFC0, 0x16u);
    return v22;
  }
  v22 = a2 + v24;
  if ( v22 > v20 && (unsigned int)sub_1C0B0(a1, v22, 0, a7, a8, a9, a10, a11, a12, a13, a14, v19, a5, a6) )
    return -1LL;
  *(_QWORD *)(a1 + 40) = v22 + *(_QWORD *)(a1 + 32);
  return v22;
}
// 1C4CA: variable 'a11' is possibly undefined
// 1C4CA: variable 'a12' is possibly undefined
// 1C4CA: variable 'a5' is possibly undefined
// 1C4CA: variable 'a6' is possibly undefined

//----- (000000000001C520) ----------------------------------------------------
__int64 __fastcall sub_1C520(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 result; // rax

  if ( (*(_BYTE *)a1 & 8) != 0 && (_DWORD)a2 != -1 )
    result = 0xFFFFFFFFLL;
  else
    result = sub_1BBA0(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
  return result;
}

//----- (000000000001C540) ----------------------------------------------------
_QWORD *__fastcall sub_1C540(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v15; // rdi

  v15 = *(_QWORD *)(a1 + 56);
  if ( v15 && (*(_BYTE *)a1 & 1) == 0 )
    sub_21B70(v15, a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);
  *(_QWORD *)(a1 + 56) = 0LL;
  return sub_1AE70(a1, 0LL, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
}
// 1C565: variable 'a3' is possibly undefined
// 1C565: variable 'a4' is possibly undefined
// 1C565: variable 'a5' is possibly undefined
// 1C565: variable 'a6' is possibly undefined
// 1C565: variable 'a11' is possibly undefined
// 1C565: variable 'a12' is possibly undefined

//----- (000000000001C580) ----------------------------------------------------
__int64 __fastcall sub_1C580(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v5; // rbp
  __int64 result; // rax
  unsigned __int64 v7; // rdx

  if ( a3 )
  {
    v7 = a2 + a3;
    v5 = -1LL;
    if ( a2 < v7 )
      v5 = v7;
  }
  else
  {
    v5 = sub_9060(a2, 0LL);
  }
  result = sub_1A4A0((int *)a1, a2, v5, 0);
  *(_QWORD *)(a1 + 32) = a2;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 8) = a2;
  if ( a4 )
  {
    *(_QWORD *)(a1 + 40) = a4;
    *(_QWORD *)(a1 + 48) = v5;
    *(_QWORD *)(a1 + 16) = a4;
  }
  else
  {
    *(_QWORD *)(a1 + 40) = a2;
    *(_QWORD *)(a1 + 48) = a2;
    *(_QWORD *)(a1 + 16) = v5;
  }
  *(_QWORD *)(a1 + 224) = 0LL;
  return result;
}
// 9060: using guessed type __int64 __fastcall sub_9060(_QWORD, _QWORD);

//----- (000000000001C780) ----------------------------------------------------
_BOOL8 __fastcall sub_1C780(unsigned __int64 a1)
{
  char *v1; // rdx
  unsigned __int64 v2; // rax

  v1 = (_BYTE *)(&loc_FFFC + 4);
  if ( (__readfsqword(0x698u) >> 2) - 1 <= 0xFFFF )
  {
    v2 = __readfsqword(0x698u);
    v1 = (char *)(v2 >> 2);
    if ( v2 <= 3 )
      v1 = (char *)&loc_3FFFD + 3;
  }
  return (unsigned __int64)v1 >= a1;
}

//----- (000000000001C7D0) ----------------------------------------------------
__int64 __fastcall sub_1C7D0(volatile __int32 *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 result; // rax
  signed __int64 v7; // rax

  if ( *a1 == 2 )
    goto LABEL_3;
  while ( 1 )
  {
    result = (unsigned int)_InterlockedExchange(a1, 2);
    if ( !(_DWORD)result )
      break;
LABEL_3:
    v7 = sys_futex((u32 *)a1, 128, 2u, 0LL, a5, a6);
  }
  return result;
}
// 1C7F9: variable 'a5' is possibly undefined
// 1C7F9: variable 'a6' is possibly undefined

//----- (000000000001C810) ----------------------------------------------------
__int64 __fastcall sub_1C810(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  qword_BE660 = *a1;
  return result;
}
// BE660: using guessed type __int64 qword_BE660;

//----- (000000000001C820) ----------------------------------------------------
__int64 __fastcall sub_1C820(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  qword_BE658 = *a1;
  return result;
}
// BE658: using guessed type __int64 qword_BE658;

//----- (000000000001C830) ----------------------------------------------------
unsigned __int64 __fastcall sub_1C830(unsigned __int64 *a1)
{
  unsigned __int64 result; // rax
  int *v2; // rdx

  result = *a1;
  if ( *a1 <= 0x408 )
  {
    qword_BE698 = *a1;
    result += 23LL;
    v2 = (_DWORD *)(&dword_0 + 1);
    if ( result > 0x1F )
    {
      result = ((result & 0xFFFFFFFFFFFFFFF0LL) - 17) >> 4;
      v2 = (int *)(result + 1);
    }
    off_BE690 = v2;
  }
  return result;
}
// 0: using guessed type __int64 (*dword_0)(void);
// BE690: using guessed type int *off_BE690;
// BE698: using guessed type __int64 qword_BE698;

//----- (000000000001C870) ----------------------------------------------------
__int64 __fastcall sub_1C870(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  if ( (unsigned __int64)*a1 <= 0xFFFF )
    qword_BE6A0 = *a1;
  return result;
}
// BE6A0: using guessed type __int64 qword_BE6A0;

//----- (000000000001C890) ----------------------------------------------------
__int64 __fastcall sub_1C890(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  qword_BE6A8 = *a1;
  return result;
}
// BE6A8: using guessed type __int64 qword_BE6A8;

//----- (000000000001C8A0) ----------------------------------------------------
__int64 __fastcall sub_1C8A0(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // rcx
  unsigned __int8 v3; // r10
  unsigned __int64 v4; // rdx
  unsigned __int64 i; // rdx
  __int64 v6; // rax

  if ( a1 )
  {
    v2 = *(_QWORD *)(a1 - 8);
    v3 = ((unsigned __int64)(a1 - 16) >> 11) ^ ((unsigned __int64)(a1 - 16) >> 3);
    if ( v3 == 1 )
      v3 = 2;
    v4 = (v2 & 0xFFFFFFFFFFFFFFF8LL) - 8;
    if ( (v2 & 2) != 0 )
      v4 = (v2 & 0xFFFFFFFFFFFFFFF8LL) - 16;
    for ( i = v4 - 1; a2 < i; i -= v6 )
    {
      v6 = i - a2;
      if ( i - a2 > 0xFF )
        v6 = 255LL;
      if ( v6 == v3 )
        v6 = v3 - 1LL;
      *(_BYTE *)(a1 + i) = v6;
    }
    *(_BYTE *)(a1 + a2) = v3;
  }
  return a1;
}

//----- (000000000001C930) ----------------------------------------------------
unsigned __int64 __fastcall sub_1C930(__int64 a1, _QWORD *a2)
{
  unsigned __int64 v3; // r8
  __int64 v4; // rcx
  char v5; // si
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r10
  unsigned __int64 v8; // rax
  _BYTE *v9; // rcx
  __int64 v10; // rdx
  __int64 v12; // rcx
  unsigned __int64 v13; // rdi
  unsigned __int64 v14; // rdx
  __int64 v15; // rax

  if ( (a1 & 0xF) != 0 )
    return 0LL;
  v3 = a1 - 16;
  v4 = *(_QWORD *)(a1 - 8);
  v5 = ((unsigned __int64)(a1 - 16) >> 11) ^ ((unsigned __int64)(a1 - 16) >> 3);
  v6 = v4 & 0xFFFFFFFFFFFFFFF8LL;
  if ( v5 == 1 )
    v5 = 2;
  if ( (v4 & 2) != 0 )
  {
    v7 = ((unsigned __int64)&off_BF078[-1].r_addend + 7) & a1;
    if ( (((v7 - 16) & 0xFFFFFFFFFFFFFFEFLL) == 0
       || v7 - 1 > 0x1FFE
       || ((v7 - 64) & 0xFFFFFFFFFFFFFFBFLL) == 0
       || ((v7 - 256) & 0xFFFFFFFFFFFFFEFFLL) == 0
       || ((v7 - 1024) & 0xFFFFFFFFFFFFFBFFLL) == 0
       || v7 == 4096)
      && (v4 & 3) == 2
      && (((unsigned __int64)&off_BF078[-1].r_addend + 7) & ((v3 - *(_QWORD *)(a1 - 16)) | (v6 + *(_QWORD *)(a1 - 16)))) == 0 )
    {
      v8 = v6 - 1;
      v9 = (_BYTE *)(v3 + v6 - 1);
      v10 = (unsigned __int8)*v9;
      if ( v5 == (_BYTE)v10 )
        goto LABEL_35;
      while ( v10 && v10 + 16 <= v8 )
      {
        v8 -= v10;
        v9 = (_BYTE *)(v3 + v8);
        v10 = *(unsigned __int8 *)(v3 + v8);
        if ( (_BYTE)v10 == v5 )
          goto LABEL_35;
      }
    }
    return 0LL;
  }
  if ( (dword_BE6E4 & 2) == 0 && (qword_BE688 > v3 || v3 + v6 >= qword_BEF68 + qword_BE688) )
    return 0LL;
  if ( v6 <= 0x1F || (v4 & 8) != 0 || (*(_BYTE *)(v3 + v6 + 8) & 1) == 0 )
    return 0LL;
  if ( (v4 & 1) == 0 )
  {
    v12 = *(_QWORD *)(a1 - 16);
    if ( (v12 & 0xF) != 0 )
      return 0LL;
    v13 = v3 - v12;
    if ( (dword_BE6E4 & 2) == 0 && qword_BE688 > v13 )
      return 0LL;
    if ( v12 != (*(_QWORD *)(v13 + 8) & 0xFFFFFFFFFFFFFFF8LL) )
      return 0LL;
  }
  v14 = v6 + 7;
  v9 = (_BYTE *)(v3 + v14);
  v15 = *(unsigned __int8 *)(v3 + v14);
  if ( v5 != (_BYTE)v15 )
  {
    while ( v15 && v15 + 16 <= v14 )
    {
      v14 -= v15;
      v9 = (_BYTE *)(v3 + v14);
      v15 = *(unsigned __int8 *)(v3 + v14);
      if ( (_BYTE)v15 == v5 )
        goto LABEL_35;
    }
    return 0LL;
  }
LABEL_35:
  *v9 = ~v5;
  if ( a2 )
    *a2 = v9;
  return v3;
}
// BE688: using guessed type __int64 qword_BE688;
// BE6E4: using guessed type int dword_BE6E4;
// BEF68: using guessed type __int64 qword_BEF68;
// BF078: using guessed type Elf64_Rela *off_BF078;

//----- (000000000001CB30) ----------------------------------------------------
void *__fastcall sub_1CB30(void **a1)
{
  void *result; // rax

  result = *a1;
  dword_BE674 = 1;
  off_BE640 = result;
  return result;
}
// BE640: using guessed type void *off_BE640;
// BE674: using guessed type int dword_BE674;

//----- (000000000001CB50) ----------------------------------------------------
void *__fastcall sub_1CB50(void **a1)
{
  void *result; // rax

  result = *a1;
  dword_BE674 = 1;
  off_BE648 = result;
  return result;
}
// BE648: using guessed type void *off_BE648;
// BE674: using guessed type int dword_BE674;

//----- (000000000001CB70) ----------------------------------------------------
void *__fastcall sub_1CB70(void **a1)
{
  void *result; // rax

  result = *a1;
  if ( (unsigned __int64)*a1 <= 0x2000000 )
  {
    dword_BE674 = 1;
    off_BE650 = result;
  }
  return result;
}
// BE650: using guessed type void *off_BE650;
// BE674: using guessed type int dword_BE674;

//----- (000000000001CBA0) ----------------------------------------------------
__int64 __fastcall sub_1CBA0(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  dword_BE674 = 1;
  dword_BE66C = result;
  return result;
}
// BE66C: using guessed type int dword_BE66C;
// BE674: using guessed type int dword_BE674;

//----- (000000000001CBC0) ----------------------------------------------------
__int64 __fastcall sub_1CBC0(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  dword_C1254 = *a1;
  return result;
}
// C1254: using guessed type int dword_C1254;

//----- (000000000001CBD0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1CBD0(unsigned __int64 *a1)
{
  unsigned __int64 result; // rax
  unsigned __int64 v2; // rdx
  bool v3; // cc

  result = *a1;
  if ( *a1 <= 0xA0 )
  {
    v2 = (result + 8) & 0xFFFFFFFFFFFFFFF0LL;
    v3 = result <= 7;
    result = 16LL;
    if ( !v3 )
      result = v2;
    qword_C1258 = result;
  }
  return result;
}
// C1258: using guessed type __int64 qword_C1258;

//----- (000000000001CC00) ----------------------------------------------------
__int64 __fastcall sub_1CC00(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  double v9; // xmm4_8
  double v10; // xmm5_8

  sub_16EA0(1, &off_A6B5F, a2, a3, a4, a5, a6, a7, a8, a9, a1);
  return sub_1CC20(a2, a3, a4, a5, v9, v10, a8, a9);
}
// 1CC1B: variable 'v9' is possibly undefined
// 1CC1B: variable 'v10' is possibly undefined
// A6B5F: using guessed type void *__ptr32 off_A6B5F;

//----- (000000000001CC20) ----------------------------------------------------
unsigned __int64 __fastcall sub_1CC20(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  unsigned __int64 result; // rax
  __int64 v9; // rdx
  unsigned __int64 v10; // rcx

  result = qword_BE740;
  if ( (__int64 *)qword_BE740 != &qword_BE740 )
  {
    v9 = *(_QWORD *)(qword_BE740 + 8);
    if ( (v9 & 2) != 0
      || (v10 = v9 & 0xFFFFFFFFFFFFFFF8LL, (v9 & 0xFFFFFFFFFFFFFFF8LL) <= 0x1F)
      || (v9 & 1) == 0
      || (dword_BE6E4 & 2) == 0 && (result = v10 + qword_BE740, v10 + qword_BE740 != qword_BE688 + qword_BEF68) )
    {
      sub_1CC00((__int64)"malloc: top chunk is corrupt", a1, a2, a3, a4, a5, a6, a7, a8);
      result = sub_1CC80();
    }
  }
  return result;
}
// 1CC80: using guessed type __int64 sub_1CC80(void);
// BE688: using guessed type __int64 qword_BE688;
// BE6E4: using guessed type int dword_BE6E4;
// BE740: using guessed type __int64 qword_BE740;
// BEF68: using guessed type __int64 qword_BEF68;

//----- (000000000001CC80) ----------------------------------------------------
u32 *__fastcall sub_1CC80(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  int v12; // er9
  const char *v13; // rsi
  __int64 v14; // r8
  const char *v15; // rdi
  unsigned __int64 v16; // rax
  __int64 v17; // rcx
  unsigned __int64 v18; // rdx
  int v19; // esi
  __int64 v20; // rbp
  int v21; // ecx
  __int64 i; // rax
  __int64 v23; // rdx
  __int64 v24; // rdx
  int v25; // eax
  u32 *result; // rax

  v12 = 0;
  v13 = (const char *)(a1 + 16);
  v14 = 0LL;
  v15 = (const char *)(a1 + 96);
  do
  {
    v16 = *(_QWORD *)v13;
    if ( *(_QWORD *)v13 )
    {
      while ( (v16 & 0xF) == 0 )
      {
        v17 = *(_QWORD *)(v16 + 16);
        ++v12;
        v14 += *(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8LL;
        v18 = (v16 + 16) >> 12;
        v16 = v17 ^ v18;
        if ( v18 == v17 )
          goto LABEL_7;
      }
      v15 = "int_mallinfo(): unaligned fastbin chunk detected";
      sub_1CC00((__int64)"int_mallinfo(): unaligned fastbin chunk detected", a3, a4, a5, a6, a7, a8, a9, a10);
    }
LABEL_7:
    v13 += 8;
  }
  while ( v15 != v13 );
  v19 = 1;
  v20 = *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8LL);
  v21 = v14 + (v20 & 0xFFFFFFF8);
  do
  {
    for ( i = *((_QWORD *)v15 + 3); (const char *)i != v15; v21 += v23 & 0xFFFFFFF8 )
    {
      v23 = *(_QWORD *)(i + 8);
      i = *(_QWORD *)(i + 24);
      ++v19;
    }
    v15 += 16;
  }
  while ( (const char *)(a1 + 2128) != v15 );
  v24 = *(_QWORD *)(a1 + 2184);
  v25 = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a2 + 8) += v12;
  *(_DWORD *)(a2 + 4) += v19;
  *(_DWORD *)(a2 + 32) += v21;
  *(_DWORD *)(a2 + 28) = v24 + v25 - v21;
  result = &dword_BE6E0;
  *(_DWORD *)a2 += v24;
  *(_DWORD *)(a2 + 24) += v14;
  if ( (u32 *)a1 == &dword_BE6E0 )
  {
    *(_DWORD *)(a2 + 12) = dword_BE668;
    result = (u32 *)qword_BE678;
    *(_QWORD *)(a2 + 16) = (unsigned int)qword_BE678;
    *(_DWORD *)(a2 + 36) = v20 & 0xFFFFFFF8;
  }
  return result;
}
// 1CCB0: variable 'v12' is possibly undefined
// 1CCB8: variable 'v14' is possibly undefined
// 1CCD9: variable 'a7' is possibly undefined
// 1CCD9: variable 'a8' is possibly undefined
// 1CCE7: variable 'a1' is possibly undefined
// 1CD3F: variable 'a2' is possibly undefined
// BE668: using guessed type int dword_BE668;
// BE678: using guessed type __int64 qword_BE678;

//----- (000000000001CDA0) ----------------------------------------------------
void __fastcall __noreturn sub_1CDA0(const char *a1, __int64 a2, unsigned int a3, __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  const char *v13; // rcx
  __int64 v14; // rdx
  __int64 v15; // rcx
  u32 *v16; // r8
  u32 v17; // er9
  double v18; // xmm4_8
  double v19; // xmm5_8

  v13 = (const char *)&unk_A6E65;
  if ( *(_BYTE *)off_BEFD8 )
    v13 = ": ";
  sub_13580(0LL, (__int64)"%s%s%s:%u: %s%sAssertion `%s' failed.\n", off_BEFD8, v13, a2, a3, a4, ": ");
  sub_13CE0(
    (__int64)stderr,
    (__int64)"%s%s%s:%u: %s%sAssertion `%s' failed.\n",
    v14,
    v15,
    v16,
    v17,
    a5,
    a6,
    a7,
    a8,
    v18,
    v19,
    a11,
    a12);
  exit();
}
// 1CDE8: variable 'v14' is possibly undefined
// 1CDE8: variable 'v15' is possibly undefined
// 1CDE8: variable 'v16' is possibly undefined
// 1CDE8: variable 'v17' is possibly undefined
// 1CDE8: variable 'v18' is possibly undefined
// 1CDE8: variable 'v19' is possibly undefined
// BEFD8: using guessed type void *off_BEFD8;

//----- (000000000001CE00) ----------------------------------------------------
char *__fastcall sub_1CE00(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rsi
  unsigned __int64 v3; // rbx
  char *v4; // rax
  char *v5; // r12
  _BYTE *v6; // rax
  signed __int64 v7; // r13
  char *v9; // rax

  v2 = a1 + a2;
  if ( v2 <= 0x7FFF )
  {
    v2 = 0x8000LL;
  }
  else if ( v2 > 0x4000000 )
  {
    v2 = 0x4000000LL;
    if ( a1 > 0x4000000 )
      return 0LL;
  }
  v3 = ((unsigned __int64)off_BF078 + v2 - 1) & -(__int64)off_BF078;
  if ( addr )
  {
    v4 = (char *)mmap(addr, 0x4000000uLL, 0LL, 0x4022u, 0xFFFFFFFFuLL, 0LL);
    addr = 0LL;
    v5 = v4;
    if ( v4 != (char *)-1LL )
    {
      if ( ((unsigned int)v4 & 0x3FFFFFF) == 0 )
        goto LABEL_11;
      munmap(v4, 0x4000000uLL);
    }
  }
  v6 = mmap(0LL, 0x8000000uLL, 0LL, 0x4022u, 0xFFFFFFFFuLL, 0LL);
  if ( v6 != (_BYTE *)-1LL )
  {
    v5 = (char *)((unsigned __int64)(v6 + 0x3FFFFFF) & 0xFFFFFFFFFC000000LL);
    v7 = v5 - v6;
    if ( v5 == v6 )
      addr = v5 + 0x4000000;
    else
      munmap(v6, v5 - v6);
    munmap(v5 + 0x4000000, 0x4000000 - v7);
    goto LABEL_11;
  }
  v9 = (char *)mmap(0LL, 0x4000000uLL, 0LL, 0x4022u, 0xFFFFFFFFuLL, 0LL);
  v5 = v9;
  if ( v9 != (char *)-1LL )
  {
    if ( ((unsigned int)v9 & 0x3FFFFFF) != 0 )
    {
LABEL_18:
      munmap(v5, 0x4000000uLL);
      return 0LL;
    }
LABEL_11:
    if ( !(unsigned int)sub_4BD40((unsigned __int64)v5, v3, 3uLL) )
    {
      *((_QWORD *)v5 + 2) = v3;
      *((_QWORD *)v5 + 3) = v3;
      return v5;
    }
    goto LABEL_18;
  }
  return 0LL;
}
// BF078: using guessed type Elf64_Rela *off_BF078;

//----- (000000000001CFB0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1CFB0(_QWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  unsigned __int64 v9; // r8
  size_t v10; // rsi

  if ( (a1[1] & 2) == 0 )
LABEL_5:
    sub_1CDA0(
      "chunk_is_mmapped (p)",
      (__int64)"malloc.c",
      0xB0Cu,
      (__int64)"munmap_chunk",
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      a9);
  v9 = (unsigned __int64)a1 - *a1;
  v10 = *a1 + (a1[1] & 0xFFFFFFFFFFFFFFF8LL);
  if ( ((((unsigned __int64)&off_BF078[-1].r_addend + 7) & (unsigned __int64)(a1 + 2)) - 1) & ((unsigned __int64)&off_BF078[-1].r_addend
                                                                                             + 7) & (unsigned __int64)(a1 + 2) | (v10 | v9) & ((unsigned __int64)&off_BF078[-1].r_addend + 7) )
  {
    sub_1CC00((__int64)"munmap_chunk(): invalid pointer", a2, a3, a4, a5, a6, a7, a8, a9);
    goto LABEL_5;
  }
  _InterlockedDecrement(&dword_BE668);
  _InterlockedAdd64(&qword_BE678, -(__int64)v10);
  return munmap((void *)v9, v10);
}
// 1D03E: variable 'a6' is possibly undefined
// 1D03E: variable 'a7' is possibly undefined
// BE668: using guessed type int dword_BE668;
// BE678: using guessed type __int64 qword_BE678;
// BF078: using guessed type Elf64_Rela *off_BF078;

//----- (000000000001D050) ----------------------------------------------------
__int64 __fastcall sub_1D050(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  result = (unsigned int)dword_C1254;
  if ( dword_C1254 )
  {
    LOBYTE(result) = ~(_BYTE)dword_C1254;
    result = sub_9190(a1, (unsigned int)result, a2);
  }
  return result;
}
// C1254: using guessed type int dword_C1254;

//----- (000000000001D070) ----------------------------------------------------
__int64 *__fastcall sub_1D070(__int64 *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  __int64 v10; // r12
  unsigned __int64 v11; // rbp
  unsigned __int64 v12; // rbx
  unsigned __int64 v13; // rax
  double v14; // xmm4_8
  double v15; // xmm5_8
  _QWORD *v16; // r8
  unsigned __int64 v17; // rbx
  __int64 v18; // rtt

  v10 = *a1;
  if ( (a1[1] & 2) == 0 )
    sub_1CDA0("chunk_is_mmapped (p)", "malloc.c", 2866LL, "mremap_chunk", a3, a4, a5, a6, a7, a8, a9, a10);
  v11 = v10 + (a1[1] & 0xFFFFFFFFFFFFFFF8LL);
  if ( ((((unsigned __int64)&off_BF078[-1].r_addend + 7) & (unsigned __int64)(a1 + 2)) - 1) & ((unsigned __int64)&off_BF078[-1].r_addend
                                                                                             + 7) & (unsigned __int64)(a1 + 2) | ((unsigned __int64)&off_BF078[-1].r_addend + 7) & (v11 | ((unsigned __int64)a1 - v10)) )
  {
    sub_1CC00((__int64)"mremap_chunk(): invalid pointer", a3, a4, a5, a6, a7, a8, a9, a10);
    return 0LL;
  }
  v12 = -(__int64)off_BF078 & ((unsigned __int64)&off_BF078->r_offset + a2 + v10 + 7);
  if ( v11 != v12 )
  {
    v13 = sub_4D040((unsigned __int64)a1 - v10, v11, v12, 1uLL, (unsigned __int64)a1 - v10);
    if ( v13 != -1LL )
    {
      v16 = (_QWORD *)(v13 + v10);
      if ( (((_BYTE)v13 + (_BYTE)v10) & 0xF) != 0 )
        sub_1CDA0("aligned_OK (chunk2mem (p))", "malloc.c", 2890LL, "mremap_chunk", a3, a4, a5, a6, v14, v15, a9, a10);
      if ( *v16 != v10 )
        sub_1CDA0("prev_size (p) == offset", "malloc.c", 2892LL, "mremap_chunk", a3, a4, a5, a6, v14, v15, a9, a10);
      v16[1] = (v12 - v10) | 2;
      v17 = _InterlockedExchangeAdd64(&qword_BE678, v12 - v11) + v12 - v11;
      do
      {
        if ( v17 <= qword_BE680 )
          break;
        v18 = qword_BE680;
      }
      while ( v18 != _InterlockedCompareExchange64(&qword_BE680, v17, qword_BE680) );
      return v16;
    }
    return 0LL;
  }
  return a1;
}
// 1D1AE: variable 'v14' is possibly undefined
// 1D1AE: variable 'v15' is possibly undefined
// 1CDA0: using guessed type double sub_1CDA0(const char *, ...);
// BE678: using guessed type __int64 qword_BE678;
// BE680: using guessed type __int64 qword_BE680;
// BF078: using guessed type Elf64_Rela *off_BF078;

//----- (000000000001D1E0) ----------------------------------------------------
void __noreturn sub_1D1E0()
{
  sub_1CDA0("replaced_arena->attached_threads > 0", "arena.c", 676LL, "detach_arena");
}
// 1CDA0: using guessed type __int64 sub_1CDA0(const char *, ...);

//----- (000000000001D210) ----------------------------------------------------
unsigned __int64 __fastcall sub_1D210(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  unsigned __int64 v6; // rbp
  bool v9; // zf
  __int64 v10; // rax
  signed __int64 v13; // rax

  if ( !qword_C1248 )
    return 0LL;
  v6 = __readfsqword(0xFFFFFFD8);
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C1250, 1, 0) )
      sub_1C7D0((volatile __int32 *)&dword_C1250, a2, 1LL, a4, a5, a6);
  }
  else
  {
    _EDX = 1;
    __asm { cmpxchg cs:dword_C1250, edx }
  }
  _R12 = qword_C1248;
  if ( qword_C1248 )
  {
    v9 = *(_QWORD *)(qword_C1248 + 2176) == 0LL;
    qword_C1248 = *(_QWORD *)(qword_C1248 + 2168);
    if ( !v9 )
      sub_1CDA0("result->attached_threads == 0", "arena.c", 770LL, "get_free_list", a5, a6);
    *(_QWORD *)(_R12 + 2176) = 1LL;
    if ( v6 )
    {
      v10 = *(_QWORD *)(v6 + 2176);
      if ( !v10 )
        sub_1D1E0();
      *(_QWORD *)(v6 + 2176) = v10 - 1;
    }
  }
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedExchange((volatile __int32 *)&dword_C1250, 0) > 1 )
    {
      a2 = 129LL;
      v13 = sys_futex(&dword_C1250, 129, 1u, 0LL, a5, a6);
    }
  }
  else
  {
    --dword_C1250;
  }
  if ( !_R12 )
    return 0LL;
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedCompareExchange((volatile signed __int32 *)_R12, 1, 0) )
      sub_1C7D0((volatile __int32 *)_R12, a2, 1LL, a4, a5, a6);
  }
  else
  {
    _EDX = 1;
    __asm { cmpxchg [r12], edx }
  }
  __writefsqword(0xFFFFFFD8, _R12);
  return _R12;
}
// 1D346: variable 'a5' is possibly undefined
// 1D346: variable 'a6' is possibly undefined
// 1D366: variable 'a4' is possibly undefined
// 1CDA0: using guessed type __int64 sub_1CDA0(const char *, ...);
// C1248: using guessed type __int64 qword_C1248;

//----- (000000000001D3A0) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_1D3A0(unsigned int *a1))(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 (__fastcall *result)(unsigned __int64, unsigned __int64, __int64, __int64, u32 *, u32, double, double, double, double, double, double, double, double); // rax

  result = (__int64 (__fastcall *)(unsigned __int64, unsigned __int64, __int64, __int64, u32 *, u32, double, double, double, double, double, double, double, double))*a1;
  if ( (_DWORD)result )
  {
    dword_C1230 = 1;
    off_BE6D0 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_20790;
    qword_C1218 = (__int64)sub_1EF20;
    off_BE6C8 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_20E50;
    result = sub_20A40;
    off_BE6C0 = (__int64 (__fastcall *)())sub_20A40;
  }
  return result;
}
// BE6C0: using guessed type __int64 (__fastcall *off_BE6C0)();
// BE6C8: using guessed type __int64 (__fastcall *off_BE6C8)(_QWORD, _QWORD, _QWORD);
// BE6D0: using guessed type __int64 (__fastcall *off_BE6D0)(_QWORD, _QWORD, _QWORD);
// C1218: using guessed type __int64 qword_C1218;
// C1230: using guessed type int dword_C1230;

//----- (000000000001D960) ----------------------------------------------------
__int64 __fastcall sub_1D960(unsigned __int64 a1)
{
  unsigned __int64 v1; // rbx
  unsigned __int64 v2; // r12
  __int64 v3; // rbp
  __int64 v5; // rax
  __int64 v6; // rbp

  v1 = *(_QWORD *)(qword_BE740 + 8) & 0xFFFFFFFFFFFFFFF8LL;
  if ( v1 - 33 <= a1 )
    return 0LL;
  v2 = (v1 - 33 - a1) & -(__int64)off_BF078;
  if ( !v2 )
    return 0LL;
  v3 = off_BEF78(0LL);
  if ( v3 != v1 + qword_BE740 )
    return 0LL;
  off_BEF78(-(__int64)v2);
  if ( qword_C1210 )
    qword_C1210();
  v5 = off_BEF78(0LL);
  if ( !v5 )
    return 0LL;
  v6 = v3 - v5;
  if ( !v6 )
    return 0LL;
  qword_BEF68 -= v6;
  *(_QWORD *)(qword_BE740 + 8) = (v1 - v6) | 1;
  return 1LL;
}
// BE740: using guessed type __int64 qword_BE740;
// BEF68: using guessed type __int64 qword_BEF68;
// BEF78: using guessed type __int64 (__fastcall *off_BEF78)(_QWORD);
// BF078: using guessed type Elf64_Rela *off_BF078;
// C1210: using guessed type __int64 (*qword_C1210)(void);

//----- (000000000001DA10) ----------------------------------------------------
_QWORD *__fastcall sub_1DA10(_QWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  unsigned __int64 v9; // rcx
  _QWORD *result; // rax
  __int64 v11; // rdx
  _QWORD *v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // rdx
  double v15; // xmm4_8
  double v16; // xmm5_8

  v9 = a1[1];
  if ( (v9 & 0xFFFFFFFFFFFFFFF8LL) != *(_QWORD *)((char *)a1 + (v9 & 0xFFFFFFFFFFFFFFF8LL)) )
  {
    sub_1CC00((__int64)"corrupted size vs. prev_size", a2, a3, a4, a5, a6, a7, a8, a9);
    goto LABEL_16;
  }
  result = (_QWORD *)a1[2];
  v11 = a1[3];
  if ( a1 != (_QWORD *)result[3] || a1 != *(_QWORD **)(v11 + 16) )
  {
    result = (_QWORD *)sub_1CC00((__int64)"corrupted double-linked list", a2, a3, a4, a5, a6, a7, a8, a9);
    goto LABEL_14;
  }
  result[3] = v11;
  *(_QWORD *)(v11 + 16) = result;
  if ( v9 > 0x3FF )
  {
    v12 = (_QWORD *)a1[4];
    if ( v12 )
    {
      if ( a1 == (_QWORD *)v12[5] )
      {
        v13 = a1[5];
        if ( a1 == *(_QWORD **)(v13 + 32) )
        {
          if ( result[4] )
          {
            v12[5] = v13;
            result = (_QWORD *)a1[5];
            result[4] = v12;
            return result;
          }
          if ( a1 != v12 )
          {
            result[4] = v12;
            v14 = a1[4];
            result[5] = v13;
            *(_QWORD *)(v14 + 40) = result;
            *(_QWORD *)(a1[5] + 32LL) = result;
            return result;
          }
LABEL_14:
          result[5] = result;
          result[4] = result;
          return result;
        }
      }
LABEL_16:
      sub_1CC00((__int64)"corrupted double-linked list (not small)", a2, a3, a4, a5, a6, a7, a8, a9);
      return (_QWORD *)sub_1DAE0((__int64)"corrupted double-linked list (not small)", a2, a3, a4, a5, v15, v16, a8, a9);
    }
  }
  return result;
}
// 1DACD: variable 'a6' is possibly undefined
// 1DACD: variable 'a7' is possibly undefined
// 1DADE: variable 'v15' is possibly undefined
// 1DADE: variable 'v16' is possibly undefined

//----- (000000000001DAE0) ----------------------------------------------------
__int64 __fastcall sub_1DAE0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, unsigned __int64 a10)
{
  __int64 result; // rax
  volatile __int64 *v11; // r13
  __int64 v13; // rbx
  __int64 v14; // rdi
  __int64 v15; // rdx
  unsigned __int64 v16; // rbp
  unsigned __int64 v17; // r14
  _QWORD *v18; // r15
  __int64 v19; // r8
  __int64 v20; // rdi
  unsigned int v21; // edx
  unsigned __int64 v22; // rcx
  u32 *v23; // r8
  u32 v24; // er9
  double v25; // xmm4_8
  double v26; // xmm5_8
  __int64 v27; // [rsp+0h] [rbp-58h]
  __int64 v28; // [rsp+8h] [rbp-50h]
  __int64 v29; // [rsp+8h] [rbp-50h]
  unsigned __int64 v30; // [rsp+10h] [rbp-48h]
  __int64 v31; // [rsp+10h] [rbp-48h]
  unsigned __int64 v32; // [rsp+18h] [rbp-40h]

  result = a1 + 96;
  v11 = (volatile __int64 *)(a1 + 16);
  *(_DWORD *)(a1 + 8) = 0;
  v27 = a1 + 96;
  while ( 1 )
  {
    v13 = _InterlockedExchange64(v11, 0LL);
    if ( v13 )
      break;
LABEL_3:
    if ( (volatile __int64 *)v27 == ++v11 )
      return result;
  }
  while ( (v13 & 0xF) == 0 )
  {
    v14 = *(_QWORD *)(v13 + 8);
    if ( v11 != (volatile __int64 *)(a1 + 8LL * (((unsigned int)v14 >> 4) - 2) + 16) )
      goto LABEL_22;
    v15 = *(_QWORD *)(v13 + 16);
    v16 = v14 & 0xFFFFFFFFFFFFFFF8LL;
    v17 = (unsigned __int64)(v13 + 16) >> 12;
    v18 = (_QWORD *)(v13 + (v14 & 0xFFFFFFFFFFFFFFF8LL));
    v19 = v15 ^ v17;
    result = v18[1] & 0xFFFFFFFFFFFFFFF8LL;
    if ( (v14 & 1) == 0 )
    {
      v20 = *(_QWORD *)v13;
      v13 -= *(_QWORD *)v13;
      v16 += v20;
      if ( (*(_QWORD *)(v13 + 8) & 0xFFFFFFFFFFFFFFF8LL) != v20 )
        goto LABEL_21;
      v32 = v18[1] & 0xFFFFFFFFFFFFFFF8LL;
      v30 = v15 ^ v17;
      v28 = v15;
      sub_1DA10((_QWORD *)v13, a2, a3, a4, a5, a6, a7, a8, a9);
      result = v32;
      v19 = v30;
      v15 = v28;
    }
    if ( *(_QWORD **)(a1 + 96) == v18 )
    {
      *(_QWORD *)(v13 + 8) = (result + v16) | 1;
      *(_QWORD *)(a1 + 96) = v13;
    }
    else
    {
      if ( (*((_BYTE *)v18 + result + 8) & 1) != 0 )
      {
        v18[1] &= 0xFFFFFFFFFFFFFFFELL;
      }
      else
      {
        v31 = v19;
        v16 += result;
        v29 = v15;
        sub_1DA10(v18, a2, a3, a4, a5, a6, a7, a8, a9);
        v15 = v29;
        v19 = v31;
      }
      result = *(_QWORD *)(a1 + 112);
      *(_QWORD *)(a1 + 112) = v13;
      *(_QWORD *)(result + 24) = v13;
      if ( v16 > 0x3FF )
      {
        *(_QWORD *)(v13 + 32) = 0LL;
        *(_QWORD *)(v13 + 40) = 0LL;
      }
      *(_QWORD *)(v13 + 16) = result;
      *(_QWORD *)(v13 + 8) = v16 | 1;
      *(_QWORD *)(v13 + 24) = v27;
      *(_QWORD *)(v13 + v16) = v16;
    }
    if ( v17 == v15 )
      goto LABEL_3;
    v13 = v19;
  }
  sub_1CC00((__int64)"malloc_consolidate(): unaligned fastbin chunk detected", a2, a3, a4, a5, a6, a7, a8, a9);
LABEL_21:
  sub_1CC00((__int64)"corrupted size vs. prev_size in fastbins", a2, a3, a4, a5, a6, a7, a8, a9);
LABEL_22:
  sub_1CC00((__int64)"malloc_consolidate(): invalid chunk size", a2, a3, a4, a5, a6, a7, a8, a9);
  return sub_1DC90(
           (u32 *)"malloc_consolidate(): invalid chunk size",
           a10,
           v21,
           v22,
           v23,
           v24,
           a2,
           a3,
           a4,
           a5,
           v25,
           v26,
           a8,
           a9);
}
// 1DC04: variable 'a6' is possibly undefined
// 1DC04: variable 'a7' is possibly undefined
// 1DC8C: variable 'v21' is possibly undefined
// 1DC8C: variable 'v22' is possibly undefined
// 1DC8C: variable 'v23' is possibly undefined
// 1DC8C: variable 'v24' is possibly undefined
// 1DC8C: variable 'v25' is possibly undefined
// 1DC8C: variable 'v26' is possibly undefined

//----- (000000000001DC90) ----------------------------------------------------
__int64 __fastcall sub_1DC90(u32 *uaddr, unsigned __int64 a2, unsigned int a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  unsigned __int64 v16; // r14
  _QWORD *v17; // r13
  __int64 v18; // rax
  unsigned __int64 v19; // rbx
  unsigned __int64 v20; // rdx
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // rax
  unsigned __int8 v23; // al
  unsigned int v24; // ebx
  __int64 v25; // rcx
  unsigned __int64 v26; // rdx
  unsigned int v28; // eax
  __int64 v29; // rax
  unsigned __int64 v30; // rax
  __int64 v31; // rax
  __int64 v32; // rax
  unsigned __int64 v34; // rax
  _BOOL8 v35; // r8
  signed __int64 v36; // rax
  unsigned __int64 v38; // r15
  _QWORD *v39; // r14
  __int64 v40; // r12
  __int64 v41; // rbx
  __int64 v42; // rbx
  _QWORD *v43; // rdi
  __int64 v44; // rax
  __int64 v45; // rsi
  _QWORD *v46; // rdx
  _QWORD *v47; // rdx
  __int64 v48; // r8
  _QWORD *v49; // r13
  __int64 v50; // rsi
  unsigned __int64 v51; // rax
  unsigned __int64 v52; // rbx
  unsigned __int64 v53; // rax
  size_t v54; // r12
  __int64 v55; // r13
  unsigned __int64 v56; // rcx
  u32 *v57; // rdi
  signed __int64 v59; // rax
  char *v60; // [rsp+8h] [rbp-70h]
  unsigned __int64 v61; // [rsp+10h] [rbp-68h]
  __int32 v62; // [rsp+1Ch] [rbp-5Ch]
  void *v63; // [rsp+20h] [rbp-58h]
  __int64 v64; // [rsp+28h] [rbp-50h]
  unsigned __int64 v65; // [rsp+38h] [rbp-40h]

  v17 = (_QWORD *)a3;
  v65 = __readfsqword(0x28u);
  v18 = *(_QWORD *)(a2 + 8);
  v19 = v18 & 0xFFFFFFFFFFFFFFF8LL;
  if ( a2 > -(__int64)(v18 & 0xFFFFFFFFFFFFFFF8LL) || (_R12 = (__int64 *)a2, (a2 & 0xF) != 0) )
  {
    sub_1CC00((__int64)"free(): invalid pointer", a7, a8, a9, a10, a11, a12, a13, a14);
LABEL_46:
    sub_1CC00((__int64)"free(): invalid size", a7, a8, a9, a10, a11, a12, a13, a14);
    goto LABEL_47;
  }
  if ( v19 <= 0x1F || (v18 & 8) != 0 )
    goto LABEL_46;
  v20 = __readfsqword(0xFFFFFFC8);
  _RBP = uaddr;
  if ( v20 )
  {
    v21 = (v19 - 17) >> 4;
    if ( (unsigned __int64)off_BE690 > v21 )
    {
      a2 += 16LL;
      if ( v20 == _R12[3] )
      {
        v20 = __readfsqword(0xFFFFFFC8);
        v56 = *(_QWORD *)(v20 + 8 * v21 + 128);
        if ( v56 )
        {
          while ( (v56 & 0xF) == 0 )
          {
            if ( a2 == v56 )
            {
              sub_1CC00((__int64)"free(): double free detected in tcache 2", a7, a8, a9, a10, a11, a12, a13, a14);
LABEL_132:
              sub_1CDA0(
                "heap->ar_ptr == av",
                "malloc.c",
                4446LL,
                "_int_free",
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14);
            }
            v57 = *(u32 **)v56;
            a5 = (u32 *)(v56 >> 12);
            v56 = *(_QWORD *)v56 ^ (v56 >> 12);
            if ( a5 == v57 )
              goto LABEL_8;
          }
          sub_1CC00((__int64)"free(): unaligned chunk detected in tcache 2", a7, a8, a9, a10, a11, a12, a13, a14);
          goto LABEL_107;
        }
      }
LABEL_8:
      a4 = *(unsigned __int16 *)(v20 + 2 * v21);
      if ( a4 < qword_BE6A0 )
      {
        _R12[3] = v20;
        _R12[2] = *(_QWORD *)(v20 + 8 * v21 + 128) ^ (a2 >> 12);
        *(_QWORD *)(v20 + 8 * v21 + 128) = a2;
        *(_WORD *)(v20 + 2 * v21) = a4 + 1;
        return v65 - __readfsqword(0x28u);
      }
    }
  }
  if ( v19 <= qword_C1258 )
  {
    v16 = (unsigned __int64)_R12 + v19;
    v22 = *(__int64 *)((char *)_R12 + v19 + 8);
    if ( v22 > 0x10 && (v22 & 0xFFFFFFFFFFFFFFF8LL) < *((_QWORD *)_RBP + 273) )
    {
LABEL_12:
      v23 = dword_C1254;
      if ( !dword_C1254 )
      {
LABEL_13:
        _RBP[2] = 1;
        v24 = (unsigned int)v19 >> 4;
        v25 = v24 - 2 + 2LL;
        v26 = *(_QWORD *)&_RBP[2 * v25];
        if ( __readfsdword(0x18u) )
        {
          _RCX = &_RBP[2 * v24];
          a2 = (unsigned __int64)(_R12 + 2) >> 12;
          if ( (__int64 *)v26 != _R12 )
          {
            _R12[2] = a2 ^ v26;
            if ( __readfsdword(0x18u) )
              __asm { lock }
            __asm { cmpxchg [rcx], r12 }
            goto LABEL_16;
          }
        }
        else if ( _R12 != (__int64 *)v26 )
        {
          _R12[2] = v26 ^ ((unsigned __int64)(_R12 + 2) >> 12);
          *(_QWORD *)&_RBP[2 * v25] = _R12;
LABEL_16:
          if ( !v26 || ((unsigned __int8)v17 & 1) == 0 || v24 == (unsigned int)*(_QWORD *)(v26 + 8) >> 4 )
            return v65 - __readfsqword(0x28u);
          sub_1CC00((__int64)"invalid fastbin entry (free)", a7, a8, a9, a10, a11, a12, a13, a14);
          goto LABEL_58;
        }
        sub_1CC00((__int64)"double free or corruption (fasttop)", a7, a8, a9, a10, a11, a12, a13, a14);
        goto LABEL_68;
      }
LABEL_89:
      v51 = 0x101010101010101LL * v23;
      a2 = (unsigned int)(v19 - 16);
      _R12[2] = v51;
      *(__int64 *)((char *)_R12 + a2 + 8) = v51;
      memset64(
        (void *)((unsigned __int64)(_R12 + 3) & 0xFFFFFFFFFFFFFFF8LL),
        v51,
        ((unsigned int)v19 + (_DWORD)_R12 - (((_DWORD)_R12 + 24) & 0xFFFFFFF8)) >> 3);
      goto LABEL_13;
    }
LABEL_47:
    if ( (_DWORD)v17 )
    {
LABEL_55:
      v32 = sub_1CC00((__int64)"free(): invalid next size (fast)", a7, a8, a9, a10, a11, a12, a13, a14);
      goto LABEL_56;
    }
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedCompareExchange((volatile signed __int32 *)_RBP, 1, 0) )
        sub_1C7D0((volatile __int32 *)_RBP, a2, 1LL, a4, a5, a6);
    }
    else
    {
      _EDX = 1;
      __asm { cmpxchg [rbp+0], edx }
    }
    v34 = *(_QWORD *)(v16 + 8);
    v35 = 1LL;
    if ( v34 > 0x10 )
      v35 = (v34 & 0xFFFFFFFFFFFFFFF8LL) >= *((_QWORD *)_RBP + 273);
    if ( !__readfsdword(0x18u) )
    {
      --*_RBP;
      goto LABEL_54;
    }
LABEL_118:
    if ( _InterlockedExchange((volatile __int32 *)_RBP, 0) > 1 )
    {
      a2 = 129LL;
      v59 = sys_futex(_RBP, 129, 1u, 0LL, (u32 *)v35, a6);
    }
LABEL_54:
    if ( !v35 )
      goto LABEL_12;
    goto LABEL_55;
  }
  if ( (_R12[1] & 2) == 0 )
  {
    v28 = __readfsdword(0x18u);
    if ( ((unsigned __int8)v17 & 1) == 0 && v28 )
    {
      v62 = __readfsdword(0x18u);
      if ( v62 )
      {
        v62 = 0;
        if ( _InterlockedCompareExchange((volatile signed __int32 *)_RBP, 1, 0) )
          sub_1C7D0((volatile __int32 *)_RBP, a2, 1LL, a4, a5, a6);
      }
      else
      {
        _EDX = 1;
        __asm { cmpxchg [rbp+0], edx }
      }
    }
    else
    {
      v62 = 1;
    }
    v29 = *((_QWORD *)_RBP + 12);
    v17 = (__int64 *)((char *)_R12 + v19);
    if ( (__int64 *)v29 != _R12 )
    {
      if ( (_RBP[1] & 2) != 0 )
        goto LABEL_26;
      goto LABEL_108;
    }
LABEL_107:
    v29 = sub_1CC00((__int64)"double free or corruption (top)", a7, a8, a9, a10, a11, a12, a13, a14);
LABEL_108:
    if ( (unsigned __int64)v17 >= (*(_QWORD *)(v29 + 8) & 0xFFFFFFFFFFFFFFF8LL) + v29 )
    {
      sub_1CC00((__int64)"double free or corruption (out)", a7, a8, a9, a10, a11, a12, a13, a14);
      goto LABEL_110;
    }
LABEL_26:
    v30 = v17[1];
    if ( (v30 & 1) != 0 )
    {
      v16 = v30 & 0xFFFFFFFFFFFFFFF8LL;
      if ( v30 <= 0x10 || *((_QWORD *)_RBP + 273) <= v16 )
      {
        v23 = sub_1CC00((__int64)"free(): invalid next size (normal)", a7, a8, a9, a10, a11, a12, a13, a14);
        goto LABEL_89;
      }
      a2 = (unsigned int)dword_C1254;
      if ( !dword_C1254 )
      {
LABEL_30:
        if ( (_R12[1] & 1) == 0 )
        {
          v31 = *_R12;
          _R12 = (__int64 *)((char *)_R12 - *_R12);
          v19 += v31;
          if ( (_R12[1] & 0xFFFFFFFFFFFFFFF8LL) != v31 )
          {
LABEL_117:
            sub_1CC00((__int64)"corrupted size vs. prev_size while consolidating", a7, a8, a9, a10, a11, a12, a13, a14);
            goto LABEL_118;
          }
          sub_1DA10(_R12, a7, a8, a9, a10, a11, a12, a13, a14);
        }
        if ( *((_QWORD **)_RBP + 12) == v17 )
        {
          v19 += v16;
          _R12[1] = v19 | 1;
          *((_QWORD *)_RBP + 12) = _R12;
LABEL_39:
          if ( v19 <= 0xFFFF )
            goto LABEL_40;
LABEL_68:
          if ( _RBP[2] )
            sub_1DAE0((__int64)_RBP, a7, a8, a9, a10, a11, a12, a13, a14, a2);
          if ( _RBP == &dword_BE6E0 )
          {
            if ( (*(_QWORD *)(*((_QWORD *)_RBP + 12) + 8LL) & 0xFFFFFFFFFFFFFFF8LL) >= (unsigned __int64)off_BE640 )
              sub_1D960((unsigned __int64)off_BE648);
          }
          else
          {
            v38 = *((_QWORD *)_RBP + 12);
            v39 = (_QWORD *)(v38 & 0xFFFFFFFFFC000000LL);
            if ( *(u32 **)(v38 & 0xFFFFFFFFFC000000LL) != _RBP )
              goto LABEL_132;
            v63 = off_BE648;
            v64 = (__int64)off_BF078;
            if ( (_QWORD *)v38 == v39 + 4 )
            {
              v60 = (char *)&off_BF078[1].r_info + (_QWORD)off_BE648;
              v61 = (unsigned __int64)&off_BF078[-1].r_addend + 7;
              while ( 1 )
              {
                v43 = v39;
                v39 = (_QWORD *)v39[1];
                v44 = v39[2];
                v45 = ((_BYTE)v39 + (_BYTE)v44 - 16) & 0xF;
                v46 = (_QWORD *)((char *)v39 + v44 - 16 - v45);
                if ( v46[1] != 1LL )
                  sub_1CDA0(
                    "chunksize_nomask (p) == (0 | PREV_INUSE)",
                    "arena.c",
                    613LL,
                    "heap_trim",
                    a5,
                    a6,
                    a7,
                    a8,
                    a9,
                    a10,
                    a11,
                    a12,
                    a13,
                    a14);
                v47 = (_QWORD *)((char *)v46 - *v46);
                v48 = v47[1];
                v49 = v47;
                v50 = (v48 & 0xFFFFFFFFFFFFFFF8LL) + v45;
                v40 = v50 + 16;
                if ( (unsigned __int64)(v50 + 15) > 0x3E )
                  sub_1CDA0(
                    "new_size > 0 && new_size < (long) (2 * MINSIZE)",
                    "arena.c",
                    616LL,
                    "heap_trim",
                    a7,
                    a8,
                    a9,
                    a10,
                    a11,
                    a12,
                    a13,
                    a14);
                a5 = (u32 *)(v48 & 1);
                if ( (_DWORD)a5 )
                {
                  v41 = v50 + 16;
                }
                else
                {
                  v40 += *v47;
                  v41 = v40;
                  if ( (unsigned __int64)(v40 - 1) > 0x3FFFFFE )
                    sub_1CDA0(
                      "new_size > 0 && new_size < HEAP_MAX_SIZE",
                      "arena.c",
                      619LL,
                      "heap_trim",
                      a5,
                      a6,
                      a7,
                      a8,
                      a9,
                      a10,
                      a11,
                      a12,
                      a13,
                      a14);
                }
                if ( 0x4000000 - v44 + v40 < (unsigned __int64)v60 )
                  break;
                *((_QWORD *)_RBP + 273) -= v43[2];
                if ( addr == v43 + 0x800000 )
                  addr = 0LL;
                v38 = (unsigned __int64)v47;
                munmap(v43, 0x4000000uLL);
                if ( (v49[1] & 1) == 0 )
                {
                  v38 = (unsigned __int64)v49 - *v49;
                  sub_1DA10((_QWORD *)v38, a7, a8, a9, a10, a11, a12, a13, a14);
                }
                if ( ((v38 + v40) & v61) != 0 )
                  sub_1CDA0(
                    "((unsigned long) ((char *) p + new_size) & (pagesz - 1)) == 0",
                    "arena.c",
                    631LL,
                    "heap_trim",
                    a7,
                    a8,
                    a9,
                    a10,
                    a11,
                    a12,
                    a13,
                    a14);
                if ( (_QWORD *)(v38 + v40) != (_QWORD *)((char *)v39 + v39[2]) )
                  sub_1CDA0(
                    "((char *) p + new_size) == ((char *) heap + heap->size)",
                    "arena.c",
                    632LL,
                    "heap_trim",
                    a7,
                    a8,
                    a9,
                    a10,
                    a11,
                    a12,
                    a13,
                    a14);
                v42 = v41 | 1;
                *((_QWORD *)_RBP + 12) = v38;
                *(_QWORD *)(v38 + 8) = v42;
                if ( (_QWORD *)v38 != v39 + 4 )
                  goto LABEL_92;
              }
              v42 = *(_QWORD *)(v38 + 8);
              v39 = v43;
            }
            else
            {
              v42 = *(_QWORD *)(v38 + 8);
            }
LABEL_92:
            v52 = v42 & 0xFFFFFFFFFFFFFFF8LL;
            if ( (unsigned __int64)off_BE640 <= v52 )
            {
              v53 = v52 - 33;
              if ( (__int64)(v52 - 33) >= 0 && (unsigned __int64)v63 < v53 )
              {
                v54 = -v64 & (v53 - (_QWORD)v63);
                if ( v54 )
                {
                  v55 = v39[2] - v54;
                  if ( v55 > 31 )
                  {
                    if ( dword_BE620 < 0 )
                    {
                      dword_BE620 = 1;
                    }
                    else if ( !dword_BE620 )
                    {
                      sub_4BD70((unsigned __int64)v39 + v55, v54, 4);
LABEL_100:
                      v39[2] = v55;
                      *((_QWORD *)_RBP + 273) -= v54;
                      *(_QWORD *)(v38 + 8) = (v52 - v54) | 1;
                      goto LABEL_40;
                    }
                    if ( mmap((char *)v39 + v55, v54, 0LL, 0x32u, 0xFFFFFFFFuLL, 0LL) != (void *)-1LL )
                    {
                      v39[3] = v55;
                      goto LABEL_100;
                    }
                  }
                }
              }
            }
          }
LABEL_40:
          if ( !v62 )
          {
            if ( __readfsdword(0x18u) )
            {
LABEL_58:
              if ( _InterlockedExchange((volatile __int32 *)_RBP, v62) > 1 )
                v36 = sys_futex(_RBP, 129, 1u, 0LL, a5, a6);
              return v65 - __readfsqword(0x28u);
            }
            --*_RBP;
          }
          return v65 - __readfsqword(0x28u);
        }
        if ( (*((_BYTE *)v17 + v16 + 8) & 1) != 0 )
        {
          v17[1] &= 0xFFFFFFFFFFFFFFFELL;
        }
        else
        {
          v19 += v16;
          sub_1DA10(v17, a7, a8, a9, a10, a11, a12, a13, a14);
        }
        v32 = *((_QWORD *)_RBP + 14);
        if ( *(u32 **)(v32 + 24) == _RBP + 24 )
        {
          _R12[2] = v32;
          _R12[3] = (__int64)(_RBP + 24);
          if ( v19 <= 0x3FF )
          {
LABEL_38:
            *((_QWORD *)_RBP + 14) = _R12;
            *(_QWORD *)(v32 + 24) = _R12;
            _R12[1] = v19 | 1;
            *(__int64 *)((char *)_R12 + v19) = v19;
            goto LABEL_39;
          }
LABEL_56:
          _R12[4] = 0LL;
          _R12[5] = 0LL;
          goto LABEL_38;
        }
        sub_1CC00((__int64)"free(): corrupted unsorted chunks", a7, a8, a9, a10, a11, a12, a13, a14);
        goto LABEL_117;
      }
LABEL_111:
      sub_9190((__int64)(_R12 + 2), a2, v19 - 16);
      goto LABEL_30;
    }
LABEL_110:
    sub_1CC00((__int64)"double free or corruption (!prev)", a7, a8, a9, a10, a11, a12, a13, a14);
    goto LABEL_111;
  }
  return sub_1CFB0(_R12);
}
// 1DD6B: variable '_RBP' is possibly undefined
// 1DD94: variable '_R12' is possibly undefined
// 1DE94: variable 'a11' is possibly undefined
// 1DE94: variable 'a12' is possibly undefined
// 1DEA3: variable 'v16' is possibly undefined
// 1DF08: variable 'v62' is possibly undefined
// 1E00A: variable 'v35' is possibly undefined
// 1E074: variable 'a5' is possibly undefined
// 1E074: variable 'a6' is possibly undefined
// 1E091: variable 'a4' is possibly undefined
// 1CDA0: using guessed type double sub_1CDA0(const char *, ...);
// 1CFB0: using guessed type __int64 __fastcall sub_1CFB0(_QWORD);
// BD7E0: using guessed type int dword_BD7E0;
// BE620: using guessed type int dword_BE620;
// BE640: using guessed type void *off_BE640;
// BE648: using guessed type void *off_BE648;
// BE690: using guessed type int *off_BE690;
// BE6A0: using guessed type __int64 qword_BE6A0;
// BF078: using guessed type Elf64_Rela *off_BF078;
// C1254: using guessed type int dword_C1254;
// C1258: using guessed type __int64 qword_C1258;

//----- (000000000001E6C0) ----------------------------------------------------
_QWORD *__fastcall sub_1E6C0(unsigned __int64 a1, __int64 rsi0, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  unsigned __int64 v10; // rbp
  __int64 v11; // r13
  __int64 v13; // r15
  unsigned __int64 v14; // r14
  __int64 v15; // rax
  unsigned __int64 v16; // r12
  unsigned __int64 v17; // r11
  unsigned __int64 v18; // r10
  unsigned __int64 v19; // rcx
  __int64 v20; // r8
  unsigned __int64 v21; // rax
  void (__fastcall __noreturn *v22)(); // r9
  unsigned __int64 v23; // rdi
  unsigned __int64 v24; // r15
  __int64 v25; // rdx
  unsigned __int64 v26; // rax
  __int64 v27; // r8
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // rcx
  unsigned __int64 v30; // rax
  _QWORD *v31; // r8
  unsigned __int64 v33; // r12
  char *v34; // rax
  __int64 v35; // r9
  char *v36; // rsi
  unsigned __int64 v37; // r12
  __int64 v38; // rcx
  __int64 v39; // rax
  unsigned __int64 v40; // rcx
  unsigned __int64 *v41; // rsi
  _QWORD *v42; // rax
  signed __int32 v43; // edx
  int v44; // eax
  unsigned __int64 v45; // r13
  __int64 v46; // rtt
  char *v47; // rsi
  __int64 v48; // r13
  unsigned __int64 v49; // rsi
  signed __int64 v50; // rsi
  unsigned __int64 v51; // rcx
  __int64 v52; // r9
  double v53; // xmm4_8
  double v54; // xmm5_8
  const char *v55; // rdi
  char v56; // dl
  int v57; // eax
  char *v58; // rax
  __int64 v59; // rcx
  unsigned __int64 v60; // r12
  unsigned __int64 v61; // rax
  unsigned __int64 v62; // r8
  unsigned __int64 v63; // rdi
  __int64 v64; // rax
  __int64 v65; // rax
  char v66; // [rsp+0h] [rbp-68h]
  char *v67; // [rsp+0h] [rbp-68h]
  __int64 v68; // [rsp+0h] [rbp-68h]
  unsigned __int64 v69; // [rsp+8h] [rbp-60h]
  __int64 v70; // [rsp+8h] [rbp-60h]
  unsigned __int64 a2; // [rsp+10h] [rbp-58h]
  unsigned __int64 a2b; // [rsp+10h] [rbp-58h]
  unsigned __int64 a2a; // [rsp+10h] [rbp-58h]
  unsigned __int64 v74; // [rsp+18h] [rbp-50h]
  void (__fastcall __noreturn *v75)(); // [rsp+20h] [rbp-48h]
  __int64 v76; // [rsp+28h] [rbp-40h]

  v10 = a1;
  v11 = (__int64)off_BF078;
  if ( rsi0 )
  {
    if ( (unsigned __int64)off_BE650 > a1 || dword_BE668 >= dword_BE66C )
    {
      v66 = 0;
LABEL_4:
      v13 = rsi0 + 96;
      a2 = -v11 & (v11 + a1 + 7);
      while ( 1 )
      {
        v14 = *(_QWORD *)(rsi0 + 96);
        v15 = *(_QWORD *)(v14 + 8);
        v16 = v15 & 0xFFFFFFFFFFFFFFF8LL;
        v17 = v14 + (v15 & 0xFFFFFFFFFFFFFFF8LL);
        if ( (v14 != v13 || v16) && (v16 <= 0x1F || (v15 & 1) == 0 || ((v11 - 1) & v17) != 0) )
          sub_1CDA0(
            "(old_top == initial_top (av) && old_size == 0) || ((unsigned long) (old_size) >= MINSIZE && prev_inuse (old_"
            "top) && ((unsigned long) old_end & (pagesize - 1)) == 0)",
            "malloc.c",
            2394LL,
            "sysmalloc",
            a3,
            a4,
            a5,
            a6,
            a7,
            a8,
            a9,
            a10,
            v66);
        v18 = v10 + 32;
        if ( v10 + 32 <= v16 )
          sub_1CDA0(
            "(unsigned long) (old_size) < (unsigned long) (nb + MINSIZE)",
            "malloc.c",
            2400LL,
            "sysmalloc",
            a3,
            a4,
            a5,
            a6,
            a7,
            a8,
            a9,
            a10);
        if ( (u32 *)rsi0 == &dword_BE6E0 )
          break;
        v19 = v14 & 0xFFFFFFFFFC000000LL;
        if ( (__int64)(v18 - v16) > 0 )
        {
          v20 = *(_QWORD *)((char *)&word_10 + (v14 & 0xFFFFFFFFFC000000LL));
          v21 = ((unsigned __int64)off_BF078 + v18 - v16 - 1) & -(__int64)off_BF078;
          v22 = (void (__fastcall __noreturn *)())(v21 + v20);
          if ( v21 + v20 <= 0x4000000 )
          {
            v23 = *(unsigned __int64 *)((char *)&off_18 + (v14 & 0xFFFFFFFFFC000000LL));
            if ( (unsigned __int64)v22 <= v23 )
            {
              v24 = v10 + 32;
              goto LABEL_16;
            }
            v76 = *(_QWORD *)((char *)&word_10 + (v14 & 0xFFFFFFFFFC000000LL));
            v75 = (void (__fastcall __noreturn *)())(v21 + v20);
            v57 = sub_4BD40(v19 + v23, (size_t)v22 - v23, 3uLL);
            v19 = v14 & 0xFFFFFFFFFC000000LL;
            v18 = v10 + 32;
            if ( !v57 )
            {
              v22 = v75;
              v20 = v76;
              v24 = v10 + 32;
              *(void (__fastcall __noreturn **)())((char *)&off_18 + (v14 & 0xFFFFFFFFFC000000LL)) = v75;
LABEL_16:
              *(_QWORD *)(v19 + 16) = v22;
              v25 = *(_QWORD *)(v19 + 16);
              v26 = v25 + *(_QWORD *)(rsi0 + 2184) - v20;
              v27 = *(_QWORD *)(rsi0 + 96);
              *(_QWORD *)(rsi0 + 2184) = v26;
              *(_QWORD *)(v14 + 8) = (v19 + v25 - v14) | 1;
LABEL_17:
              if ( *(_QWORD *)(rsi0 + 2192) < v26 )
                *(_QWORD *)(rsi0 + 2192) = v26;
              v28 = *(_QWORD *)(v27 + 8) & 0xFFFFFFFFFFFFFFF8LL;
              if ( v24 <= v28 )
              {
                v29 = v27 + v10;
                v30 = v28 - v10;
                *(_QWORD *)(rsi0 + 96) = v27 + v10;
                if ( (u32 *)rsi0 != &dword_BE6E0 )
                  v10 |= 4uLL;
                v31 = (_QWORD *)(v27 + 16);
                *(v31 - 1) = v10 | 1;
                *(_QWORD *)(v29 + 8) = v30 | 1;
                return v31;
              }
              __writefsdword(0xFFFFFFC0, 0xCu);
              return 0LL;
            }
          }
        }
        v69 = v18;
        v74 = v19;
        v34 = sub_1CE00(v10 + 64, (__int64)off_BE648);
        v36 = v34;
        if ( v34 )
        {
          *(_QWORD *)v34 = rsi0;
          v27 = (__int64)(v34 + 32);
          v37 = (v16 - 32) & 0xFFFFFFFFFFFFFFF0LL;
          v24 = v69;
          *((_QWORD *)v34 + 1) = v74;
          v38 = *((_QWORD *)v34 + 2);
          v39 = *(_QWORD *)(rsi0 + 2184);
          *(_QWORD *)(rsi0 + 96) = v36 + 32;
          v26 = v38 + v39;
          *(_QWORD *)(rsi0 + 2184) = v26;
          *((_QWORD *)v36 + 5) = (v38 - 32) | 1;
          v40 = v37 + 16;
          v41 = (unsigned __int64 *)(v14 + v37 + 16);
          v41[1] = 1LL;
          if ( v37 > 0x1F )
          {
            *(_QWORD *)(v14 + v37 + 8) = 17LL;
            *v41 = 16LL;
            *(_QWORD *)(v14 + 8) = v37 | 5;
            sub_1DC90((u32 *)rsi0, v14, 1u, v40, (u32 *)v27, v35, a3, a4, a5, a6, a7, a8, a9, a10);
            v26 = *(_QWORD *)(rsi0 + 2184);
            v27 = *(_QWORD *)(rsi0 + 96);
          }
          else
          {
            *(_QWORD *)(v14 + 8) = v40 | 1;
            *v41 = v40;
          }
          goto LABEL_17;
        }
        if ( v66 )
        {
          v26 = *(_QWORD *)(rsi0 + 2184);
          v27 = *(_QWORD *)(rsi0 + 96);
          v24 = v69;
          goto LABEL_17;
        }
        v33 = a2;
        if ( a2 > v10 )
        {
          v42 = mmap(0LL, a2, 3uLL, 0x22u, 0xFFFFFFFFuLL, 0LL);
          if ( v42 != (_QWORD *)-1LL )
            goto LABEL_34;
        }
        v66 = 1;
      }
      v24 = v10 + 32;
      v67 = (char *)(v11 - 1);
      v47 = (char *)off_BE648 + v11 + 31;
      v48 = -v11;
      v49 = (unsigned __int64)&v47[v10];
      if ( (*(_BYTE *)(rsi0 + 4) & 2) != 0 )
      {
        v50 = v48 & v49;
        if ( v50 <= 0 )
          goto LABEL_53;
      }
      else
      {
        v50 = v48 & (v49 - v16);
        if ( v50 <= 0 )
        {
LABEL_63:
          v50 = v48 & (unsigned __int64)&v67[v16 + v50];
          goto LABEL_53;
        }
      }
      v51 = off_BEF78(v50);
      v17 = v14 + v16;
      if ( v51 )
      {
        if ( qword_C1210 )
        {
          a2a = v51;
          qword_C1210(a3, a4, a5, a6, v53, v54, a9, a10);
          v17 = v14 + v16;
          v51 = a2a;
        }
        v55 = (const char *)qword_BE688;
        v56 = 1;
        v26 = v50 + qword_BEF68;
        if ( qword_BE688 )
        {
          v55 = 0LL;
          goto LABEL_49;
        }
LABEL_65:
        qword_BE688 = v51;
LABEL_49:
        qword_BEF68 = v26;
        if ( v17 == v51 && v56 )
        {
          v27 = qword_BE740;
          *(_QWORD *)(v14 + 8) = (v16 + v50) | 1;
          goto LABEL_17;
        }
        if ( (dword_BE6E4 & 2) == 0 )
        {
          if ( !v16 )
          {
LABEL_77:
            v61 = v51 & 0xF;
            if ( (v51 & 0xF) != 0 )
            {
              v62 = v51 + 16 - v61;
              v63 = v16 + 16 - v61;
            }
            else
            {
              v63 = v16;
              v62 = v51;
            }
            v48 = ((unsigned __int64)&v67[v63 + v50 + v51] & v48) - (v50 + v51);
            if ( v48 < 0 )
              sub_1CDA0("correction >= 0", "malloc.c", 2615LL, "sysmalloc", v62, a3, a4, a5, a6, v53, v54, a9, a10);
            v70 = v62;
            v64 = off_BEF78(v48);
            v59 = v48;
            v27 = v70;
            v55 = (const char *)v64;
            if ( v64 )
            {
              if ( qword_C1210 )
              {
                qword_C1210(a3, a4, a5, a6, v53, v54, a9, a10);
                v59 = v48;
                v27 = v70;
              }
              goto LABEL_70;
            }
            v65 = off_BEF78(0LL);
            v27 = v70;
            v55 = (const char *)v65;
            goto LABEL_85;
          }
          if ( v17 <= v51 )
          {
            qword_BEF68 = v51 - v17 + v26;
            goto LABEL_77;
          }
          v55 = "break adjusted to free malloc space";
          sub_1CC00((__int64)"break adjusted to free malloc space", a3, a4, a5, a6, v53, v54, a9, a10);
LABEL_102:
          v27 = v51;
          v59 = 0LL;
          goto LABEL_70;
        }
        v48 = v51 & 0xF;
        if ( (v51 & 0xF) == 0 )
        {
          if ( v56 )
          {
            v68 = v51;
            v55 = (const char *)off_BEF78(0LL);
            v27 = v68;
LABEL_85:
            if ( !v55 )
              goto LABEL_56;
            v48 = 0LL;
            v59 = 0LL;
LABEL_70:
            qword_BE740 = v27;
            v26 = v48 + qword_BEF68;
            *(_QWORD *)(v27 + 8) = (unsigned __int64)&v55[v59 - v27] | 1;
            qword_BEF68 = v26;
            if ( !v16 )
              goto LABEL_17;
            v60 = (v16 - 32) & 0xFFFFFFFFFFFFFFF0LL;
            *(_QWORD *)(v14 + 8) = v60 | 1;
            *(_QWORD *)(v14 + v60 + 8) = 17LL;
            *(_QWORD *)(v14 + v60 + 24) = 17LL;
            if ( v60 <= 0x1F )
              goto LABEL_17;
            sub_1DC90(&dword_BE6E0, v14, 1u, v60 | 1, (u32 *)v27, v52, a3, a4, a5, a6, v53, v54, a9, a10);
LABEL_56:
            v26 = qword_BEF68;
            v27 = qword_BE740;
            goto LABEL_17;
          }
          goto LABEL_102;
        }
LABEL_96:
        sub_1CDA0(
          "((unsigned long) chunk2mem (brk) & MALLOC_ALIGN_MASK) == 0",
          "malloc.c",
          2647LL,
          "sysmalloc",
          a3,
          a4,
          a5,
          a6,
          v53,
          v54,
          a9,
          a10,
          v67);
      }
      if ( (dword_BE6E4 & 2) == 0 )
        goto LABEL_63;
LABEL_53:
      if ( (unsigned __int64)v50 < 0x100000 )
        v50 = 0x100000LL;
      if ( v10 >= v50 )
        goto LABEL_56;
      a2b = v17;
      v58 = (char *)mmap(0LL, v50, 3uLL, 0x22u, 0xFFFFFFFFuLL, 0LL);
      v17 = a2b;
      v27 = (__int64)v58;
      if ( v58 == (char *)-1LL )
        goto LABEL_56;
      dword_BE6E4 |= 2u;
      v55 = &v58[v50];
      if ( !v58 )
        goto LABEL_56;
      v26 = v50 + qword_BEF68;
      if ( qword_BE688 )
      {
        qword_BEF68 += v50;
        v59 = 0LL;
        v48 = v27 & 0xF;
        if ( (v27 & 0xF) == 0 )
          goto LABEL_70;
        goto LABEL_96;
      }
      v51 = v27;
      v56 = 0;
      goto LABEL_65;
    }
    v33 = -(__int64)off_BF078 & ((unsigned __int64)&off_BF078->r_offset + a1 + 7);
    if ( a1 >= v33 || (v42 = mmap(0LL, v33, 3uLL, 0x22u, 0xFFFFFFFFuLL, 0LL), v42 == (_QWORD *)-1LL) )
    {
      v66 = 1;
      goto LABEL_4;
    }
  }
  else
  {
    v33 = -(__int64)off_BF078 & ((unsigned __int64)&off_BF078->r_offset + a1 + 7);
    if ( a1 >= v33 )
      return 0LL;
    v42 = mmap(0LL, v33, 3uLL, 0x22u, 0xFFFFFFFFuLL, 0LL);
    if ( v42 == (_QWORD *)-1LL )
      return 0LL;
  }
LABEL_34:
  v31 = v42 + 2;
  if ( ((unsigned __int8)v42 & 0xF) != 0 )
    sub_1CDA0(
      "((INTERNAL_SIZE_T) chunk2mem (mm) & MALLOC_ALIGN_MASK) == 0",
      "malloc.c",
      2342LL,
      "sysmalloc",
      v31,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      a9,
      a10);
  *v42 = 0LL;
  v42[1] = v33 | 2;
  v43 = _InterlockedIncrement(&dword_BE668);
  do
    v44 = dword_BE670;
  while ( v43 > dword_BE670 && v44 != _InterlockedCompareExchange(&dword_BE670, v43, dword_BE670) );
  v45 = v33 + _InterlockedExchangeAdd64(&qword_BE678, v33);
  do
  {
    if ( v45 <= qword_BE680 )
      break;
    v46 = qword_BE680;
  }
  while ( v46 != _InterlockedCompareExchange64(&qword_BE680, v45, qword_BE680) );
  return v31;
}
// 1ECDE: conditional instruction was optimized away because of 'r12.8 in (20..FFFFFFFFFFFFFFF8)'
// 1EDC7: variable 'v53' is possibly undefined
// 1EDC7: variable 'v54' is possibly undefined
// 1EB03: variable 'v35' is possibly undefined
// 1EB03: variable 'a7' is possibly undefined
// 1EB03: variable 'a8' is possibly undefined
// 1ECAE: variable 'v52' is possibly undefined
// 1EF13: variable 'v51' is possibly undefined
// 10: using guessed type __int16 word_10;
// 18: using guessed type void (__fastcall __noreturn *off_18)();
// 1CDA0: using guessed type double sub_1CDA0(const char *, ...);
// BE648: using guessed type void *off_BE648;
// BE650: using guessed type void *off_BE650;
// BE668: using guessed type int dword_BE668;
// BE66C: using guessed type int dword_BE66C;
// BE670: using guessed type int dword_BE670;
// BE678: using guessed type __int64 qword_BE678;
// BE680: using guessed type __int64 qword_BE680;
// BE688: using guessed type __int64 qword_BE688;
// BE6E4: using guessed type int dword_BE6E4;
// BE740: using guessed type __int64 qword_BE740;
// BEF68: using guessed type __int64 qword_BEF68;
// BEF78: using guessed type __int64 (__fastcall *off_BEF78)(_QWORD);
// BF078: using guessed type Elf64_Rela *off_BF078;
// C1210: using guessed type __int64 (__fastcall *qword_C1210)(double, double, double, double, double, double, double, double);

//----- (000000000001EF20) ----------------------------------------------------
void __fastcall sub_1EF20(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14)
{
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rcx
  __int64 v17; // r9
  double v18; // xmm4_8
  double v19; // xmm5_8
  unsigned __int64 v20; // r8
  u32 *v21; // r8
  u32 v22; // er9
  signed __int64 v23; // rax
  signed __int64 v24; // rax
  __int64 v25; // rdx
  __int64 v26; // rcx
  u32 *v27; // r8
  u32 v28; // er9
  double v29; // xmm4_8
  double v30; // xmm5_8

  if ( a1 )
  {
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_BE6E0, 1, 0) )
        sub_1C7D0((volatile __int32 *)&dword_BE6E0, a2, 1LL, a12, a13, a14);
    }
    else
    {
      _EDX = 1;
      __asm { cmpxchg cs:dword_BE6E0, edx }
    }
    v15 = sub_1C930(a1, 0LL);
    v20 = v15;
    if ( v15 )
    {
      if ( (*(_BYTE *)(v15 + 8) & 2) != 0 )
      {
        if ( __readfsdword(0x18u) )
        {
          if ( _InterlockedExchange((volatile __int32 *)&dword_BE6E0, 0) > 1 )
            v23 = sys_futex(&dword_BE6E0, 129, 1u, 0LL, (u32 *)v15, v17);
        }
        else
        {
          --dword_BE6E0;
        }
        sub_1CFB0(v20);
      }
      else
      {
        sub_1DC90(&dword_BE6E0, v15, 1u, v16, (u32 *)v15, v17, a3, a4, a5, a6, v18, v19, a9, a10);
        if ( __readfsdword(0x18u) )
        {
          if ( _InterlockedExchange((volatile __int32 *)&dword_BE6E0, 0) > 1 )
            v24 = sys_futex(&dword_BE6E0, 129, 1u, 0LL, v21, v22);
        }
        else
        {
          --dword_BE6E0;
        }
      }
    }
    else
    {
      sub_1CC00((__int64)"free(): invalid pointer", a3, a4, a5, a6, v18, v19, a9, a10);
      sub_1F070((u32 *)"free(): invalid pointer", 0LL, a3, a4, a5, a6, v29, v30, a9, a10, v25, v26, v27, v28);
    }
  }
}
// 1EF80: variable 'v20' is possibly undefined
// 1EF97: variable 'v16' is possibly undefined
// 1EF97: variable 'v17' is possibly undefined
// 1EF97: variable 'v18' is possibly undefined
// 1EF97: variable 'v19' is possibly undefined
// 1F052: variable 'v21' is possibly undefined
// 1F052: variable 'v22' is possibly undefined
// 1F06E: variable 'v29' is possibly undefined
// 1F06E: variable 'v30' is possibly undefined
// 1F06E: variable 'v25' is possibly undefined
// 1F06E: variable 'v26' is possibly undefined
// 1F06E: variable 'v27' is possibly undefined
// 1F06E: variable 'v28' is possibly undefined
// 1CFB0: using guessed type __int64 __fastcall sub_1CFB0(_QWORD);

//----- (000000000001F070) ----------------------------------------------------
u32 *__fastcall sub_1F070(u32 *a1, u32 *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14)
{
  __int64 v14; // rax
  unsigned __int64 v15; // rdx
  __int64 v17; // rcx
  unsigned __int64 v19; // r13
  __int64 v21; // rax
  __int64 v22; // rax
  __int64 *v23; // rcx
  __int64 v24; // rdx
  int v26; // eax
  signed __int64 v29; // rax
  char *v30; // rax
  u32 *v31; // r8
  u32 v32; // er9
  char *v33; // rbx
  char *v34; // rax
  __int64 v35; // rdx
  __int64 v36; // rax
  unsigned __int64 v37; // rbp
  __int64 v39; // rax
  signed __int64 v41; // rax
  signed __int64 v42; // rax

  v14 = qword_C1228;
  v15 = qword_BE628;
  if ( !qword_C1228 )
  {
    v14 = qword_BE660;
    if ( qword_BE660 )
    {
      qword_C1228 = qword_BE660;
    }
    else if ( qword_BE658 < (unsigned __int64)qword_BE628 )
    {
      v26 = sub_4CA20(a3, a4, a5, a6, a7, a8, a9, a10);
      if ( v26 <= 0 )
      {
        qword_C1228 = 16LL;
        v15 = qword_BE628;
        v14 = 16LL;
      }
      else
      {
        v15 = qword_BE628;
        v14 = 8 * v26;
        qword_C1228 = (int)v14;
      }
    }
  }
  if ( v14 - 1 >= v15 )
  {
    _RCX = v15 + 1;
    if ( __readfsdword(0x18u) )
      __asm { lock }
    __asm { cmpxchg cs:qword_BE628, rcx }
    a2 = (u32 *)off_BE648;
    a1 += 562;
    v30 = sub_1CE00((unsigned __int64)a1, (__int64)off_BE648);
    v33 = v30;
    if ( !v30 )
    {
      a2 = (u32 *)off_BE648;
      a1 = (_DWORD *)&stru_8C8;
      v33 = sub_1CE00(0x8C8uLL, (__int64)off_BE648);
      if ( !v33 )
      {
        if ( __readfsdword(0x18u) )
          __asm { lock }
        --qword_BE628;
        return 0LL;
      }
    }
    _R12 = (u32 *)(v33 + 32);
    v34 = v33 + 128;
    *(_QWORD *)v33 = v33 + 32;
    do
    {
      *((_QWORD *)v34 + 3) = v34;
      *((_QWORD *)v34 + 2) = v34;
      v34 += 16;
    }
    while ( v33 + 2160 != v34 );
    if ( _R12 == &dword_BE6E0 )
      qword_C1258 = 128LL;
    else
      *((_DWORD *)v33 + 9) |= 2u;
    *((_DWORD *)v33 + 10) = 0;
    v35 = (__int64)(v33 + 2232);
    *((_QWORD *)v33 + 276) = 1LL;
    v36 = *((_QWORD *)v33 + 2);
    *((_QWORD *)v33 + 278) = v36;
    *((_QWORD *)v33 + 277) = v36;
    v17 = ((_BYTE)v33 - 56) & 0xF;
    if ( (((_BYTE)v33 - 56) & 0xF) != 0 )
      v35 = v35 - v17 + 16;
    *((_QWORD *)v33 + 16) = v35;
    *(_QWORD *)(v35 + 8) = (unsigned __int64)&v33[v36 - v35] | 1;
    v37 = __readfsqword(0xFFFFFFD8);
    __writefsqword(0xFFFFFFD8, (unsigned __int64)_R12);
    *((_DWORD *)v33 + 8) = 0;
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C1240, 1, 0) )
      {
        a1 = &dword_C1240;
        sub_1C7D0((volatile __int32 *)&dword_C1240, (__int64)a2, 1LL, v17, v31, v32);
      }
    }
    else
    {
      _EDX = 1;
      __asm { cmpxchg cs:dword_C1240, edx }
    }
    *((int **)v33 + 274) = off_BEF50[0];
    off_BEF50[0] = (int *)(v33 + 32);
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedExchange((volatile __int32 *)&dword_C1240, 0) > 1 )
      {
        a2 = (_DWORD *)(&qword_80 + 1);
        a1 = &dword_C1240;
        v41 = sys_futex(&dword_C1240, 129, 1u, 0LL, v31, v32);
      }
    }
    else
    {
      --dword_C1240;
    }
    if ( __readfsdword(0x18u) )
    {
      _RDX = 1LL;
      if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C1250, 1, 0) )
      {
        a1 = &dword_C1250;
        sub_1C7D0((volatile __int32 *)&dword_C1250, (__int64)a2, 1LL, v17, v31, v32);
      }
    }
    else
    {
      _RDX = 1LL;
      __asm { cmpxchg cs:dword_C1250, edx }
    }
    if ( v37 )
    {
      v39 = *(_QWORD *)(v37 + 2176);
      if ( !v39 )
        goto LABEL_77;
      *(_QWORD *)(v37 + 2176) = v39 - 1;
    }
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedExchange((volatile __int32 *)&dword_C1250, 0) > 1 )
      {
        a2 = (_DWORD *)(&qword_80 + 1);
        v42 = sys_futex(&dword_C1250, 129, 1u, 0LL, v31, v32);
      }
    }
    else
    {
      --dword_C1250;
    }
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedCompareExchange((volatile signed __int32 *)_R12, 1, 0) )
        sub_1C7D0((volatile __int32 *)v33 + 8, (__int64)a2, 1LL, v17, v31, v32);
    }
    else
    {
      _EDX = 1;
      __asm { cmpxchg [r12], edx }
    }
    return _R12;
  }
  _R12 = (u32 *)qword_C1220;
  if ( !qword_C1220 )
  {
    _R12 = &dword_BE6E0;
    qword_C1220 = (__int64)&dword_BE6E0;
  }
  v17 = 0LL;
  _EDX = 1;
  do
  {
    if ( !__readfsdword(0x18u) )
    {
      __asm { cmpxchg [r12], edx }
      goto LABEL_12;
    }
    if ( !_InterlockedCompareExchange((volatile signed __int32 *)_R12, 1, 0) )
      goto LABEL_12;
    _R12 = (u32 *)*((_QWORD *)_R12 + 270);
  }
  while ( _R12 != (u32 *)qword_C1220 );
  if ( a2 == _R12 )
    _R12 = (u32 *)*((_QWORD *)a2 + 270);
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedCompareExchange((volatile signed __int32 *)_R12, 1, 0) )
    {
      a1 = _R12;
      sub_1C7D0((volatile __int32 *)_R12, (__int64)a2, 1LL, 0LL, a13, a14);
    }
  }
  else
  {
    _EDX = 1;
    __asm { cmpxchg [r12], edx }
  }
LABEL_12:
  v19 = __readfsqword(0xFFFFFFD8);
  if ( __readfsdword(0x18u) )
  {
    _RDX = 1LL;
    if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C1250, 1, 0) )
    {
      a1 = &dword_C1250;
      sub_1C7D0((volatile __int32 *)&dword_C1250, (__int64)a2, 1LL, v17, a13, a14);
    }
  }
  else
  {
    _RDX = 1LL;
    __asm { cmpxchg cs:dword_C1250, edx }
  }
  if ( !v19 )
    goto LABEL_17;
  v21 = *(_QWORD *)(v19 + 2176);
  if ( !v21 )
LABEL_77:
    sub_1D1E0(a1, a2, _RDX, v17);
  *(_QWORD *)(v19 + 2176) = v21 - 1;
LABEL_17:
  v22 = qword_C1248;
  v23 = &qword_C1248;
  if ( qword_C1248 )
  {
    while ( 1 )
    {
      if ( *(_QWORD *)(v22 + 2176) )
        sub_1CDA0("p->attached_threads == 0", "arena.c", 796LL, "remove_from_free_list");
      v24 = *(_QWORD *)(v22 + 2168);
      if ( (u32 *)v22 == _R12 )
        break;
      v23 = (__int64 *)(v22 + 2168);
      if ( !v24 )
        goto LABEL_24;
      v22 = *(_QWORD *)(v22 + 2168);
    }
    *v23 = v24;
  }
LABEL_24:
  ++*((_QWORD *)_R12 + 272);
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedExchange((volatile __int32 *)&dword_C1250, 0) > 1 )
      v29 = sys_futex(&dword_C1250, 129, 1u, 0LL, a13, a14);
  }
  else
  {
    --dword_C1250;
  }
  __writefsqword(0xFFFFFFD8, (unsigned __int64)_R12);
  qword_C1220 = *((_QWORD *)_R12 + 270);
  return _R12;
}
// 1F0D7: conditional instruction was optimized away because of 'al.1==0'
// 1F2C2: variable 'a13' is possibly undefined
// 1F2C2: variable 'a14' is possibly undefined
// 1F2EC: variable 'v17' is possibly undefined
// 1F535: variable 'v31' is possibly undefined
// 1F535: variable 'v32' is possibly undefined
// 1F596: variable '_RDX' is possibly undefined
// 80: using guessed type __int64 qword_80;
// 8C8: using guessed type Elf64_Rela;
// 1CDA0: using guessed type __int64 sub_1CDA0(const char *, ...);
// 1D1E0: using guessed type __int64 __fastcall sub_1D1E0(_QWORD, _QWORD, _QWORD, _QWORD);
// BE628: using guessed type __int64 qword_BE628;
// BE648: using guessed type void *off_BE648;
// BE658: using guessed type __int64 qword_BE658;
// BE660: using guessed type __int64 qword_BE660;
// BEF50: using guessed type int *off_BEF50[2];
// C1220: using guessed type __int64 qword_C1220;
// C1228: using guessed type __int64 qword_C1228;
// C1248: using guessed type __int64 qword_C1248;
// C1258: using guessed type __int64 qword_C1258;

//----- (000000000001F5F0) ----------------------------------------------------
unsigned __int64 sub_1F5F0()
{
  u32 *v0; // rax
  char *v2; // [rsp+0h] [rbp-18h] BYREF
  unsigned __int64 v3; // [rsp+8h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  dword_BE624 = 0;
  __writefsqword(0xFFFFFFD8, (unsigned __int64)&dword_BE6E0);
  v0 = &dword_BE6E0 + 24;
  do
  {
    *((_QWORD *)v0 + 3) = v0;
    *((_QWORD *)v0 + 2) = v0;
    v0 += 4;
  }
  while ( v0 != &dword_BE6E0 + 532 );
  qword_C1258 = 128LL;
  dword_BE6E8 = 0;
  qword_BE740 = (__int64)(&dword_BE6E0 + 24);
  sub_4E120(0x1Du, &v2, (__int64 (__fastcall *)(char **))sub_1D3A0);
  sub_4E120(0xAu, &v2, (__int64 (__fastcall *)(char **))sub_1CB50);
  sub_4E120(3u, &v2, (__int64 (__fastcall *)(char **))sub_1CBC0);
  sub_4E120(0x16u, &v2, (__int64 (__fastcall *)(char **))sub_1CB70);
  sub_4E120(2u, &v2, (__int64 (__fastcall *)(char **))sub_1CB30);
  sub_4E120(0xFu, &v2, (__int64 (__fastcall *)(char **))sub_1CBA0);
  sub_4E120(0x15u, &v2, (__int64 (__fastcall *)(char **))sub_1C810);
  sub_4E120(0x19u, &v2, (__int64 (__fastcall *)(char **))sub_1C820);
  sub_4E120(0x1Cu, &v2, (__int64 (__fastcall *)(char **))sub_1C830);
  sub_4E120(0x18u, &v2, (__int64 (__fastcall *)(char **))sub_1C870);
  sub_4E120(0x11u, &v2, (__int64 (__fastcall *)(char **))sub_1C890);
  sub_4E120(8u, &v2, (__int64 (__fastcall *)(char **))sub_1CBD0);
  dword_BE624 = 1;
  return v3 - __readfsqword(0x28u);
}
// BE624: using guessed type int dword_BE624;
// BE6E8: using guessed type int dword_BE6E8;
// BE740: using guessed type __int64 qword_BE740;
// C1258: using guessed type __int64 qword_C1258;

//----- (000000000001F780) ----------------------------------------------------
u32 *__fastcall sub_1F780(u32 *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  u32 *result; // rax
  u32 *v16; // rbp
  __int64 v17; // rdx
  __int64 v18; // rcx
  u32 *v19; // r8
  u32 v20; // er9
  double v21; // xmm4_8
  double v22; // xmm5_8
  signed __int64 v23; // rax
  signed __int64 v24; // rax

  if ( a1 == &dword_BE6E0 )
  {
    v16 = (u32 *)a2;
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedExchange((volatile __int32 *)a1, 0) > 1 )
      {
        a2 = 129LL;
        v24 = sys_futex(a1, 129, 1u, 0LL, a5, a6);
      }
    }
    else
    {
      --*a1;
    }
    result = (u32 *)sub_1D210((__int64)a1, a2, a3, a4, a5, a6);
    if ( !result )
      result = sub_1F070(v16, &dword_BE6E0, a7, a8, a9, a10, v21, v22, a13, a14, v17, v18, v19, v20);
  }
  else
  {
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedExchange((volatile __int32 *)a1, 0) > 1 )
      {
        a2 = 129LL;
        v23 = sys_futex(a1, 129, 1u, 0LL, a5, a6);
      }
    }
    else
    {
      --*a1;
    }
    if ( __readfsdword(0x18u) )
    {
      result = &dword_BE6E0;
      if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_BE6E0, 1, 0) )
      {
        sub_1C7D0((volatile __int32 *)&dword_BE6E0, a2, 1LL, a4, a5, a6);
        result = &dword_BE6E0;
      }
    }
    else
    {
      _EDX = 1;
      __asm { cmpxchg cs:dword_BE6E0, edx }
      result = &dword_BE6E0;
    }
  }
  return result;
}
// 1F7E2: variable 'a3' is possibly undefined
// 1F7E2: variable 'a4' is possibly undefined
// 1F7E2: variable 'a5' is possibly undefined
// 1F7E2: variable 'a6' is possibly undefined
// 1F7FB: variable 'v21' is possibly undefined
// 1F7FB: variable 'v22' is possibly undefined
// 1F7FB: variable 'v17' is possibly undefined
// 1F7FB: variable 'v18' is possibly undefined
// 1F7FB: variable 'v19' is possibly undefined
// 1F7FB: variable 'v20' is possibly undefined

//----- (000000000001F880) ----------------------------------------------------
unsigned __int64 __fastcall sub_1F880(const char *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  unsigned __int64 v10; // r14
  const char *v11; // rbx
  __int64 v12; // r12
  unsigned __int64 v13; // r13
  __int64 v14; // rdx
  unsigned __int64 v15; // rbp
  const char *v16; // rdx
  unsigned __int64 i; // r15
  const char *v18; // rax
  __int64 v19; // rcx
  unsigned __int64 v20; // r9
  unsigned __int64 v21; // r8
  unsigned __int64 v22; // rdi
  unsigned __int16 v23; // r11
  unsigned __int64 v24; // r13
  const char *v25; // rcx
  __int64 v26; // rsi
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // rcx
  unsigned __int64 v30; // r10
  unsigned __int64 v31; // rdi
  unsigned __int64 v32; // rsi
  unsigned __int64 v33; // rax
  int v34; // er9
  __int64 v35; // rsi
  __int64 v37; // rcx
  unsigned __int64 v38; // r9
  unsigned __int64 v39; // r10
  __int64 v40; // rax
  __int64 v41; // r8
  unsigned __int64 v42; // r11
  unsigned __int64 v43; // rcx
  unsigned __int64 v44; // rcx
  unsigned __int16 v45; // ax
  __int64 v46; // rdx
  unsigned __int64 v48; // rdx
  __int64 v50; // rax
  __int64 v51; // r11
  const char *v52; // r9
  const char *v53; // rax
  unsigned __int64 v54; // r11
  __int64 v55; // r8
  unsigned __int64 v56; // rcx
  unsigned __int64 *v57; // r10
  unsigned __int64 v58; // rsi
  unsigned __int64 v59; // rdx
  int v60; // edx
  const char *v61; // rsi
  const char *v62; // rdi
  const char *v63; // rsi
  unsigned __int64 v64; // rdi
  unsigned __int64 v65; // rdx
  unsigned __int64 v66; // rdx
  const char *v67; // rdi
  const char *v68; // r10
  unsigned __int64 v69; // rcx
  const char *v70; // rax
  _QWORD *v71; // rdx
  __int64 v72; // rdx
  const char *v73; // rdi
  unsigned int v74; // eax
  __int64 v75; // r8
  unsigned __int64 j; // rsi
  unsigned int v77; // ecx
  unsigned __int64 v78; // rax
  int v79; // eax
  const char *v80; // rdx
  unsigned __int64 v81; // rcx
  __int64 v82; // rsi
  unsigned __int64 v83; // rsi
  unsigned __int64 v84; // rsi
  __int64 v85; // rcx
  double v86; // xmm4_8
  double v87; // xmm5_8
  unsigned __int64 v88; // r14
  __int64 v89; // rdx
  _QWORD *v90; // rax
  unsigned int v91; // eax
  __int64 v92; // r12
  unsigned __int64 v93; // r13
  double v94; // xmm4_8
  double v95; // xmm5_8
  unsigned __int64 v96; // r14
  __int64 v97; // rdx
  _QWORD *v98; // rax
  unsigned __int64 v99; // [rsp+0h] [rbp-A8h]
  const char *v100; // [rsp+0h] [rbp-A8h]
  unsigned __int64 v101; // [rsp+8h] [rbp-A0h]
  unsigned __int64 v102; // [rsp+10h] [rbp-98h]
  const char *v103; // [rsp+10h] [rbp-98h]
  __int64 v104; // [rsp+18h] [rbp-90h]
  int v105; // [rsp+20h] [rbp-88h]
  bool v106; // [rsp+27h] [rbp-81h]
  unsigned __int64 v107; // [rsp+28h] [rbp-80h]
  unsigned __int64 v108; // [rsp+30h] [rbp-78h]
  unsigned __int64 v109; // [rsp+38h] [rbp-70h]
  int v110; // [rsp+40h] [rbp-68h]
  int v111; // [rsp+44h] [rbp-64h]
  unsigned __int64 v112; // [rsp+48h] [rbp-60h]
  unsigned __int64 v113; // [rsp+50h] [rbp-58h]
  unsigned __int64 v114; // [rsp+58h] [rbp-50h]
  int v115; // [rsp+60h] [rbp-48h]
  int v116; // [rsp+64h] [rbp-44h]
  int v117; // [rsp+68h] [rbp-40h]
  int v118; // [rsp+6Ch] [rbp-3Ch]

  if ( a2 < 0 )
  {
    i = 0LL;
    __writefsdword(0xFFFFFFC0, 0xCu);
    return i;
  }
  v11 = a1;
  v12 = a2;
  if ( (unsigned __int64)(a2 + 23) > 0x1F )
  {
    v28 = (a2 + 23) & 0xFFFFFFFFFFFFFFF0LL;
    v15 = v28;
    if ( !a1 )
      goto LABEL_89;
    v13 = (unsigned int)v28 >> 4;
    if ( v28 > qword_C1258 )
    {
      if ( v28 > 0x3FF )
      {
        v29 = v28 >> 12;
        v30 = v28 >> 15;
        v31 = v28 >> 6;
        v32 = v28 >> 9;
        i = (unsigned int)(v28 >> 15) + 119;
        v113 = v28 >> 12;
        v33 = v28 >> 18;
        v112 = v30;
        if ( v15 > (unsigned __int64)off_BFFF8 + 7 )
          LODWORD(v33) = 2;
        v109 = v31;
        v114 = v32;
        v34 = v33 + 124;
        v111 = v31 + 48;
        v118 = v33 + 124;
        v116 = i;
        v117 = v29 + 110;
        v115 = v32 + 91;
        v105 = v31 + 48;
        if ( v31 > 0x30 )
        {
          v105 = v32 + 91;
          if ( v32 > 0x14 )
          {
            v105 = v29 + 110;
            if ( v29 > 0xA )
            {
              if ( v30 < 5 )
                v34 = i;
              v105 = v34;
            }
          }
        }
        if ( *((_DWORD *)v11 + 2) )
          sub_1DAE0((__int64)v11, a3, a4, a5, a6, a7, a8, a9, a10, v32);
        goto LABEL_58;
      }
      goto LABEL_152;
    }
    v50 = (unsigned int)(v13 - 2);
    a1 += 8 * v50;
    v35 = 8 * v50 + 16;
    i = *((_QWORD *)a1 + 2);
    if ( i )
      goto LABEL_29;
  }
  else
  {
    if ( !a1 )
      goto LABEL_88;
    if ( (unsigned __int64)qword_C1258 <= 0x1F )
    {
      v13 = 2LL;
      v14 = 128LL;
      v15 = 32LL;
      goto LABEL_6;
    }
    v35 = 16LL;
    v13 = 2LL;
    v15 = 32LL;
    i = *((_QWORD *)a1 + 2);
    if ( i )
    {
LABEL_29:
      if ( (i & 0xF) != 0 )
      {
        sub_1CC00((__int64)"malloc(): unaligned fastbin chunk detected 2", a3, a4, a5, a6, a7, a8, a9, a10);
        goto LABEL_151;
      }
      _RSI = &v11[v35];
      v37 = *(_QWORD *)(i + 16);
      if ( __readfsdword(0x18u) )
      {
        v48 = (i + 16) >> 12;
        _R8 = v37 ^ v48;
        if ( v48 != v37 && (_R8 & 0xF) != 0 )
          goto LABEL_48;
LABEL_43:
        if ( __readfsdword(0x18u) )
          __asm { lock }
        __asm { cmpxchg [rsi], r8 }
      }
      else
      {
        *((_QWORD *)a1 + 2) = v37 ^ ((i + 16) >> 12);
      }
      if ( *(_DWORD *)(i + 8) >> 4 != (_DWORD)v13 )
      {
        v73 = "malloc(): memory corruption (fast)";
        sub_1CC00((__int64)"malloc(): memory corruption (fast)", a3, a4, a5, a6, a7, a8, a9, a10);
        goto LABEL_129;
      }
      v10 = __readfsqword(0xFFFFFFC8);
      v38 = (v15 - 17) >> 4;
      if ( v10 )
      {
        if ( (unsigned __int64)off_BE690 > v38 )
        {
          v39 = v38 + 16;
          if ( *(unsigned __int16 *)(v10 + 2 * v38) < (unsigned __int64)qword_BE6A0 )
          {
            do
            {
              v46 = *((_QWORD *)a1 + 2);
              if ( !v46 )
                break;
              if ( (v46 & 0xF) != 0 )
              {
                a1 = "malloc(): unaligned fastbin chunk detected 3";
                sub_1CC00((__int64)"malloc(): unaligned fastbin chunk detected 3", a3, a4, a5, a6, a7, a8, a9, a10);
                goto LABEL_43;
              }
              LODWORD(v11) = __readfsdword(0x18u);
              v40 = v46 + 16;
              v41 = *(_QWORD *)(v46 + 16);
              v42 = v46 + 16;
              v43 = (unsigned __int64)(v46 + 16) >> 12;
              v15 = v43 ^ v41;
              if ( (_DWORD)v11 )
              {
                v43 = v42 >> 12;
                _R11 = v41 ^ (v42 >> 12);
                if ( v43 != v41 )
                {
                  while ( (_R11 & 0xF) != 0 )
                  {
LABEL_48:
                    a1 = "malloc(): unaligned fastbin chunk detected";
                    sub_1CC00((__int64)"malloc(): unaligned fastbin chunk detected", a3, a4, a5, a6, a7, a8, a9, a10);
                  }
                }
                if ( __readfsdword(0x18u) )
                  __asm { lock }
                __asm { cmpxchg [rsi], r11 }
                v40 = v46 + 16;
              }
              else
              {
                *((_QWORD *)a1 + 2) = v15;
              }
              v44 = *(_QWORD *)(v10 + 8 * v39) ^ v43;
              *(_QWORD *)(v46 + 24) = v10;
              *(_QWORD *)(v46 + 16) = v44;
              *(_QWORD *)(v10 + 8 * v39) = v40;
              v45 = *(_WORD *)(v10 + 2 * v38) + 1;
              *(_WORD *)(v10 + 2 * v38) = v45;
            }
            while ( v45 < (unsigned __int64)qword_BE6A0 );
          }
        }
      }
LABEL_16:
      v26 = (unsigned int)dword_C1254;
      i += 16LL;
      if ( !dword_C1254 )
        return i;
      goto LABEL_91;
    }
  }
  v14 = 8LL * (unsigned int)(2 * v13 + 12);
LABEL_6:
  while ( 2 )
  {
    v16 = &v11[v14];
    i = *((_QWORD *)v16 + 1);
    v18 = v16 - 16;
    if ( v16 - 16 == (const char *)i )
    {
      v105 = v13;
      v117 = 110;
      v109 = v15 >> 6;
      v114 = v15 >> 9;
      v115 = (v15 >> 9) + 91;
      v111 = (v15 >> 6) + 48;
      v116 = 119;
      v118 = 124;
      v112 = 0LL;
      v113 = 0LL;
LABEL_58:
      v51 = 0LL;
      v101 = (v15 - 17) >> 4;
      if ( __readfsqword(0xFFFFFFC8) && (unsigned __int64)off_BE690 > (v15 - 17) >> 4 )
        v51 = v15;
      v99 = 0LL;
      v52 = v11 + 96;
      v110 = v13;
      v104 = v12;
      v12 = v51;
      goto LABEL_62;
    }
    v19 = *(_QWORD *)(i + 24);
    if ( *(_QWORD *)(v19 + 16) == i )
    {
      *(_QWORD *)(i + v15 + 8) |= 1uLL;
      *((_QWORD *)v16 + 1) = v19;
      *(_QWORD *)(v19 + 16) = v18;
      if ( v11 != (const char *)&dword_BE6E0 )
        *(_QWORD *)(i + 8) |= 4uLL;
      v20 = __readfsqword(0xFFFFFFC8);
      if ( v20 )
      {
        v21 = (v15 - 17) >> 4;
        if ( (unsigned __int64)off_BE690 > v21 )
        {
          v22 = qword_BE6A0;
          v23 = *(_WORD *)(v20 + 2 * v21);
          v24 = v21 + 16;
          while ( v23 < v22 )
          {
            v25 = (const char *)*((_QWORD *)v16 + 1);
            if ( v18 == v25 )
              break;
            if ( v25 )
            {
              v82 = *((_QWORD *)v25 + 3);
              *(_QWORD *)&v25[v15 + 8] |= 1uLL;
              if ( v11 != (const char *)&dword_BE6E0 )
                *((_QWORD *)v25 + 1) |= 4uLL;
              *((_QWORD *)v16 + 1) = v82;
              ++v23;
              *(_QWORD *)(v82 + 16) = v18;
              v83 = *(_QWORD *)(v20 + 8 * v24) ^ ((unsigned __int64)(v25 + 16) >> 12);
              *((_QWORD *)v25 + 3) = v20;
              *((_QWORD *)v25 + 2) = v83;
              *(_QWORD *)(v20 + 8 * v24) = v25 + 16;
              *(_WORD *)(v20 + 2 * v21) = v23;
            }
          }
        }
      }
      goto LABEL_16;
    }
    v53 = (const char *)sub_1CC00(
                          (__int64)"malloc(): smallbin double linked list corrupted",
                          a3,
                          a4,
                          a5,
                          a6,
                          a7,
                          a8,
                          a9,
                          a10);
LABEL_154:
    v84 = *((_QWORD *)v68 + 1);
    if ( (v84 & 4) != 0 )
      goto LABEL_205;
    while ( v69 < v84 )
    {
      v68 = (const char *)*((_QWORD *)v68 + 4);
      v84 = *((_QWORD *)v68 + 1);
      if ( (v84 & 4) != 0 )
        sub_1CDA0("chunk_main_arena (fwd)", "malloc.c", 3884LL, "_int_malloc", v55, a3, a4, a5, a6, a7, a8, a9, a10);
    }
    if ( v69 == v84 )
    {
      v63 = (const char *)*((_QWORD *)v68 + 2);
    }
    else
    {
      v85 = *((_QWORD *)v68 + 5);
      *((_QWORD *)v53 + 4) = v68;
      *((_QWORD *)v53 + 5) = v85;
      if ( *(const char **)(*((_QWORD *)v68 + 5) + 32LL) != v68 )
        goto LABEL_176;
      *((_QWORD *)v68 + 5) = v53;
      v63 = v68;
      *(_QWORD *)(*((_QWORD *)v53 + 5) + 32LL) = v53;
    }
    v62 = (const char *)*((_QWORD *)v63 + 3);
    if ( *((const char **)v62 + 2) != v63 )
    {
      sub_1CC00((__int64)"malloc(): largebin double linked list corrupted (bk)", a3, a4, a5, a6, a7, a8, a9, a10);
      goto LABEL_207;
    }
    LOBYTE(v56) = v60;
LABEL_77:
    ++v99;
    *(_DWORD *)&v11[4 * (v60 >> 5) + 2144] |= 1 << v56;
    *((_QWORD *)v53 + 3) = v62;
    *((_QWORD *)v53 + 2) = v63;
    *((_QWORD *)v63 + 3) = v53;
    *((_QWORD *)v62 + 2) = v53;
    if ( (_DWORD)v13 )
    {
      if ( v54 < v99 && v106 )
      {
        i = *(_QWORD *)(v10 + 8 * (v101 + 16));
        if ( (i & 0xF) == 0 )
        {
          *(_QWORD *)(v10 + 8 * (v101 + 16)) = *(_QWORD *)i ^ (i >> 12);
          --*(_WORD *)(v10 + 2 * v101);
          *(_QWORD *)(i + 8) = 0LL;
          return i;
        }
      }
      else
      {
        v55 = (unsigned int)(v55 + 1);
        if ( (int)v55 <= 9999 )
        {
          v53 = (const char *)*((_QWORD *)v11 + 15);
          goto LABEL_84;
        }
LABEL_180:
        v11 = (const char *)v101;
        i = *(_QWORD *)(v10 + 8 * (v101 + 16));
        if ( (i & 0xF) == 0 )
        {
          *(_QWORD *)(v10 + 8 * (v101 + 16)) = *(_QWORD *)i ^ (i >> 12);
          --*(_WORD *)(v10 + 2 * v101);
          *(_QWORD *)(i + 8) = 0LL;
          return i;
        }
      }
LABEL_188:
      v70 = (const char *)sub_1CC00(
                            (__int64)"malloc(): unaligned tcache chunk detected",
                            a3,
                            a4,
                            a5,
                            a6,
                            a7,
                            a8,
                            a9,
                            a10);
LABEL_189:
      v92 = v104;
      for ( i = v71[5]; ; i = *(_QWORD *)(i + 40) )
      {
        v93 = *(_QWORD *)(i + 8) & 0xFFFFFFFFFFFFFFF8LL;
        if ( v15 <= v93 )
          break;
      }
      if ( *((_QWORD *)v70 + 1) != i && *(_QWORD *)(i + 8) == *(_QWORD *)(*(_QWORD *)(i + 16) + 8LL) )
        i = *(_QWORD *)(i + 16);
      v99 = (unsigned __int64)v52;
      sub_1DA10((_QWORD *)i, a3, a4, a5, a6, a7, a8, a9, a10);
      v96 = v93 - v15;
      if ( v93 - v15 <= 0x1F )
      {
        *(_QWORD *)(i + v93 + 8) |= 1uLL;
        if ( v11 != (const char *)&dword_BE6E0 )
          *(_QWORD *)(i + 8) |= 4uLL;
      }
      else
      {
        v97 = *((_QWORD *)v11 + 14);
        v98 = (_QWORD *)(i + v15);
        if ( *(_QWORD *)(v97 + 24) != v99 )
        {
          sub_1CC00((__int64)"malloc(): corrupted unsorted chunks", a3, a4, a5, a6, v94, v95, a9, a10);
LABEL_205:
          sub_1CDA0(
            "chunk_main_arena (fwd)",
            "malloc.c",
            3880LL,
            "_int_malloc",
            v55,
            a3,
            a4,
            a5,
            a6,
            a7,
            a8,
            a9,
            a10,
            v99);
        }
        v98[3] = v99;
        v98[2] = v97;
        *((_QWORD *)v11 + 14) = v98;
        *(_QWORD *)(v97 + 24) = v98;
        if ( v96 > 0x3FF )
        {
          v98[4] = 0LL;
          v98[5] = 0LL;
        }
        *(_QWORD *)(i + 8) = v15 | (4LL * (v11 != (const char *)&dword_BE6E0)) | 1;
        v98[1] = v96 | 1;
        *(_QWORD *)(i + v93) = v96;
      }
LABEL_183:
      i += 16LL;
LABEL_184:
      sub_1D050(i, v92);
      return i;
    }
    v55 = (unsigned int)(v55 + 1);
    if ( (int)v55 <= 9999 )
    {
      v53 = (const char *)*((_QWORD *)v11 + 15);
      if ( v53 != v52 )
      {
        while ( 1 )
        {
LABEL_64:
          v56 = *((_QWORD *)v53 + 1) & 0xFFFFFFFFFFFFFFF8LL;
          v57 = (unsigned __int64 *)&v53[v56];
          if ( v56 <= 0x10 || (v58 = *((_QWORD *)v11 + 273), v58 < v56) )
          {
            sub_1CC00((__int64)"malloc(): invalid size (unsorted)", a3, a4, a5, a6, a7, a8, a9, a10);
LABEL_88:
            v15 = 32LL;
LABEL_89:
            i = (unsigned __int64)sub_1E6C0(v15, 0LL, a3, a4, a5, a6, a7, a8, a9, a10);
            if ( !i )
              return i;
LABEL_90:
            v26 = (unsigned int)dword_C1254;
            if ( !dword_C1254 )
              return i;
LABEL_91:
            LOBYTE(v26) = ~(_BYTE)v26;
            sub_9190(i, v26, v12);
            return i;
          }
          v59 = v57[1];
          if ( v59 > 0xF && v58 >= v59 )
            break;
          v53 = (const char *)sub_1CC00(
                                (__int64)"malloc(): invalid next size (unsorted)",
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                a9,
                                a10);
LABEL_93:
          v57[1] = v59 | 1;
          if ( v11 != (const char *)&dword_BE6E0 )
            *((_QWORD *)v53 + 1) |= 4uLL;
          i = (unsigned __int64)(v53 + 16);
          if ( !v12 || (v64 = v101, v65 = *(unsigned __int16 *)(v10 + 2 * v101), v65 >= v102) )
          {
            v12 = v104;
            goto LABEL_90;
          }
LABEL_123:
          *((_QWORD *)v53 + 3) = v10;
          *((_QWORD *)v53 + 2) = *(_QWORD *)(v10 + 8 * v107) ^ (i >> 12);
          v53 = (const char *)v58;
          *(_QWORD *)(v10 + 8 * v107) = i;
          *(_WORD *)(v10 + 2 * v64) = v65 + 1;
LABEL_84:
          if ( v52 == v53 )
            goto LABEL_180;
          v13 = 1LL;
        }
        v58 = *v57 & 0xFFFFFFFFFFFFFFF8LL;
        if ( v58 == v56 )
        {
          v58 = *((_QWORD *)v53 + 3);
          if ( v53 != *(const char **)(v58 + 16) || *((const char **)v53 + 2) != v52 )
          {
            v64 = (unsigned __int64)"malloc(): unsorted double linked list corrupted";
            v53 = (const char *)sub_1CC00(
                                  (__int64)"malloc(): unsorted double linked list corrupted",
                                  a3,
                                  a4,
                                  a5,
                                  a6,
                                  a7,
                                  a8,
                                  a9,
                                  a10);
            goto LABEL_123;
          }
          if ( (v59 & 1) != 0 )
          {
LABEL_151:
            sub_1CC00((__int64)"malloc(): invalid next->prev_inuse (unsorted)", a3, a4, a5, a6, a7, a8, a9, a10);
LABEL_152:
            v14 = 8LL * (unsigned int)(2 * v13 - 2) + 112;
            continue;
          }
          if ( v15 > 0x3FF || (const char *)v58 != v52 )
            goto LABEL_74;
        }
        else
        {
          v53 = (const char *)sub_1CC00(
                                (__int64)"malloc(): mismatching next->prev_size (unsorted)",
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                a9,
                                a10);
        }
        if ( v53 == *((const char **)v11 + 13) && v108 < v56 )
        {
          v80 = &v53[v15];
          v81 = v56 - v15;
          *((_QWORD *)v11 + 14) = &v53[v15];
          *((_QWORD *)v11 + 15) = &v53[v15];
          *((_QWORD *)v11 + 13) = &v53[v15];
          *((_QWORD *)v80 + 2) = v52;
          *((_QWORD *)v80 + 3) = v52;
          if ( v81 > 0x3FF )
          {
            *((_QWORD *)v80 + 4) = 0LL;
            *((_QWORD *)v80 + 5) = 0LL;
          }
          i = (unsigned __int64)(v53 + 16);
          *((_QWORD *)v53 + 1) = v15 | (4LL * (v11 != (const char *)&dword_BE6E0)) | 1;
          *((_QWORD *)v80 + 1) = v81 | 1;
          *v57 = v81;
          sub_1D050((__int64)(v53 + 16), v104);
          return i;
        }
LABEL_74:
        *((_QWORD *)v11 + 15) = v58;
        *(_QWORD *)(v58 + 16) = v52;
        if ( v15 != v56 )
        {
          if ( v56 <= 0x3FF )
          {
            LODWORD(v56) = (unsigned int)v56 >> 4;
            v60 = v56;
            v61 = &v11[16 * (int)v56 + 96];
            v62 = v61 - 16;
            v63 = *(const char **)v61;
            goto LABEL_77;
          }
          v60 = (v56 >> 6) + 48;
          if ( v56 > 0xC3F )
          {
            v60 = (v56 >> 9) + 91;
            if ( v56 > 0x29FF )
            {
              v60 = (v56 >> 12) + 110;
              if ( v56 > 0xAFFF )
              {
                v60 = (v56 >> 15) + 119;
                if ( v56 > (unsigned __int64)&loc_27FFD + 2 )
                {
                  v66 = v56 >> 18;
                  if ( v56 > (unsigned __int64)off_BFFF8 + 7 )
                    LODWORD(v66) = 2;
                  v60 = v66 + 124;
                }
              }
            }
          }
          v67 = &v11[16 * v60 + 96];
          v68 = *(const char **)v67;
          v63 = v67 - 16;
          if ( v67 - 16 != *(const char **)v67 )
          {
            v62 = (const char *)*((_QWORD *)v67 + 1);
            v69 = v56 | 1;
            i = *((_QWORD *)v62 + 1);
            if ( (i & 4) != 0 )
              sub_1CDA0(
                "chunk_main_arena (bck->bk)",
                "malloc.c",
                3867LL,
                "_int_malloc",
                v55,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10);
            if ( i > v69 )
            {
              v56 = *((_QWORD *)v68 + 5);
              *((_QWORD *)v53 + 4) = v68;
              *((_QWORD *)v53 + 5) = v56;
              *(_QWORD *)(v56 + 32) = v53;
              LOBYTE(v56) = v60;
              *((_QWORD *)v68 + 5) = v53;
              goto LABEL_77;
            }
            goto LABEL_154;
          }
          *((_QWORD *)v53 + 5) = v53;
          LOBYTE(v56) = v60;
          v62 = v67 - 16;
          *((_QWORD *)v53 + 4) = v53;
          goto LABEL_77;
        }
        goto LABEL_93;
      }
    }
    break;
  }
LABEL_111:
  if ( v15 > 0x3FF )
  {
    v70 = &v11[8 * (2 * v105 + 12)];
    v71 = *(_QWORD **)v70;
    if ( *(const char **)v70 != v70 - 16 && v15 <= v71[1] )
      goto LABEL_189;
  }
  v72 = (__int64)&v11[8 * (2 * v105 + 14) - 16];
  LODWORD(v73) = (unsigned int)(v105 + 1) >> 5;
  v74 = 1 << (v105 + 1);
  v75 = (unsigned int)v73;
  for ( j = *(unsigned int *)&v11[4 * (unsigned int)v73 + 2144]; ; *(_DWORD *)&v11[4 * v75 + 2144] = j )
  {
    if ( v74 > (unsigned int)j || !v74 )
    {
      while ( 1 )
      {
        LODWORD(v73) = (_DWORD)v73 + 1;
        if ( (_DWORD)v73 == 4 )
          break;
LABEL_129:
        v75 = (unsigned int)v73;
        j = *(unsigned int *)&v11[4 * (unsigned int)v73 + 2144];
        if ( (_DWORD)j )
        {
          v72 = (__int64)&v11[8 * (((_DWORD)v73 << 6) + 12) - 16];
          v74 = 1;
          goto LABEL_119;
        }
      }
      i = *((_QWORD *)v11 + 12);
      v78 = *(_QWORD *)(i + 8) & 0xFFFFFFFFFFFFFFF8LL;
      if ( *((_QWORD *)v11 + 273) < v78 )
      {
        sub_1CC00((__int64)"malloc(): corrupted top size", a3, a4, a5, a6, a7, a8, a9, a10);
LABEL_176:
        sub_1CC00(
          (__int64)"malloc(): largebin double linked list corrupted (nextsize)",
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          a9,
          a10);
LABEL_177:
        *(_QWORD *)(i + v13 + 8) |= 1uLL;
        if ( v11 != (const char *)&dword_BE6E0 )
          *(_QWORD *)(i + 8) |= 4uLL;
        goto LABEL_173;
      }
      if ( v15 + 32 <= v78 )
      {
        v92 = v104;
        *((_QWORD *)v11 + 12) = i + v15;
        *(_QWORD *)(i + 8) = v15 | (4LL * (v11 != (const char *)&dword_BE6E0)) | 1;
        *(_QWORD *)(i + v15 + 8) = (v78 - v15) | 1;
        goto LABEL_183;
      }
      v103 = v52;
      if ( !*((_DWORD *)v11 + 2) )
      {
        v92 = v104;
        i = (unsigned __int64)sub_1E6C0(v15, (__int64)v11, a3, a4, a5, a6, a7, a8, a9, a10);
        if ( !i )
          return i;
        goto LABEL_184;
      }
      sub_1DAE0((__int64)v11, a3, a4, a5, a6, a7, a8, a9, a10, j);
      v52 = v103;
      v105 = v110;
      if ( v15 > 0x3FF )
      {
        v105 = v111;
        if ( v109 > 0x30 )
        {
          v105 = v115;
          if ( v114 > 0x14 )
          {
            v105 = v117;
            if ( v113 > 0xA )
            {
              v79 = v116;
              if ( v112 > 4 )
                v79 = v118;
              v105 = v79;
            }
          }
        }
      }
LABEL_62:
      v53 = (const char *)*((_QWORD *)v11 + 15);
      if ( v53 != v52 )
      {
        v54 = qword_BE6A8;
        v106 = qword_BE6A8 != 0;
        v55 = 0LL;
        v13 = 0LL;
        v10 = __readfsqword(0xFFFFFFC8);
        v102 = qword_BE6A0;
        v108 = v15 + 32;
        v107 = v101 + 16;
        goto LABEL_64;
      }
      goto LABEL_111;
    }
LABEL_119:
    while ( ((unsigned int)j & v74) == 0 )
    {
      v72 += 16LL;
      v74 *= 2;
      if ( !v74 )
        sub_1CDA0("bit != 0", "malloc.c", 4045LL, "_int_malloc", a3, a4, a5, a6, a7, a8, a9, a10);
    }
    i = *(_QWORD *)(v72 + 24);
    if ( v72 != i )
      break;
    v77 = v74;
    v72 += 16LL;
    v74 *= 2;
    j = ~v77 & (unsigned int)j;
  }
  v12 = v104;
  v13 = *(_QWORD *)(i + 8) & 0xFFFFFFFFFFFFFFF8LL;
  if ( v15 > v13 )
LABEL_207:
    sub_1CDA0(
      "(unsigned long) (size) >= (unsigned long) (nb)",
      "malloc.c",
      4064LL,
      "_int_malloc",
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      a9,
      a10,
      v99);
  v100 = v52;
  sub_1DA10(*(_QWORD **)(v72 + 24), a3, a4, a5, a6, a7, a8, a9, a10);
  v88 = v13 - v15;
  if ( v13 - v15 <= 0x1F )
    goto LABEL_177;
  v89 = *((_QWORD *)v11 + 14);
  v90 = (_QWORD *)(i + v15);
  if ( *(const char **)(v89 + 24) != v100 )
  {
    sub_1CC00((__int64)"malloc(): corrupted unsorted chunks 2", a3, a4, a5, a6, v86, v87, a9, a10);
    goto LABEL_188;
  }
  v90[3] = v100;
  v90[2] = v89;
  *((_QWORD *)v11 + 14) = v90;
  *(_QWORD *)(v89 + 24) = v90;
  if ( v15 <= 0x3FF )
    *((_QWORD *)v11 + 13) = v90;
  if ( v88 > 0x3FF )
  {
    v90[4] = 0LL;
    v90[5] = 0LL;
  }
  *(_QWORD *)(i + 8) = v15 | (4LL * (v11 != (const char *)&dword_BE6E0)) | 1;
  v90[1] = v88 | 1;
  *(_QWORD *)(i + v13) = v88;
LABEL_173:
  v91 = dword_C1254;
  i += 16LL;
  if ( dword_C1254 )
  {
    LOBYTE(v91) = ~(_BYTE)dword_C1254;
    sub_9190(i, v91, v12);
  }
  return i;
}
// 1FB5C: variable 'v10' is possibly undefined
// 1FB5C: variable 'v39' is possibly undefined
// 1FB5C: variable 'v43' is possibly undefined
// 1FB60: variable 'v46' is possibly undefined
// 1FB6C: variable 'v38' is possibly undefined
// 1FBA2: variable 'a7' is possibly undefined
// 1FBA2: variable 'a8' is possibly undefined
// 1FC08: variable '_R11' is possibly undefined
// 1FD66: variable 'v101' is possibly undefined
// 1FDCA: variable 'v52' is possibly undefined
// 1FDF6: variable 'v56' is possibly undefined
// 1FE29: variable 'v99' is possibly undefined
// 1FE20: variable 'v60' is possibly undefined
// 1FE5C: variable 'v54' is possibly undefined
// 1FE63: variable 'v106' is possibly undefined
// 1FEA8: variable 'v55' is possibly undefined
// 1FF50: variable 'v59' is possibly undefined
// 1FF5B: variable 'v57' is possibly undefined
// 1FF84: variable 'v102' is possibly undefined
// 1FF8A: variable 'v104' is possibly undefined
// 2007F: variable 'v105' is possibly undefined
// 2013B: variable 'v107' is possibly undefined
// 20130: variable 'v65' is possibly undefined
// 20201: variable 'v110' is possibly undefined
// 20215: variable 'v111' is possibly undefined
// 20219: variable 'v109' is possibly undefined
// 20229: variable 'v115' is possibly undefined
// 2022D: variable 'v114' is possibly undefined
// 2023D: variable 'v117' is possibly undefined
// 20241: variable 'v113' is possibly undefined
// 20247: variable 'v116' is possibly undefined
// 20251: variable 'v112' is possibly undefined
// 20251: variable 'v118' is possibly undefined
// 2027F: variable 'v108' is possibly undefined
// 203A8: variable 'v68' is possibly undefined
// 203D5: variable 'v69' is possibly undefined
// 205FD: variable 'v86' is possibly undefined
// 205FD: variable 'v87' is possibly undefined
// 20613: variable 'v71' is possibly undefined
// 20732: variable 'v94' is possibly undefined
// 20732: variable 'v95' is possibly undefined
// 1CDA0: using guessed type double sub_1CDA0(const char *, ...);
// BE690: using guessed type int *off_BE690;
// BE6A0: using guessed type __int64 qword_BE6A0;
// BE6A8: using guessed type __int64 qword_BE6A8;
// BFFF8: using guessed type __int64 (__fastcall *off_BFFF8[2])();
// C1254: using guessed type int dword_C1254;
// C1258: using guessed type __int64 qword_C1258;

//----- (0000000000020790) ----------------------------------------------------
__int64 __fastcall sub_20790(unsigned __int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14)
{
  double v15; // xmm4_8
  double v16; // xmm5_8
  u32 *v17; // r8
  u32 v18; // er9
  __int64 result; // rax
  signed __int64 v20; // rax

  if ( a1 == -1LL )
  {
    __writefsdword(0xFFFFFFC0, 0xCu);
    result = 0LL;
  }
  else
  {
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_BE6E0, 1, 0) )
        sub_1C7D0((volatile __int32 *)&dword_BE6E0, a2, 1LL, a12, a13, a14);
    }
    else
    {
      _EDX = 1;
      __asm { cmpxchg cs:dword_BE6E0, edx }
    }
    sub_1CC20(a3, a4, a5, a6, a7, a8, a9, a10);
    v17 = (u32 *)sub_1F880((const char *)&dword_BE6E0, a1 + 1, a3, a4, a5, a6, v15, v16, a9, a10);
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedExchange((volatile __int32 *)&dword_BE6E0, 0) > 1 )
        v20 = sys_futex(&dword_BE6E0, 129, 1u, 0LL, v17, v18);
    }
    else
    {
      --dword_BE6E0;
    }
    result = sub_1C8A0((__int64)v17, a1);
  }
  return result;
}
// 207C3: variable 'a7' is possibly undefined
// 207C3: variable 'a8' is possibly undefined
// 207D2: variable 'v15' is possibly undefined
// 207D2: variable 'v16' is possibly undefined
// 207FA: variable 'v17' is possibly undefined
// 20846: variable 'v18' is possibly undefined

//----- (0000000000020860) ----------------------------------------------------
_QWORD *__fastcall sub_20860(u32 *uaddr, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  unsigned __int64 v11; // rdx
  unsigned __int64 v13; // r15
  unsigned __int64 v14; // rax
  u32 *v15; // r8
  __int64 v16; // r9
  double v17; // xmm4_8
  double v18; // xmm5_8
  _QWORD *v19; // r12
  unsigned __int64 v20; // rsi
  unsigned __int64 *v21; // r13
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // r14
  __int64 v24; // rax
  __int64 v25; // rdx
  __int64 v26; // rax
  unsigned __int64 v27; // rax
  unsigned __int64 v28; // rax
  unsigned __int64 v29; // r8
  unsigned __int64 v31; // rcx

  if ( a3 < 0 )
  {
    v19 = 0LL;
    __writefsdword(0xFFFFFFC0, 0xCu);
  }
  else
  {
    v11 = a3 + 23;
    v13 = v11 & 0xFFFFFFFFFFFFFFF0LL;
    if ( v11 <= 0x1F )
      v13 = 32LL;
    v14 = sub_1F880((const char *)uaddr, v13 + a2 + 32, a4, a5, a6, a7, a8, a9, a10, a11);
    v19 = (_QWORD *)v14;
    if ( v14 )
    {
      v20 = v14 - 16;
      if ( v14 % a2 )
      {
        v21 = (unsigned __int64 *)((-a2 & (v14 + a2 - 1)) - 16);
        v22 = (-a2 & (v14 + a2 - 1)) - v14;
        if ( v22 <= 0x1F )
        {
          v21 = (unsigned __int64 *)((char *)v21 + a2);
          v22 = (unsigned __int64)v21 - v20;
        }
        v23 = (*(_QWORD *)(v14 - 8) & 0xFFFFFFFFFFFFFFF8LL) - v22;
        v24 = *(_QWORD *)(v14 - 8) & 2LL;
        if ( (*(v19 - 1) & 2) != 0 )
        {
          v31 = *(v19 - 2) + v22;
          v19 = v21 + 2;
          *v21 = v31;
          v21[1] = v23 | 2;
          return v19;
        }
        v25 = (*(v19 - 1) & 0xFFFFFFFFFFFFFFF8LL) - v22;
        if ( uaddr != &dword_BE6E0 )
        {
          v25 = v23 | 4;
          v24 = 4LL;
        }
        v21[1] = v25 | 1;
        *(unsigned __int64 *)((char *)v21 + v23 + 8) |= 1uLL;
        *(v19 - 1) = v22 | *(v19 - 1) & 7LL | v24;
        sub_1DC90(uaddr, v20, 1u, v22, v15, v16, a4, a5, a6, a7, v17, v18, a10, a11);
        if ( v23 < v13 || (v19 = v21 + 2, (unsigned __int64)(v21 + 2) % a2) )
          sub_1CDA0("newsize >= nb && (((unsigned long) (chunk2mem (p))) % alignment) == 0", a4);
        v20 = (unsigned __int64)v21;
      }
      v26 = *(_QWORD *)(v20 + 8);
      if ( (v26 & 2) == 0 )
      {
        v27 = v26 & 0xFFFFFFFFFFFFFFF8LL;
        if ( v13 + 32 < v27 )
        {
          v28 = v27 - v13;
          v29 = v20 + v13;
          if ( uaddr != &dword_BE6E0 )
            v28 |= 4uLL;
          *(_QWORD *)(v29 + 8) = v28 | 1;
          *(_QWORD *)(v20 + 8) = *(_QWORD *)(v20 + 8) & 7LL | v13;
          sub_1DC90(uaddr, v29, 1u, (unsigned __int64)&dword_BE6E0, (u32 *)v29, v16, a4, a5, a6, a7, v17, v18, a10, a11);
        }
      }
    }
  }
  return v19;
}
// 20938: variable 'v15' is possibly undefined
// 20938: variable 'v16' is possibly undefined
// 20938: variable 'v17' is possibly undefined
// 20938: variable 'v18' is possibly undefined
// 1CDA0: using guessed type double sub_1CDA0(const char *, ...);

//----- (0000000000020A40) ----------------------------------------------------
__int64 __fastcall sub_20A40(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  unsigned __int64 v14; // rbp
  double v16; // xmm4_8
  double v17; // xmm5_8
  u32 *v18; // r8
  u32 v19; // er9
  signed __int64 v21; // rax

  if ( a1 <= 0x10 )
    return sub_20790(a2, 0LL, a7, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6);
  if ( a1 > 0x1F )
  {
    if ( a1 > 0x8000000000000000LL )
    {
      __writefsdword(0xFFFFFFC0, 0x16u);
      return 0LL;
    }
    if ( -33LL - a1 >= a2 )
    {
      if ( (a1 & (a1 - 1)) != 0 )
      {
        v14 = 32LL;
        if ( a1 != 32 )
        {
          do
            v14 *= 2LL;
          while ( a1 > v14 );
        }
      }
      else
      {
        v14 = a1;
      }
      goto LABEL_4;
    }
LABEL_16:
    __writefsdword(0xFFFFFFC0, 0xCu);
    return 0LL;
  }
  v14 = 32LL;
  if ( a2 > 0xFFFFFFFFFFFFFFBFLL )
    goto LABEL_16;
LABEL_4:
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_BE6E0, 1, 0) )
      sub_1C7D0((volatile __int32 *)&dword_BE6E0, a2, 1LL, a4, a5, a6);
  }
  else
  {
    _EDX = 1;
    __asm { cmpxchg cs:dword_BE6E0, edx }
  }
  sub_1CC20(a7, a8, a9, a10, a11, a12, a13, a14);
  v18 = (u32 *)sub_20860(&dword_BE6E0, v14, a2 + 1, a7, a8, a9, a10, v16, v17, a13, a14);
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedExchange((volatile __int32 *)&dword_BE6E0, 0) > 1 )
      v21 = sys_futex(&dword_BE6E0, 129, 1u, 0LL, v18, v19);
  }
  else
  {
    --dword_BE6E0;
  }
  return sub_1C8A0((__int64)v18, a2);
}
// 20A89: variable 'a11' is possibly undefined
// 20A89: variable 'a12' is possibly undefined
// 20A9D: variable 'v16' is possibly undefined
// 20A9D: variable 'v17' is possibly undefined
// 20AC9: variable 'v18' is possibly undefined
// 20B8A: variable 'v19' is possibly undefined

//----- (0000000000020BD0) ----------------------------------------------------
u32 *__fastcall sub_20BD0(u32 *uaddr, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  u32 *v15; // r12
  u32 *v17; // r14
  __int64 v18; // r15
  unsigned __int64 v20; // rdx
  unsigned __int64 v21; // rcx
  unsigned __int64 v22; // rsi
  unsigned __int64 v23; // rax
  u32 *v24; // rax
  unsigned __int64 v25; // rdx
  unsigned __int64 v26; // rax
  unsigned __int64 v28; // rsi
  unsigned __int64 v29; // rax
  unsigned __int64 v30; // rcx
  u32 *v31; // r8
  __int64 v32; // r9
  double v33; // xmm4_8
  double v34; // xmm5_8
  unsigned __int64 v35; // [rsp+8h] [rbp-40h]
  u32 *v36; // [rsp+8h] [rbp-40h]

  v20 = *(_QWORD *)(a2 + 8);
  if ( v20 <= 0x10 || (v21 = *((_QWORD *)uaddr + 273), v15 = uaddr, v21 <= a3) )
  {
    sub_1CC00((__int64)"realloc(): invalid old size", a7, a8, a9, a10, a11, a12, a13, a14);
LABEL_26:
    uaddr = (u32 *)"realloc(): invalid next size";
    v23 = sub_1CC00((__int64)"realloc(): invalid next size", a7, a8, a9, a10, a11, a12, a13, a14);
    goto LABEL_27;
  }
  v18 = *(_QWORD *)(a2 + 8) & 2LL;
  if ( (v20 & 2) != 0 )
    sub_1CDA0(
      "!chunk_is_mmapped (oldp)",
      "malloc.c",
      4595LL,
      "_int_realloc",
      a5,
      a6,
      a7,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14);
  v17 = (u32 *)(a2 + a3);
  v22 = *(_QWORD *)(a2 + a3 + 8);
  v23 = v22 & 0xFFFFFFFFFFFFFFF8LL;
  if ( v21 <= (v22 & 0xFFFFFFFFFFFFFFF8LL) || v22 <= 0x10 )
    goto LABEL_26;
  if ( a3 >= a4 )
  {
LABEL_13:
    v25 = v20 & 7;
    v26 = a3 - a4;
    if ( a3 - a4 > 0x1F )
    {
      v28 = a2 + a4;
      if ( v15 != &dword_BE6E0 )
      {
        v26 |= 4uLL;
        v18 = 4LL;
      }
      *(_QWORD *)(a2 + 8) = v18 | a4 | v25;
      *(_QWORD *)(v28 + 8) = v26 | 1;
      *((_QWORD *)v17 + 1) |= 1uLL;
      sub_1DC90(v15, v28, 1u, (unsigned __int64)&dword_BE6E0, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
    }
    else
    {
      if ( v15 != &dword_BE6E0 )
        v18 = 4LL;
      *(_QWORD *)(a2 + 8) = v18 | a3 | v25;
      *((_QWORD *)v17 + 1) |= 1uLL;
    }
    return (u32 *)(a2 + 16);
  }
  if ( *((u32 **)uaddr + 12) != v17 )
  {
    if ( (*((_BYTE *)v17 + v23 + 8) & 1) == 0 )
    {
      v29 = a3 + v23;
      if ( a4 <= v29 )
      {
        v35 = v29;
        sub_1DA10(v17, a7, a8, a9, a10, a11, a12, a13, a14);
        v20 = *(_QWORD *)(a2 + 8);
        a3 = v35;
        v17 = (u32 *)(a2 + v35);
        goto LABEL_13;
      }
    }
LABEL_9:
    v24 = (u32 *)sub_1F880((const char *)v15, a4 - 15, a7, a8, a9, a10, a11, a12, a13, a14);
    a5 = v24;
    if ( !v24 )
      return a5;
    if ( v17 != v24 - 4 )
    {
      v36 = v24;
      memcpy(v24, (const void *)(a2 + 16), a3 - 8);
      sub_1DC90(v15, a2, 1u, v30, v31, v32, a7, a8, a9, a10, v33, v34, a13, a14);
      return v36;
    }
    a3 += *((_QWORD *)v24 - 1) & 0xFFFFFFFFFFFFFFF8LL;
    if ( a4 > a3 )
      sub_1CDA0("(unsigned long) (newsize) >= (unsigned long) (nb)", "malloc.c", 4664LL, "_int_realloc");
    v20 = *(_QWORD *)(a2 + 8);
    v17 = (u32 *)(a2 + a3);
    goto LABEL_13;
  }
LABEL_27:
  if ( a4 + 32 > a3 + v23 )
    goto LABEL_9;
  a5 = (u32 *)(a2 + 16);
  if ( uaddr != &dword_BE6E0 )
    v18 = 4LL;
  *(_QWORD *)(a2 + 8) = v18 | a4 | v20 & 7;
  *((_QWORD *)uaddr + 12) = a2 + a4;
  *(_QWORD *)(a2 + a4 + 8) = (a3 + v23 - a4) | 1;
  return a5;
}
// 20C59: variable 'v15' is possibly undefined
// 20C52: variable 'a4' is possibly undefined
// 20C59: variable 'a11' is possibly undefined
// 20C59: variable 'a12' is possibly undefined
// 20C6D: variable 'v17' is possibly undefined
// 20C87: variable 'a2' is possibly undefined
// 20CB5: variable 'v18' is possibly undefined
// 20D1A: variable 'a5' is possibly undefined
// 20D1A: variable 'a6' is possibly undefined
// 20D80: variable 'v30' is possibly undefined
// 20D80: variable 'v31' is possibly undefined
// 20D80: variable 'v32' is possibly undefined
// 20D80: variable 'v33' is possibly undefined
// 20D80: variable 'v34' is possibly undefined
// 20DCF: variable 'v20' is possibly undefined
// 1CDA0: using guessed type double sub_1CDA0(const char *, ...);

//----- (0000000000020E50) ----------------------------------------------------
int __fastcall sub_20E50(u32 *a1, unsigned __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v14; // r14
  u32 *v15; // r13
  __int64 *v18; // rsi
  u32 *v19; // r8
  u32 v20; // er9
  __int64 *v21; // r12
  double v22; // xmm4_8
  double v23; // xmm5_8
  __int64 v24; // rcx
  __int64 v25; // rbx
  unsigned __int64 v26; // r15
  unsigned __int64 v28; // rbx
  __int64 *v29; // rax
  double v30; // xmm4_8
  double v31; // xmm5_8
  u32 *v32; // r8
  __int64 v33; // r9
  double v34; // xmm4_8
  double v35; // xmm5_8
  double v37; // xmm4_8
  double v38; // xmm5_8
  u32 *v39; // rax
  signed __int64 v40; // rax
  signed __int64 v41; // rax
  __int64 v42; // rdx
  __int64 v43; // rcx
  u32 *v44; // r8
  u32 v45; // er9
  double v46; // xmm4_8
  double v47; // xmm5_8
  __int64 v48[9]; // [rsp+0h] [rbp-48h] BYREF

  v48[1] = __readfsqword(0x28u);
  v14 = a2 + 1;
  if ( a2 == -1LL )
  {
    __writefsdword(0xFFFFFFC0, 0xCu);
    return 0;
  }
  v15 = a1;
  if ( !a1 )
    return sub_20790(a2, 0LL, a7, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6);
  if ( !a2 )
  {
    sub_1EF20((__int64)a1, 0LL, a7, a8, a9, a10, a11, a12, a13, a14, a3, a4, a5, a6);
    return 0;
  }
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_BE6E0, 1, 0) )
      sub_1C7D0((volatile __int32 *)&dword_BE6E0, a2, 1LL, a4, a5, a6);
  }
  else
  {
    _EDX = 1;
    __asm { cmpxchg cs:dword_BE6E0, edx }
  }
  v18 = v48;
  v21 = (__int64 *)sub_1C930((__int64)a1, v48);
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedExchange((volatile __int32 *)&dword_BE6E0, 0) > 1 )
    {
      v18 = &qword_80 + 1;
      v40 = sys_futex(&dword_BE6E0, 129, 1u, 0LL, v19, v20);
    }
  }
  else
  {
    --dword_BE6E0;
  }
  if ( !v21 )
  {
    sub_1CC00((__int64)"realloc(): invalid pointer", a7, a8, a9, a10, v22, v23, a13, a14);
    return sub_21140(
             (__int64)"realloc(): invalid pointer",
             (__int64)v18,
             v42,
             v43,
             v44,
             v45,
             a7,
             a8,
             a9,
             a10,
             v46,
             v47,
             a13,
             a14);
  }
  if ( v14 < 0 )
    goto LABEL_18;
  v24 = 32LL;
  v25 = v21[1];
  if ( (unsigned __int64)(v14 + 23) > 0x1F )
    v24 = (v14 + 23) & 0xFFFFFFFFFFFFFFF0LL;
  v26 = v24;
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_BE6E0, 1, 0) )
      sub_1C7D0((volatile __int32 *)&dword_BE6E0, (__int64)v18, 1LL, v24, v19, v20);
  }
  else
  {
    _EDX = 1;
    __asm { cmpxchg cs:dword_BE6E0, edx }
  }
  v28 = v25 & 0xFFFFFFFFFFFFFFF8LL;
  if ( (v21[1] & 2) == 0 )
  {
    sub_1CC20(a7, a8, a9, a10, v22, v23, a13, a14);
    v15 = sub_20BD0(&dword_BE6E0, (unsigned __int64)v21, v28, v26, v32, v33, a7, a8, a9, a10, v34, v35, a13, a14);
    if ( v15 )
      goto LABEL_19;
LABEL_18:
    v15 = 0LL;
    *(_BYTE *)v48[0] = ~*(_BYTE *)v48[0];
    goto LABEL_19;
  }
  v29 = sub_1D070(v21, v26, a7, a8, a9, a10, v22, v23, a13, a14);
  if ( !v29 )
  {
    if ( v26 <= v28 - 8 )
      goto LABEL_19;
    sub_1CC20(a7, a8, a9, a10, v30, v31, a13, a14);
    v39 = (u32 *)sub_1F880((const char *)&dword_BE6E0, v14, a7, a8, a9, a10, v37, v38, a13, a14);
    if ( v39 )
    {
      v15 = v39;
      memcpy(v39, a1, v28 - 16);
      sub_1CFB0(v21);
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  v15 = (u32 *)(v29 + 2);
LABEL_19:
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedExchange((volatile __int32 *)&dword_BE6E0, 0) > 1 )
      v41 = sys_futex(&dword_BE6E0, 129, 1u, 0LL, v19, v20);
  }
  else
  {
    --dword_BE6E0;
  }
  return sub_1C8A0((__int64)v15, a2);
}
// 20F38: variable 'v22' is possibly undefined
// 20F38: variable 'v23' is possibly undefined
// 20F65: variable 'v32' is possibly undefined
// 20F65: variable 'v33' is possibly undefined
// 20F65: variable 'v34' is possibly undefined
// 20F65: variable 'v35' is possibly undefined
// 20FC9: variable 'v30' is possibly undefined
// 20FC9: variable 'v31' is possibly undefined
// 20FD8: variable 'v37' is possibly undefined
// 20FD8: variable 'v38' is possibly undefined
// 210AA: variable 'v19' is possibly undefined
// 210AA: variable 'v20' is possibly undefined
// 2113D: variable 'v42' is possibly undefined
// 2113D: variable 'v43' is possibly undefined
// 2113D: variable 'v44' is possibly undefined
// 2113D: variable 'v45' is possibly undefined
// 2113D: variable 'v46' is possibly undefined
// 2113D: variable 'v47' is possibly undefined
// 80: using guessed type __int64 qword_80;
// 1CFB0: using guessed type __int64 __fastcall sub_1CFB0(_QWORD);

//----- (0000000000021140) ----------------------------------------------------
int __fastcall sub_21140(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v16; // rdx
  __int64 v17; // rcx
  unsigned __int64 v18; // r8
  __int64 v19; // r9
  double v20; // xmm4_8
  double v21; // xmm5_8
  unsigned __int64 v22; // rax
  __int64 v23; // rdx
  __int64 v24; // rcx
  u32 *v25; // r8
  u32 v26; // er9
  double v27; // xmm4_8
  double v28; // xmm5_8
  double v29; // xmm4_8
  double v30; // xmm5_8

  _RBP = (volatile __int32 *)__readfsqword(0xFFFFFFD8);
  if ( _RBP )
  {
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedCompareExchange(_RBP, 1, 0) )
        sub_1C7D0(_RBP, a2, 1LL, a4, a5, a6);
    }
    else
    {
      _EDX = 1;
      __asm { cmpxchg [rbp+0], edx }
    }
  }
  else
  {
    _RBP = (volatile __int32 *)sub_1D210(a1, a2, a3, a4, a5, a6);
    if ( !_RBP )
    {
      _RBP = (volatile __int32 *)sub_1F070(
                                   (u32 *)byte_280,
                                   0LL,
                                   a7,
                                   a8,
                                   a9,
                                   a10,
                                   a11,
                                   a12,
                                   a13,
                                   a14,
                                   v23,
                                   v24,
                                   v25,
                                   v26);
      v22 = sub_1F880((const char *)_RBP, 640LL, a7, a8, a9, a10, v27, v28, a13, a14);
      v18 = v22;
      if ( v22 )
        goto LABEL_14;
      if ( !_RBP )
        goto LABEL_7;
LABEL_13:
      _RBP = (volatile __int32 *)sub_1F780(
                                   (u32 *)_RBP,
                                   640LL,
                                   v16,
                                   v17,
                                   (u32 *)v18,
                                   v19,
                                   a7,
                                   a8,
                                   a9,
                                   a10,
                                   v20,
                                   v21,
                                   a13,
                                   a14);
      v22 = sub_1F880((const char *)_RBP, 640LL, a7, a8, a9, a10, v29, v30, a13, a14);
      v18 = v22;
LABEL_14:
      if ( !_RBP )
        goto LABEL_7;
      goto LABEL_5;
    }
  }
  v18 = sub_1F880((const char *)_RBP, 640LL, a7, a8, a9, a10, a11, a12, a13, a14);
  if ( !v18 )
    goto LABEL_13;
LABEL_5:
  LODWORD(v22) = __readfsdword(0x18u);
  if ( (_DWORD)v22 )
  {
    LODWORD(v22) = _InterlockedExchange(_RBP, 0);
    if ( (int)v22 > 1 )
      v22 = sys_futex((u32 *)_RBP, 129, 1u, 0LL, (u32 *)v18, v19);
  }
  else
  {
    --*_RBP;
  }
LABEL_7:
  if ( v18 )
  {
    __writefsqword(0xFFFFFFC8, v18);
    LODWORD(v22) = 0;
    *(_QWORD *)v18 = 0LL;
    *(_QWORD *)(v18 + 632) = 0LL;
    memset(
      (void *)((v18 + 8) & 0xFFFFFFFFFFFFFFF8LL),
      0,
      8LL * (((unsigned int)v18 - (((_DWORD)v18 + 8) & 0xFFFFFFF8) + 640) >> 3));
  }
  return v22;
}
// 21176: variable 'a11' is possibly undefined
// 21176: variable 'a12' is possibly undefined
// 2119E: variable 'v18' is possibly undefined
// 211F4: variable 'v23' is possibly undefined
// 211F4: variable 'v24' is possibly undefined
// 211F4: variable 'v25' is possibly undefined
// 211F4: variable 'v26' is possibly undefined
// 21204: variable 'v27' is possibly undefined
// 21204: variable 'v28' is possibly undefined
// 21228: variable 'v16' is possibly undefined
// 21228: variable 'v17' is possibly undefined
// 21228: variable 'v19' is possibly undefined
// 21228: variable 'v20' is possibly undefined
// 21228: variable 'v21' is possibly undefined
// 21238: variable 'v29' is possibly undefined
// 21238: variable 'v30' is possibly undefined

//----- (0000000000021500) ----------------------------------------------------
__int64 __fastcall sub_21500(u32 *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  unsigned __int64 v15; // rbx
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rax
  u32 *v18; // r8
  __int64 v19; // rax
  __int64 result; // rax
  unsigned __int64 v21; // r8
  __int64 v23; // rdx
  __int64 v24; // rcx
  u32 v25; // er9
  __int64 v26; // rax
  u32 *v27; // rdx
  __int64 v28; // rdx
  __int64 v29; // rcx
  u32 *v30; // r8
  u32 v31; // er9
  double v32; // xmm4_8
  double v33; // xmm5_8
  double v34; // xmm4_8
  double v35; // xmm5_8
  signed __int64 v36; // rax
  void *retaddr; // [rsp+18h] [rbp+0h]

  if ( off_BE6D0 )
    return off_BE6D0(a1, retaddr, a3);
  if ( (__int64)a1 >= 0 )
  {
    v15 = 0LL;
    if ( (unsigned __int64)a1 + 23 > 0x1F )
      v15 = ((((unsigned __int64)a1 + 23) & 0xFFFFFFFFFFFFFFF0LL) - 17) >> 4;
    v16 = __readfsqword(0xFFFFFFC8);
    if ( v16 )
    {
      if ( v15 >= (unsigned __int64)off_BE690 )
        goto LABEL_7;
    }
    else
    {
      if ( __readfsbyte(0xFFFFFFD0) )
        goto LABEL_7;
      sub_21140((__int64)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
      if ( (unsigned __int64)off_BE690 <= v15 )
        goto LABEL_7;
      v16 = __readfsqword(0xFFFFFFC8);
      if ( !v16 )
        goto LABEL_7;
    }
    a3 = *(unsigned __int16 *)(v16 + 2 * v15);
    if ( (_WORD)a3 )
    {
      v21 = *(_QWORD *)(v16 + 8 * (v15 + 16));
      if ( (v21 & 0xF) == 0 )
      {
        *(_QWORD *)(v16 + 8 * (v15 + 16)) = *(_QWORD *)v21 ^ (v21 >> 12);
        *(_WORD *)(v16 + 2 * v15) = a3 - 1;
        result = v21;
        *(_QWORD *)(v21 + 8) = 0LL;
        return result;
      }
      sub_1CC00((__int64)"malloc(): unaligned tcache chunk detected", a7, a8, a9, a10, a11, a12, a13, a14);
LABEL_44:
      if ( _InterlockedExchange((volatile __int32 *)_R12, 0) > 1 )
        v36 = sys_futex(_R12, 129, 1u, 0LL, v18, v25);
LABEL_28:
      if ( v18 )
      {
        v26 = *((_QWORD *)v18 - 1);
        if ( (v26 & 2) == 0 )
        {
          v27 = &dword_BE6E0;
          if ( (v26 & 4) != 0 )
            v27 = *(u32 **)((unsigned __int64)(v18 - 4) & 0xFFFFFFFFFC000000LL);
          if ( v27 != _R12 )
            sub_1CDA0(
              "!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))",
              "malloc.c",
              3099LL,
              "__libc_malloc");
        }
        return (__int64)v18;
      }
      return 0LL;
    }
LABEL_7:
    if ( !__readfsdword(0x18u) )
    {
      v17 = sub_1F880((const char *)&dword_BE6E0, (__int64)a1, a7, a8, a9, a10, a11, a12, a13, a14);
      v18 = (u32 *)v17;
      if ( v17 )
      {
        v19 = *(_QWORD *)(v17 - 8);
        if ( (v19 & 2) == 0
          && (v19 & 4) != 0
          && *(u32 **)((unsigned __int64)(v18 - 4) & 0xFFFFFFFFFC000000LL) != &dword_BE6E0 )
        {
          sub_1CDA0(
            "!victim || chunk_is_mmapped (mem2chunk (victim)) || &main_arena == arena_for_chunk (mem2chunk (victim))",
            "malloc.c",
            3079LL,
            "__libc_malloc");
        }
        return (__int64)v18;
      }
      return 0LL;
    }
    _R12 = (u32 *)__readfsqword(0xFFFFFFD8);
    if ( _R12 )
    {
      if ( __readfsdword(0x18u) )
      {
        if ( _InterlockedCompareExchange((volatile signed __int32 *)_R12, 1, 0) )
          sub_1C7D0((volatile __int32 *)_R12, a2, 1LL, a4, a5, a6);
      }
      else
      {
        _EDX = 1;
        __asm { cmpxchg [r12], edx }
      }
    }
    else
    {
      _R12 = (u32 *)sub_1D210((__int64)a1, a2, a3, a4, a5, a6);
      if ( !_R12 )
      {
        _R12 = sub_1F070(a1, 0LL, a7, a8, a9, a10, a11, a12, a13, a14, v28, v29, v30, v31);
        v18 = (u32 *)sub_1F880((const char *)_R12, (__int64)a1, a7, a8, a9, a10, v32, v33, a13, a14);
        if ( v18 )
          goto LABEL_41;
        if ( !_R12 )
          goto LABEL_28;
LABEL_40:
        _R12 = sub_1F780(_R12, (__int64)a1, v23, v24, v18, v25);
        v18 = (u32 *)sub_1F880((const char *)_R12, (__int64)a1, a7, a8, a9, a10, v34, v35, a13, a14);
LABEL_41:
        if ( !_R12 )
          goto LABEL_28;
        goto LABEL_26;
      }
    }
    v18 = (u32 *)sub_1F880((const char *)_R12, (__int64)a1, a7, a8, a9, a10, a11, a12, a13, a14);
    if ( v18 )
    {
LABEL_26:
      if ( !__readfsdword(0x18u) )
      {
        --*_R12;
        goto LABEL_28;
      }
      goto LABEL_44;
    }
    goto LABEL_40;
  }
  __writefsdword(0xFFFFFFC0, 0xCu);
  return 0LL;
}
// 2156D: variable 'a11' is possibly undefined
// 2156D: variable 'a12' is possibly undefined
// 215A5: variable 'v18' is possibly undefined
// 21712: variable '_R12' is possibly undefined
// 21756: variable 'a4' is possibly undefined
// 21756: variable 'a5' is possibly undefined
// 21756: variable 'a6' is possibly undefined
// 21780: variable 'a3' is possibly undefined
// 21796: variable 'v28' is possibly undefined
// 21796: variable 'v29' is possibly undefined
// 21796: variable 'v30' is possibly undefined
// 21796: variable 'v31' is possibly undefined
// 217A4: variable 'v32' is possibly undefined
// 217A4: variable 'v33' is possibly undefined
// 217C7: variable 'v23' is possibly undefined
// 217C7: variable 'v24' is possibly undefined
// 217C7: variable 'v25' is possibly undefined
// 217D5: variable 'v34' is possibly undefined
// 217D5: variable 'v35' is possibly undefined
// 1CDA0: using guessed type __int64 sub_1CDA0(const char *, ...);
// BE690: using guessed type int *off_BE690;
// BE6D0: using guessed type __int64 (__fastcall *off_BE6D0)(_QWORD, _QWORD, _QWORD);

//----- (0000000000021830) ----------------------------------------------------
__int64 __fastcall sub_21830(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  off_BE6D0 = 0LL;
  if ( dword_BE624 < 0 )
    sub_1F5F0();
  return sub_21500((u32 *)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
}
// 21849: variable 'a3' is possibly undefined
// 21849: variable 'a4' is possibly undefined
// 21849: variable 'a5' is possibly undefined
// 21849: variable 'a6' is possibly undefined
// 21849: variable 'a11' is possibly undefined
// 21849: variable 'a12' is possibly undefined
// BE624: using guessed type int dword_BE624;
// BE6D0: using guessed type __int64 (__fastcall *off_BE6D0)(_QWORD, _QWORD, _QWORD);

//----- (0000000000021870) ----------------------------------------------------
__int64 __fastcall sub_21870(unsigned __int64 a1, u32 *a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  unsigned __int64 v14; // rbp
  u32 *v15; // rax
  double v16; // xmm4_8
  double v17; // xmm5_8
  u32 *v18; // r8
  __int64 v19; // rax
  __int64 v23; // rdx
  __int64 v24; // rcx
  __int64 v25; // r9
  double v26; // xmm4_8
  double v27; // xmm5_8
  __int64 v28; // rax
  u32 *v29; // rdx
  __int64 v30; // rdx
  __int64 v31; // rcx
  u32 *v32; // r8
  u32 v33; // er9
  double v34; // xmm4_8
  double v35; // xmm5_8
  double v36; // xmm4_8
  double v37; // xmm5_8
  signed __int64 v38; // rax

  if ( !off_BE6C0 )
  {
    if ( a1 <= 0x10 )
      return sub_21500(a2, (__int64)a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
    if ( a1 > 0x1F )
    {
      if ( a1 > 0x8000000000000000LL )
      {
        v18 = 0LL;
        __writefsdword(0xFFFFFFC0, 0x16u);
        return (__int64)v18;
      }
      if ( (a1 & (a1 - 1)) != 0 )
      {
        v14 = 32LL;
        if ( a1 != 32 )
        {
          do
            v14 *= 2LL;
          while ( a1 > v14 );
        }
      }
      else
      {
        v14 = a1;
      }
    }
    else
    {
      v14 = 32LL;
    }
    if ( !__readfsdword(0x18u) )
    {
      v15 = (u32 *)sub_20860(&dword_BE6E0, v14, (__int64)a2, a7, a8, a9, a10, a11, a12, a13, a14);
      v18 = v15;
      if ( v15 )
      {
        v19 = *((_QWORD *)v15 - 1);
        if ( (v19 & 2) == 0
          && (v19 & 4) != 0
          && *(u32 **)((unsigned __int64)(v18 - 4) & 0xFFFFFFFFFC000000LL) != &dword_BE6E0 )
        {
          sub_1CDA0(
            "!p || chunk_is_mmapped (mem2chunk (p)) || &main_arena == arena_for_chunk (mem2chunk (p))",
            (__int64)"malloc.c",
            0xCFCu,
            (__int64)"_mid_memalign",
            a7,
            a8,
            a9,
            a10,
            v16,
            v17,
            a13,
            a14);
        }
        return (__int64)v18;
      }
      return 0LL;
    }
    _R13 = (volatile __int32 *)__readfsqword(0xFFFFFFD8);
    if ( _R13 )
    {
      if ( __readfsdword(0x18u) )
      {
        if ( _InterlockedCompareExchange(_R13, 1, 0) )
          sub_1C7D0(_R13, (__int64)a2, 1LL, a4, a5, a6);
      }
      else
      {
        _EDX = 1;
        __asm { cmpxchg [r13+0], edx }
      }
    }
    else
    {
      _R13 = (volatile __int32 *)sub_1D210(a1, (__int64)a2, a3, a4, a5, a6);
      if ( !_R13 )
      {
        _R13 = (volatile __int32 *)sub_1F070(
                                     (u32 *)((char *)a2 + v14 + 32),
                                     0LL,
                                     a7,
                                     a8,
                                     a9,
                                     a10,
                                     a11,
                                     a12,
                                     a13,
                                     a14,
                                     v30,
                                     v31,
                                     v32,
                                     v33);
        v18 = (u32 *)sub_20860((u32 *)_R13, v14, (__int64)a2, a7, a8, a9, a10, v34, v35, a13, a14);
        if ( v18 )
          goto LABEL_38;
        if ( !_R13 )
          goto LABEL_25;
LABEL_37:
        _R13 = (volatile __int32 *)sub_1F780(
                                     (u32 *)_R13,
                                     (__int64)a2,
                                     v23,
                                     v24,
                                     v18,
                                     v25,
                                     a7,
                                     a8,
                                     a9,
                                     a10,
                                     v26,
                                     v27,
                                     a13,
                                     a14);
        v18 = (u32 *)sub_20860((u32 *)_R13, v14, (__int64)a2, a7, a8, a9, a10, v36, v37, a13, a14);
LABEL_38:
        if ( !_R13 )
          goto LABEL_25;
        goto LABEL_23;
      }
    }
    v18 = (u32 *)sub_20860((u32 *)_R13, v14, (__int64)a2, a7, a8, a9, a10, a11, a12, a13, a14);
    if ( v18 )
    {
LABEL_23:
      if ( __readfsdword(0x18u) )
      {
        if ( _InterlockedExchange(_R13, 0) > 1 )
          v38 = sys_futex((u32 *)_R13, 129, 1u, 0LL, v18, v25);
      }
      else
      {
        --*_R13;
      }
LABEL_25:
      if ( v18 )
      {
        v28 = *((_QWORD *)v18 - 1);
        if ( (v28 & 2) == 0 )
        {
          v29 = &dword_BE6E0;
          if ( (v28 & 4) != 0 )
            v29 = *(u32 **)((unsigned __int64)(v18 - 4) & 0xFFFFFFFFFC000000LL);
          if ( v29 != (u32 *)_R13 )
            sub_1CDA0(
              "!p || chunk_is_mmapped (mem2chunk (p)) || ar_ptr == arena_for_chunk (mem2chunk (p))",
              (__int64)"malloc.c",
              0xD0Fu,
              (__int64)"_mid_memalign",
              a7,
              a8,
              a9,
              a10,
              v26,
              v27,
              a13,
              a14);
        }
        return (__int64)v18;
      }
      return 0LL;
    }
    goto LABEL_37;
  }
  return off_BE6C0();
}
// 218F2: variable 'v18' is possibly undefined
// 219A7: variable 'a11' is possibly undefined
// 219A7: variable 'a12' is possibly undefined
// 21A1D: variable 'v26' is possibly undefined
// 21A1D: variable 'v27' is possibly undefined
// 21A78: variable 'v30' is possibly undefined
// 21A78: variable 'v31' is possibly undefined
// 21A78: variable 'v32' is possibly undefined
// 21A78: variable 'v33' is possibly undefined
// 21A89: variable 'v34' is possibly undefined
// 21A89: variable 'v35' is possibly undefined
// 21AA6: variable 'v23' is possibly undefined
// 21AA6: variable 'v24' is possibly undefined
// 21AA6: variable 'v25' is possibly undefined
// 21AB7: variable 'v36' is possibly undefined
// 21AB7: variable 'v37' is possibly undefined
// 21B12: variable 'v16' is possibly undefined
// 21B12: variable 'v17' is possibly undefined
// BE6C0: using guessed type __int64 (*off_BE6C0)(void);

//----- (0000000000021B20) ----------------------------------------------------
__int64 __fastcall sub_21B20(unsigned __int64 a1, u32 *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, __int64 a14)
{
  __int64 retaddr; // [rsp+18h] [rbp+0h]

  off_BE6C0 = 0LL;
  if ( dword_BE624 < 0 )
    sub_1F5F0();
  return sub_21870(a1, a2, retaddr, a12, a13, a14, a3, a4, a5, a6, a7, a8, a9, a10);
}
// 21B5D: variable 'a12' is possibly undefined
// 21B5D: variable 'a13' is possibly undefined
// 21B5D: variable 'a14' is possibly undefined
// 21B5D: variable 'a7' is possibly undefined
// 21B5D: variable 'a8' is possibly undefined
// BE624: using guessed type int dword_BE624;
// BE6C0: using guessed type __int64 (*off_BE6C0)(void);

//----- (0000000000021B70) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_21B70(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14))(_QWORD, _QWORD)
{
  __int64 (__fastcall *result)(_QWORD, _QWORD); // rax
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rsi
  u32 *v17; // rdi
  void *retaddr; // [rsp+18h] [rbp+0h]

  result = qword_C1218;
  if ( qword_C1218 )
    return (__int64 (__fastcall *)(_QWORD, _QWORD))qword_C1218(a1, retaddr);
  if ( a1 )
  {
    v15 = *(_QWORD *)(a1 - 8);
    v16 = a1 - 16;
    if ( (v15 & 2) != 0 )
    {
      if ( !dword_BE674 && v15 > (unsigned __int64)off_BE650 && v15 <= 0x2000000 )
      {
        off_BE650 = (void *)(v15 & 0xFFFFFFFFFFFFFFF8LL);
        off_BE640 = (void *)(2 * (v15 & 0xFFFFFFFFFFFFFFF8LL));
      }
      result = (__int64 (__fastcall *)(_QWORD, _QWORD))sub_1CFB0((_QWORD *)(a1 - 16), a2, a3, a4, a5, a6, a7, a8, a9);
    }
    else
    {
      if ( !__readfsqword(0xFFFFFFC8) && !__readfsbyte(0xFFFFFFD0) )
      {
        sub_21140(a1, v16, a11, a12, a13, a14, a2, a3, a4, a5, a6, a7, a8, a9);
        v16 = a1 - 16;
        v15 = *(_QWORD *)(a1 - 8);
      }
      v17 = &dword_BE6E0;
      if ( (v15 & 4) != 0 )
        v17 = *(u32 **)(v16 & 0xFFFFFFFFFC000000LL);
      result = (__int64 (__fastcall *)(_QWORD, _QWORD))sub_1DC90(
                                                         v17,
                                                         v16,
                                                         0,
                                                         a12,
                                                         a13,
                                                         a14,
                                                         a2,
                                                         a3,
                                                         a4,
                                                         a5,
                                                         a6,
                                                         a7,
                                                         a8,
                                                         a9);
    }
  }
  return result;
}
// C1218: invalid function type has been ignored
// 21BC6: variable 'a12' is possibly undefined
// 21BC6: variable 'a13' is possibly undefined
// 21BC6: variable 'a14' is possibly undefined
// 21BC6: variable 'a6' is possibly undefined
// 21BC6: variable 'a7' is possibly undefined
// BE640: using guessed type void *off_BE640;
// BE650: using guessed type void *off_BE650;
// BE674: using guessed type int dword_BE674;
// C1218: using guessed type __int64 (__fastcall *qword_C1218)(_QWORD, _QWORD);

//----- (0000000000021DF0) ----------------------------------------------------
_QWORD *__fastcall sub_21DF0(const char *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v16; // rax
  unsigned __int64 v17; // r14
  volatile __int32 *v18; // rbx
  unsigned __int64 v19; // r15
  __int64 v20; // rcx
  __int64 v21; // rsi
  __int64 v22; // rsi
  __int64 *v23; // rax
  __int64 v24; // rdx
  u32 *v25; // r8
  u32 v26; // er9
  double v27; // xmm4_8
  double v28; // xmm5_8
  _QWORD *v29; // r13
  u32 *v30; // rax
  __int64 v31; // rax
  u32 *v32; // rdx
  _QWORD *v33; // rax
  const char *v34; // rsi
  __int64 v35; // rdx
  __int64 v36; // rcx
  u32 *v37; // r8
  u32 v38; // er9
  double v39; // xmm4_8
  double v40; // xmm5_8
  __int64 v41; // rax
  u32 *v42; // rdx
  _QWORD *v43; // rax
  unsigned __int64 v44; // rcx
  u32 *v45; // r8
  __int64 v46; // r9
  double v47; // xmm4_8
  double v48; // xmm5_8
  signed __int64 v49; // rax
  unsigned __int64 v50; // [rsp+20h] [rbp-40h]
  __int64 v51; // [rsp+20h] [rbp-40h]
  void *retaddr; // [rsp+60h] [rbp+0h]

  while ( !off_BE6C8 )
  {
    if ( !a2 )
    {
      if ( !a1 )
        return (_QWORD *)sub_21500((u32 *)a2, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
      sub_21B70(a1);
      return 0LL;
    }
    if ( !a1 )
      return (_QWORD *)sub_21500((u32 *)a2, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
    v16 = *((_QWORD *)a1 - 1);
    v17 = (unsigned __int64)(a1 - 16);
    v18 = 0LL;
    v19 = v16 & 0xFFFFFFFFFFFFFFF8LL;
    if ( (v16 & 2) == 0 )
    {
      if ( !__readfsqword(0xFFFFFFC8) && !__readfsbyte(0xFFFFFFD0) )
      {
        sub_21140((__int64)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
        v16 = *((_QWORD *)a1 - 1);
      }
      v18 = (volatile __int32 *)&dword_BE6E0;
      if ( (v16 & 4) != 0 )
        v18 = *(volatile __int32 **)(v17 & 0xFFFFFFFFFC000000LL);
    }
    if ( -(__int64)v19 >= v17 && (v17 & 0xF) == 0 )
    {
      if ( a2 < 0 )
      {
        v29 = 0LL;
        __writefsdword(0xFFFFFFC0, 0xCu);
      }
      else
      {
        v20 = 32LL;
        v21 = (a2 + 23) & 0xFFFFFFFFFFFFFFF0LL;
        if ( (unsigned __int64)(a2 + 23) > 0x1F )
          v20 = (a2 + 23) & 0xFFFFFFFFFFFFFFF0LL;
        if ( (v16 & 2) != 0 )
        {
          v22 = v20;
          v50 = v20;
          v23 = sub_1D070((__int64 *)a1 - 2, v20, a7, a8, a9, a10, a11, a12, a13, a14);
          v29 = v23 + 2;
          if ( !v23 )
          {
            v29 = a1;
            if ( v19 - 8 < v50 )
            {
              v33 = (_QWORD *)sub_21500((u32 *)a2, v22, v24, v50, v25, v26, a7, a8, a9, a10, v27, v28, a13, a14);
              v29 = v33;
              if ( v33 )
              {
                memcpy(v33, a1, v19 - 16);
                sub_1CFB0(v17);
              }
            }
          }
        }
        else if ( __readfsdword(0x18u) )
        {
          if ( _InterlockedCompareExchange(v18, 1, 0) )
          {
            v51 = v20;
            sub_1C7D0(v18, v21, 1LL, v20, a5, a6);
            v20 = v51;
          }
          v34 = a1 - 16;
          v29 = sub_20BD0((u32 *)v18, v17, v19, v20, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
          if ( __readfsdword(0x18u) )
          {
            if ( _InterlockedExchange(v18, 0) > 1 )
            {
              v34 = (_BYTE *)(&qword_80 + 1);
              v49 = sys_futex((u32 *)v18, 129, 1u, 0LL, v37, v38);
            }
          }
          else
          {
            --*v18;
          }
          if ( v29 )
          {
            v41 = *(v29 - 1);
            if ( (v41 & 2) == 0 )
            {
              v42 = &dword_BE6E0;
              if ( (v41 & 4) != 0 )
                v42 = *(u32 **)((unsigned __int64)(v29 - 2) & 0xFFFFFFFFFC000000LL);
              if ( v18 != (volatile __int32 *)v42 )
                sub_1CDA0(
                  "!newp || chunk_is_mmapped (mem2chunk (newp)) || ar_ptr == arena_for_chunk (mem2chunk (newp))",
                  "malloc.c",
                  3258LL,
                  "__libc_realloc");
            }
          }
          else
          {
            v43 = (_QWORD *)sub_21500((u32 *)a2, (__int64)v34, v35, v36, v37, v38, a7, a8, a9, a10, v39, v40, a13, a14);
            v29 = v43;
            if ( v43 )
            {
              memcpy(v43, a1, v19 - 8);
              sub_1DC90((u32 *)v18, v17, 0, v44, v45, v46, a7, a8, a9, a10, v47, v48, a13, a14);
            }
          }
        }
        else
        {
          v30 = sub_20BD0(
                  (u32 *)v18,
                  (unsigned __int64)(a1 - 16),
                  v19,
                  v20,
                  a5,
                  a6,
                  a7,
                  a8,
                  a9,
                  a10,
                  a11,
                  a12,
                  a13,
                  a14);
          v29 = v30;
          if ( v30 )
          {
            v31 = *((_QWORD *)v30 - 1);
            if ( (v31 & 2) == 0 )
            {
              v32 = &dword_BE6E0;
              if ( (v31 & 4) != 0 )
                v32 = *(u32 **)((unsigned __int64)(v29 - 2) & 0xFFFFFFFFFC000000LL);
              if ( v18 != (volatile __int32 *)v32 )
                sub_1CDA0(
                  "!newp || chunk_is_mmapped (mem2chunk (newp)) || ar_ptr == arena_for_chunk (mem2chunk (newp))",
                  "malloc.c",
                  3247LL,
                  "__libc_realloc");
            }
          }
        }
      }
      return v29;
    }
    a1 = "realloc(): invalid pointer";
    sub_1CC00((__int64)"realloc(): invalid pointer", a7, a8, a9, a10, a11, a12, a13, a14);
    off_BE6D0 = 0LL;
    off_BE6C8 = 0LL;
    if ( dword_BE624 < 0 )
    {
      sub_1F5F0();
      a1 = "realloc(): invalid pointer";
    }
  }
  return (_QWORD *)off_BE6C8(a1, a2, retaddr);
}
// 21E37: variable 'a3' is possibly undefined
// 21E37: variable 'a4' is possibly undefined
// 21E37: variable 'a5' is possibly undefined
// 21E37: variable 'a6' is possibly undefined
// 21E37: variable 'a11' is possibly undefined
// 21E37: variable 'a12' is possibly undefined
// 21F8B: variable 'v24' is possibly undefined
// 21F8B: variable 'v25' is possibly undefined
// 21F8B: variable 'v26' is possibly undefined
// 21F8B: variable 'v27' is possibly undefined
// 21F8B: variable 'v28' is possibly undefined
// 220BC: variable 'v35' is possibly undefined
// 220BC: variable 'v36' is possibly undefined
// 220BC: variable 'v37' is possibly undefined
// 220BC: variable 'v38' is possibly undefined
// 220BC: variable 'v39' is possibly undefined
// 220BC: variable 'v40' is possibly undefined
// 220E4: variable 'v44' is possibly undefined
// 220E4: variable 'v45' is possibly undefined
// 220E4: variable 'v46' is possibly undefined
// 220E4: variable 'v47' is possibly undefined
// 220E4: variable 'v48' is possibly undefined
// 80: using guessed type __int64 qword_80;
// 1CDA0: using guessed type double sub_1CDA0(const char *, ...);
// 1CFB0: using guessed type __int64 __fastcall sub_1CFB0(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// BE624: using guessed type int dword_BE624;
// BE6C8: using guessed type __int64 (__fastcall *off_BE6C8)(_QWORD, _QWORD, _QWORD);
// BE6D0: using guessed type __int64 (__fastcall *off_BE6D0)(_QWORD, _QWORD, _QWORD);

//----- (0000000000022260) ----------------------------------------------------
__int64 __fastcall sub_22260(unsigned __int64 a1, unsigned __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, __int64 a14)
{
  unsigned __int128 v14; // rax
  __int64 v15; // r12
  __int64 v16; // r13
  char *v18; // rbx
  unsigned __int64 v19; // rax
  u32 *v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // r9
  double v23; // xmm4_8
  double v24; // xmm5_8
  unsigned __int64 v25; // r8
  __int64 v26; // rax
  __int64 v27; // rdx
  unsigned __int64 v28; // rdx
  unsigned __int64 v30; // rdx
  __int64 v31; // rdi
  __int64 v32; // rax
  double v34; // xmm4_8
  double v35; // xmm5_8
  __int64 v36; // rdx
  __int64 v37; // rcx
  u32 *v38; // r8
  u32 v39; // er9
  signed __int64 v40; // rax
  void *retaddr; // [rsp+78h] [rbp+0h]

  v14 = a2 * (unsigned __int128)a1;
  v15 = a2 * a1;
  if ( ((a2 * a1) & 0x8000000000000000LL) == 0LL && is_mul_ok(a2, a1) )
  {
    if ( off_BE6D0 )
    {
      v32 = off_BE6D0(v15, retaddr, *((_QWORD *)&v14 + 1));
      v28 = a2 * a1;
      v31 = v32;
      if ( v32 )
        return sub_9190(v31, 0LL, v28);
      return 0LL;
    }
    if ( !__readfsqword(0xFFFFFFC8) && !__readfsbyte(0xFFFFFFD0) )
      sub_21140(a1, a2, *((__int64 *)&v14 + 1), a12, a13, a14, a3, a4, a5, a6, a7, a8, a9, a10);
    if ( __readfsdword(0x18u) )
    {
      _RBP = (u32 *)__readfsqword(0xFFFFFFD8);
      if ( _RBP )
      {
        if ( __readfsdword(0x18u) )
        {
          if ( _InterlockedCompareExchange((volatile signed __int32 *)_RBP, 1, 0) )
            sub_1C7D0((volatile __int32 *)_RBP, a2, 1LL, a12, a13, a14);
        }
        else
        {
          _EDX = 1;
          __asm { cmpxchg [rbp+0], edx }
        }
      }
      else
      {
        _RBP = (u32 *)sub_1D210(a1, a2, *((__int64 *)&v14 + 1), a12, a13, a14);
        if ( !_RBP )
        {
          _RBP = sub_1F070((u32 *)v15, 0LL, a3, a4, a5, a6, a7, a8, a9, a10, v36, v37, v38, v39);
          if ( !_RBP )
          {
            v16 = 0LL;
            v18 = 0LL;
            goto LABEL_7;
          }
        }
      }
      v16 = *((_QWORD *)_RBP + 12);
      v18 = (char *)(*(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8LL);
      if ( _RBP != &dword_BE6E0
        && v18 < *(char **)((char *)&off_18 + (v16 & 0xFFFFFFFFFC000000LL)) + (v16 & 0xFFFFFFFFFC000000LL) - v16 )
      {
        v18 = *(char **)((char *)&off_18 + (v16 & 0xFFFFFFFFFC000000LL)) + (v16 & 0xFFFFFFFFFC000000LL) - v16;
      }
    }
    else
    {
      v16 = qword_BE740;
      _RBP = &dword_BE6E0;
      v18 = (char *)(*(_QWORD *)(qword_BE740 + 8) & 0xFFFFFFFFFFFFFFF8LL);
    }
LABEL_7:
    v19 = sub_1F880((const char *)_RBP, v15, a3, a4, a5, a6, a7, a8, a9, a10);
    v25 = v19;
    if ( v19 )
    {
      v26 = *(_QWORD *)(v19 - 8);
      if ( (v26 & 2) == 0 )
      {
        v20 = &dword_BE6E0;
        if ( (v26 & 4) != 0 )
          v20 = *(u32 **)((v25 - 16) & 0xFFFFFFFFFC000000LL);
        if ( v20 != _RBP )
          sub_1CDA0(
            "!mem || chunk_is_mmapped (mem2chunk (mem)) || av == arena_for_chunk (mem2chunk (mem))",
            "malloc.c",
            3450LL,
            "__libc_calloc",
            v25);
      }
    }
    if ( __readfsdword(0x18u) )
    {
      if ( !v25 )
      {
        if ( !_RBP )
          goto LABEL_10;
        _RBP = sub_1F780(_RBP, v15, (__int64)v20, v21, 0LL, v22, a3, a4, a5, a6, v23, v24, a9, a10);
        v25 = sub_1F880((const char *)_RBP, v15, a3, a4, a5, a6, v34, v35, a9, a10);
      }
      if ( _RBP )
      {
        if ( __readfsdword(0x18u) )
        {
          if ( _InterlockedExchange((volatile __int32 *)_RBP, 0) > 1 )
            v40 = sys_futex(_RBP, 129, 1u, 0LL, (u32 *)v25, v22);
        }
        else
        {
          --*_RBP;
        }
      }
    }
LABEL_10:
    if ( v25 )
    {
      v27 = *(_QWORD *)(v25 - 8);
      if ( (v27 & 2) != 0 )
      {
        v28 = a2 * a1;
        if ( !dword_C1254 )
          return v25;
      }
      else
      {
        v30 = v27 & 0xFFFFFFFFFFFFFFF8LL;
        if ( !dword_C1254 && v16 == v25 - 16 && (unsigned __int64)v18 < v30 )
          v30 = (unsigned __int64)v18;
        v28 = v30 - 8;
        if ( v28 <= 0x17 )
          sub_1CDA0("nclears >= 3", "malloc.c", 3497LL, "__libc_calloc");
        if ( v28 <= 0x4F )
        {
          *(_QWORD *)v25 = 0LL;
          *(_QWORD *)(v25 + 8) = 0LL;
          *(_QWORD *)(v25 + 16) = 0LL;
          if ( v28 > 0x27 )
          {
            *(_QWORD *)(v25 + 24) = 0LL;
            *(_QWORD *)(v25 + 32) = 0LL;
            if ( v28 > 0x37 )
            {
              *(_QWORD *)(v25 + 40) = 0LL;
              *(_QWORD *)(v25 + 48) = 0LL;
              if ( v28 > 0x47 )
              {
                *(_QWORD *)(v25 + 56) = 0LL;
                *(_QWORD *)(v25 + 64) = 0LL;
              }
            }
          }
          return v25;
        }
      }
      v31 = v25;
      return sub_9190(v31, 0LL, v28);
    }
    return 0LL;
  }
  __writefsdword(0xFFFFFFC0, 0xCu);
  return 0LL;
}
// 222DB: variable 'a7' is possibly undefined
// 222DB: variable 'a8' is possibly undefined
// 22307: variable 'v25' is possibly undefined
// 224FD: variable 'v20' is possibly undefined
// 224FD: variable 'v21' is possibly undefined
// 224FD: variable 'v22' is possibly undefined
// 224FD: variable 'v23' is possibly undefined
// 224FD: variable 'v24' is possibly undefined
// 2250B: variable 'v34' is possibly undefined
// 2250B: variable 'v35' is possibly undefined
// 22558: variable 'v14' is possibly undefined
// 22558: variable 'a12' is possibly undefined
// 22558: variable 'a13' is possibly undefined
// 22558: variable 'a14' is possibly undefined
// 2256E: variable 'v36' is possibly undefined
// 2256E: variable 'v37' is possibly undefined
// 2256E: variable 'v38' is possibly undefined
// 2256E: variable 'v39' is possibly undefined
// 18: using guessed type void (__fastcall __noreturn *off_18)();
// 1CDA0: using guessed type double sub_1CDA0(const char *, ...);
// BE6D0: using guessed type __int64 (__fastcall *off_BE6D0)(_QWORD, _QWORD, _QWORD);
// BE740: using guessed type __int64 qword_BE740;
// C1254: using guessed type int dword_C1254;

//----- (0000000000022FE0) ----------------------------------------------------
unsigned __int64 __fastcall sub_22FE0(__int64 a1)
{
  unsigned __int64 result; // rax

  result = sub_4BB00(a1);
  if ( result == -1LL )
    result = 0LL;
  return result;
}

//----- (0000000000023000) ----------------------------------------------------
void *sub_23000()
{
  void *result; // rax

  if ( (dword_C1434 & 0x800) != 0
    || (BYTE4(xmmword_C1384) & 0x20) == 0
    || (result = sub_40590, (dword_C1434 & 0x100) == 0) )
  {
    result = &loc_40150;
    if ( (dword_C1434 & 0x40) != 0 )
      result = sub_452C0;
  }
  return result;
}
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (0000000000023040) ----------------------------------------------------
void *sub_23040()
{
  void *result; // rax

  if ( (dword_C1434 & 0x800) != 0
    || (BYTE4(xmmword_C1384) & 0x20) == 0
    || (result = sub_26790, (dword_C1434 & 0x100) == 0) )
  {
    result = sub_25270;
    if ( (dword_C1434 & 0x10) == 0 )
    {
      result = sub_23E20;
      if ( (BYTE9(xmmword_C1364) & 2) != 0 )
        result = sub_25520;
    }
  }
  return result;
}
// C1364: using guessed type __int128 xmmword_C1364;
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (0000000000023090) ----------------------------------------------------
void *sub_23090()
{
  void *result; // rax

  if ( (dword_C1434 & 0x800) != 0
    || (BYTE4(xmmword_C1384) & 0x20) == 0
    || (result = sub_40CF0, (dword_C1434 & 0x100) == 0) )
  {
    result = sub_44220;
    if ( (dword_C1434 & 0x10) == 0 )
    {
      result = sub_41080;
      if ( (BYTE9(xmmword_C1364) & 2) != 0 )
        result = sub_41260;
    }
  }
  return result;
}
// C1364: using guessed type __int128 xmmword_C1364;
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (00000000000230E0) ----------------------------------------------------
_BYTE *(__fastcall *sub_230E0())(__int64 a1, const __m128i *a2)
{
  _BYTE *(__fastcall *result)(__int64, const __m128i *); // rax

  result = (_BYTE *(__fastcall *)(__int64, const __m128i *))&loc_471F0;
  if ( (BYTE10(xmmword_C1364) & 0x10) != 0 )
    result = sub_472A0;
  return result;
}
// C1364: using guessed type __int128 xmmword_C1364;

//----- (0000000000023100) ----------------------------------------------------
void *__fastcall sub_23100(void *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  u32 *v10; // r12
  __int64 v11; // rdx
  __int64 v12; // rcx
  u32 *v13; // r8
  u32 v14; // er9
  double v15; // xmm4_8
  double v16; // xmm5_8
  void *v17; // rax
  void *result; // rax

  v10 = (u32 *)(strlen((__int64)a1) + 1);
  v17 = (void *)sub_21500(v10, a2, v11, v12, v13, v14, a3, a4, a5, a6, v15, v16, a9, a10);
  if ( v17 )
    result = memcpy(v17, a1, (size_t)v10);
  else
    result = 0LL;
  return result;
}
// 2311A: variable 'v11' is possibly undefined
// 2311A: variable 'v12' is possibly undefined
// 2311A: variable 'v13' is possibly undefined
// 2311A: variable 'v14' is possibly undefined
// 2311A: variable 'v15' is possibly undefined
// 2311A: variable 'v16' is possibly undefined

//----- (0000000000023140) ----------------------------------------------------
__int64 __fastcall sub_23140(unsigned int a1, char *a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  unsigned __int8 *v12; // rax
  double v13; // xmm4_8
  double v14; // xmm5_8
  const char *v16; // rax

  v12 = (unsigned __int8 *)sub_68F10(a1);
  if ( v12 )
    return sub_CF50("libc", v12, 5u, a4, a5, a6, a7, v13, v14, a10, a11);
  v16 = (const char *)sub_CF50("libc", "Unknown error ", 5u, a4, a5, a6, a7, v13, v14, a10, a11);
  sub_5E420(a2, a3, (__int64)"%s%d", v16, a1);
  return (__int64)a2;
}
// 2316D: variable 'v13' is possibly undefined
// 2316D: variable 'v14' is possibly undefined

//----- (00000000000231C0) ----------------------------------------------------
__int64 (__fastcall *sub_231C0())()
{
  __int64 (__fastcall *result)(); // rax

  result = (__int64 (__fastcall *)())sub_409B0;
  if ( (dword_C1434 & 0x800) == 0 && (BYTE4(xmmword_C1384) & 0x20) != 0 && (dword_C1434 & 0x100) != 0 )
    result = (__int64 (__fastcall *)())sub_40B50;
  return result;
}
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (00000000000231F0) ----------------------------------------------------
void *sub_231F0()
{
  void *result; // rax

  if ( (dword_C1434 & 0x800) != 0
    || (BYTE4(xmmword_C1384) & 0x20) == 0
    || (result = sub_2AB80, (dword_C1434 & 0x100) == 0) )
  {
    if ( (DWORD2(xmmword_C1364) & 0x100000) == 0 || (result = sub_29BA0, (dword_C1434 & 0x80) != 0) )
    {
      result = sub_26BD0;
      if ( (BYTE9(xmmword_C1364) & 2) != 0 )
        result = sub_28430;
    }
  }
  return result;
}
// C1364: using guessed type __int128 xmmword_C1364;
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (0000000000023250) ----------------------------------------------------
__int64 __fastcall sub_23250(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v8; // rsi
  __int64 v9; // r15
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // rax
  unsigned __int8 v13; // di
  __int64 v14; // rsi
  __int64 v15; // r10
  __int64 v16; // rcx
  __int64 v17; // rdi
  __int64 v18; // rax
  unsigned __int8 v19; // r11
  unsigned __int64 v20; // rdi
  unsigned __int64 v21; // r13
  char *v22; // rax
  unsigned __int8 *v23; // rax
  __int64 v24; // rdx
  unsigned __int64 v25; // rcx
  __int64 v26; // rdx
  unsigned __int64 v27; // r9
  unsigned __int64 v28; // r8
  unsigned __int64 v29; // rax
  __int64 v30; // rbx
  unsigned __int64 v31; // rcx
  unsigned __int64 v32; // r13
  unsigned __int64 v33; // rax
  unsigned __int64 v34; // r9
  __int64 v35; // r15
  unsigned __int64 v36; // r14
  __int64 v37; // r12
  unsigned __int64 v38; // rbp
  unsigned __int64 v39; // rax
  unsigned __int64 v40; // rdx
  __int64 v41; // rax
  unsigned __int64 v42; // rdx
  unsigned __int64 v43; // rax
  unsigned __int64 v45; // r9
  unsigned __int64 v46; // rcx
  unsigned __int64 v47; // r8
  unsigned __int64 v48; // rax
  __int64 v49; // r15
  unsigned __int64 v50; // rax
  unsigned __int64 v51; // rbx
  unsigned __int64 v52; // rax
  unsigned __int64 v53; // r13
  unsigned __int64 v54; // r12
  __int64 v55; // rax
  __int64 v56; // rax
  unsigned __int64 v57; // rax
  unsigned __int64 v59; // [rsp+0h] [rbp-888h]
  unsigned __int64 v60; // [rsp+0h] [rbp-888h]
  unsigned __int64 v61; // [rsp+8h] [rbp-880h]
  unsigned __int64 v62; // [rsp+8h] [rbp-880h]
  unsigned __int64 v63; // [rsp+10h] [rbp-878h]
  unsigned __int64 v64; // [rsp+10h] [rbp-878h]
  unsigned __int64 v65; // [rsp+18h] [rbp-870h]
  unsigned __int64 v66; // [rsp+18h] [rbp-870h]
  unsigned __int64 v67; // [rsp+20h] [rbp-868h]
  unsigned __int64 v68; // [rsp+20h] [rbp-868h]
  unsigned __int64 v69; // [rsp+28h] [rbp-860h]
  unsigned __int64 v70; // [rsp+30h] [rbp-858h]
  unsigned __int64 v71; // [rsp+38h] [rbp-850h]
  __int64 v72[256]; // [rsp+40h] [rbp-848h] BYREF
  char v73; // [rsp+840h] [rbp-48h] BYREF
  unsigned __int64 v74; // [rsp+848h] [rbp-40h]

  v74 = __readfsqword(0x28u);
  if ( a4 <= 1 )
  {
    v9 = 1LL;
    v21 = 0LL;
    goto LABEL_16;
  }
  v8 = 0LL;
  v9 = 1LL;
  v10 = 1LL;
  v11 = -1LL;
  v12 = 1LL;
  do
  {
    while ( 1 )
    {
      v13 = *(_BYTE *)(a3 + v10 + v11);
      if ( *(_BYTE *)(a3 + v12) >= v13 )
        break;
      v8 = v12;
      v10 = 1LL;
      v9 = v12 - v11;
LABEL_4:
      v12 = v10 + v8;
      if ( a4 <= v10 + v8 )
        goto LABEL_8;
    }
    if ( *(_BYTE *)(a3 + v12) == v13 )
    {
      if ( v10 == v9 )
      {
        v8 += v10;
        v10 = 1LL;
      }
      else
      {
        ++v10;
      }
      goto LABEL_4;
    }
    v11 = v8;
    v10 = 1LL;
    ++v8;
    v9 = 1LL;
    v12 = v8 + 1;
  }
  while ( a4 > v8 + 1 );
LABEL_8:
  v14 = 0LL;
  v15 = 1LL;
  v16 = 1LL;
  v17 = -1LL;
  v18 = 1LL;
  do
  {
    while ( 1 )
    {
      v19 = *(_BYTE *)(a3 + v17 + v16);
      if ( *(_BYTE *)(a3 + v18) <= v19 )
        break;
      v14 = v18;
      v16 = 1LL;
      v15 = v18 - v17;
LABEL_10:
      v18 = v14 + v16;
      if ( a4 <= v14 + v16 )
        goto LABEL_14;
    }
    if ( *(_BYTE *)(a3 + v18) == v19 )
    {
      if ( v15 == v16 )
      {
        v14 += v15;
        v16 = 1LL;
      }
      else
      {
        ++v16;
      }
      goto LABEL_10;
    }
    v17 = v14;
    v16 = 1LL;
    ++v14;
    v15 = 1LL;
    v18 = v14 + 1;
  }
  while ( a4 > v14 + 1 );
LABEL_14:
  v20 = v17 + 1;
  v21 = v11 + 1;
  if ( v11 + 1 <= v20 )
  {
    v9 = v15;
    v21 = v20;
  }
LABEL_16:
  v22 = (char *)v72;
  do
  {
    *(_QWORD *)v22 = a4;
    v22 += 8;
  }
  while ( v22 != &v73 );
  if ( a4 )
  {
    v23 = (unsigned __int8 *)a3;
    do
    {
      v24 = *v23;
      v25 = a3 + a4 - 1 - (_QWORD)v23++;
      v72[v24] = v25;
    }
    while ( (unsigned __int8 *)(a4 + a3) != v23 );
  }
  if ( !(unsigned int)memcmp(a3, a3 + v9, v21) )
  {
    v27 = a4 - 1;
    v67 = a4 + 512;
    v28 = a4;
    v70 = 1 - v21;
    v71 = v21 - 1;
    v29 = a4;
    v30 = 0LL;
    v31 = v21;
    v32 = 0LL;
    v69 = v29 - v9;
    v33 = v27;
    v34 = v9;
    v35 = a1;
    v36 = a2;
    v37 = a3;
    v38 = v33;
    while ( 1 )
    {
LABEL_27:
      v40 = v30 + v28;
      if ( v30 + v28 > v36 )
      {
        v65 = v28;
        v63 = v34;
        v61 = v31;
        v59 = v30 + v28;
        v41 = sub_9040(v35 + v36, v67, v40, v31, v28, v34);
        v40 = v59;
        v31 = v61;
        v36 += v41;
        v34 = v63;
        v28 = v65;
        if ( v59 > v36 )
          return 0LL;
      }
      v39 = v72[*(unsigned __int8 *)(v35 + v40 - 1)];
      if ( v39 )
        break;
      v39 = v31;
      if ( v32 >= v31 )
        v39 = v32;
      if ( v39 < v38 )
      {
        while ( *(_BYTE *)(v37 + v39) == *(_BYTE *)(v35 + v30 + v39) )
        {
          if ( ++v39 >= v38 )
            goto LABEL_41;
        }
        v30 += v70;
        goto LABEL_26;
      }
LABEL_41:
      v42 = v31;
      v43 = v71;
      if ( v32 < v31 )
      {
        while ( 1 )
        {
          v42 = v43 + 1;
          if ( *(_BYTE *)(v37 + v43) != *(_BYTE *)(v43 + v35 + v30 + v71 - v31 + 1) )
            break;
          if ( v32 == v43 )
          {
            v42 = v32;
            break;
          }
          --v43;
        }
      }
      if ( v32 + 1 > v42 )
        return v35 + v30;
      v32 = v69;
      v30 += v34;
    }
    if ( v32 && v39 < v34 )
      v39 = v69;
LABEL_26:
    v30 += v39;
    v32 = 0LL;
    goto LABEL_27;
  }
  v45 = a4 - 1;
  v46 = v21;
  v47 = a4;
  v48 = a4 - v21;
  if ( a4 - v21 < v21 )
    v48 = v21;
  v49 = 0LL;
  v68 = v48 + 1;
  v50 = a4 + 512;
  v51 = a4 - 1;
  v64 = v50;
  v52 = 1 - v21;
  v53 = a2;
  v66 = v52;
  while ( 1 )
  {
    v54 = v49 + v47;
    if ( v49 + v47 > v53 )
    {
      v62 = v47;
      v60 = v46;
      v55 = sub_9040(a1 + v53, v64, v26, v46, v47, v45);
      v46 = v60;
      v47 = v62;
      v53 += v55;
      if ( v54 > v53 )
        return 0LL;
    }
    v56 = v72[*(unsigned __int8 *)(a1 + v54 - 1)];
    if ( v56 )
      goto LABEL_53;
    v56 = v46;
    v26 = a1 + v49;
    if ( v46 < v51 )
    {
      while ( *(_BYTE *)(a3 + v56) == *(_BYTE *)(v26 + v56) )
      {
        if ( ++v56 >= v51 )
          goto LABEL_62;
      }
      v49 += v66;
LABEL_53:
      v49 += v56;
      continue;
    }
LABEL_62:
    v57 = v46 - 1;
    if ( !v46 )
      return a1 + v49;
    v26 = a1 + v49 - 1;
    while ( *(_BYTE *)(a3 + v57) == *(_BYTE *)(v57 + a1 + v49) )
    {
      if ( v57-- == 0 )
        return a1 + v49;
    }
    v49 += v68;
  }
}
// 235EE: variable 'v26' is possibly undefined
// 235EE: variable 'v45' is possibly undefined
// 9040: using guessed type __int64 __fastcall sub_9040(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000239D0) ----------------------------------------------------
_BYTE *(__fastcall *sub_239D0())(__int64 a1, unsigned __int8 *a2)
{
  _BYTE *(__fastcall *result)(__int64, unsigned __int8 *); // rax

  result = sub_46D50;
  if ( (dword_C1434 & 0x10) == 0 )
    result = (_BYTE *(__fastcall *)(__int64, unsigned __int8 *))&loc_236D0;
  return result;
}
// C1434: using guessed type int dword_C1434;

//----- (00000000000239F0) ----------------------------------------------------
void *sub_239F0()
{
  void *result; // rax

  result = sub_2B0B0;
  if ( (dword_C1434 & 0x800) == 0 && (BYTE4(xmmword_C1384) & 0x20) != 0 && (dword_C1434 & 0x100) != 0 )
    result = sub_2B5F0;
  return result;
}
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (0000000000023A20) ----------------------------------------------------
__int64 (__fastcall *sub_23A20())()
{
  __int64 (__fastcall *result)(); // rax

  if ( (dword_C1434 & 0x800) != 0
    || (BYTE4(xmmword_C1384) & 0x20) == 0
    || (DWORD2(xmmword_C1364) & 0x400000) == 0
    || (result = (__int64 (__fastcall *)())sub_2BE10, (dword_C1434 & 0x100) == 0) )
  {
    result = (__int64 (__fastcall *)())sub_2C1F0;
    if ( (DWORD2(xmmword_C1364) & 0x80000) == 0 )
    {
      result = (__int64 (__fastcall *)())sub_2BA10;
      if ( (BYTE9(xmmword_C1364) & 2) != 0 )
        result = (__int64 (__fastcall *)())sub_455E0;
    }
  }
  return result;
}
// C1364: using guessed type __int128 xmmword_C1364;
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (0000000000023A80) ----------------------------------------------------
__int64 (__fastcall *sub_23A80())()
{
  __int64 (__fastcall *result)(); // rax

  result = (__int64 (__fastcall *)())&loc_476F0;
  if ( (dword_C1434 & 0x3000) == 0 )
  {
    if ( (DWORD1(xmmword_C1384) & 0x10000) == 0 || (dword_C1434 & 0x4000) != 0 )
    {
      if ( (dword_C1434 & 0x100) != 0 )
      {
        result = (__int64 (__fastcall *)())&loc_47AA0;
        if ( (BYTE5(xmmword_C1384) & 2) == 0 )
          result = (__int64 (__fastcall *)())sub_47A50;
      }
      else if ( (BYTE9(xmmword_C1364) & 2) == 0 || (dword_C1434 & 0x20) != 0 )
      {
        result = (__int64 (__fastcall *)())&loc_47740;
        if ( (BYTE5(xmmword_C1384) & 2) == 0 )
          result = (__int64 (__fastcall *)())sub_47680;
      }
      else
      {
        result = sub_30240;
        if ( (dword_C1434 & 8) != 0 )
          result = sub_358E0;
      }
    }
    else
    {
      result = (__int64 (__fastcall *)())sub_38430;
      if ( (dword_C1434 & 0x800) == 0 )
      {
        result = (__int64 (__fastcall *)())&loc_47EE0;
        if ( (BYTE5(xmmword_C1384) & 2) == 0 )
          result = (__int64 (__fastcall *)())sub_47E90;
      }
    }
  }
  return result;
}
// 30240: using guessed type __int64 __fastcall sub_30240();
// 358E0: using guessed type __int64 __fastcall sub_358E0();
// C1364: using guessed type __int128 xmmword_C1364;
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (0000000000023B30) ----------------------------------------------------
__int64 (__fastcall *sub_23B30())()
{
  __int64 (__fastcall *result)(); // rax
  int v1; // eax
  bool v2; // zf

  result = sub_48440;
  if ( (dword_C1434 & 0x1000) == 0 )
  {
    if ( (DWORD1(xmmword_C1384) & 0x10000) == 0 || (dword_C1434 & 0x4000) != 0 )
    {
      v1 = WORD2(xmmword_C1384) & 0x200;
      if ( (BYTE4(xmmword_C1384) & 0x20) != 0 )
      {
        v2 = v1 == 0;
        result = (__int64 (__fastcall *)())&loc_485C0;
        if ( v2 )
          result = sub_48570;
      }
      else
      {
        v2 = v1 == 0;
        result = sub_483F0;
        if ( !v2 )
          result = sub_48460;
      }
    }
    else
    {
      result = sub_473F0;
      if ( (dword_C1434 & 0x800) == 0 )
      {
        result = (__int64 (__fastcall *)())&loc_48750;
        if ( (BYTE5(xmmword_C1384) & 2) == 0 )
          result = sub_486F0;
      }
    }
  }
  return result;
}
// 473F0: using guessed type __int64 __fastcall sub_473F0();
// 483F0: using guessed type __int64 __fastcall sub_483F0();
// 48440: using guessed type __int64 __fastcall sub_48440();
// 48460: using guessed type __int64 __fastcall sub_48460();
// 48570: using guessed type __int64 __fastcall sub_48570();
// 486F0: using guessed type __int64 __fastcall sub_486F0();
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (0000000000023BC0) ----------------------------------------------------
void (*sub_23BC0())()
{
  void (*result)(); // rax

  result = (void (*)())&loc_476C0;
  if ( (dword_C1434 & 0x3000) == 0 )
  {
    if ( (DWORD1(xmmword_C1384) & 0x10000) == 0 || (dword_C1434 & 0x4000) != 0 )
    {
      if ( (dword_C1434 & 0x100) != 0 )
      {
        result = (void (*)())&loc_47A90;
        if ( (BYTE5(xmmword_C1384) & 2) == 0 )
          result = sub_47A40;
      }
      else if ( (BYTE9(xmmword_C1364) & 2) == 0 || (dword_C1434 & 0x20) != 0 )
      {
        result = (void (*)())&loc_47730;
        if ( (BYTE5(xmmword_C1384) & 2) == 0 )
          result = sub_47670;
      }
      else
      {
        result = (void (*)())sub_2D840;
        if ( (dword_C1434 & 8) != 0 )
          result = (void (*)())sub_32DD0;
      }
    }
    else
    {
      result = (void (*)())sub_38410;
      if ( (dword_C1434 & 0x800) == 0 )
      {
        result = (void (*)())&loc_47ED0;
        if ( (BYTE5(xmmword_C1384) & 2) == 0 )
          result = sub_47E80;
      }
    }
  }
  return result;
}
// 2D840: using guessed type __int64 __fastcall sub_2D840();
// 32DD0: using guessed type __int64 __fastcall sub_32DD0();
// 38410: using guessed type __int64 __fastcall sub_38410();
// C1364: using guessed type __int128 xmmword_C1364;
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (0000000000023C70) ----------------------------------------------------
void *sub_23C70()
{
  void *result; // rax

  if ( (dword_C1434 & 0x800) != 0
    || (BYTE4(xmmword_C1384) & 0x20) == 0
    || (result = sub_44F10, (dword_C1434 & 0x100) == 0) )
  {
    result = sub_44850;
    if ( (dword_C1434 & 0x10) == 0 )
    {
      result = sub_41170;
      if ( (BYTE9(xmmword_C1364) & 2) != 0 )
        result = sub_42A10;
    }
  }
  return result;
}
// C1364: using guessed type __int128 xmmword_C1364;
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (0000000000023CC0) ----------------------------------------------------
__int64 (__fastcall *sub_23CC0())()
{
  __int64 (__fastcall *result)(); // rax

  result = (__int64 (__fastcall *)())sub_3EAE4;
  if ( (DWORD2(xmmword_C1364) & 0x10000000) == 0 )
  {
    if ( (DWORD2(xmmword_C1364) & 0x100000) == 0
      || (result = (__int64 (__fastcall *)())sub_3CF34, (dword_C1434 & 0x80u) != 0) )
    {
      result = (__int64 (__fastcall *)())sub_38B90;
      if ( (BYTE9(xmmword_C1364) & 2) != 0 )
        result = (__int64 (__fastcall *)())sub_3ADE0;
    }
  }
  return result;
}
// C1364: using guessed type __int128 xmmword_C1364;
// C1434: using guessed type int dword_C1434;

//----- (0000000000023D10) ----------------------------------------------------
__int64 (__fastcall *sub_23D10())()
{
  __int64 (__fastcall *result)(); // rax

  result = (__int64 (__fastcall *)())&loc_476F0;
  if ( (dword_C1434 & 0x3000) == 0 )
  {
    if ( (DWORD1(xmmword_C1384) & 0x10000) == 0 || (dword_C1434 & 0x4000) != 0 )
    {
      if ( (dword_C1434 & 0x100) != 0 )
      {
        result = (__int64 (__fastcall *)())&loc_47AA0;
        if ( (BYTE5(xmmword_C1384) & 2) == 0 )
          result = (__int64 (__fastcall *)())sub_47A50;
      }
      else if ( (BYTE9(xmmword_C1364) & 2) == 0 || (dword_C1434 & 0x20) != 0 )
      {
        result = (__int64 (__fastcall *)())&loc_47740;
        if ( (BYTE5(xmmword_C1384) & 2) == 0 )
          result = (__int64 (__fastcall *)())sub_47680;
      }
      else
      {
        result = (__int64 (__fastcall *)())sub_2D860;
        if ( (dword_C1434 & 8) != 0 )
          result = (__int64 (__fastcall *)())sub_32DF0;
      }
    }
    else
    {
      result = (__int64 (__fastcall *)())sub_38430;
      if ( (dword_C1434 & 0x800) == 0 )
      {
        result = (__int64 (__fastcall *)())&loc_47EE0;
        if ( (BYTE5(xmmword_C1384) & 2) == 0 )
          result = (__int64 (__fastcall *)())sub_47E90;
      }
    }
  }
  return result;
}
// C1364: using guessed type __int128 xmmword_C1364;
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (0000000000023DC0) ----------------------------------------------------
void *sub_23DC0()
{
  void *result; // rax

  result = sub_2B3E0;
  if ( (dword_C1434 & 0x800) == 0 && (BYTE4(xmmword_C1384) & 0x20) != 0 && (dword_C1434 & 0x100) != 0 )
    result = sub_2B8C0;
  return result;
}
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (0000000000023DF0) ----------------------------------------------------
void *sub_23DF0()
{
  void *result; // rax

  result = sub_40380;
  if ( (dword_C1434 & 0x800) == 0 && (BYTE4(xmmword_C1384) & 0x20) != 0 && (dword_C1434 & 0x100) != 0 )
    result = sub_407C0;
  return result;
}
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (0000000000023E20) ----------------------------------------------------
__int64 __fastcall sub_23E20(__int64 *a1, __int64 *a2)
{
  unsigned int v2; // ecx
  unsigned int v3; // eax
  __m128i v4; // xmm1
  __m128i v5; // xmm2
  unsigned __int64 v6; // rdx
  const __m128i *v7; // rsi
  __m128i *v8; // rdi
  __int64 v9; // r8
  __int64 v10; // rcx
  __int64 v11; // rax
  unsigned int v12; // et0
  __m128i *v13; // rt1
  __m128i v15; // xmm1
  __m128i v16; // xmm0
  __m128i v17; // xmm1
  __m128i v18; // xmm0
  __m128i v19; // xmm1

  v2 = (unsigned __int8)a2 & 0x3F;
  v3 = (unsigned __int8)a1 & 0x3F;
  if ( v2 <= 0x30 && v3 <= 0x30 )
  {
    v4.m128i_i64[0] = *a1;
    v5.m128i_i64[0] = *a2;
    v4.m128i_i64[1] = a1[1];
    v5.m128i_i64[1] = a2[1];
    v6 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v4, v5), _mm_cmpeq_epi8((__m128i)0LL, v4)))
                      - 0xFFFF);
    if ( (_DWORD)v6 )
    {
LABEL_16:
      _BitScanForward64(&v6, v6);
      return *((unsigned __int8 *)a1 + v6) - (unsigned int)*((unsigned __int8 *)a2 + v6);
    }
    a2 += 2;
    a1 += 2;
  }
  v7 = (const __m128i *)((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL);
  v8 = (__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL);
  v9 = 0LL;
  v10 = v2 & 0xF;
  v11 = v3 & 0xF;
  if ( (_DWORD)v10 == (_DWORD)v11 )
  {
    v15 = _mm_load_si128(v7);
    v6 = (0xFFFFu >> v10)
       - ((unsigned int)_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v15, *v8), _mm_cmpeq_epi8((__m128i)0LL, v15))) >> v10);
    if ( !(_DWORD)v6 )
    {
      v10 = 16LL;
      v16 = 0LL;
      while ( 1 )
      {
        v17 = _mm_load_si128((const __m128i *)((char *)v7 + v10));
        v18 = _mm_cmpeq_epi8(v16, v17);
        v6 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v17, _mm_load_si128((__m128i *)((char *)v8 + v10))), v18))
                          - 0xFFFF);
        if ( (_DWORD)v6 )
          break;
        v10 += 16LL;
        v19 = _mm_load_si128((const __m128i *)((char *)v7 + v10));
        v16 = _mm_cmpeq_epi8(v18, v19);
        v6 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v19, _mm_load_si128((__m128i *)((char *)v8 + v10))), v16))
                          - 0xFFFF);
        if ( (_DWORD)v6 )
          break;
        v10 += 16LL;
      }
      v11 = v10;
    }
    a1 = (__int64 *)((char *)v8->m128i_i64 + v11);
    a2 = (__int64 *)((char *)v7->m128i_i64 + v10);
    goto LABEL_16;
  }
  if ( (unsigned int)v10 <= (unsigned int)v11 )
  {
    v9 = 0xFFFFLL;
    v12 = v11;
    v11 = (unsigned int)v10;
    v10 = v12;
    v13 = (__m128i *)v7;
    v7 = v8;
    v8 = v13;
  }
  return ((__int64 (__fastcall *)(__m128i *, const __m128i *, __int64, __int64, __int64))((char *)dword_91618
                                                                                        + dword_91618[v11 + 15 - v10]))(
           v8,
           v7,
           0xFFFFLL,
           v10,
           v9);
}

//----- (0000000000025270) ----------------------------------------------------
__int64 __fastcall sub_25270(const __m128i *a1, const __m128i *a2)
{
  __int64 v2; // rdx
  __m128i v3; // xmm1
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rdx
  __int64 result; // rax
  __m128i v7; // xmm6
  __m128i v8; // xmm5
  __m128i v9; // xmm4
  const __m128i *v10; // rax
  const __m128i *v11; // rdx
  unsigned __int64 v12; // rsi
  __m128i v14; // xmm2
  __m128i v15; // xmm3
  __m128i v16; // xmm0
  __m128i v17; // xmm1
  __m128i v18; // xmm2
  __m128i v19; // xmm3
  __m128i v20; // xmm5
  __m128i v21; // xmm6
  __m128i v22; // xmm2
  unsigned __int64 v23; // rcx
  __int64 v24; // r9
  __m128i v25; // xmm2
  __m128i v26; // xmm3
  __m128i v27; // xmm0
  __m128i v28; // xmm1
  __m128i v29; // xmm2
  __m128i v30; // xmm3
  unsigned __int64 v31; // rdi
  unsigned __int64 v32; // rcx
  int v33; // eax
  int v34; // ecx

  v2 = 0LL;
  if ( (((unsigned __int16)a2 | (unsigned __int16)a1) & 0xFFFu) > 0xFC0 )
  {
    while ( 1 )
    {
      v33 = a1->m128i_u8[v2];
      v34 = a2->m128i_u8[v2];
      if ( !(_BYTE)v33 )
        break;
      if ( (_BYTE)v33 != (_BYTE)v34 )
        goto LABEL_16;
      if ( ++v2 == 64 )
        goto LABEL_5;
    }
    v33 = 0;
LABEL_16:
    result = (unsigned int)(v33 - v34);
  }
  else
  {
    v3 = _mm_loadu_si128(a1);
    v4 = (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_cmpeq_epi8(_mm_loadu_si128(a2), v3), v3), (__m128i)0LL));
    if ( (_DWORD)v4
      || (v7 = _mm_loadu_si128(a1 + 1),
          v8 = _mm_loadu_si128(a1 + 2),
          v9 = _mm_loadu_si128(a1 + 3),
          (v4 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(
                                                   _mm_cmpeq_epi8(
                                                     _mm_min_epu8(_mm_cmpeq_epi8(_mm_loadu_si128(a2 + 3), v9), v9),
                                                     (__m128i)0LL)) << 48) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_cmpeq_epi8(_mm_loadu_si128(a2 + 1), v7), v7), (__m128i)0LL)) << 16) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_cmpeq_epi8(_mm_loadu_si128(a2 + 2), v8), v8), (__m128i)0LL)) << 32)) != 0) )
    {
      _BitScanForward64(&v5, v4);
      result = a1->m128i_u8[v5] - (unsigned int)a2->m128i_u8[v5];
    }
    else
    {
LABEL_5:
      v10 = (const __m128i *)((unsigned __int64)&a1[4] & 0xFFFFFFFFFFFFFFC0LL);
      v11 = (const __m128i *)((char *)a2 + (char *)v10 - (char *)a1);
      v12 = (4096 - (unsigned __int64)(((_WORD)a2 + (((_WORD)a1 + 64) & 0xFFC0) - (_WORD)a1) & 0xFFF)) >> 6;
      while ( 1 )
      {
        if ( v12-- == 0 )
        {
          v24 = (unsigned __int8)v11 & 0x3F;
          v25 = _mm_loadu_si128((const __m128i *)((char *)v10 - v24));
          v26 = _mm_loadu_si128((const __m128i *)((char *)v10 - v24 + 16));
          v27 = _mm_min_epu8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)v11 - v24)), v25), v25);
          v28 = _mm_min_epu8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)v11 - v24 + 16)), v26), v26);
          v29 = _mm_loadu_si128((const __m128i *)((char *)v10 - v24 + 32));
          v30 = _mm_loadu_si128((const __m128i *)((char *)v10 - v24 + 48));
          v12 = 63LL;
          v31 = (((unsigned __int64)(unsigned int)_mm_movemask_epi8(
                                                    _mm_cmpeq_epi8(
                                                      _mm_min_epu8(
                                                        _mm_cmpeq_epi8(
                                                          _mm_load_si128((const __m128i *)((char *)v11 - v24 + 48)),
                                                          v30),
                                                        v30),
                                                      (__m128i)0LL)) << 48) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v28, (__m128i)0LL)) << 16) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)v11 - v24 + 32)), v29), v29), (__m128i)0LL)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v27, (__m128i)0LL))) >> ((unsigned __int8)v11 & 0x3F);
          if ( v31 )
            break;
        }
        v14 = _mm_load_si128(v10);
        v15 = _mm_load_si128(v10 + 1);
        v16 = _mm_min_epu8(_mm_cmpeq_epi8(_mm_loadu_si128(v11), v14), v14);
        v17 = _mm_min_epu8(_mm_cmpeq_epi8(_mm_loadu_si128(v11 + 1), v15), v15);
        v18 = _mm_load_si128(v10 + 2);
        v19 = _mm_load_si128(v10 + 3);
        v20 = _mm_min_epu8(_mm_cmpeq_epi8(_mm_loadu_si128(v11 + 2), v18), v18);
        v21 = _mm_min_epu8(_mm_cmpeq_epi8(_mm_loadu_si128(v11 + 3), v19), v19);
        if ( _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(_mm_min_epu8(v16, v17), v20), v21), (__m128i)0LL)) )
        {
          v22 = _mm_load_si128(v10);
          _BitScanForward64(
            &v23,
            ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v21, (__m128i)0LL)) << 48) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_cmpeq_epi8(_mm_loadu_si128(v11), v22), v22), (__m128i)0LL)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v20, (__m128i)0LL)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v17, (__m128i)0LL)) << 16));
          return v10->m128i_u8[v23] - (unsigned int)v11->m128i_u8[v23];
        }
        v10 += 4;
        v11 += 4;
      }
      _BitScanForward64(&v32, v31);
      result = v10->m128i_u8[v32] - (unsigned int)v11->m128i_u8[v32];
    }
  }
  return result;
}

//----- (0000000000025520) ----------------------------------------------------
__int64 __fastcall sub_25520(__int64 *a1, __int64 *a2)
{
  unsigned int v2; // ecx
  unsigned int v3; // eax
  __m128i v4; // xmm1
  __m128i v5; // xmm2
  unsigned __int64 v6; // rdx
  const __m128i *v7; // rsi
  __m128i *v8; // rdi
  __int64 v9; // r8
  __int64 v10; // rcx
  __int64 v11; // rax
  unsigned int v12; // et0
  __m128i *v13; // rt1
  __m128i v15; // xmm1
  __m128i v16; // xmm0
  __m128i v17; // xmm1
  __m128i v18; // xmm0
  __m128i v19; // xmm1

  v2 = (unsigned __int8)a2 & 0x3F;
  v3 = (unsigned __int8)a1 & 0x3F;
  if ( v2 <= 0x30 && v3 <= 0x30 )
  {
    v4.m128i_i64[0] = *a1;
    v5.m128i_i64[0] = *a2;
    v4.m128i_i64[1] = a1[1];
    v5.m128i_i64[1] = a2[1];
    v6 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v4, v5), _mm_cmpeq_epi8((__m128i)0LL, v4)))
                      - 0xFFFF);
    if ( (_DWORD)v6 )
    {
LABEL_16:
      _BitScanForward64(&v6, v6);
      return *((unsigned __int8 *)a1 + v6) - (unsigned int)*((unsigned __int8 *)a2 + v6);
    }
    a2 += 2;
    a1 += 2;
  }
  v7 = (const __m128i *)((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL);
  v8 = (__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL);
  v9 = 0LL;
  v10 = v2 & 0xF;
  v11 = v3 & 0xF;
  if ( (_DWORD)v10 == (_DWORD)v11 )
  {
    v15 = _mm_load_si128(v7);
    v6 = (0xFFFFu >> v10)
       - ((unsigned int)_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v15, *v8), _mm_cmpeq_epi8((__m128i)0LL, v15))) >> v10);
    if ( !(_DWORD)v6 )
    {
      v10 = 16LL;
      v16 = 0LL;
      while ( 1 )
      {
        v17 = _mm_load_si128((const __m128i *)((char *)v7 + v10));
        v18 = _mm_cmpeq_epi8(v16, v17);
        v6 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v17, _mm_load_si128((__m128i *)((char *)v8 + v10))), v18))
                          - 0xFFFF);
        if ( (_DWORD)v6 )
          break;
        v10 += 16LL;
        v19 = _mm_load_si128((const __m128i *)((char *)v7 + v10));
        v16 = _mm_cmpeq_epi8(v18, v19);
        v6 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v19, _mm_load_si128((__m128i *)((char *)v8 + v10))), v16))
                          - 0xFFFF);
        if ( (_DWORD)v6 )
          break;
        v10 += 16LL;
      }
      v11 = v10;
    }
    a1 = (__int64 *)((char *)v8->m128i_i64 + v11);
    a2 = (__int64 *)((char *)v7->m128i_i64 + v10);
    goto LABEL_16;
  }
  if ( (unsigned int)v10 <= (unsigned int)v11 )
  {
    v9 = 0xFFFFLL;
    v12 = v11;
    v11 = (unsigned int)v10;
    v10 = v12;
    v13 = (__m128i *)v7;
    v7 = v8;
    v8 = v13;
  }
  return ((__int64 (__fastcall *)(__m128i *, const __m128i *, __int64, __int64, __int64))((char *)dword_91658
                                                                                        + dword_91658[v11 + 15 - v10]))(
           v8,
           v7,
           0xFFFFLL,
           v10,
           v9);
}

//----- (0000000000026790) ----------------------------------------------------
__int64 __fastcall sub_26790(unsigned __int64 _RDI, __int64 _RSI, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __m128 _XMM7)
{
  int v12; // eax
  __int64 result; // rax
  unsigned __int64 v36; // rdx
  bool v38; // zf
  unsigned __int64 v64; // rcx
  __int64 v83; // r8
  int v85; // eax
  int v86; // ecx
  __int64 v87; // rdi
  __int64 v88; // rsi

  _RDX = 0LL;
  __asm { vpxor   xmm7, xmm7, xmm7 }
  v12 = ((unsigned __int16)_RSI | (unsigned __int16)_RDI) & 0xFFF;
  if ( (unsigned int)v12 <= 0xF80 )
  {
    __asm
    {
      vmovdqu ymm1, ymmword ptr [rdi]
      vpcmpeqb ymm0, ymm1, ymmword ptr [rsi]
      vpminub ymm0, ymm0, ymm1
      vpcmpeqb ymm0, ymm0, ymm7
      vpmovmskb ecx, ymm0
    }
    if ( _ECX )
    {
      __asm { tzcnt   edx, ecx }
      result = *(unsigned __int8 *)(_RDI + _RDX) - (unsigned int)*(unsigned __int8 *)(_RSI + _RDX);
      __asm { vzeroupper }
    }
    else
    {
      __asm
      {
        vmovdqu ymm6, ymmword ptr [rdi+20h]
        vpcmpeqb ymm3, ymm6, ymmword ptr [rsi+20h]
        vpminub ymm3, ymm3, ymm6
        vpcmpeqb ymm3, ymm3, ymm7
        vpmovmskb ecx, ymm3
      }
      if ( _ECX )
      {
        __asm { tzcnt   edx, ecx }
        result = *(unsigned __int8 *)(_RDI + _RDX + 32) - (unsigned int)*(unsigned __int8 *)(_RSI + _RDX + 32);
        __asm { vzeroupper }
      }
      else
      {
        __asm
        {
          vmovdqu ymm5, ymmword ptr [rdi+40h]
          vmovdqu ymm4, ymmword ptr [rdi+60h]
          vmovdqu ymm0, ymmword ptr [rsi+60h]
          vpcmpeqb ymm2, ymm5, ymmword ptr [rsi+40h]
          vpminub ymm2, ymm2, ymm5
          vpcmpeqb ymm0, ymm0, ymm4
          vpcmpeqb ymm2, ymm2, ymm7
          vpmovmskb ecx, ymm2
        }
        if ( _ECX )
        {
          __asm { tzcnt   edx, ecx }
          result = *(unsigned __int8 *)(_RDI + _RDX + 64) - (unsigned int)*(unsigned __int8 *)(_RSI + _RDX + 64);
          __asm { vzeroupper }
        }
        else
        {
          __asm
          {
            vpminub ymm0, ymm0, ymm4
            vpcmpeqb ymm0, ymm0, ymm7
            vpmovmskb ecx, ymm0
          }
          if ( _ECX )
          {
            __asm { tzcnt   edx, ecx }
            result = *(unsigned __int8 *)(_RDI + _RDX + 96) - (unsigned int)*(unsigned __int8 *)(_RSI + _RDX + 96);
            __asm { vzeroupper }
          }
          else
          {
LABEL_10:
            _RAX = (_RDI + 128) & 0xFFFFFFFFFFFFFF80LL;
            v36 = _RSI + _RAX - _RDI;
            _RCX = (4096 - (unsigned __int64)(((_WORD)_RSI + (((_WORD)_RDI + 128) & 0xFF80) - (_WORD)_RDI) & 0xFFF)) >> 7;
            LODWORD(_RSI) = _RCX;
            while ( 1 )
            {
              v38 = (_DWORD)_RSI == 0;
              _RSI = (unsigned int)(_RSI - 1);
              if ( v38 )
              {
                v64 = v36 & 0x7F;
                _R10 = -(__int64)v64;
                if ( (v36 & 0x7F) < 0x40 )
                {
                  __asm
                  {
                    vmovdqu ymm2, ymmword ptr [rax+r10]
                    vmovdqu ymm3, ymmword ptr [rax+r10+20h]
                    vpcmpeqb ymm0, ymm2, ymmword ptr [rdx+r10]
                    vpcmpeqb ymm1, ymm3, ymmword ptr [rdx+r10+20h]
                    vpminub ymm0, ymm0, ymm2
                    vpminub ymm1, ymm1, ymm3
                    vpcmpeqb ymm0, ymm0, ymm7
                    vpcmpeqb ymm1, ymm1, ymm7
                    vpmovmskb edi, ymm0
                    vpmovmskb esi, ymm1
                  }
                  _RSI <<= 32;
                  _RDI = (_RSI ^ _RDI) >> v64;
                  if ( _RDI )
                  {
                    __asm { tzcnt   rcx, rdi }
                    result = *(unsigned __int8 *)(_RAX + _RCX) - (unsigned int)*(unsigned __int8 *)(v36 + _RCX);
                    __asm { vzeroupper }
                    return result;
                  }
                }
                __asm
                {
                  vmovdqu ymm2, ymmword ptr [rax+r10+40h]
                  vmovdqu ymm3, ymmword ptr [rax+r10+60h]
                  vpcmpeqb ymm5, ymm2, ymmword ptr [rdx+r10+40h]
                  vpminub ymm5, ymm5, ymm2
                  vpcmpeqb ymm6, ymm3, ymmword ptr [rdx+r10+60h]
                  vpcmpeqb ymm5, ymm5, ymm7
                  vpminub ymm6, ymm6, ymm3
                  vpcmpeqb ymm6, ymm6, ymm7
                  vpmovmskb edi, ymm5
                  vpmovmskb esi, ymm6
                }
                _RDI ^= _RSI << 32;
                v83 = 0LL;
                _RCX = (unsigned int)(v64 - 64);
                if ( (v36 & 0x7F) > 0x40 )
                {
                  _RDI >>= _RCX;
                  v83 = (unsigned int)_RCX;
                }
                LODWORD(_RSI) = 31;
                if ( _RDI )
                {
                  __asm { tzcnt   rcx, rdi }
                  result = *(unsigned __int8 *)(_RAX + v83 + _R10 + _RCX + 64)
                         - (unsigned int)*(unsigned __int8 *)(v36 + v83 + _R10 + _RCX + 64);
                  __asm { vzeroupper }
                  return result;
                }
              }
              __asm
              {
                vmovdqa ymm0, ymmword ptr [rax]
                vmovdqa ymm3, ymmword ptr [rax+20h]
                vpcmpeqb ymm4, ymm0, ymmword ptr [rdx]
                vpcmpeqb ymm1, ymm3, ymmword ptr [rdx+20h]
                vpminub ymm4, ymm4, ymm0
                vpminub ymm1, ymm1, ymm3
                vmovdqa ymm2, ymmword ptr [rax+40h]
                vpminub ymm0, ymm4, ymm1
                vmovdqa ymm3, ymmword ptr [rax+60h]
                vpcmpeqb ymm5, ymm2, ymmword ptr [rdx+40h]
                vpcmpeqb ymm6, ymm3, ymmword ptr [rdx+60h]
                vpminub ymm5, ymm5, ymm2
                vpminub ymm6, ymm6, ymm3
                vpminub ymm0, ymm0, ymm5
                vpminub ymm0, ymm0, ymm6
                vpcmpeqb ymm0, ymm0, ymm7
                vpmovmskb ecx, ymm0
              }
              if ( _ECX )
                break;
              _RAX += 128LL;
              v36 += 128LL;
            }
            __asm
            {
              vpcmpeqb ymm0, ymm4, ymm7
              vpmovmskb edi, ymm0
            }
            if ( _EDI )
            {
              __asm { tzcnt   ecx, edi }
              result = *(unsigned __int8 *)(_RAX + _RCX) - (unsigned int)*(unsigned __int8 *)(v36 + _RCX);
              __asm { vzeroupper }
            }
            else
            {
              __asm
              {
                vpcmpeqb ymm1, ymm1, ymm7
                vpmovmskb ecx, ymm1
              }
              if ( _ECX )
              {
                __asm { tzcnt   edi, ecx }
                result = *(unsigned __int8 *)(_RAX + _RDI + 32) - (unsigned int)*(unsigned __int8 *)(v36 + _RDI + 32);
                __asm { vzeroupper }
              }
              else
              {
                __asm
                {
                  vpcmpeqb ymm5, ymm5, ymm7
                  vpmovmskb ecx, ymm5
                }
                if ( _ECX )
                {
                  __asm { tzcnt   edi, ecx }
                  result = *(unsigned __int8 *)(_RAX + _RDI + 64) - (unsigned int)*(unsigned __int8 *)(v36 + _RDI + 64);
                  __asm { vzeroupper }
                }
                else
                {
                  __asm
                  {
                    vpcmpeqb ymm6, ymm6, ymm7
                    vpmovmskb esi, ymm6
                    tzcnt   ecx, esi
                  }
                  result = *(unsigned __int8 *)(_RAX + _RCX + 96) - (unsigned int)*(unsigned __int8 *)(v36 + _RCX + 96);
                  __asm { vzeroupper }
                }
              }
            }
          }
        }
      }
    }
    return result;
  }
  if ( (((unsigned __int16)_RSI | (unsigned __int16)_RDI) & 0xFFFu) <= 0xFE0 )
  {
    do
    {
      __asm
      {
        vmovdqu ymm1, ymmword ptr [rdi+rdx]
        vpcmpeqb ymm0, ymm1, ymmword ptr [rsi+rdx]
        vpminub ymm0, ymm0, ymm1
        vpcmpeqb ymm0, ymm0, ymm7
        vpmovmskb ecx, ymm0
      }
      if ( _ECX )
        goto LABEL_33;
      _RDX = (unsigned int)(_RDX + 32);
      v12 += 32;
    }
    while ( v12 <= 4064 );
  }
  if ( v12 <= 4080 )
  {
    __asm
    {
      vmovdqu xmm1, xmmword ptr [rdi+rdx]
      vpcmpeqb xmm0, xmm1, xmmword ptr [rsi+rdx]
      vpminub xmm0, xmm0, xmm1
      vpcmpeqb xmm0, xmm0, xmm7
      vpmovmskb ecx, xmm0
    }
    if ( _ECX )
      goto LABEL_33;
    _RDX = (unsigned int)(_RDX + 16);
    v12 += 16;
  }
  if ( v12 <= 4088 )
  {
    __asm
    {
      vmovq   xmm1, qword ptr [rdi+rdx]
      vmovq   xmm0, qword ptr [rsi+rdx]
      vpcmpeqb xmm0, xmm1, xmm0
      vpminub xmm0, xmm0, xmm1
      vpcmpeqb xmm0, xmm0, xmm7
      vpmovmskb ecx, xmm0
    }
    _ECX = (unsigned __int8)_ECX;
    if ( (_BYTE)_ECX )
      goto LABEL_33;
    _RDX = (unsigned int)(_RDX + 8);
    v12 += 8;
  }
  if ( v12 > 4092 )
    goto LABEL_46;
  __asm
  {
    vmovd   xmm1, dword ptr [rdi+rdx]
    vmovd   xmm0, dword ptr [rsi+rdx]
    vpcmpeqb xmm0, xmm1, xmm0
    vpminub xmm0, xmm0, xmm1
    vpcmpeqb xmm0, xmm0, xmm7
    vpmovmskb ecx, xmm0
  }
  _ECX = _ECX & 0xF;
  if ( _ECX )
  {
LABEL_33:
    v87 = _RDX + _RDI;
    v88 = _RDX + _RSI;
    __asm { tzcnt   edx, ecx }
    result = *(unsigned __int8 *)(v87 + _RDX) - (unsigned int)*(unsigned __int8 *)(v88 + _RDX);
    __asm { vzeroupper }
    return result;
  }
  _RDX = (unsigned int)(_RDX + 4);
LABEL_46:
  v85 = *(unsigned __int8 *)(_RDI + _RDX);
  v86 = *(unsigned __int8 *)(_RSI + _RDX);
  if ( *(_BYTE *)(_RDI + _RDX) )
  {
    while ( 1 )
    {
      result = (unsigned int)(v85 - v86);
      if ( (_DWORD)result )
        break;
      _RDX = (unsigned int)(_RDX + 1);
      if ( (_DWORD)_RDX == 128 )
        goto LABEL_10;
      v85 = *(unsigned __int8 *)(_RDI + _RDX);
      v86 = *(unsigned __int8 *)(_RSI + _RDX);
      if ( !*(_BYTE *)(_RDI + _RDX) )
      {
        result = (unsigned int)(v85 - v86);
        break;
      }
    }
    __asm { vzeroupper }
  }
  else
  {
    result = (unsigned int)(v85 - v86);
    __asm { vzeroupper }
  }
  return result;
}

//----- (0000000000026BD0) ----------------------------------------------------
__int64 __fastcall sub_26BD0(__int64 *a1, __int64 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r11
  unsigned int v4; // ecx
  unsigned int v5; // eax
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  unsigned __int64 v8; // rdx
  bool v9; // cc
  const __m128i *v10; // rsi
  __m128i *v11; // rdi
  __int64 v12; // r8
  __int64 v13; // rcx
  __int64 v14; // rax
  unsigned int v15; // et0
  __m128i *v16; // rt1
  __m128i v18; // xmm1
  __m128i v19; // xmm0
  __m128i v20; // xmm1
  __m128i v21; // xmm0
  __m128i v22; // xmm1

  if ( !a3 )
    return 0LL;
  if ( a3 == 1 )
    return *(unsigned __int8 *)a1 - (unsigned int)*(unsigned __int8 *)a2;
  v3 = a3;
  v4 = (unsigned __int8)a2 & 0x3F;
  v5 = (unsigned __int8)a1 & 0x3F;
  if ( v4 <= 0x30 && v5 <= 0x30 )
  {
    v6.m128i_i64[0] = *a1;
    v7.m128i_i64[0] = *a2;
    v6.m128i_i64[1] = a1[1];
    v7.m128i_i64[1] = a2[1];
    v8 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v6, v7), _mm_cmpeq_epi8((__m128i)0LL, v6)))
                      - 0xFFFF);
    if ( (_DWORD)v8 )
      goto LABEL_23;
    v9 = v3 <= 0x10;
    v3 -= 16LL;
    if ( v9 )
      return 0LL;
    a2 += 2;
    a1 += 2;
  }
  v10 = (const __m128i *)((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL);
  v11 = (__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL);
  v12 = 0LL;
  v13 = v4 & 0xF;
  v14 = v5 & 0xF;
  if ( (_DWORD)v13 == (_DWORD)v14 )
  {
    v18 = _mm_load_si128(v10);
    v8 = (0xFFFFu >> v13)
       - ((unsigned int)_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v18, *v11), _mm_cmpeq_epi8((__m128i)0LL, v18))) >> v13);
    if ( (_DWORD)v8 )
    {
LABEL_22:
      a1 = (__int64 *)((char *)v11->m128i_i64 + v14);
      a2 = (__int64 *)((char *)v10->m128i_i64 + v13);
LABEL_23:
      _BitScanForward64(&v8, v8);
      if ( v3 > v8 )
        return *((unsigned __int8 *)a1 + v8) - (unsigned int)*((unsigned __int8 *)a2 + v8);
      return 0LL;
    }
    if ( v3 >= v13 + v3 - 16 && v13 + v3 != 16 )
    {
      v3 = v13 + v3 - 16;
      v13 = 16LL;
      v19 = 0LL;
      while ( 1 )
      {
        v20 = _mm_load_si128((const __m128i *)((char *)v10 + v13));
        v21 = _mm_cmpeq_epi8(v19, v20);
        v8 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v20, _mm_load_si128((__m128i *)((char *)v11 + v13))), v21))
                          - 0xFFFF);
        if ( (_DWORD)v8 )
          break;
        v9 = v3 <= 0x10;
        v3 -= 16LL;
        if ( v9 )
          return 0LL;
        v13 += 16LL;
        v22 = _mm_load_si128((const __m128i *)((char *)v10 + v13));
        v19 = _mm_cmpeq_epi8(v21, v22);
        v8 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v22, _mm_load_si128((__m128i *)((char *)v11 + v13))), v19))
                          - 0xFFFF);
        if ( (_DWORD)v8 )
          break;
        v9 = v3 <= 0x10;
        v3 -= 16LL;
        if ( v9 )
          return 0LL;
        v13 += 16LL;
      }
      v14 = v13;
      goto LABEL_22;
    }
    return 0LL;
  }
  if ( (unsigned int)v13 <= (unsigned int)v14 )
  {
    v12 = 0xFFFFLL;
    v15 = v14;
    v14 = (unsigned int)v13;
    v13 = v15;
    v16 = (__m128i *)v10;
    v10 = v11;
    v11 = v16;
  }
  return ((__int64 (__fastcall *)(__m128i *, const __m128i *, __int64, __int64, __int64))((char *)dword_91698
                                                                                        + dword_91698[v14 + 15 - v13]))(
           v11,
           v10,
           0xFFFFLL,
           v13,
           v12);
}

//----- (0000000000028430) ----------------------------------------------------
__int64 __fastcall sub_28430(__int64 *a1, __int64 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r11
  unsigned int v4; // ecx
  unsigned int v5; // eax
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  unsigned __int64 v8; // rdx
  bool v9; // cc
  const __m128i *v10; // rsi
  __m128i *v11; // rdi
  __int64 v12; // r8
  __int64 v13; // rcx
  __int64 v14; // rax
  unsigned int v15; // et0
  __m128i *v16; // rt1
  __m128i v18; // xmm1
  __m128i v19; // xmm0
  __m128i v20; // xmm1
  __m128i v21; // xmm0
  __m128i v22; // xmm1

  if ( !a3 )
    return 0LL;
  if ( a3 == 1 )
    return *(unsigned __int8 *)a1 - (unsigned int)*(unsigned __int8 *)a2;
  v3 = a3;
  v4 = (unsigned __int8)a2 & 0x3F;
  v5 = (unsigned __int8)a1 & 0x3F;
  if ( v4 <= 0x30 && v5 <= 0x30 )
  {
    v6.m128i_i64[0] = *a1;
    v7.m128i_i64[0] = *a2;
    v6.m128i_i64[1] = a1[1];
    v7.m128i_i64[1] = a2[1];
    v8 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v6, v7), _mm_cmpeq_epi8((__m128i)0LL, v6)))
                      - 0xFFFF);
    if ( (_DWORD)v8 )
      goto LABEL_23;
    v9 = v3 <= 0x10;
    v3 -= 16LL;
    if ( v9 )
      return 0LL;
    a2 += 2;
    a1 += 2;
  }
  v10 = (const __m128i *)((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL);
  v11 = (__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL);
  v12 = 0LL;
  v13 = v4 & 0xF;
  v14 = v5 & 0xF;
  if ( (_DWORD)v13 == (_DWORD)v14 )
  {
    v18 = _mm_load_si128(v10);
    v8 = (0xFFFFu >> v13)
       - ((unsigned int)_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v18, *v11), _mm_cmpeq_epi8((__m128i)0LL, v18))) >> v13);
    if ( (_DWORD)v8 )
    {
LABEL_22:
      a1 = (__int64 *)((char *)v11->m128i_i64 + v14);
      a2 = (__int64 *)((char *)v10->m128i_i64 + v13);
LABEL_23:
      _BitScanForward64(&v8, v8);
      if ( v3 > v8 )
        return *((unsigned __int8 *)a1 + v8) - (unsigned int)*((unsigned __int8 *)a2 + v8);
      return 0LL;
    }
    if ( v3 >= v13 + v3 - 16 && v13 + v3 != 16 )
    {
      v3 = v13 + v3 - 16;
      v13 = 16LL;
      v19 = 0LL;
      while ( 1 )
      {
        v20 = _mm_load_si128((const __m128i *)((char *)v10 + v13));
        v21 = _mm_cmpeq_epi8(v19, v20);
        v8 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v20, _mm_load_si128((__m128i *)((char *)v11 + v13))), v21))
                          - 0xFFFF);
        if ( (_DWORD)v8 )
          break;
        v9 = v3 <= 0x10;
        v3 -= 16LL;
        if ( v9 )
          return 0LL;
        v13 += 16LL;
        v22 = _mm_load_si128((const __m128i *)((char *)v10 + v13));
        v19 = _mm_cmpeq_epi8(v21, v22);
        v8 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v22, _mm_load_si128((__m128i *)((char *)v11 + v13))), v19))
                          - 0xFFFF);
        if ( (_DWORD)v8 )
          break;
        v9 = v3 <= 0x10;
        v3 -= 16LL;
        if ( v9 )
          return 0LL;
        v13 += 16LL;
      }
      v14 = v13;
      goto LABEL_22;
    }
    return 0LL;
  }
  if ( (unsigned int)v13 <= (unsigned int)v14 )
  {
    v12 = 0xFFFFLL;
    v15 = v14;
    v14 = (unsigned int)v13;
    v13 = v15;
    v16 = (__m128i *)v10;
    v10 = v11;
    v11 = v16;
  }
  return ((__int64 (__fastcall *)(__m128i *, const __m128i *, __int64, __int64, __int64))((char *)dword_916D8
                                                                                        + dword_916D8[v14 + 15 - v13]))(
           v11,
           v10,
           0xFFFFLL,
           v13,
           v12);
}

//----- (0000000000029BA0) ----------------------------------------------------
__int64 __fastcall sub_29BA0(const __m128i *a1, const __m128i *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r11
  unsigned int v4; // ecx
  unsigned int v5; // eax
  __m128i v6; // xmm1
  unsigned __int64 v7; // rdx
  char v8; // cc
  const __m128i *v9; // rsi
  const __m128i *v10; // rdi
  __int64 v11; // r8
  __int64 v12; // rcx
  __int64 v13; // rax
  unsigned int v14; // et0
  const __m128i *v15; // rt1
  __m128i v16; // xmm1
  __m128i v18; // xmm1
  unsigned __int64 v19; // r11
  __int64 v20; // rdx
  __m128i v21; // xmm0
  unsigned __int8 v22; // cf
  unsigned __int64 v23; // rcx
  __m128i v24; // xmm0

  if ( !a3 )
    return 0LL;
  if ( a3 == 1 )
    return a1->m128i_u8[0] - (unsigned int)a2->m128i_u8[0];
  v3 = a3;
  v4 = (unsigned __int8)a2 & 0x3F;
  v5 = (unsigned __int8)a1 & 0x3F;
  if ( v4 <= 0x30 && v5 <= 0x30 )
  {
    v6 = _mm_loadu_si128(a1);
    v7 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v6, _mm_loadu_si128(a2)), _mm_cmpeq_epi8((__m128i)0LL, v6)))
                      - 0xFFFF);
    if ( (_DWORD)v7 )
      goto LABEL_25;
    v8 = v3 <= 0x10;
    v3 -= 16LL;
    if ( !v8 )
    {
      ++a2;
      ++a1;
      goto LABEL_8;
    }
    return 0LL;
  }
LABEL_8:
  v9 = (const __m128i *)((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL);
  v10 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL);
  v11 = 0LL;
  v12 = v4 & 0xF;
  v13 = v5 & 0xF;
  if ( (_DWORD)v12 == (_DWORD)v13 )
  {
    v18 = _mm_load_si128(v9);
    v7 = (0xFFFFu >> v12)
       - ((unsigned int)_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v18, *v10), _mm_cmpeq_epi8((__m128i)0LL, v18))) >> v12);
    if ( !(_DWORD)v7 )
    {
      if ( v3 >= v12 + v3 - 16 && v12 + v3 != 16 )
      {
        v19 = v12 + v3 - 16;
        v20 = 1LL;
        while ( 1 )
        {
          v21 = _mm_load_si128(&v10[v20]);
          v23 = (unsigned int)_mm_cmpistri(v21, v9[v20], 26);
          v22 = _mm_cmpistrc(v21, v9[v20], 26);
          v8 = v22 | _mm_cmpistrz(v21, v9[v20++], 26);
          if ( v8 )
            break;
          v8 = v19 <= 0x10;
          v19 -= 16LL;
          if ( v8 )
            return 0LL;
          v24 = _mm_load_si128(&v10[v20]);
          v23 = (unsigned int)_mm_cmpistri(v24, v9[v20], 26);
          v22 = _mm_cmpistrc(v24, v9[v20], 26);
          v8 = v22 | _mm_cmpistrz(v24, v9[v20++], 26);
          if ( v8 )
            break;
          v8 = v19 <= 0x10;
          v19 -= 16LL;
          if ( v8 )
            return 0LL;
        }
        if ( v22 && v19 > v23 )
          return v10[v20 - 1].m128i_u8[v23] - (unsigned int)v9[v20 - 1].m128i_u8[v23];
      }
      return 0LL;
    }
    a1 = (const __m128i *)((char *)v10 + v13);
    a2 = (const __m128i *)((char *)v9 + v12);
LABEL_25:
    _BitScanForward64(&v7, v7);
    if ( v3 > v7 )
      return a1->m128i_u8[v7] - (unsigned int)a2->m128i_u8[v7];
    return 0LL;
  }
  if ( (unsigned int)v12 <= (unsigned int)v13 )
  {
    v11 = 0xFFFFLL;
    v14 = v13;
    v13 = (unsigned int)v12;
    v12 = v14;
    v15 = v9;
    v9 = v10;
    v10 = v15;
  }
  v16 = _mm_load_si128(v9);
  return ((__int64 (__fastcall *)(const __m128i *, const __m128i *, __int64, __int64, __int64, double, double, double))((char *)dword_91718 + dword_91718[v13 + 15 - v12]))(
           v10,
           v9,
           0xFFFFLL,
           v12,
           v11,
           *(double *)_mm_cmpeq_epi8((__m128i)0LL, v16).m128i_i64,
           *(double *)v16.m128i_i64,
           *(double *)_mm_load_si128(v10).m128i_i64);
}

//----- (000000000002AB80) ----------------------------------------------------
__int64 __fastcall sub_2AB80(unsigned __int64 _RDI, unsigned __int64 _RSI, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __m128 _XMM7)
{
  int v14; // eax
  __int64 result; // rax
  unsigned __int64 v21; // rdx
  unsigned __int64 v22; // rdx
  unsigned __int64 v23; // rdx
  unsigned __int64 v40; // rdx
  bool v42; // cc
  unsigned __int64 v43; // r11
  unsigned __int64 v44; // rdx
  bool v46; // zf
  unsigned __int64 v68; // rdi
  unsigned __int64 v71; // rdi
  unsigned __int64 v74; // rcx
  unsigned __int64 v75; // rcx
  __int64 v94; // r8
  unsigned __int64 v96; // rcx
  int v97; // eax
  int v98; // ecx
  unsigned __int64 v99; // rdi
  unsigned __int64 v100; // rsi
  unsigned __int64 v101; // r11

  if ( a3 == 1 )
  {
    result = *(unsigned __int8 *)_RDI - (unsigned int)*(unsigned __int8 *)_RSI;
    __asm { vzeroupper }
    return result;
  }
  if ( !a3 )
    goto LABEL_53;
  _RDX = 0LL;
  __asm { vpxor   xmm7, xmm7, xmm7 }
  v14 = ((unsigned __int16)_RSI | (unsigned __int16)_RDI) & 0xFFF;
  if ( (unsigned int)v14 <= 0xF80 )
  {
    __asm
    {
      vmovdqu ymm1, ymmword ptr [rdi]
      vpcmpeqb ymm0, ymm1, ymmword ptr [rsi]
      vpminub ymm0, ymm0, ymm1
      vpcmpeqb ymm0, ymm0, ymm7
      vpmovmskb ecx, ymm0
    }
    if ( _ECX )
    {
      __asm { tzcnt   edx, ecx }
      if ( _RDX < a3 )
      {
        result = *(unsigned __int8 *)(_RDI + _RDX) - (unsigned int)*(unsigned __int8 *)(_RSI + _RDX);
        __asm { vzeroupper }
        return result;
      }
    }
    else
    {
      __asm
      {
        vmovdqu ymm6, ymmword ptr [rdi+20h]
        vpcmpeqb ymm3, ymm6, ymmword ptr [rsi+20h]
        vpminub ymm3, ymm3, ymm6
        vpcmpeqb ymm3, ymm3, ymm7
        vpmovmskb ecx, ymm3
      }
      if ( _ECX )
      {
        __asm { tzcnt   edx, ecx }
        v21 = _RDX + 32;
        if ( v21 < a3 )
        {
          result = *(unsigned __int8 *)(_RDI + v21) - (unsigned int)*(unsigned __int8 *)(_RSI + v21);
          __asm { vzeroupper }
          return result;
        }
      }
      else
      {
        __asm
        {
          vmovdqu ymm5, ymmword ptr [rdi+40h]
          vmovdqu ymm4, ymmword ptr [rdi+60h]
          vmovdqu ymm0, ymmword ptr [rsi+60h]
          vpcmpeqb ymm2, ymm5, ymmword ptr [rsi+40h]
          vpminub ymm2, ymm2, ymm5
          vpcmpeqb ymm0, ymm0, ymm4
          vpcmpeqb ymm2, ymm2, ymm7
          vpmovmskb ecx, ymm2
        }
        if ( _ECX )
        {
          __asm { tzcnt   edx, ecx }
          v22 = _RDX + 64;
          if ( v22 < a3 )
          {
            result = *(unsigned __int8 *)(_RDI + v22) - (unsigned int)*(unsigned __int8 *)(_RSI + v22);
            __asm { vzeroupper }
            return result;
          }
        }
        else
        {
          __asm
          {
            vpminub ymm0, ymm0, ymm4
            vpcmpeqb ymm0, ymm0, ymm7
            vpmovmskb ecx, ymm0
          }
          if ( _ECX )
          {
            __asm { tzcnt   edx, ecx }
            v23 = _RDX + 96;
            if ( v23 < a3 )
            {
              result = *(unsigned __int8 *)(_RDI + v23) - (unsigned int)*(unsigned __int8 *)(_RSI + v23);
              __asm { vzeroupper }
              return result;
            }
          }
          else
          {
LABEL_16:
            v40 = ((_RDI + 128) & 0xFFFFFFFFFFFFFF80LL) - _RDI;
            _RAX = (_RDI + 128) & 0xFFFFFFFFFFFFFF80LL;
            v42 = a3 <= v40;
            v43 = a3 - v40;
            if ( !v42 )
            {
              v44 = _RSI + v40;
              _RCX = (4096 - (v44 & 0xFFF)) >> 7;
              LODWORD(_RSI) = _RCX;
              while ( 1 )
              {
                v46 = (_DWORD)_RSI == 0;
                _RSI = (unsigned int)(_RSI - 1);
                if ( v46 )
                {
                  v75 = v44 & 0x7F;
                  _R10 = -(__int64)v75;
                  if ( (v44 & 0x7F) < 0x40 )
                  {
                    __asm
                    {
                      vmovdqu ymm2, ymmword ptr [rax+r10]
                      vmovdqu ymm3, ymmword ptr [rax+r10+20h]
                      vpcmpeqb ymm0, ymm2, ymmword ptr [rdx+r10]
                      vpcmpeqb ymm1, ymm3, ymmword ptr [rdx+r10+20h]
                      vpminub ymm0, ymm0, ymm2
                      vpminub ymm1, ymm1, ymm3
                      vpcmpeqb ymm0, ymm0, ymm7
                      vpcmpeqb ymm1, ymm1, ymm7
                      vpmovmskb edi, ymm0
                      vpmovmskb esi, ymm1
                    }
                    _RSI <<= 32;
                    _RDI = (_RSI ^ _RDI) >> v75;
                    if ( _RDI )
                    {
                      __asm { tzcnt   rcx, rdi }
                      if ( v43 <= _RCX )
                        goto LABEL_53;
                      result = *(unsigned __int8 *)(_RAX + _RCX) - (unsigned int)*(unsigned __int8 *)(v44 + _RCX);
                      __asm { vzeroupper }
                      return result;
                    }
                  }
                  __asm
                  {
                    vmovdqu ymm2, ymmword ptr [rax+r10+40h]
                    vmovdqu ymm3, ymmword ptr [rax+r10+60h]
                    vpcmpeqb ymm5, ymm2, ymmword ptr [rdx+r10+40h]
                    vpminub ymm5, ymm5, ymm2
                    vpcmpeqb ymm6, ymm3, ymmword ptr [rdx+r10+60h]
                    vpcmpeqb ymm5, ymm5, ymm7
                    vpminub ymm6, ymm6, ymm3
                    vpcmpeqb ymm6, ymm6, ymm7
                    vpmovmskb edi, ymm5
                    vpmovmskb esi, ymm6
                  }
                  _RDI ^= _RSI << 32;
                  v94 = 0LL;
                  _RCX = (unsigned int)(v75 - 64);
                  if ( (v44 & 0x7F) > 0x40 )
                  {
                    _RDI >>= _RCX;
                    v94 = (unsigned int)_RCX;
                  }
                  LODWORD(_RSI) = 31;
                  if ( _RDI )
                  {
                    __asm { tzcnt   rcx, rdi }
                    v96 = v94 + _R10 + _RCX + 64;
                    if ( v43 <= v96 )
                      goto LABEL_53;
                    result = *(unsigned __int8 *)(_RAX + v96) - (unsigned int)*(unsigned __int8 *)(v44 + v96);
                    __asm { vzeroupper }
                    return result;
                  }
                  if ( v43 <= _R10 + 128 )
                    goto LABEL_53;
                }
                __asm
                {
                  vmovdqa ymm0, ymmword ptr [rax]
                  vmovdqa ymm3, ymmword ptr [rax+20h]
                  vpcmpeqb ymm4, ymm0, ymmword ptr [rdx]
                  vpcmpeqb ymm1, ymm3, ymmword ptr [rdx+20h]
                  vpminub ymm4, ymm4, ymm0
                  vpminub ymm1, ymm1, ymm3
                  vmovdqa ymm2, ymmword ptr [rax+40h]
                  vpminub ymm0, ymm4, ymm1
                  vmovdqa ymm3, ymmword ptr [rax+60h]
                  vpcmpeqb ymm5, ymm2, ymmword ptr [rdx+40h]
                  vpcmpeqb ymm6, ymm3, ymmword ptr [rdx+60h]
                  vpminub ymm5, ymm5, ymm2
                  vpminub ymm6, ymm6, ymm3
                  vpminub ymm0, ymm0, ymm5
                  vpminub ymm0, ymm0, ymm6
                  vpcmpeqb ymm0, ymm0, ymm7
                  vpmovmskb ecx, ymm0
                }
                if ( _ECX )
                  break;
                v42 = v43 <= 0x80;
                v43 -= 128LL;
                if ( v42 )
                  goto LABEL_53;
                _RAX += 128LL;
                v44 += 128LL;
              }
              __asm
              {
                vpcmpeqb ymm0, ymm4, ymm7
                vpmovmskb edi, ymm0
              }
              if ( _EDI )
              {
                __asm { tzcnt   ecx, edi }
                if ( v43 <= _RCX )
                  goto LABEL_53;
                result = *(unsigned __int8 *)(_RAX + _RCX) - (unsigned int)*(unsigned __int8 *)(v44 + _RCX);
                __asm { vzeroupper }
                return result;
              }
              if ( v43 <= 0x20 )
                goto LABEL_53;
              __asm
              {
                vpcmpeqb ymm1, ymm1, ymm7
                vpmovmskb ecx, ymm1
              }
              if ( _ECX )
              {
                __asm { tzcnt   edi, ecx }
                v68 = _RDI + 32;
                if ( v43 <= v68 )
                  goto LABEL_53;
                result = *(unsigned __int8 *)(_RAX + v68) - (unsigned int)*(unsigned __int8 *)(v44 + v68);
                __asm { vzeroupper }
                return result;
              }
              if ( v43 <= 0x40 )
                goto LABEL_53;
              __asm
              {
                vpcmpeqb ymm5, ymm5, ymm7
                vpmovmskb ecx, ymm5
              }
              if ( _ECX )
              {
                __asm { tzcnt   edi, ecx }
                v71 = _RDI + 64;
                if ( v43 <= v71 )
                  goto LABEL_53;
                result = *(unsigned __int8 *)(_RAX + v71) - (unsigned int)*(unsigned __int8 *)(v44 + v71);
                __asm { vzeroupper }
                return result;
              }
              if ( v43 > 0x60 )
              {
                __asm
                {
                  vpcmpeqb ymm6, ymm6, ymm7
                  vpmovmskb esi, ymm6
                  tzcnt   ecx, esi
                }
                v74 = _RCX + 96;
                if ( v43 > v74 )
                {
                  result = *(unsigned __int8 *)(_RAX + v74) - (unsigned int)*(unsigned __int8 *)(v44 + v74);
                  __asm { vzeroupper }
                  return result;
                }
              }
            }
          }
        }
      }
    }
    goto LABEL_53;
  }
  if ( (((unsigned __int16)_RSI | (unsigned __int16)_RDI) & 0xFFFu) <= 0xFE0 )
  {
    while ( 1 )
    {
      __asm
      {
        vmovdqu ymm1, ymmword ptr [rdi+rdx]
        vpcmpeqb ymm0, ymm1, ymmword ptr [rsi+rdx]
        vpminub ymm0, ymm0, ymm1
        vpcmpeqb ymm0, ymm0, ymm7
        vpmovmskb ecx, ymm0
      }
      if ( _ECX )
        break;
      _RDX = (unsigned int)(_RDX + 32);
      v14 += 32;
      if ( _RDX >= a3 )
        goto LABEL_53;
      if ( v14 > 4064 )
        goto LABEL_61;
    }
LABEL_55:
    v99 = _RDX + _RDI;
    v100 = _RDX + _RSI;
    v101 = a3 - _RDX;
    __asm { tzcnt   edx, ecx }
    if ( _RDX < v101 )
    {
      result = *(unsigned __int8 *)(v99 + _RDX) - (unsigned int)*(unsigned __int8 *)(v100 + _RDX);
      __asm { vzeroupper }
      return result;
    }
LABEL_53:
    result = 0LL;
    __asm { vzeroupper }
    return result;
  }
LABEL_61:
  if ( v14 <= 4080 )
  {
    __asm
    {
      vmovdqu xmm1, xmmword ptr [rdi+rdx]
      vpcmpeqb xmm0, xmm1, xmmword ptr [rsi+rdx]
      vpminub xmm0, xmm0, xmm1
      vpcmpeqb xmm0, xmm0, xmm7
      vpmovmskb ecx, xmm0
    }
    if ( _ECX )
      goto LABEL_55;
    _RDX = (unsigned int)(_RDX + 16);
    v14 += 16;
    if ( _RDX >= a3 )
      goto LABEL_53;
  }
  if ( v14 <= 4088 )
  {
    __asm
    {
      vmovq   xmm1, qword ptr [rdi+rdx]
      vmovq   xmm0, qword ptr [rsi+rdx]
      vpcmpeqb xmm0, xmm1, xmm0
      vpminub xmm0, xmm0, xmm1
      vpcmpeqb xmm0, xmm0, xmm7
      vpmovmskb ecx, xmm0
    }
    _ECX = (unsigned __int8)_ECX;
    if ( (_BYTE)_ECX )
      goto LABEL_55;
    _RDX = (unsigned int)(_RDX + 8);
    v14 += 8;
    if ( _RDX >= a3 )
      goto LABEL_53;
  }
  if ( v14 <= 4092 )
  {
    __asm
    {
      vmovd   xmm1, dword ptr [rdi+rdx]
      vmovd   xmm0, dword ptr [rsi+rdx]
      vpcmpeqb xmm0, xmm1, xmm0
      vpminub xmm0, xmm0, xmm1
      vpcmpeqb xmm0, xmm0, xmm7
      vpmovmskb ecx, xmm0
    }
    _ECX = _ECX & 0xF;
    if ( _ECX )
      goto LABEL_55;
    _RDX = (unsigned int)(_RDX + 4);
    if ( _RDX >= a3 )
      goto LABEL_53;
  }
  if ( _RDX >= a3 )
    goto LABEL_53;
  v97 = *(unsigned __int8 *)(_RDI + _RDX);
  v98 = *(unsigned __int8 *)(_RSI + _RDX);
  if ( *(_BYTE *)(_RDI + _RDX) )
  {
    while ( 1 )
    {
      result = (unsigned int)(v97 - v98);
      if ( (_DWORD)result )
        break;
      _RDX = (unsigned int)(_RDX + 1);
      if ( (_DWORD)_RDX == 128 )
        goto LABEL_16;
      if ( _RDX >= a3 )
        goto LABEL_53;
      v97 = *(unsigned __int8 *)(_RDI + _RDX);
      v98 = *(unsigned __int8 *)(_RSI + _RDX);
      if ( !*(_BYTE *)(_RDI + _RDX) )
      {
        result = (unsigned int)(v97 - v98);
        break;
      }
    }
    __asm { vzeroupper }
  }
  else
  {
    result = (unsigned int)(v97 - v98);
    __asm { vzeroupper }
  }
  return result;
}

//----- (000000000002B0B0) ----------------------------------------------------
__int64 __fastcall sub_2B0B0(const __m128i *a1, unsigned int a2, unsigned __int64 a3)
{
  __m128i v3; // xmm1
  __m128i v4; // xmm1
  unsigned int v5; // ecx
  __m128i v6; // xmm1
  unsigned __int64 v7; // rax
  char v8; // cc
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  const __m128i *v13; // rdi
  unsigned __int64 v14; // rax
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // rdx
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __m128i v21; // xmm4
  __int64 v22; // rax
  char v23; // cl
  __m128i v24; // xmm0
  __m128i v25; // xmm2
  int v26; // eax
  __m128i v27; // xmm3
  __m128i v28; // xmm1
  __int64 v29; // rax
  unsigned __int64 v30; // rdx
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // rdx
  unsigned __int64 v33; // rax
  unsigned __int64 v34; // rdx
  unsigned __int64 v35; // rax

  v3 = _mm_cvtsi32_si128(a2);
  v4 = _mm_unpacklo_epi8(v3, v3);
  if ( !a3 )
    return 0LL;
  v5 = (unsigned __int8)a1 & 0x3F;
  v6 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v4, v4), 0);
  if ( v5 <= 0x30 )
  {
    LODWORD(v7) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), v6));
    if ( (_DWORD)v7 )
      goto LABEL_44;
    v8 = a3 <= 0x10;
    v9 = a3 - 16;
    if ( v8 )
      return 0LL;
    a1 = (const __m128i *)((unsigned __int64)&a1[1] & 0xFFFFFFFFFFFFFFF0LL);
    v10 = (v5 & 0xF) + v9;
    v8 = v10 <= 0x40;
    v11 = v10 - 64;
    if ( v8 )
      goto LABEL_29;
    goto LABEL_12;
  }
  v12 = (unsigned __int8)a1 & 0xF;
  v13 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL);
  LODWORD(v14) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v13), v6)) >> v12;
  if ( (_DWORD)v14 )
  {
    _BitScanForward((unsigned int *)&v14, v14);
    if ( a3 > v14 )
      return (__int64)v13 + v14 + v12;
    return 0LL;
  }
  v16 = 16 - v12;
  v8 = a3 <= v16;
  v17 = a3 - v16;
  if ( !v8 )
  {
    a1 = v13 + 1;
    v8 = v17 <= 0x40;
    v11 = v17 - 64;
    if ( v8 )
      goto LABEL_29;
LABEL_12:
    LODWORD(v18) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1), v6));
    if ( (_DWORD)v18 )
      goto LABEL_41;
    LODWORD(v19) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 1), v6));
    if ( (_DWORD)v19 )
      goto LABEL_42;
    LODWORD(v20) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 2), v6));
    if ( (_DWORD)v20 )
      goto LABEL_43;
    v21 = _mm_cmpeq_epi8(_mm_load_si128(a1 + 3), v6);
    a1 += 4;
    LODWORD(v22) = _mm_movemask_epi8(v21);
    if ( (_DWORD)v22 )
      goto LABEL_40;
    if ( ((unsigned __int8)a1 & 0x3F) == 0 )
      goto LABEL_23;
    v8 = v11 <= 0x40;
    v11 -= 64LL;
    if ( !v8 )
    {
      LODWORD(v18) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1), v6));
      if ( (_DWORD)v18 )
        goto LABEL_41;
      LODWORD(v19) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 1), v6));
      if ( (_DWORD)v19 )
        goto LABEL_42;
      LODWORD(v20) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 2), v6));
      if ( !(_DWORD)v20 )
      {
        LODWORD(v22) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 3), v6));
        a1 += 4;
        if ( !(_DWORD)v22 )
        {
          v23 = (char)a1;
          a1 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL);
          v11 += v23 & 0x3F;
LABEL_23:
          while ( 1 )
          {
            v8 = v11 <= 0x40;
            v11 -= 64LL;
            if ( v8 )
              goto LABEL_29;
            v24 = _mm_cmpeq_epi8(_mm_load_si128(a1), v6);
            v25 = _mm_cmpeq_epi8(_mm_load_si128(a1 + 1), v6);
            v26 = _mm_movemask_epi8(
                    _mm_max_epu8(
                      _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 3), v6), v25),
                      _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 2), v6), v24)));
            a1 += 4;
            if ( v26 )
            {
              a1 -= 4;
              LODWORD(v18) = _mm_movemask_epi8(v24);
              if ( (_DWORD)v18 )
                goto LABEL_41;
              LODWORD(v19) = _mm_movemask_epi8(v25);
              if ( (_DWORD)v19 )
                goto LABEL_42;
              v27 = _mm_cmpeq_epi8(_mm_load_si128(a1 + 2), v6);
              v28 = _mm_cmpeq_epi8(v6, a1[3]);
              LODWORD(v20) = _mm_movemask_epi8(v27);
              if ( (_DWORD)v20 )
                goto LABEL_43;
              _BitScanForward((unsigned int *)&v29, _mm_movemask_epi8(v28));
              return (__int64)&a1[3] + v29;
            }
          }
        }
LABEL_40:
        _BitScanForward((unsigned int *)&v22, v22);
        return (__int64)&a1[-1] + v22;
      }
LABEL_43:
      _BitScanForward((unsigned int *)&v20, v20);
      return (__int64)&a1[2] + v20;
    }
LABEL_29:
    v8 = ((int)v11 + 32 < 0) ^ __OFADD__(32, (_DWORD)v11) | ((_DWORD)v11 == -32);
    v30 = (unsigned int)(v11 + 32);
    if ( !v8 )
    {
      LODWORD(v18) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1), v6));
      if ( !(_DWORD)v18 )
      {
        LODWORD(v19) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 1), v6));
        if ( !(_DWORD)v19 )
        {
          LODWORD(v31) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 2), v6));
          if ( (_DWORD)v31 )
          {
            _BitScanForward((unsigned int *)&v31, v31);
            if ( v30 > v31 )
              return (__int64)&a1[2] + v31;
          }
          else
          {
            v8 = (int)v30 <= 16;
            v32 = (unsigned int)(v30 - 16);
            if ( !v8 )
            {
              LODWORD(v33) = _mm_movemask_epi8(_mm_cmpeq_epi8(v6, a1[3]));
              if ( !(_DWORD)v33 )
                return 0LL;
              _BitScanForward((unsigned int *)&v33, v33);
              if ( v32 > v33 )
                return (__int64)&a1[3] + v33;
            }
          }
          return 0LL;
        }
LABEL_42:
        _BitScanForward((unsigned int *)&v19, v19);
        return (__int64)&a1[1] + v19;
      }
LABEL_41:
      _BitScanForward((unsigned int *)&v18, v18);
      return (__int64)a1 + v18;
    }
    a3 = (unsigned int)(v30 + 32);
    LODWORD(v7) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1), v6));
    if ( !(_DWORD)v7 )
    {
      v8 = (unsigned int)a3 <= 0x10;
      v34 = (unsigned int)(a3 - 16);
      if ( !v8 )
      {
        LODWORD(v35) = _mm_movemask_epi8(_mm_cmpeq_epi8(v6, a1[1]));
        if ( !(_DWORD)v35 )
          return 0LL;
        _BitScanForward((unsigned int *)&v35, v35);
        if ( v34 > v35 )
          return (__int64)&a1[1] + v35;
      }
      return 0LL;
    }
LABEL_44:
    _BitScanForward((unsigned int *)&v7, v7);
    if ( a3 > v7 )
      return (__int64)a1 + v7;
  }
  return 0LL;
}
// 2B12F: variable 'v14' is possibly undefined
// 2B2B2: variable 'v29' is possibly undefined
// 2B353: variable 'v22' is possibly undefined
// 2B363: variable 'v18' is possibly undefined
// 2B373: variable 'v19' is possibly undefined
// 2B383: variable 'v20' is possibly undefined
// 2B396: variable 'v7' is possibly undefined
// 2B3A6: variable 'v35' is possibly undefined
// 2B3B6: variable 'v31' is possibly undefined
// 2B3C6: variable 'v33' is possibly undefined

//----- (000000000002B3E0) ----------------------------------------------------
__int64 __fastcall sub_2B3E0(const __m128i *a1, unsigned __int64 a2)
{
  __m128i v2; // xmm1
  __m128i v3; // xmm1
  __int64 v4; // rax
  __int64 v5; // rcx
  const __m128i *v6; // rdi
  __int64 v7; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __m128i v11; // xmm4
  __int64 v12; // rax
  __m128i v13; // xmm0
  __m128i v14; // xmm2
  int v15; // eax
  __m128i v16; // xmm3
  __m128i v17; // xmm1
  __int64 v18; // rax

  v2 = _mm_unpacklo_epi8((__m128i)a2, (__m128i)a2);
  v3 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v2, v2), 0);
  if ( ((unsigned __int8)a1 & 0x3Fu) > 0x30uLL )
  {
    v5 = (unsigned __int8)a1 & 0xF;
    v6 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL);
    LODWORD(v7) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v6), v3)) >> v5;
    if ( (_DWORD)v7 )
    {
      _BitScanForward((unsigned int *)&v7, v7);
      return (__int64)v6 + v7 + v5;
    }
    a1 = v6 + 1;
  }
  else
  {
    LODWORD(v4) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), v3));
    if ( (_DWORD)v4 )
      goto LABEL_23;
    a1 = (const __m128i *)((unsigned __int64)&a1[1] & 0xFFFFFFFFFFFFFFF0LL);
  }
  LODWORD(v4) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1), v3));
  if ( (_DWORD)v4 )
    goto LABEL_23;
  LODWORD(v9) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 1), v3));
  if ( (_DWORD)v9 )
    goto LABEL_24;
  LODWORD(v10) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 2), v3));
  if ( !(_DWORD)v10 )
  {
    v11 = _mm_cmpeq_epi8(_mm_load_si128(a1 + 3), v3);
    a1 += 4;
    LODWORD(v12) = _mm_movemask_epi8(v11);
    if ( (_DWORD)v12 )
      goto LABEL_22;
    if ( ((unsigned __int8)a1 & 0x3F) == 0 )
      goto LABEL_17;
    LODWORD(v4) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1), v3));
    if ( (_DWORD)v4 )
      goto LABEL_23;
    LODWORD(v9) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 1), v3));
    if ( (_DWORD)v9 )
      goto LABEL_24;
    LODWORD(v10) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 2), v3));
    if ( !(_DWORD)v10 )
    {
      LODWORD(v12) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 3), v3));
      a1 += 4;
      if ( !(_DWORD)v12 )
      {
        a1 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL);
        do
        {
LABEL_17:
          v13 = _mm_cmpeq_epi8(_mm_load_si128(a1), v3);
          v14 = _mm_cmpeq_epi8(_mm_load_si128(a1 + 1), v3);
          v15 = _mm_movemask_epi8(
                  _mm_max_epu8(
                    _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 3), v3), v14),
                    _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 2), v3), v13)));
          a1 += 4;
        }
        while ( !v15 );
        a1 -= 4;
        LODWORD(v4) = _mm_movemask_epi8(v13);
        if ( !(_DWORD)v4 )
        {
          LODWORD(v9) = _mm_movemask_epi8(v14);
          if ( !(_DWORD)v9 )
          {
            v16 = _mm_cmpeq_epi8(_mm_load_si128(a1 + 2), v3);
            v17 = _mm_cmpeq_epi8(v3, a1[3]);
            LODWORD(v10) = _mm_movemask_epi8(v16);
            if ( !(_DWORD)v10 )
            {
              _BitScanForward((unsigned int *)&v18, _mm_movemask_epi8(v17));
              return (__int64)&a1[3] + v18;
            }
            goto LABEL_25;
          }
LABEL_24:
          _BitScanForward((unsigned int *)&v9, v9);
          return (__int64)&a1[1] + v9;
        }
LABEL_23:
        _BitScanForward((unsigned int *)&v4, v4);
        return (__int64)a1 + v4;
      }
LABEL_22:
      _BitScanForward((unsigned int *)&v12, v12);
      return (__int64)&a1[-1] + v12;
    }
  }
LABEL_25:
  _BitScanForward((unsigned int *)&v10, v10);
  return (__int64)&a1[2] + v10;
}
// 2B44D: variable 'v7' is possibly undefined
// 2B59C: variable 'v18' is possibly undefined
// 2B5B3: variable 'v12' is possibly undefined
// 2B5C3: variable 'v4' is possibly undefined
// 2B5D3: variable 'v9' is possibly undefined
// 2B5E3: variable 'v10' is possibly undefined

//----- (000000000002B5F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_2B5F0(unsigned __int64 a1, int _ESI, unsigned __int64 a3)
{
  unsigned int v6; // ecx
  char v8; // cc
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rdi
  unsigned __int64 result; // rax
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rdx
  unsigned __int64 v23; // rcx
  unsigned __int64 v32; // rdx
  unsigned __int64 v36; // rdx
  unsigned __int64 v39; // rdx

  if ( !a3 )
    return 0LL;
  __asm
  {
    vmovd   xmm0, esi
    vpbroadcastb ymm0, xmm0
  }
  v6 = a1 & 0x3F;
  if ( v6 <= 0x20 )
  {
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
    {
LABEL_31:
      __asm { tzcnt   eax, eax }
      if ( a3 > _RAX )
      {
        result = a1 + _RAX;
        __asm { vzeroupper }
        return result;
      }
      goto LABEL_39;
    }
    v8 = a3 <= 0x20;
    v9 = a3 - 32;
    if ( !v8 )
    {
      a1 = (a1 + 32) & 0xFFFFFFFFFFFFFFE0LL;
      v10 = (v6 & 0x1F) + v9;
      v8 = v10 <= 0x80;
      v11 = v10 - 128;
      if ( v8 )
        goto LABEL_20;
      goto LABEL_12;
    }
    goto LABEL_39;
  }
  v12 = a1 & 0x1F;
  v13 = a1 & 0xFFFFFFFFFFFFFFE0LL;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  _RAX = (unsigned int)(_EAX >> v12);
  if ( (_DWORD)_RAX )
  {
    __asm { tzcnt   eax, eax }
    if ( a3 > _RAX )
    {
      result = v12 + v13 + _RAX;
      __asm { vzeroupper }
      return result;
    }
    goto LABEL_39;
  }
  v17 = 32 - v12;
  v8 = a3 <= v17;
  v18 = a3 - v17;
  if ( v8 )
  {
LABEL_39:
    __asm { vzeroupper }
    return 0LL;
  }
  a1 = v13 + 32;
  v8 = v18 <= 0x80;
  v11 = v18 - 128;
  if ( v8 )
    goto LABEL_20;
LABEL_12:
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_41;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_42;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+40h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_43;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+60h]
    vpmovmskb eax, ymm1
  }
  if ( !(_DWORD)_RAX )
  {
    a1 += 128LL;
    v8 = v11 <= 0x80;
    v11 -= 128LL;
    if ( !v8 )
    {
      v23 = a1 & 0x7F;
      a1 &= 0xFFFFFFFFFFFFFF80LL;
      v11 += v23;
      while ( 1 )
      {
        __asm
        {
          vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
          vpcmpeqb ymm2, ymm0, ymmword ptr [rdi+20h]
          vpcmpeqb ymm3, ymm0, ymmword ptr [rdi+40h]
          vpcmpeqb ymm4, ymm0, ymmword ptr [rdi+60h]
          vpor    ymm5, ymm2, ymm1
          vpor    ymm6, ymm4, ymm3
          vpor    ymm5, ymm6, ymm5
          vpmovmskb eax, ymm5
        }
        if ( _EAX )
          break;
        a1 += 128LL;
        v8 = v11 <= 0x80;
        v11 -= 128LL;
        if ( v8 )
          goto LABEL_20;
      }
      __asm { vpmovmskb eax, ymm1 }
      if ( !(_DWORD)_RAX )
      {
        __asm { vpmovmskb eax, ymm2 }
        if ( !(_DWORD)_RAX )
        {
          __asm { vpmovmskb eax, ymm3 }
          if ( !(_DWORD)_RAX )
          {
            __asm { vpmovmskb eax, ymm4 }
            goto LABEL_48;
          }
LABEL_43:
          __asm { tzcnt   eax, eax }
          result = a1 + _RAX + 64;
          __asm { vzeroupper }
          return result;
        }
LABEL_42:
        __asm { tzcnt   eax, eax }
        result = a1 + _RAX + 32;
        __asm { vzeroupper }
        return result;
      }
LABEL_41:
      __asm { tzcnt   eax, eax }
      result = a1 + _RAX;
      __asm { vzeroupper }
      return result;
    }
LABEL_20:
    v8 = ((int)v11 + 64 < 0) ^ __OFADD__(64, (_DWORD)v11) | ((_DWORD)v11 == -64);
    v32 = (unsigned int)(v11 + 64);
    if ( !v8 )
    {
      __asm
      {
        vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
        vpmovmskb eax, ymm1
      }
      if ( (_DWORD)_RAX )
        goto LABEL_41;
      __asm
      {
        vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
        vpmovmskb eax, ymm1
      }
      if ( (_DWORD)_RAX )
        goto LABEL_42;
      __asm
      {
        vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+40h]
        vpmovmskb eax, ymm1
      }
      if ( (_DWORD)_RAX )
      {
        __asm { tzcnt   eax, eax }
        if ( v32 > _RAX )
        {
          result = a1 + _RAX + 64;
          __asm { vzeroupper }
          return result;
        }
      }
      else
      {
        v8 = (int)v32 <= 32;
        v36 = (unsigned int)(v32 - 32);
        if ( !v8 )
        {
          __asm
          {
            vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+60h]
            vpmovmskb eax, ymm1
          }
          if ( !(_DWORD)_RAX )
          {
            result = 0LL;
            __asm { vzeroupper }
            return result;
          }
          __asm { tzcnt   eax, eax }
          if ( v36 > _RAX )
          {
            result = a1 + _RAX + 96;
            __asm { vzeroupper }
            return result;
          }
        }
      }
      goto LABEL_39;
    }
    a3 = (unsigned int)(v32 + 64);
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( !(_DWORD)_RAX )
    {
      v8 = (int)a3 <= 32;
      v39 = (unsigned int)(a3 - 32);
      if ( !v8 )
      {
        __asm
        {
          vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
          vpmovmskb eax, ymm1
        }
        if ( !(_DWORD)_RAX )
        {
          result = 0LL;
          __asm { vzeroupper }
          return result;
        }
        __asm { tzcnt   eax, eax }
        if ( v39 > _RAX )
        {
          result = a1 + _RAX + 32;
          __asm { vzeroupper }
          return result;
        }
      }
      goto LABEL_39;
    }
    goto LABEL_31;
  }
LABEL_48:
  __asm { tzcnt   eax, eax }
  result = a1 + _RAX + 96;
  __asm { vzeroupper }
  return result;
}
// 2B7E7: variable '_RAX' is possibly undefined

//----- (000000000002B8C0) ----------------------------------------------------
unsigned __int64 __fastcall sub_2B8C0(unsigned __int64 i, int _ESI)
{
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rdi
  unsigned __int64 result; // rax

  __asm
  {
    vmovd   xmm0, esi
    vpbroadcastb ymm0, xmm0
  }
  if ( (i & 0x3F) > 0x20 )
  {
    v6 = i & 0x1F;
    v7 = i & 0xFFFFFFFFFFFFFFE0LL;
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    _RAX = (unsigned int)(_EAX >> v6);
    if ( (_DWORD)_RAX )
    {
      __asm { tzcnt   eax, eax }
      result = v6 + v7 + _RAX;
      __asm { vzeroupper }
      return result;
    }
    i = v7 + 32;
  }
  else
  {
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
      goto LABEL_14;
    i = (i + 32) & 0xFFFFFFFFFFFFFFE0LL;
  }
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_14;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_15;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+40h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_16;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+60h]
    vpmovmskb eax, ymm1
  }
  if ( !(_DWORD)_RAX )
  {
    for ( i = (i + 128) & 0xFFFFFFFFFFFFFF80LL; ; i += 128LL )
    {
      __asm
      {
        vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
        vpcmpeqb ymm2, ymm0, ymmword ptr [rdi+20h]
        vpcmpeqb ymm3, ymm0, ymmword ptr [rdi+40h]
        vpcmpeqb ymm4, ymm0, ymmword ptr [rdi+60h]
        vpor    ymm5, ymm2, ymm1
        vpor    ymm6, ymm4, ymm3
        vpor    ymm5, ymm6, ymm5
        vpmovmskb eax, ymm5
      }
      if ( _EAX )
        break;
    }
    __asm { vpmovmskb eax, ymm1 }
    if ( !(_DWORD)_RAX )
    {
      __asm { vpmovmskb eax, ymm2 }
      if ( !(_DWORD)_RAX )
      {
        __asm { vpmovmskb eax, ymm3 }
        if ( !(_DWORD)_RAX )
        {
          __asm { vpmovmskb eax, ymm4 }
          goto LABEL_21;
        }
LABEL_16:
        __asm { tzcnt   eax, eax }
        result = i + _RAX + 64;
        __asm { vzeroupper }
        return result;
      }
LABEL_15:
      __asm { tzcnt   eax, eax }
      result = i + _RAX + 32;
      __asm { vzeroupper }
      return result;
    }
LABEL_14:
    __asm { tzcnt   eax, eax }
    result = i + _RAX;
    __asm { vzeroupper }
    return result;
  }
LABEL_21:
  __asm { tzcnt   eax, eax }
  result = i + _RAX + 96;
  __asm { vzeroupper }
  return result;
}
// 2B9B4: variable '_RAX' is possibly undefined

//----- (000000000002BA10) ----------------------------------------------------
__int64 __fastcall sub_2BA10(const __m128i *a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  signed __int64 v3; // rsi
  unsigned __int64 v4; // r10
  int v5; // eax
  int v6; // edx
  __int64 result; // rax
  __int64 v8; // rax
  __int64 v9; // rdx
  unsigned int v10; // edx
  __int64 v11; // rcx
  unsigned __int8 *v12; // rcx
  __int64 v13; // rcx
  unsigned __int64 v14; // r11
  unsigned int v15; // edx
  unsigned __int64 v16; // r11
  __int64 v17; // rcx
  const __m128i *v18; // r10
  unsigned __int64 v19; // r11

  if ( !a3 )
    return 0LL;
  if ( a3 <= 1 )
  {
    v5 = a1->m128i_u8[0];
    v6 = *a2;
    return (unsigned int)(v5 - v6);
  }
  v3 = a2 - (unsigned __int8 *)a1;
  v4 = a3;
  if ( a3 < 0x20 )
    goto LABEL_4;
  v14 = (unsigned __int64)a1->m128i_u64 + a3;
  if ( ((unsigned __int8)a1 & 0xF) != 0 )
  {
    v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), _mm_loadu_si128((const __m128i *)((char *)a1 + v3))))
        - 0xFFFF;
    if ( v15 )
      goto LABEL_48;
    a1 = (const __m128i *)((char *)a1 - ((unsigned __int8)a1 & 0xF) + 16);
  }
  if ( (v3 & 0xF) == 0 )
  {
    if ( (unsigned __int64)a1 >= (v14 & 0xFFFFFFFFFFFFFFE0LL) )
      goto LABEL_46;
    if ( ((unsigned __int8)a1 & 0x10) != 0 )
    {
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
      if ( v15 )
        goto LABEL_48;
      if ( (const __m128i *)(v14 & 0xFFFFFFFFFFFFFFE0LL) == ++a1 )
        goto LABEL_46;
    }
    v18 = (const __m128i *)(v14 & 0xFFFFFFFFFFFFFFC0LL);
    if ( ((unsigned __int8)a1 & 0x20) != 0 )
    {
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
      if ( v15 )
        goto LABEL_48;
      ++a1;
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
      if ( v15 )
        goto LABEL_48;
      ++a1;
    }
    if ( v18 != a1 )
    {
      while ( 1 )
      {
        v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
        if ( v15 )
          goto LABEL_48;
        ++a1;
        v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
        if ( v15 )
          goto LABEL_48;
        ++a1;
        v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
        if ( v15 )
          goto LABEL_48;
        ++a1;
        v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
        if ( v15 )
          goto LABEL_48;
        if ( v18 == ++a1 )
        {
          if ( (unsigned __int64)a1 >= (v14 & 0xFFFFFFFFFFFFFFE0LL) )
            goto LABEL_46;
          while ( 1 )
          {
            v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
            if ( v15 )
              goto LABEL_48;
            ++a1;
            v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
            if ( v15 )
              goto LABEL_48;
            if ( ++a1 == (const __m128i *)(v14 & 0xFFFFFFFFFFFFFFE0LL) )
            {
              v19 = v14 - (_QWORD)a1;
              if ( !v19 )
                return 0LL;
              v4 = v19;
              goto LABEL_4;
            }
          }
        }
      }
    }
    goto LABEL_42;
  }
  if ( ((unsigned __int8)a1 & 0x10) != 0 )
  {
    v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
    if ( v15 )
      goto LABEL_48;
    ++a1;
  }
  if ( (unsigned __int64)a1 >= (v14 & 0xFFFFFFFFFFFFFFE0LL) )
    goto LABEL_46;
  if ( ((unsigned __int8)a1 & 0x20) == 0 )
    goto LABEL_36;
  v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
  if ( v15
    || (++a1,
        (v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF) != 0) )
  {
LABEL_48:
    _BitScanForward((unsigned int *)&v17, v15);
    v5 = a1->m128i_u8[v17];
    v6 = a1->m128i_u8[v3 + v17];
    return (unsigned int)(v5 - v6);
  }
  ++a1;
LABEL_36:
  if ( (unsigned __int64)a1 < (v14 & 0xFFFFFFFFFFFFFFC0LL) )
  {
    do
    {
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
      if ( v15 )
        goto LABEL_48;
      ++a1;
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
      if ( v15 )
        goto LABEL_48;
      ++a1;
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
      if ( v15 )
        goto LABEL_48;
      ++a1;
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
      if ( v15 )
        goto LABEL_48;
      ++a1;
    }
    while ( (const __m128i *)(v14 & 0xFFFFFFFFFFFFFFC0LL) != a1 );
  }
LABEL_42:
  if ( (unsigned __int64)a1 < (v14 & 0xFFFFFFFFFFFFFFE0LL) )
  {
    do
    {
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
      if ( v15 )
        goto LABEL_48;
      ++a1;
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
      if ( v15 )
        goto LABEL_48;
      ++a1;
    }
    while ( (const __m128i *)(v14 & 0xFFFFFFFFFFFFFFE0LL) != a1 );
  }
LABEL_46:
  v16 = v14 - (_QWORD)a1;
  if ( !v16 )
    return 0LL;
  v4 = v16;
LABEL_4:
  if ( (v4 & 1) == 0 )
    goto LABEL_7;
  v5 = a1->m128i_u8[0];
  v6 = a1->m128i_u8[v3];
  if ( --v4 )
  {
    a1 = (const __m128i *)((char *)a1 + 1);
    result = (unsigned int)(v5 - v6);
    if ( (_DWORD)result )
      return result;
    if ( (v4 & 2) != 0 )
    {
      v8 = a1->m128i_u16[0];
      v9 = *(unsigned __int16 *)((char *)a1->m128i_u16 + v3);
      v4 -= 2LL;
      if ( !v4 )
        goto LABEL_21;
      a1 = (const __m128i *)((char *)a1 + 2);
      if ( (_DWORD)v8 != (_DWORD)v9 )
        goto LABEL_21;
    }
LABEL_7:
    if ( ((v4 & 4) == 0
       || (v8 = a1->m128i_u32[0], v9 = *(unsigned int *)((char *)a1->m128i_u32 + v3), (v4 -= 4LL) != 0)
       && (a1 = (const __m128i *)((char *)a1 + 4), (_DWORD)v8 == (_DWORD)v9))
      && ((v4 & 8) == 0
       || (v8 = a1->m128i_i64[0], v9 = *(__int64 *)((char *)a1->m128i_i64 + v3), v4 != 8)
       && (a1 = (const __m128i *)((char *)a1 + 8), v8 == v9)) )
    {
      v10 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), _mm_loadu_si128((const __m128i *)((char *)a1 + v3))))
          - 0xFFFF;
      if ( v10 )
      {
        _BitScanForward((unsigned int *)&v11, v10);
        v12 = &a1->m128i_u8[v11];
        v5 = *v12;
        v6 = v12[v3];
        return (unsigned int)(v5 - v6);
      }
    }
    else
    {
LABEL_21:
      if ( v8 != v9 )
      {
        _BitScanForward64((unsigned __int64 *)&v13, v8 - v9);
        return (unsigned __int8)(v8 >> (8 * (unsigned __int8)(v13 >> 3)))
             - (unsigned int)(unsigned __int8)(v9 >> (8 * (unsigned __int8)(v13 >> 3)));
      }
    }
    return 0LL;
  }
  return (unsigned int)(v5 - v6);
}
// 2BAD4: variable 'v11' is possibly undefined
// 2BCA3: variable 'v17' is possibly undefined

//----- (000000000002BE10) ----------------------------------------------------
unsigned __int64 __fastcall sub_2BE10(__int64 _RDI, __int64 _RSI, unsigned __int64 _RDX, __int64 _RCX)
{
  unsigned __int64 result; // rax
  unsigned __int64 v38; // rax
  unsigned __int64 v39; // rcx
  unsigned __int32 v41; // eax
  unsigned __int32 v42; // ecx

  if ( _RDX >= 0x20 )
  {
    __asm
    {
      vmovdqu ymm2, ymmword ptr [rsi]
      vpcmpeqb ymm2, ymm2, ymmword ptr [rdi]
      vpmovmskb eax, ymm2
    }
    LODWORD(result) = _EAX + 1;
    if ( (_DWORD)result )
      goto LABEL_12;
    if ( _RDX <= 0x40 )
    {
LABEL_10:
      _RDI = _RDI + _RDX - 32;
      _RSI = _RSI + _RDX - 32;
      __asm
      {
        vmovdqu ymm2, ymmword ptr [rsi]
        vpcmpeqb ymm2, ymm2, ymmword ptr [rdi]
        vpmovmskb eax, ymm2
      }
      result = (unsigned int)(_EAX + 1);
      if ( !(_DWORD)result )
      {
        __asm { vzeroupper }
        return result;
      }
      goto LABEL_12;
    }
    __asm { vpcmpeqb ymm0, ymm0, ymm0 }
    if ( _RDX > 0x100 )
    {
      __asm
      {
        vmovdqu ymm2, ymmword ptr [rsi]
        vpcmpeqb ymm2, ymm2, ymmword ptr [rdi]
        vpmovmskb eax, ymm2
      }
      LODWORD(result) = _EAX + 1;
      if ( (_DWORD)result )
        goto LABEL_12;
      _RCX = (_RDI & 0x1F) - 32;
      _RSI -= _RCX;
      _RDI -= _RCX;
      _RDX += _RCX;
      while ( 1 )
      {
        __asm
        {
          vmovdqu ymm1, ymmword ptr [rsi]
          vpcmpeqb ymm1, ymm1, ymmword ptr [rdi]
          vmovdqu ymm2, ymmword ptr [rsi+20h]
          vpcmpeqb ymm2, ymm2, ymmword ptr [rdi+20h]
          vpand   ymm5, ymm1, ymm2
          vmovdqu ymm3, ymmword ptr [rsi+40h]
          vpcmpeqb ymm3, ymm3, ymmword ptr [rdi+40h]
          vpand   ymm5, ymm5, ymm3
          vmovdqu ymm4, ymmword ptr [rsi+60h]
          vpcmpeqb ymm4, ymm4, ymmword ptr [rdi+60h]
          vpand   ymm5, ymm5, ymm4
          vptest  ymm5, ymm0
        }
        if ( !_CF )
          break;
        _RDI += 128LL;
        _RSI += 128LL;
        _RDX -= 128LL;
        if ( _RDX < 0x80 )
        {
          if ( _RDX <= 0x20 )
            goto LABEL_10;
          if ( _RDX <= 0x40 )
          {
            __asm
            {
              vmovdqu ymm2, ymmword ptr [rsi]
              vpcmpeqb ymm2, ymm2, ymmword ptr [rdi]
              vpmovmskb eax, ymm2
            }
            LODWORD(result) = _EAX + 1;
            if ( (_DWORD)result )
              goto LABEL_12;
            goto LABEL_10;
          }
          goto LABEL_36;
        }
      }
    }
    else
    {
      if ( _RDX < 0x80 )
      {
LABEL_36:
        __asm
        {
          vmovdqu ymm2, ymmword ptr [rsi]
          vpcmpeqb ymm2, ymm2, ymmword ptr [rdi]
          vpmovmskb eax, ymm2
        }
        LODWORD(result) = _EAX + 1;
        if ( !(_DWORD)result )
        {
          _RDI += 32LL;
          _RSI += 32LL;
          __asm
          {
            vmovdqu ymm2, ymmword ptr [rsi]
            vpcmpeqb ymm2, ymm2, ymmword ptr [rdi]
            vpmovmskb eax, ymm2
          }
          LODWORD(result) = _EAX + 1;
          if ( !(_DWORD)result )
          {
            _RDI = _RDI + _RDX - 96;
            _RSI = _RSI + _RDX - 96;
            __asm
            {
              vmovdqu ymm2, ymmword ptr [rsi]
              vpcmpeqb ymm2, ymm2, ymmword ptr [rdi]
              vpmovmskb eax, ymm2
            }
            LODWORD(result) = _EAX + 1;
            if ( !(_DWORD)result )
            {
              _RDI += 32LL;
              _RSI += 32LL;
              __asm
              {
                vmovdqu ymm2, ymmword ptr [rsi]
                vpcmpeqb ymm2, ymm2, ymmword ptr [rdi]
                vpmovmskb eax, ymm2
              }
              result = (unsigned int)(_EAX + 1);
              if ( !(_DWORD)result )
              {
                __asm { vzeroupper }
                return result;
              }
            }
          }
        }
        goto LABEL_12;
      }
      __asm
      {
        vmovdqu ymm1, ymmword ptr [rsi]
        vpcmpeqb ymm1, ymm1, ymmword ptr [rdi]
        vmovdqu ymm2, ymmword ptr [rsi+20h]
        vpcmpeqb ymm2, ymm2, ymmword ptr [rdi+20h]
        vmovdqu ymm3, ymmword ptr [rsi+40h]
        vpcmpeqb ymm3, ymm3, ymmword ptr [rdi+40h]
        vmovdqu ymm4, ymmword ptr [rsi+60h]
        vpcmpeqb ymm4, ymm4, ymmword ptr [rdi+60h]
        vpand   ymm5, ymm2, ymm1
        vpand   ymm6, ymm4, ymm3
        vpand   ymm5, ymm6, ymm5
        vptest  ymm5, ymm0
      }
      if ( _CF )
      {
        _RDI = _RDI + _RDX - 128;
        _RSI = _RSI + _RDX - 128;
        __asm
        {
          vmovdqu ymm1, ymmword ptr [rsi]
          vpcmpeqb ymm1, ymm1, ymmword ptr [rdi]
          vmovdqu ymm2, ymmword ptr [rsi+20h]
          vpcmpeqb ymm2, ymm2, ymmword ptr [rdi+20h]
          vpand   ymm5, ymm1, ymm2
          vmovdqu ymm3, ymmword ptr [rsi+40h]
          vpcmpeqb ymm3, ymm3, ymmword ptr [rdi+40h]
          vpand   ymm5, ymm5, ymm3
          vmovdqu ymm4, ymmword ptr [rsi+60h]
          vpcmpeqb ymm4, ymm4, ymmword ptr [rdi+60h]
          vpand   ymm5, ymm5, ymm4
          vptest  ymm5, ymm0
        }
        if ( _CF )
        {
          result = 0LL;
          __asm { vzeroupper }
          return result;
        }
      }
    }
    __asm { vpmovmskb eax, ymm1 }
    LODWORD(result) = _EAX + 1;
    if ( !(_DWORD)result )
    {
      __asm { vpmovmskb eax, ymm2 }
      if ( _EAX + 1 )
      {
        __asm { tzcnt   ecx, eax }
        result = *(unsigned __int8 *)(_RDI + _RCX + 32) - (unsigned int)*(unsigned __int8 *)(_RSI + _RCX + 32);
        __asm { vzeroupper }
      }
      else
      {
        __asm { vpmovmskb eax, ymm3 }
        if ( _EAX + 1 )
        {
          __asm { tzcnt   ecx, eax }
          result = *(unsigned __int8 *)(_RDI + _RCX + 64) - (unsigned int)*(unsigned __int8 *)(_RSI + _RCX + 64);
          __asm { vzeroupper }
        }
        else
        {
          __asm { vpmovmskb eax, ymm4 }
          ++_EAX;
          __asm { tzcnt   ecx, eax }
          result = *(unsigned __int8 *)(_RDI + _RCX + 96) - (unsigned int)*(unsigned __int8 *)(_RSI + _RCX + 96);
          __asm { vzeroupper }
        }
      }
      return result;
    }
LABEL_12:
    __asm { tzcnt   ecx, eax }
    result = *(unsigned __int8 *)(_RDI + _RCX) - (unsigned int)*(unsigned __int8 *)(_RSI + _RCX);
    __asm { vzeroupper }
    return result;
  }
  if ( (_BYTE)_RDX == 1 )
    return *(unsigned __int8 *)_RDI - (unsigned int)*(unsigned __int8 *)_RSI;
  if ( !(_BYTE)_RDX )
    return 0LL;
  if ( (unsigned __int8)_RDX < 4u )
  {
    v41 = _byteswap_ulong(*(unsigned __int16 *)_RDI << 8);
    v42 = _byteswap_ulong(*(unsigned __int16 *)_RSI << 8);
    LOBYTE(v41) = *(_BYTE *)(_RDI + _RDX - 1);
    LOBYTE(v42) = *(_BYTE *)(_RSI + _RDX - 1);
    return v41 - v42;
  }
  if ( (unsigned __int8)_RDX < 8u )
  {
    __asm
    {
      movbe   eax, [rdi]
      movbe   ecx, [rsi]
      movbe   edi, [rdi+rdx-4]
      movbe   esi, [rsi+rdx-4]
    }
    v38 = _RDI | (_RAX << 32);
    v39 = _RSI | (_RCX << 32);
    _CF = v38 < v39;
    result = v38 - v39;
    if ( result )
      result = _CF ? -1 : 1;
  }
  else if ( (unsigned __int8)_RDX >= 0x10u )
  {
    __asm
    {
      vmovdqu xmm2, xmmword ptr [rsi]
      vpcmpeqb xmm2, xmm2, xmmword ptr [rdi]
      vpmovmskb eax, xmm2
    }
    LODWORD(result) = _EAX - 0xFFFF;
    if ( (_DWORD)result )
      goto LABEL_12;
    _RDI = _RDI + _RDX - 16;
    _RSI = _RSI + _RDX - 16;
    __asm
    {
      vmovdqu xmm2, xmmword ptr [rsi]
      vpcmpeqb xmm2, xmm2, xmmword ptr [rdi]
      vpmovmskb eax, xmm2
    }
    result = (unsigned int)(_EAX - 0xFFFF);
    if ( (_DWORD)result )
      goto LABEL_12;
  }
  else
  {
    __asm
    {
      vmovq   xmm1, qword ptr [rdi]
      vmovq   xmm2, qword ptr [rsi]
      vpcmpeqb xmm2, xmm2, xmm1
      vpmovmskb eax, xmm2
    }
    LODWORD(result) = _EAX - 0xFFFF;
    if ( (_DWORD)result )
      goto LABEL_12;
    _RDI = _RDI + _RDX - 8;
    _RSI = _RSI + _RDX - 8;
    __asm
    {
      vmovq   xmm1, qword ptr [rdi]
      vmovq   xmm2, qword ptr [rsi]
      vpcmpeqb xmm2, xmm2, xmm1
      vpmovmskb eax, xmm2
    }
    result = (unsigned int)(_EAX - 0xFFFF);
    if ( (_DWORD)result )
      goto LABEL_12;
  }
  return result;
}
// 2BF48: variable '_RAX' is possibly undefined

//----- (000000000002C1F0) ----------------------------------------------------
__int64 __fastcall sub_2C1F0(const __m128i *_RDI, __m128i *_RSI, unsigned __int64 a3)
{
  __m128i *v4; // rcx
  signed __int64 v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rdx
  __m128i v8; // xmm2
  __m128i v9; // xmm3
  __m128i v10; // xmm4
  bool v11; // cf
  const __m128i *v12; // rdi
  __m128i *v13; // rsi
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // rcx

  if ( a3 <= 0x4F )
  {
    if ( a3 == 1 )
      return _RDI->m128i_u8[0] - (unsigned int)_RSI->m128i_u8[0];
    return ((__int64 (__fastcall *)(__int8 *, __int8 *, double))((char *)dword_91758 + dword_91758[a3]))(
             &_RDI->m128i_i8[a3],
             &_RSI->m128i_i8[a3],
             0.0);
  }
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI), _mm_loadu_si128(_RSI))) )
    goto LABEL_141;
  v4 = _RSI;
  _RSI = (__m128i *)(((unsigned __int64)_RSI & 0xFFFFFFFFFFFFFFF0LL) + 16);
  v5 = (char *)v4 - (char *)_RSI;
  _RDI = (const __m128i *)((char *)_RDI - v5);
  a3 += v5;
  if ( ((unsigned __int8)_RDI & 0xF) != 0 )
  {
    if ( a3 <= 0x80 )
      goto LABEL_7;
    if ( a3 <= 0x200 )
    {
      if ( a3 <= 0x100 )
        goto LABEL_18;
      a3 -= 256LL;
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI), *_RSI)) )
        goto LABEL_141;
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 1), _RSI[1])) )
        goto LABEL_140;
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 2), _RSI[2])) )
        goto LABEL_139;
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 3), _RSI[3])) )
        goto LABEL_138;
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 4), _RSI[4])) )
        goto LABEL_137;
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 5), _RSI[5])) )
        goto LABEL_136;
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 6), _RSI[6])) )
        goto LABEL_135;
      if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 7), _RSI[7])) )
      {
        if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 8), _RSI[8])) )
        {
          if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 9), _RSI[9])) )
          {
            if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 10), _RSI[10])) )
            {
              if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 11), _RSI[11])) )
              {
                if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 12), _RSI[12])) )
                {
                  if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 13), _RSI[13])) )
                  {
                    if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 14), _RSI[14])) )
                    {
                      if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 15), _RSI[15])) )
                      {
                        _RSI += 16;
                        _RDI += 16;
                        if ( a3 < 0x80 )
                        {
                          if ( a3 < 0x40 )
                          {
                            if ( a3 >= 0x20 )
                            {
                              if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI), *_RSI)) )
                                goto LABEL_141;
                              if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 1), _RSI[1])) )
                                goto LABEL_140;
                              a3 -= 32LL;
                              _RDI += 2;
                              _RSI += 2;
                            }
                            return ((__int64 (__fastcall *)(__int8 *, __int8 *, double))((char *)dword_91758
                                                                                       + dword_91758[a3]))(
                                     &_RDI->m128i_i8[a3],
                                     &_RSI->m128i_i8[a3],
                                     0.0);
                          }
LABEL_7:
                          v6 = a3 - 64;
                          if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI), *_RSI)) )
                          {
                            if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 1), _RSI[1])) )
                            {
                              if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 2), _RSI[2])) )
                              {
                                if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 3), _RSI[3])) )
                                {
                                  if ( v6 < 0x20 )
                                    return ((__int64 (__fastcall *)(__int8 *, __int8 *, double))((char *)dword_91758
                                                                                               + dword_91758[v6]))(
                                             &_RDI[4].m128i_i8[v6],
                                             &_RSI[4].m128i_i8[v6],
                                             0.0);
                                  if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 4), _RSI[4])) )
                                  {
                                    if ( _mm_testc_si128(
                                           (__m128i)0LL,
                                           _mm_xor_si128(_mm_loadu_si128(_RDI + 5), _RSI[5])) )
                                    {
                                      v6 -= 32LL;
                                      _RDI += 2;
                                      _RSI += 2;
                                      return ((__int64 (__fastcall *)(__int8 *, __int8 *, double))((char *)dword_91758
                                                                                                 + dword_91758[v6]))(
                                               &_RDI[4].m128i_i8[v6],
                                               &_RSI[4].m128i_i8[v6],
                                               0.0);
                                    }
                                    goto LABEL_136;
                                  }
LABEL_137:
                                  v12 = _RDI + 5;
                                  v13 = _RSI + 5;
                                  goto LABEL_142;
                                }
LABEL_138:
                                v12 = _RDI + 4;
                                v13 = _RSI + 4;
                                goto LABEL_142;
                              }
                              goto LABEL_139;
                            }
LABEL_140:
                            ++_RDI;
                            ++_RSI;
                          }
LABEL_141:
                          v12 = _RDI + 1;
                          v13 = _RSI + 1;
                          goto LABEL_142;
                        }
LABEL_18:
                        a3 -= 128LL;
                        if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI), *_RSI)) )
                          goto LABEL_141;
                        if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 1), _RSI[1])) )
                          goto LABEL_140;
                        if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 2), _RSI[2])) )
                        {
                          if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 3), _RSI[3])) )
                            goto LABEL_138;
                          if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 4), _RSI[4])) )
                            goto LABEL_137;
                          if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 5), _RSI[5])) )
                          {
                            if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 6), _RSI[6])) )
                            {
                              if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 7), _RSI[7])) )
                              {
                                _RSI += 8;
                                _RDI += 8;
                                if ( a3 < 0x40 )
                                {
                                  if ( a3 >= 0x20 )
                                  {
                                    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI), *_RSI)) )
                                      goto LABEL_141;
                                    if ( !_mm_testc_si128(
                                            (__m128i)0LL,
                                            _mm_xor_si128(_mm_loadu_si128(_RDI + 1), _RSI[1])) )
                                      goto LABEL_140;
                                    a3 -= 32LL;
                                    _RDI += 2;
                                    _RSI += 2;
                                  }
                                  return ((__int64 (__fastcall *)(_QWORD, _QWORD, double))((char *)dword_91758
                                                                                         + dword_91758[a3]))(
                                           &_RDI->m128i_i8[a3],
                                           &_RSI->m128i_i8[a3],
                                           0.0);
                                }
                                goto LABEL_7;
                              }
                              goto LABEL_134;
                            }
LABEL_135:
                            v12 = _RDI + 7;
                            v13 = _RSI + 7;
                            goto LABEL_142;
                          }
LABEL_136:
                          v12 = _RDI + 6;
                          v13 = _RSI + 6;
                          goto LABEL_142;
                        }
LABEL_139:
                        ++_RDI;
                        ++_RSI;
                        goto LABEL_140;
                      }
                      goto LABEL_126;
                    }
LABEL_127:
                    v12 = _RDI + 15;
                    v13 = _RSI + 15;
                    goto LABEL_142;
                  }
LABEL_128:
                  v12 = _RDI + 14;
                  v13 = _RSI + 14;
                  goto LABEL_142;
                }
LABEL_129:
                v12 = _RDI + 13;
                v13 = _RSI + 13;
                goto LABEL_142;
              }
LABEL_130:
              v12 = _RDI + 12;
              v13 = _RSI + 12;
              goto LABEL_142;
            }
LABEL_131:
            v12 = _RDI + 11;
            v13 = _RSI + 11;
            goto LABEL_142;
          }
LABEL_132:
          v12 = _RDI + 10;
          v13 = _RSI + 10;
          goto LABEL_142;
        }
LABEL_133:
        v12 = _RDI + 9;
        v13 = _RSI + 9;
        goto LABEL_142;
      }
LABEL_134:
      v12 = _RDI + 8;
      v13 = _RSI + 8;
      goto LABEL_142;
    }
    if ( a3 > (unsigned __int64)off_BEFC8 + ((unsigned __int64)off_BEFC8 >> 1) )
    {
      v7 = a3 - 64;
      while ( 1 )
      {
        __asm
        {
          prefetchnta byte ptr [rdi+1C0h]
          prefetchnta byte ptr [rsi+1C0h]
        }
        v8 = _mm_xor_si128(_mm_loadu_si128(_RDI), *_RSI);
        v9 = _mm_xor_si128(_mm_loadu_si128(_RDI + 1), _RSI[1]);
        v10 = _mm_xor_si128(_mm_loadu_si128(_RDI + 2), _RSI[2]);
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_or_si128(_mm_or_si128(_mm_or_si128(v8, v9), v10), _mm_xor_si128(_mm_loadu_si128(_RDI + 3), _RSI[3]))) )
          break;
        _RSI += 4;
        _RDI += 4;
        v11 = v7 < 0x40;
        v7 -= 64LL;
        if ( v11 )
          return ((__int64 (__fastcall *)(__int8 *, __int8 *, double))((char *)dword_91758 + dword_91758[v7 + 64]))(
                   &_RDI[4].m128i_i8[v7],
                   &_RSI[4].m128i_i8[v7],
                   0.0);
      }
    }
    else
    {
      v7 = a3 - 64;
      while ( 1 )
      {
        v8 = _mm_xor_si128(_mm_loadu_si128(_RDI), *_RSI);
        v9 = _mm_xor_si128(_mm_loadu_si128(_RDI + 1), _RSI[1]);
        v10 = _mm_xor_si128(_mm_loadu_si128(_RDI + 2), _RSI[2]);
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_or_si128(_mm_or_si128(_mm_or_si128(v8, v9), v10), _mm_xor_si128(_mm_loadu_si128(_RDI + 3), _RSI[3]))) )
          break;
        _RSI += 4;
        _RDI += 4;
        v11 = v7 < 0x40;
        v7 -= 64LL;
        if ( v11 )
          return ((__int64 (__fastcall *)(__int8 *, __int8 *, double))((char *)dword_91758 + dword_91758[v7 + 64]))(
                   &_RDI[4].m128i_i8[v7],
                   &_RSI[4].m128i_i8[v7],
                   0.0);
      }
    }
LABEL_122:
    v12 = _RDI + 1;
    v13 = _RSI + 1;
    if ( _mm_testc_si128((__m128i)0LL, v8) )
    {
      ++v12;
      ++v13;
      if ( _mm_testc_si128((__m128i)0LL, v9) )
      {
        ++v12;
        ++v13;
        if ( _mm_testc_si128((__m128i)0LL, v10) )
        {
          ++v12;
          ++v13;
        }
      }
    }
    goto LABEL_142;
  }
  if ( a3 <= 0x80 )
  {
LABEL_65:
    v6 = a3 - 64;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI), *_RSI)) )
      goto LABEL_141;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 1), _RSI[1])) )
      goto LABEL_140;
    if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 2), _RSI[2])) )
    {
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 3), _RSI[3])) )
        goto LABEL_138;
      if ( v6 < 0x20 )
        return ((__int64 (__fastcall *)(_QWORD, _QWORD, double))((char *)dword_91758 + dword_91758[v6]))(
                 &_RDI[4].m128i_i8[v6],
                 &_RSI[4].m128i_i8[v6],
                 0.0);
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 4), _RSI[4])) )
        goto LABEL_137;
      if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 5), _RSI[5])) )
      {
        v6 -= 32LL;
        _RDI += 2;
        _RSI += 2;
        return ((__int64 (__fastcall *)(_QWORD, _QWORD, double))((char *)dword_91758 + dword_91758[v6]))(
                 &_RDI[4].m128i_i8[v6],
                 &_RSI[4].m128i_i8[v6],
                 0.0);
      }
      goto LABEL_136;
    }
    goto LABEL_139;
  }
  if ( a3 > 0x200 )
  {
    if ( a3 > (unsigned __int64)off_BEFC8 + ((unsigned __int64)off_BEFC8 >> 1) )
    {
      v7 = a3 - 64;
      while ( 1 )
      {
        __asm
        {
          prefetchnta byte ptr [rdi+1C0h]
          prefetchnta byte ptr [rsi+1C0h]
        }
        v8 = _mm_xor_si128(_mm_load_si128(_RDI), *_RSI);
        v9 = _mm_xor_si128(_mm_load_si128(_RDI + 1), _RSI[1]);
        v10 = _mm_xor_si128(_mm_load_si128(_RDI + 2), _RSI[2]);
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_or_si128(_mm_or_si128(_mm_or_si128(v8, v9), v10), _mm_xor_si128(_mm_load_si128(_RDI + 3), _RSI[3]))) )
          break;
        _RSI += 4;
        _RDI += 4;
        v11 = v7 < 0x40;
        v7 -= 64LL;
        if ( v11 )
          return ((__int64 (__fastcall *)(_QWORD, _QWORD, double))((char *)dword_91758 + dword_91758[v7 + 64]))(
                   &_RDI[4].m128i_i8[v7],
                   &_RSI[4].m128i_i8[v7],
                   0.0);
      }
    }
    else
    {
      v7 = a3 - 64;
      while ( 1 )
      {
        v8 = _mm_xor_si128(_mm_load_si128(_RDI), *_RSI);
        v9 = _mm_xor_si128(_mm_load_si128(_RDI + 1), _RSI[1]);
        v10 = _mm_xor_si128(_mm_load_si128(_RDI + 2), _RSI[2]);
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_or_si128(_mm_or_si128(_mm_or_si128(v8, v9), v10), _mm_xor_si128(_mm_load_si128(_RDI + 3), _RSI[3]))) )
          break;
        _RSI += 4;
        _RDI += 4;
        v11 = v7 < 0x40;
        v7 -= 64LL;
        if ( v11 )
          return ((__int64 (__fastcall *)(_QWORD, _QWORD, double))((char *)dword_91758 + dword_91758[v7 + 64]))(
                   &_RDI[4].m128i_i8[v7],
                   &_RSI[4].m128i_i8[v7],
                   0.0);
      }
    }
    goto LABEL_122;
  }
  if ( a3 <= 0x100 )
  {
LABEL_76:
    a3 -= 128LL;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI), *_RSI)) )
      goto LABEL_141;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 1), _RSI[1])) )
      goto LABEL_140;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 2), _RSI[2])) )
      goto LABEL_139;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 3), _RSI[3])) )
      goto LABEL_138;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 4), _RSI[4])) )
      goto LABEL_137;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 5), _RSI[5])) )
      goto LABEL_136;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 6), _RSI[6])) )
      goto LABEL_135;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 7), _RSI[7])) )
      goto LABEL_134;
    _RSI += 8;
    _RDI += 8;
    if ( a3 < 0x40 )
    {
      if ( a3 >= 0x20 )
      {
        if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI), *_RSI)) )
          goto LABEL_141;
        if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 1), _RSI[1])) )
          goto LABEL_140;
        a3 -= 32LL;
        _RDI += 2;
        _RSI += 2;
      }
      return ((__int64 (__fastcall *)(_QWORD, _QWORD, double))((char *)dword_91758 + dword_91758[a3]))(
               &_RDI->m128i_i8[a3],
               &_RSI->m128i_i8[a3],
               0.0);
    }
    goto LABEL_65;
  }
  a3 -= 256LL;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI), *_RSI)) )
    goto LABEL_141;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 1), _RSI[1])) )
    goto LABEL_140;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 2), _RSI[2])) )
    goto LABEL_139;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 3), _RSI[3])) )
    goto LABEL_138;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 4), _RSI[4])) )
    goto LABEL_137;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 5), _RSI[5])) )
    goto LABEL_136;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 6), _RSI[6])) )
    goto LABEL_135;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 7), _RSI[7])) )
    goto LABEL_134;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 8), _RSI[8])) )
    goto LABEL_133;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 9), _RSI[9])) )
    goto LABEL_132;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 10), _RSI[10])) )
    goto LABEL_131;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 11), _RSI[11])) )
    goto LABEL_130;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 12), _RSI[12])) )
    goto LABEL_129;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 13), _RSI[13])) )
    goto LABEL_128;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 14), _RSI[14])) )
    goto LABEL_127;
  if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 15), _RSI[15])) )
  {
    _RSI += 16;
    _RDI += 16;
    if ( a3 < 0x80 )
    {
      if ( a3 < 0x40 )
      {
        if ( a3 >= 0x20 )
        {
          if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI), *_RSI)) )
            goto LABEL_141;
          if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 1), _RSI[1])) )
            goto LABEL_140;
          a3 -= 32LL;
          _RDI += 2;
          _RSI += 2;
        }
        return ((__int64 (__fastcall *)(_QWORD, _QWORD, double))((char *)dword_91758 + dword_91758[a3]))(
                 &_RDI->m128i_i8[a3],
                 &_RSI->m128i_i8[a3],
                 0.0);
      }
      goto LABEL_65;
    }
    goto LABEL_76;
  }
LABEL_126:
  v12 = _RDI + 16;
  v13 = _RSI + 16;
LABEL_142:
  v14 = v12[-1].m128i_u64[0];
  v15 = v13[-1].m128i_u64[0];
  if ( v15 == v14 )
  {
    v14 = v12[-1].m128i_u64[1];
    v15 = v13[-1].m128i_u64[1];
    if ( v15 == v14 )
      return 0LL;
  }
  if ( (_DWORD)v15 == (_DWORD)v14 )
  {
    v15 >>= 32;
    v14 >>= 32;
  }
  if ( (_WORD)v14 == (_WORD)v15 )
  {
    LODWORD(v15) = WORD1(v15);
    LODWORD(v14) = WORD1(v14);
  }
  if ( (_BYTE)v14 == (_BYTE)v15 )
  {
    LODWORD(v14) = (unsigned __int16)v14;
    LODWORD(v15) = (unsigned __int16)v15;
  }
  else
  {
    LODWORD(v14) = (unsigned __int8)v14;
    LODWORD(v15) = (unsigned __int8)v15;
  }
  return (unsigned int)(v14 - v15);
}
// BEFC8: using guessed type Elf64_Rela *off_BEFC8;

//----- (000000000002D860) ----------------------------------------------------
__int64 __fastcall sub_2D860(__m128i *a1, const __m128i *_RSI, unsigned __int64 a3)
{
  __m128i v3; // xmm0
  __m128i *v4; // rcx
  __m128i *v5; // rdi
  __m128i *v6; // r8
  signed __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  const __m128i *v9; // rsi
  __int64 (__fastcall *v10)(); // rcx
  const __m128i *v11; // r9
  __int64 result; // rax
  __m128i v13; // xmm0
  __int8 *v14; // rsi
  __m128i *v15; // r8
  unsigned __int64 v16; // rdi
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rdi
  unsigned __int64 v19; // rdx
  const __m128i *v20; // rsi
  __int64 (__fastcall *v21)(); // rcx
  const __m128i *v22; // r9
  __m128i v23; // xmm1
  __m128i v24; // xmm1
  __m128i v25; // xmm2
  __m128i v26; // xmm3
  bool v27; // cf
  unsigned __int64 v28; // rdx
  __m128i v29; // xmm1
  __m128i v30; // xmm2
  __m128i v31; // xmm3
  __m128i v32; // xmm4
  __m128i v33; // xmm5
  __m128i v34; // xmm6
  __m128i v35; // xmm7
  bool v36; // cc
  __m128i v37; // xmm1
  __m128i v38; // xmm4
  __m128i v39; // xmm1
  __m128i v40; // xmm0
  __m128i v41; // xmm1
  __m128i v42; // xmm2
  __m128i v43; // xmm3
  __m128i v44; // xmm4
  __m128i v45; // xmm5
  __m128i v46; // xmm6
  __m128i v47; // xmm7
  __m128i v48; // xmm1
  __m128i v49; // xmm0
  __m128i v50; // xmm1
  __m128i v51; // xmm0
  __m128i v52; // xmm1
  unsigned __int64 v53; // rdx
  __m128i v54; // xmm1
  unsigned __int64 v56; // rdi
  __int128 v57; // xmm1
  __int128 v58; // xmm2
  __int128 v59; // xmm3
  unsigned __int64 v60; // rdx
  __int128 v61; // xmm1
  __int128 v62; // xmm2
  __int128 v63; // xmm3
  __int128 v64; // xmm4
  __int128 v65; // xmm5
  __int128 v66; // xmm6
  __int128 v67; // xmm7
  __m128i v68; // xmm1
  __m128i v69; // xmm0
  __m128i v70; // xmm1
  __m128i v71; // xmm0
  __m128i v72; // xmm1
  __m128i v73; // xmm2
  __m128i v74; // xmm3
  __m128i v75; // xmm4
  __m128i v76; // xmm5
  __m128i v77; // xmm6
  __m128i v78; // xmm7
  __m128i v79; // xmm1
  __m128i v80; // xmm0
  __m128i v81; // xmm1
  __m128i v82; // xmm0
  __m128i v83; // xmm1
  __m128i v84; // xmm1
  const __m128i *v85; // rsi
  __m128i *v86; // rdi
  __int64 v87; // rdx
  __m128i v88; // xmm0
  __m128i v89; // xmm1
  __m128i v90; // xmm2
  __m128i v91; // xmm3
  __m128i v92; // xmm4
  __m128i v93; // xmm5
  __m128i v94; // xmm6
  __m128i v95; // xmm7
  __int64 v96; // rdx
  __m128i v97; // xmm0
  __m128i v98; // xmm1
  __m128i v99; // xmm2
  __m128i v100; // xmm3
  __int8 *v101; // rsi
  __int8 *v102; // rdi
  __int64 (__fastcall *v103)(__int8 *, __int8 *, char *, __int64 (__fastcall *)(), __m128i *, const __m128i *); // rdx
  __m128i v104; // xmm1
  char *v105; // rsi
  unsigned __int64 v106; // rdi
  __int64 v107; // rdx
  __m128i v108; // xmm0
  __m128i v109; // xmm1
  __m128i v110; // xmm2
  __m128i v111; // xmm3
  __m128i v112; // xmm4
  __m128i v113; // xmm5
  __m128i v114; // xmm6
  __m128i v115; // xmm7
  __int64 v116; // rdx
  __m128i v117; // xmm0
  __m128i v118; // xmm1
  __m128i v119; // xmm2
  __m128i v120; // xmm3
  __int64 (__fastcall *v121)(unsigned __int64, char *, char *, __int64 (__fastcall *)(), __m128i *, const __m128i *); // rdx

  if ( a3 <= 0x4F )
    return ((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_91898 + dword_91898[a3]))(
             &a1->m128i_i8[a3],
             &_RSI->m128i_i8[a3]);
  if ( (char)_RSI <= (char)a1 )
  {
    v13 = _mm_loadu_si128((const __m128i *)((char *)_RSI + a3 - 16));
    v14 = &_RSI->m128i_i8[a3];
    v15 = (__m128i *)((char *)a1 + a3 - 16);
    v16 = (unsigned __int64)a1->m128i_u64 + a3;
    v17 = v16 & 0xF;
    v18 = v17 ^ v16;
    v19 = a3 - v17;
    v20 = (const __m128i *)&v14[-v17];
    v21 = off_BEFA8;
    v22 = v20;
    if ( v19 > (unsigned __int64)off_BEFA8 )
    {
      v104 = _mm_loadu_si128(v20 - 1);
      v105 = v20[-1].m128i_i8;
      *v15 = v13;
      *(__m128i *)(v18 - 16) = v104;
      v106 = v18 - 16;
      v107 = v19 - 144;
      do
      {
        v108 = _mm_loadu_si128((const __m128i *)v105 - 1);
        v109 = _mm_loadu_si128((const __m128i *)v105 - 2);
        v110 = _mm_loadu_si128((const __m128i *)v105 - 3);
        v111 = _mm_loadu_si128((const __m128i *)v105 - 4);
        v112 = _mm_loadu_si128((const __m128i *)v105 - 5);
        v113 = _mm_loadu_si128((const __m128i *)v105 - 6);
        v114 = _mm_loadu_si128((const __m128i *)v105 - 7);
        v115 = _mm_loadu_si128((const __m128i *)v105 - 8);
        v105 -= 128;
        v27 = (unsigned __int64)v107 < 0x80;
        v107 -= 128LL;
        _mm_stream_si128((__m128i *)(v106 - 16), v108);
        _mm_stream_si128((__m128i *)(v106 - 32), v109);
        _mm_stream_si128((__m128i *)(v106 - 48), v110);
        _mm_stream_si128((__m128i *)(v106 - 64), v111);
        _mm_stream_si128((__m128i *)(v106 - 80), v112);
        _mm_stream_si128((__m128i *)(v106 - 96), v113);
        _mm_stream_si128((__m128i *)(v106 - 112), v114);
        _mm_stream_si128((__m128i *)(v106 - 128), v115);
        v106 -= 128LL;
      }
      while ( !v27 );
      v36 = v107 < -64;
      v116 = v107 + 128;
      if ( !v36 )
      {
        v117 = _mm_loadu_si128((const __m128i *)v105 - 1);
        v118 = _mm_loadu_si128((const __m128i *)v105 - 2);
        v119 = _mm_loadu_si128((const __m128i *)v105 - 3);
        v120 = _mm_loadu_si128((const __m128i *)v105 - 4);
        v105 -= 64;
        _mm_stream_si128((__m128i *)(v106 - 16), v117);
        _mm_stream_si128((__m128i *)(v106 - 32), v118);
        _mm_stream_si128((__m128i *)(v106 - 48), v119);
        _mm_stream_si128((__m128i *)(v106 - 64), v120);
        v106 -= 64LL;
        v116 -= 64LL;
      }
      _mm_sfence();
      v121 = (__int64 (__fastcall *)(unsigned __int64, char *, char *, __int64 (__fastcall *)(), __m128i *, const __m128i *))((char *)dword_91898 + dword_91898[v116]);
      result = v121(v106, v105, (char *)v121, v21, v15, v22);
    }
    else if ( ((unsigned __int8)v20 & 0xF) != 0 )
    {
      result = ((__int64 (__fastcall *)(unsigned __int64, const __m128i *, unsigned __int64, Elf64_Rela *, __m128i *, double))((char *)dword_91A18 + dword_91A18[(unsigned __int8)v20 & 0xF]))(
                 v18,
                 v20,
                 v19,
                 off_BEFC8,
                 v15,
                 *(double *)v13.m128i_i64);
    }
    else
    {
      v53 = v19 - 16;
      v54 = _mm_load_si128(v20 - 1);
      _RSI = v20[-1].m128i_i8;
      *(__m128i *)(v18 - 16) = v54;
      v56 = v18 - 16;
      *v15 = v13;
      if ( v53 > 0x80 )
      {
        v27 = v53 < (unsigned __int64)off_BEFC8;
        v60 = v53 - 128;
        if ( v27 )
        {
          do
          {
            v61 = *((_OWORD *)_RSI - 2);
            v62 = *((_OWORD *)_RSI - 3);
            v63 = *((_OWORD *)_RSI - 4);
            *(__m128i *)(v56 - 16) = _mm_load_si128((const __m128i *)_RSI - 1);
            *(_OWORD *)(v56 - 32) = v61;
            *(_OWORD *)(v56 - 48) = v62;
            *(_OWORD *)(v56 - 64) = v63;
            v27 = v60 < 0x80;
            v60 -= 128LL;
            v64 = *((_OWORD *)_RSI - 5);
            v65 = *((_OWORD *)_RSI - 6);
            v66 = *((_OWORD *)_RSI - 7);
            v67 = *((_OWORD *)_RSI - 8);
            _RSI -= 128;
            *(_OWORD *)(v56 - 80) = v64;
            *(_OWORD *)(v56 - 96) = v65;
            *(_OWORD *)(v56 - 112) = v66;
            *(_OWORD *)(v56 - 128) = v67;
            v56 -= 128LL;
          }
          while ( !v27 );
          v36 = (__int64)v60 < -64;
          v53 = v60 + 128;
          if ( !v36 )
          {
            v53 -= 64LL;
            v68 = _mm_load_si128((const __m128i *)_RSI - 2);
            *(__m128i *)(v56 - 16) = _mm_load_si128((const __m128i *)_RSI - 1);
            *(__m128i *)(v56 - 32) = v68;
            v69 = _mm_load_si128((const __m128i *)_RSI - 3);
            v70 = _mm_load_si128((const __m128i *)_RSI - 4);
            _RSI -= 64;
            *(__m128i *)(v56 - 48) = v69;
            *(__m128i *)(v56 - 64) = v70;
            v56 -= 64LL;
          }
        }
        else
        {
          do
          {
            __asm
            {
              prefetcht0 byte ptr [rsi-1C0h]
              prefetcht0 byte ptr [rsi-280h]
            }
            v71 = _mm_load_si128((const __m128i *)_RSI - 1);
            v72 = _mm_load_si128((const __m128i *)_RSI - 2);
            v73 = _mm_load_si128((const __m128i *)_RSI - 3);
            v74 = _mm_load_si128((const __m128i *)_RSI - 4);
            v75 = _mm_load_si128((const __m128i *)_RSI - 5);
            v76 = _mm_load_si128((const __m128i *)_RSI - 6);
            v77 = _mm_load_si128((const __m128i *)_RSI - 7);
            v78 = _mm_load_si128((const __m128i *)_RSI - 8);
            _RSI -= 128;
            v27 = v60 < 0x80;
            v60 -= 128LL;
            *(__m128i *)(v56 - 16) = v71;
            *(__m128i *)(v56 - 32) = v72;
            *(__m128i *)(v56 - 48) = v73;
            *(__m128i *)(v56 - 64) = v74;
            *(__m128i *)(v56 - 80) = v75;
            *(__m128i *)(v56 - 96) = v76;
            *(__m128i *)(v56 - 112) = v77;
            *(__m128i *)(v56 - 128) = v78;
            v56 -= 128LL;
          }
          while ( !v27 );
          v36 = (__int64)v60 < -64;
          v53 = v60 + 128;
          if ( !v36 )
          {
            v53 -= 64LL;
            v79 = _mm_load_si128((const __m128i *)_RSI - 2);
            *(__m128i *)(v56 - 16) = _mm_load_si128((const __m128i *)_RSI - 1);
            *(__m128i *)(v56 - 32) = v79;
            v80 = _mm_load_si128((const __m128i *)_RSI - 3);
            v81 = _mm_load_si128((const __m128i *)_RSI - 4);
            _RSI -= 64;
            *(__m128i *)(v56 - 48) = v80;
            *(__m128i *)(v56 - 64) = v81;
            v56 -= 64LL;
          }
          if ( v53 >= 0x20 )
          {
            v82 = _mm_load_si128((const __m128i *)_RSI - 1);
            v53 -= 32LL;
            v83 = _mm_load_si128((const __m128i *)_RSI - 2);
            _RSI -= 32;
            *(__m128i *)(v56 - 16) = v82;
            *(__m128i *)(v56 - 32) = v83;
            v56 -= 32LL;
          }
        }
      }
      else if ( v53 >= 0x40 )
      {
        v57 = *((_OWORD *)_RSI - 2);
        v58 = *((_OWORD *)_RSI - 3);
        v59 = *((_OWORD *)_RSI - 4);
        *(_OWORD *)(v56 - 16) = *((_OWORD *)_RSI - 1);
        *(_OWORD *)(v56 - 32) = v57;
        *(_OWORD *)(v56 - 48) = v58;
        *(_OWORD *)(v56 - 64) = v59;
        v53 -= 64LL;
        _RSI -= 64;
        v56 -= 64LL;
      }
      result = ((__int64 (__fastcall *)(unsigned __int64, char *))((char *)dword_91898 + dword_91898[v53]))(v56, _RSI);
    }
  }
  else
  {
    v3 = _mm_loadu_si128(_RSI);
    v4 = a1;
    v5 = (__m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL) + 16);
    v6 = v4;
    v7 = (char *)v4 - (char *)v5;
    v8 = v7 + a3;
    v9 = (const __m128i *)((char *)_RSI - v7);
    v10 = off_BEFA8;
    v11 = v9;
    if ( v8 <= (unsigned __int64)off_BEFA8 )
    {
      if ( ((unsigned __int8)v9 & 0xF) != 0 )
        return ((__int64 (__fastcall *)(__m128i *, const __m128i *, unsigned __int64, Elf64_Rela *, __m128i *, double))((char *)dword_919D8 + dword_919D8[(unsigned __int8)v9 & 0xF]))(
                 v5,
                 v9,
                 v8,
                 off_BEFC8,
                 v6,
                 *(double *)v3.m128i_i64);
      a3 = v8 - 16;
      v23 = _mm_load_si128(v9);
      _RSI = v9 + 1;
      *v5 = v23;
      a1 = v5 + 1;
      *v6 = v3;
      if ( a3 > 0x80 )
      {
        v27 = a3 < (unsigned __int64)off_BEFC8;
        v28 = a3 - 128;
        if ( v27 )
        {
          do
          {
            v29 = _RSI[1];
            v30 = _RSI[2];
            v31 = _RSI[3];
            *a1 = _mm_load_si128(_RSI);
            a1[1] = v29;
            a1[2] = v30;
            a1[3] = v31;
            v27 = v28 < 0x80;
            v28 -= 128LL;
            v32 = _RSI[4];
            v33 = _RSI[5];
            v34 = _RSI[6];
            v35 = _RSI[7];
            _RSI += 8;
            a1[4] = v32;
            a1[5] = v33;
            a1[6] = v34;
            a1[7] = v35;
            a1 += 8;
          }
          while ( !v27 );
          v36 = (__int64)v28 < -64;
          a3 = v28 + 128;
          if ( !v36 )
          {
            a3 -= 64LL;
            v37 = _mm_load_si128(_RSI + 1);
            *a1 = _mm_load_si128(_RSI);
            a1[1] = v37;
            v38 = _mm_load_si128(_RSI + 2);
            v39 = _mm_load_si128(_RSI + 3);
            _RSI += 4;
            a1[2] = v38;
            a1[3] = v39;
            a1 += 4;
          }
        }
        else
        {
          do
          {
            __asm
            {
              prefetcht0 byte ptr [rsi+1C0h]
              prefetcht0 byte ptr [rsi+280h]
            }
            v40 = _mm_load_si128(_RSI);
            v41 = _mm_load_si128(_RSI + 1);
            v42 = _mm_load_si128(_RSI + 2);
            v43 = _mm_load_si128(_RSI + 3);
            v44 = _mm_load_si128(_RSI + 4);
            v45 = _mm_load_si128(_RSI + 5);
            v46 = _mm_load_si128(_RSI + 6);
            v47 = _mm_load_si128(_RSI + 7);
            _RSI += 8;
            v27 = v28 < 0x80;
            v28 -= 128LL;
            *a1 = v40;
            a1[1] = v41;
            a1[2] = v42;
            a1[3] = v43;
            a1[4] = v44;
            a1[5] = v45;
            a1[6] = v46;
            a1[7] = v47;
            a1 += 8;
          }
          while ( !v27 );
          v36 = (__int64)v28 < -64;
          a3 = v28 + 128;
          if ( !v36 )
          {
            a3 -= 64LL;
            v48 = _mm_load_si128(_RSI + 1);
            *a1 = _mm_load_si128(_RSI);
            a1[1] = v48;
            v49 = _mm_load_si128(_RSI + 2);
            v50 = _mm_load_si128(_RSI + 3);
            _RSI += 4;
            a1[2] = v49;
            a1[3] = v50;
            a1 += 4;
          }
          if ( a3 >= 0x20 )
          {
            v51 = _mm_load_si128(_RSI);
            a3 -= 32LL;
            v52 = _mm_load_si128(_RSI + 1);
            _RSI += 2;
            *a1 = v51;
            a1[1] = v52;
            a1 += 2;
          }
        }
      }
      else if ( a3 >= 0x40 )
      {
        v24 = _RSI[1];
        v25 = _RSI[2];
        v26 = _RSI[3];
        *a1 = *_RSI;
        a1[1] = v24;
        a1[2] = v25;
        a1[3] = v26;
        a3 -= 64LL;
        _RSI += 4;
        a1 += 4;
      }
      return ((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_91898 + dword_91898[a3]))(
               &a1->m128i_i8[a3],
               &_RSI->m128i_i8[a3]);
    }
    v84 = _mm_loadu_si128(v9);
    v85 = v9 + 1;
    *v6 = v3;
    _mm_stream_si128(v5, v84);
    v86 = v5 + 1;
    v87 = v8 - 144;
    do
    {
      v88 = _mm_loadu_si128(v85);
      v89 = _mm_loadu_si128(v85 + 1);
      v90 = _mm_loadu_si128(v85 + 2);
      v91 = _mm_loadu_si128(v85 + 3);
      v92 = _mm_loadu_si128(v85 + 4);
      v93 = _mm_loadu_si128(v85 + 5);
      v94 = _mm_loadu_si128(v85 + 6);
      v95 = _mm_loadu_si128(v85 + 7);
      v85 += 8;
      v27 = (unsigned __int64)v87 < 0x80;
      v87 -= 128LL;
      _mm_stream_si128(v86, v88);
      _mm_stream_si128(v86 + 1, v89);
      _mm_stream_si128(v86 + 2, v90);
      _mm_stream_si128(v86 + 3, v91);
      _mm_stream_si128(v86 + 4, v92);
      _mm_stream_si128(v86 + 5, v93);
      _mm_stream_si128(v86 + 6, v94);
      _mm_stream_si128(v86 + 7, v95);
      v86 += 8;
    }
    while ( !v27 );
    v36 = v87 < -64;
    v96 = v87 + 128;
    if ( !v36 )
    {
      v97 = _mm_loadu_si128(v85);
      v98 = _mm_loadu_si128(v85 + 1);
      v99 = _mm_loadu_si128(v85 + 2);
      v100 = _mm_loadu_si128(v85 + 3);
      v85 += 4;
      _mm_stream_si128(v86, v97);
      _mm_stream_si128(v86 + 1, v98);
      _mm_stream_si128(v86 + 2, v99);
      _mm_stream_si128(v86 + 3, v100);
      v86 += 4;
      v96 -= 64LL;
    }
    v101 = &v85->m128i_i8[v96];
    v102 = &v86->m128i_i8[v96];
    _mm_sfence();
    v103 = (__int64 (__fastcall *)(__int8 *, __int8 *, char *, __int64 (__fastcall *)(), __m128i *, const __m128i *))((char *)dword_91898 + dword_91898[v96]);
    result = v103(v102, v101, (char *)v103, v10, v6, v11);
  }
  return result;
}
// BEFA8: using guessed type __int64 (__fastcall *off_BEFA8)();
// BEFC8: using guessed type Elf64_Rela *off_BEFC8;

//----- (0000000000032DF0) ----------------------------------------------------
__int64 __fastcall sub_32DF0(__m128i *a1, const __m128i *a2, unsigned __int64 a3)
{
  __int64 result; // rax
  __m128i v4; // xmm0
  __m128i *v6; // rdi
  unsigned __int64 v7; // rdx
  const __m128i *v8; // rsi
  unsigned __int64 v9; // rdi
  const __m128i *v10; // rsi
  __m128i v11; // xmm0
  __m128i *v12; // r8
  unsigned __int64 v13; // r9
  unsigned __int64 v16; // rdx
  unsigned __int64 v17; // rdx
  bool v18; // cf
  unsigned __int64 v19; // rdx
  __m128i v20; // xmm1
  unsigned __int64 v21; // rdx
  unsigned __int64 v24; // rcx
  unsigned __int64 v25; // rdx
  unsigned __int64 v26; // rdx
  __m128i v27; // xmm0
  __m128i v28; // xmm1
  __m128i v29; // xmm2
  __m128i v30; // xmm3
  __m128i v31; // xmm4
  __m128i v32; // xmm5
  __m128i v33; // xmm6
  __m128i v34; // xmm7
  __m128i v35; // xmm1
  __m128i v36; // xmm2
  __m128i v37; // xmm3
  __m128i v38; // xmm4
  __m128i v39; // xmm5
  __m128i v40; // xmm6
  __m128i v41; // xmm7
  const __m128i *v42; // rsi
  unsigned __int64 v43; // rdi
  unsigned __int64 v44; // r9
  unsigned __int64 v45; // r9
  unsigned __int64 v46; // rdx
  unsigned __int64 v47; // rcx
  unsigned __int64 v48; // rdx
  __m128i v49; // xmm1
  __m128i v50; // xmm2
  __m128i v51; // xmm3
  __m128i v52; // xmm4
  __m128i v53; // xmm5
  __m128i v54; // xmm6
  __m128i v55; // xmm7
  __m128i v56; // xmm8
  __m128i v57; // xmm2
  __m128i v58; // xmm3
  __m128i v59; // xmm4
  __m128i v60; // xmm5
  __m128i v61; // xmm6
  __m128i v62; // xmm7
  __m128i v63; // xmm8

  if ( a3 < 0x90 )
  {
    if ( (unsigned __int8)a2 <= (unsigned __int8)a1 )
      result = ((__int64 (*)(void))((char *)dword_91C18 + dword_91C18[a3]))();
    else
      result = ((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_91E58 + dword_91E58[a3]))(
                 &a1->m128i_i8[a3],
                 &a2->m128i_i8[a3]);
    return result;
  }
  if ( (char)a2 <= (char)a1 )
  {
    if ( a3 <= 2 * qword_BEFC0 )
    {
      v9 = (unsigned __int64)a1->m128i_u64 + a3;
      v10 = (const __m128i *)((char *)a2 + a3);
      v11 = _mm_loadu_si128(v10 - 1);
      v12 = (__m128i *)(v9 - 16);
      v13 = v9 & 0xF;
      _RDI = v13 ^ v9;
      _RSI = &v10->m128i_i8[-v13];
      v16 = a3 - v13;
      if ( ((unsigned __int8)_RSI & 0xF) != 0 )
        return ((__int64 (__fastcall *)(unsigned __int64, char *, unsigned __int64, __int64, __m128i *, double))((char *)dword_920D8 + dword_920D8[(unsigned __int8)_RSI & 0xF]))(
                 _RDI,
                 _RSI,
                 v16 - 128,
                 2 * qword_BEFC0,
                 v12,
                 *(double *)v11.m128i_i64);
      v19 = v16 - 128;
      do
      {
        *(_OWORD *)(_RDI - 16) = *((_OWORD *)_RSI - 1);
        *(_OWORD *)(_RDI - 32) = *((_OWORD *)_RSI - 2);
        *(_OWORD *)(_RDI - 48) = *((_OWORD *)_RSI - 3);
        *(_OWORD *)(_RDI - 64) = *((_OWORD *)_RSI - 4);
        *(_OWORD *)(_RDI - 80) = *((_OWORD *)_RSI - 5);
        *(_OWORD *)(_RDI - 96) = *((_OWORD *)_RSI - 6);
        *(_OWORD *)(_RDI - 112) = *((_OWORD *)_RSI - 7);
        *(_OWORD *)(_RDI - 128) = *((_OWORD *)_RSI - 8);
        v18 = v19 < 0x80;
        v19 -= 128LL;
        _RDI -= 128LL;
        _RSI -= 128;
      }
      while ( !v18 );
      goto LABEL_42;
    }
    v42 = (const __m128i *)((char *)a2 + a3);
    v43 = (unsigned __int64)a1->m128i_u64 + a3;
    v11 = _mm_loadu_si128(v42 - 1);
    v12 = (__m128i *)(v43 - 16);
    v44 = v43;
    _RDI = v43 & 0xFFFFFFFFFFFFFFF0LL;
    v45 = v44 - _RDI;
    _RSI = &v42->m128i_i8[-v45];
    v46 = a3 - v45;
    v47 = (unsigned __int64)off_BEFA8;
    if ( v46 <= (unsigned __int64)off_BEFA8 )
      v47 = v46;
    v48 = v46 - v47;
    if ( v48 > 0x1000 )
    {
      if ( v48 > 8 * v47 )
      {
        v48 += v47;
        v47 = 0LL;
      }
      v19 = v48 - 128;
      do
      {
        v18 = v19 < 0x80;
        v19 -= 128LL;
        __asm
        {
          prefetcht0 byte ptr [rsi-200h]
          prefetcht0 byte ptr [rsi-300h]
        }
        v49 = _mm_loadu_si128((const __m128i *)_RSI - 1);
        v50 = _mm_loadu_si128((const __m128i *)_RSI - 2);
        v51 = _mm_loadu_si128((const __m128i *)_RSI - 3);
        v52 = _mm_loadu_si128((const __m128i *)_RSI - 4);
        v53 = _mm_loadu_si128((const __m128i *)_RSI - 5);
        v54 = _mm_loadu_si128((const __m128i *)_RSI - 6);
        v55 = _mm_loadu_si128((const __m128i *)_RSI - 7);
        v56 = _mm_loadu_si128((const __m128i *)_RSI - 8);
        _mm_lfence();
        _mm_stream_si128((__m128i *)(_RDI - 16), v49);
        _mm_stream_si128((__m128i *)(_RDI - 32), v50);
        _mm_stream_si128((__m128i *)(_RDI - 48), v51);
        _mm_stream_si128((__m128i *)(_RDI - 64), v52);
        _mm_stream_si128((__m128i *)(_RDI - 80), v53);
        _mm_stream_si128((__m128i *)(_RDI - 96), v54);
        _mm_stream_si128((__m128i *)(_RDI - 112), v55);
        _mm_stream_si128((__m128i *)(_RDI - 128), v56);
        _RSI -= 128;
        _RDI -= 128LL;
      }
      while ( !v18 );
      _mm_sfence();
      if ( v47 < 0x80 )
        goto LABEL_42;
      v48 = v19 + 128;
    }
    v19 = v47 + v48 - 128;
    do
    {
      __asm
      {
        prefetchnta byte ptr [rsi-1C0h]
        prefetchnta byte ptr [rsi-280h]
        prefetchnta byte ptr [rdi-1C0h]
        prefetchnta byte ptr [rdi-280h]
      }
      v18 = v19 < 0x80;
      v19 -= 128LL;
      v57 = _mm_loadu_si128((const __m128i *)_RSI - 2);
      v58 = _mm_loadu_si128((const __m128i *)_RSI - 3);
      v59 = _mm_loadu_si128((const __m128i *)_RSI - 4);
      v60 = _mm_loadu_si128((const __m128i *)_RSI - 5);
      v61 = _mm_loadu_si128((const __m128i *)_RSI - 6);
      v62 = _mm_loadu_si128((const __m128i *)_RSI - 7);
      v63 = _mm_loadu_si128((const __m128i *)_RSI - 8);
      *(__m128i *)(_RDI - 16) = _mm_loadu_si128((const __m128i *)_RSI - 1);
      *(__m128i *)(_RDI - 32) = v57;
      *(__m128i *)(_RDI - 48) = v58;
      *(__m128i *)(_RDI - 64) = v59;
      *(__m128i *)(_RDI - 80) = v60;
      *(__m128i *)(_RDI - 96) = v61;
      *(__m128i *)(_RDI - 112) = v62;
      *(__m128i *)(_RDI - 128) = v63;
      _RSI -= 128;
      _RDI -= 128LL;
    }
    while ( !v18 );
LABEL_42:
    *v12 = v11;
    return ((__int64 (__fastcall *)(unsigned __int64, char *))((char *)dword_91C18 + dword_91C18[v19 + 128]))(
             _RDI - (v19 + 128),
             &_RSI[-v19 - 128]);
  }
  v4 = _mm_loadu_si128(a2);
  v6 = (__m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL) + 16);
  v7 = a3 - ((char *)v6 - (char *)a1);
  v8 = (const __m128i *)((char *)a2 + (char *)v6 - (char *)a1);
  if ( ((unsigned __int8)v8 & 0xF) != 0 )
  {
    if ( v7 < qword_BEFC0 )
      return ((__int64 (__fastcall *)(__m128i *, const __m128i *, unsigned __int64, double))((char *)dword_92098
                                                                                           + dword_92098[(unsigned __int8)v8 & 0xF]))(
               v6,
               v8,
               v7 - 128,
               *(double *)v4.m128i_i64);
LABEL_19:
    v20 = _mm_loadu_si128(v8);
    *a1 = v4;
    *v6 = v20;
    v21 = v7 - 16;
    _RSI = v8 + 1;
    _RDI = v6 + 1;
    v24 = (unsigned __int64)off_BEFA8;
    if ( v21 <= (unsigned __int64)off_BEFA8 )
      v24 = v21;
    v25 = v21 - v24;
    if ( v25 > 0x1000 )
    {
      if ( v25 > 8 * v24 )
      {
        v25 += v24;
        v24 = 0LL;
      }
      v26 = v25 - 128;
      do
      {
        v18 = v26 < 0x80;
        v26 -= 128LL;
        __asm
        {
          prefetcht0 byte ptr [rsi+200h]
          prefetcht0 byte ptr [rsi+300h]
        }
        v27 = _mm_loadu_si128(_RSI);
        v28 = _mm_loadu_si128(_RSI + 1);
        v29 = _mm_loadu_si128(_RSI + 2);
        v30 = _mm_loadu_si128(_RSI + 3);
        v31 = _mm_loadu_si128(_RSI + 4);
        v32 = _mm_loadu_si128(_RSI + 5);
        v33 = _mm_loadu_si128(_RSI + 6);
        v34 = _mm_loadu_si128(_RSI + 7);
        _mm_lfence();
        _mm_stream_si128(_RDI, v27);
        _mm_stream_si128(_RDI + 1, v28);
        _mm_stream_si128(_RDI + 2, v29);
        _mm_stream_si128(_RDI + 3, v30);
        _mm_stream_si128(_RDI + 4, v31);
        _mm_stream_si128(_RDI + 5, v32);
        _mm_stream_si128(_RDI + 6, v33);
        _mm_stream_si128(_RDI + 7, v34);
        _RSI += 8;
        _RDI += 8;
      }
      while ( !v18 );
      _mm_sfence();
      if ( v24 < 0x80 )
        return ((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_91E58 + dword_91E58[v26 + 128]))(
                 &_RDI[8].m128i_i8[v26],
                 &_RSI[8].m128i_i8[v26]);
      v25 = v26 + 128;
    }
    v26 = v24 + v25 - 128;
    do
    {
      __asm
      {
        prefetchnta byte ptr [rsi+1C0h]
        prefetchnta byte ptr [rsi+280h]
        prefetchnta byte ptr [rdi+1C0h]
        prefetchnta byte ptr [rdi+280h]
      }
      v18 = v26 < 0x80;
      v26 -= 128LL;
      v35 = _mm_loadu_si128(_RSI + 1);
      v36 = _mm_loadu_si128(_RSI + 2);
      v37 = _mm_loadu_si128(_RSI + 3);
      v38 = _mm_loadu_si128(_RSI + 4);
      v39 = _mm_loadu_si128(_RSI + 5);
      v40 = _mm_loadu_si128(_RSI + 6);
      v41 = _mm_loadu_si128(_RSI + 7);
      *_RDI = _mm_loadu_si128(_RSI);
      _RDI[1] = v35;
      _RDI[2] = v36;
      _RDI[3] = v37;
      _RDI[4] = v38;
      _RDI[5] = v39;
      _RDI[6] = v40;
      _RDI[7] = v41;
      _RSI += 8;
      _RDI += 8;
    }
    while ( !v18 );
    return ((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_91E58 + dword_91E58[v26 + 128]))(
             &_RDI[8].m128i_i8[v26],
             &_RSI[8].m128i_i8[v26]);
  }
  if ( v7 + (v7 >> 8) >= (unsigned __int64)off_BEFC8 )
    goto LABEL_19;
  v17 = v7 - 128;
  do
  {
    *v6 = _mm_load_si128(v8);
    v6[1] = v8[1];
    v6[2] = v8[2];
    v6[3] = v8[3];
    v6[4] = v8[4];
    v6[5] = v8[5];
    v6[6] = v8[6];
    v6[7] = v8[7];
    v18 = v17 < 0x80;
    v17 -= 128LL;
    v8 += 8;
    v6 += 8;
  }
  while ( !v18 );
  *a1 = v4;
  return ((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_91E58 + dword_91E58[v17 + 128]))(
           &v6[8].m128i_i8[v17],
           &v8[8].m128i_i8[v17]);
}
// BEFA8: using guessed type __int64 (__fastcall *off_BEFA8)();
// BEFC0: using guessed type __int64 qword_BEFC0;
// BEFC8: using guessed type Elf64_Rela *off_BEFC8;

//----- (0000000000038430) ----------------------------------------------------
unsigned __int64 __fastcall sub_38430(unsigned __int64 _RDI, _BYTE *_RSI, unsigned __int64 a3)
{
  unsigned __int64 result; // rax
  __int64 v26; // rcx
  int v27; // ecx
  __int16 v28; // cx
  unsigned __int64 v82; // r8
  unsigned __int64 v83; // r8
  unsigned __int64 v90; // r8

  result = _RDI;
  _RCX = &_RSI[a3];
  _R9 = _RDI + a3;
  if ( a3 > 0x200 )
  {
    if ( a3 < (unsigned __int64)off_BEFA8 )
    {
      if ( a3 > 0x400 )
      {
        if ( _RDI > (unsigned __int64)_RSI )
        {
          _RDI = _RDI + 512;
          __asm
          {
            vmovups zmm8, zmmword ptr [rsi+1C0h]
            vmovups zmm9, zmmword ptr [rsi+180h]
            vmovups zmm10, zmmword ptr [rsi+140h]
            vmovups zmm11, zmmword ptr [rsi+100h]
            vmovups zmm12, zmmword ptr [rsi+0C0h]
            vmovups zmm13, zmmword ptr [rsi+80h]
            vmovups zmm14, zmmword ptr [rsi+40h]
            vmovups zmm15, zmmword ptr [rsi]
            prefetcht1 byte ptr [rcx-40h]
            prefetcht1 byte ptr [rcx-80h]
            prefetcht1 byte ptr [rcx-0C0h]
            prefetcht1 byte ptr [rcx-100h]
            prefetcht1 byte ptr [rcx-140h]
            prefetcht1 byte ptr [rcx-180h]
            prefetcht1 byte ptr [rcx-1C0h]
            prefetcht1 byte ptr [rcx-200h]
          }
          do
          {
            __asm
            {
              vmovups zmm0, zmmword ptr [rcx-40h]
              vmovups zmm1, zmmword ptr [rcx-80h]
              vmovups zmm2, zmmword ptr [rcx-0C0h]
              vmovups zmm3, zmmword ptr [rcx-100h]
              vmovups zmm4, zmmword ptr [rcx-140h]
              vmovups zmm5, zmmword ptr [rcx-180h]
              vmovups zmm6, zmmword ptr [rcx-1C0h]
              vmovups zmm7, zmmword ptr [rcx-200h]
            }
            _RCX -= 512;
            __asm
            {
              prefetcht1 byte ptr [rcx-40h]
              prefetcht1 byte ptr [rcx-80h]
              prefetcht1 byte ptr [rcx-0C0h]
              prefetcht1 byte ptr [rcx-100h]
              prefetcht1 byte ptr [rcx-140h]
              prefetcht1 byte ptr [rcx-180h]
              prefetcht1 byte ptr [rcx-1C0h]
              prefetcht1 byte ptr [rcx-200h]
              vmovups zmmword ptr [r9-40h], zmm0
              vmovups zmmword ptr [r9-80h], zmm1
              vmovups zmmword ptr [r9-0C0h], zmm2
              vmovups zmmword ptr [r9-100h], zmm3
              vmovups zmmword ptr [r9-140h], zmm4
              vmovups zmmword ptr [r9-180h], zmm5
              vmovups zmmword ptr [r9-1C0h], zmm6
              vmovups zmmword ptr [r9-200h], zmm7
            }
            _R9 -= 512LL;
          }
          while ( _R9 > _RDI );
          __asm
          {
            vmovups zmmword ptr [rdi-40h], zmm8
            vmovups zmmword ptr [rdi-80h], zmm9
            vmovups zmmword ptr [rdi-0C0h], zmm10
            vmovups zmmword ptr [rdi-100h], zmm11
            vmovups zmmword ptr [rdi-140h], zmm12
            vmovups zmmword ptr [rdi-180h], zmm13
            vmovups zmmword ptr [rdi-1C0h], zmm14
            vmovups zmmword ptr [rdi-200h], zmm15
          }
        }
        else
        {
          _R9 = _R9 - 512;
          __asm
          {
            vmovups zmm8, zmmword ptr [rcx-200h]
            vmovups zmm9, zmmword ptr [rcx-1C0h]
            vmovups zmm10, zmmword ptr [rcx-180h]
            vmovups zmm11, zmmword ptr [rcx-140h]
            vmovups zmm12, zmmword ptr [rcx-100h]
            vmovups zmm13, zmmword ptr [rcx-0C0h]
            vmovups zmm14, zmmword ptr [rcx-80h]
            vmovups zmm15, zmmword ptr [rcx-40h]
            prefetcht1 byte ptr [rsi]
            prefetcht1 byte ptr [rsi+40h]
            prefetcht1 byte ptr [rsi+80h]
            prefetcht1 byte ptr [rsi+0C0h]
            prefetcht1 byte ptr [rsi+100h]
            prefetcht1 byte ptr [rsi+140h]
            prefetcht1 byte ptr [rsi+180h]
            prefetcht1 byte ptr [rsi+1C0h]
          }
          do
          {
            __asm
            {
              vmovups zmm0, zmmword ptr [rsi]
              vmovups zmm1, zmmword ptr [rsi+40h]
              vmovups zmm2, zmmword ptr [rsi+80h]
              vmovups zmm3, zmmword ptr [rsi+0C0h]
              vmovups zmm4, zmmword ptr [rsi+100h]
              vmovups zmm5, zmmword ptr [rsi+140h]
              vmovups zmm6, zmmword ptr [rsi+180h]
              vmovups zmm7, zmmword ptr [rsi+1C0h]
            }
            _RSI += 512;
            __asm
            {
              prefetcht1 byte ptr [rsi]
              prefetcht1 byte ptr [rsi+40h]
              prefetcht1 byte ptr [rsi+80h]
              prefetcht1 byte ptr [rsi+0C0h]
              prefetcht1 byte ptr [rsi+100h]
              prefetcht1 byte ptr [rsi+140h]
              prefetcht1 byte ptr [rsi+180h]
              prefetcht1 byte ptr [rsi+1C0h]
              vmovups zmmword ptr [rdi], zmm0
              vmovups zmmword ptr [rdi+40h], zmm1
              vmovups zmmword ptr [rdi+80h], zmm2
              vmovups zmmword ptr [rdi+0C0h], zmm3
              vmovups zmmword ptr [rdi+100h], zmm4
              vmovups zmmword ptr [rdi+140h], zmm5
              vmovups zmmword ptr [rdi+180h], zmm6
              vmovups zmmword ptr [rdi+1C0h], zmm7
            }
            _RDI += 512LL;
          }
          while ( _RDI < _R9 );
          __asm
          {
            vmovups zmmword ptr [r9], zmm8
            vmovups zmmword ptr [r9+40h], zmm9
            vmovups zmmword ptr [r9+80h], zmm10
            vmovups zmmword ptr [r9+0C0h], zmm11
            vmovups zmmword ptr [r9+100h], zmm12
            vmovups zmmword ptr [r9+140h], zmm13
            vmovups zmmword ptr [r9+180h], zmm14
            vmovups zmmword ptr [r9+1C0h], zmm15
          }
        }
      }
      else
      {
        __asm
        {
          prefetcht1 byte ptr [rsi]
          prefetcht1 byte ptr [rsi+40h]
          prefetcht1 byte ptr [rsi+80h]
          prefetcht1 byte ptr [rsi+0C0h]
          prefetcht1 byte ptr [rsi+100h]
          prefetcht1 byte ptr [rsi+140h]
          prefetcht1 byte ptr [rsi+180h]
          prefetcht1 byte ptr [rsi+1C0h]
          prefetcht1 byte ptr [rcx-200h]
          prefetcht1 byte ptr [rcx-1C0h]
          prefetcht1 byte ptr [rcx-180h]
          prefetcht1 byte ptr [rcx-140h]
          prefetcht1 byte ptr [rcx-100h]
          prefetcht1 byte ptr [rcx-0C0h]
          prefetcht1 byte ptr [rcx-80h]
          prefetcht1 byte ptr [rcx-40h]
          vmovups zmm0, zmmword ptr [rsi]
          vmovups zmm1, zmmword ptr [rsi+40h]
          vmovups zmm2, zmmword ptr [rsi+80h]
          vmovups zmm3, zmmword ptr [rsi+0C0h]
          vmovups zmm4, zmmword ptr [rsi+100h]
          vmovups zmm5, zmmword ptr [rsi+140h]
          vmovups zmm6, zmmword ptr [rsi+180h]
          vmovups zmm7, zmmword ptr [rsi+1C0h]
          vmovups zmm8, zmmword ptr [rcx-200h]
          vmovups zmm9, zmmword ptr [rcx-1C0h]
          vmovups zmm10, zmmword ptr [rcx-180h]
          vmovups zmm11, zmmword ptr [rcx-140h]
          vmovups zmm12, zmmword ptr [rcx-100h]
          vmovups zmm13, zmmword ptr [rcx-0C0h]
          vmovups zmm14, zmmword ptr [rcx-80h]
          vmovups zmm15, zmmword ptr [rcx-40h]
          vmovups zmmword ptr [rdi], zmm0
          vmovups zmmword ptr [rdi+40h], zmm1
          vmovups zmmword ptr [rdi+80h], zmm2
          vmovups zmmword ptr [rdi+0C0h], zmm3
          vmovups zmmword ptr [rdi+100h], zmm4
          vmovups zmmword ptr [rdi+140h], zmm5
          vmovups zmmword ptr [rdi+180h], zmm6
          vmovups zmmword ptr [rdi+1C0h], zmm7
          vmovups zmmword ptr [r9-200h], zmm8
          vmovups zmmword ptr [r9-1C0h], zmm9
          vmovups zmmword ptr [r9-180h], zmm10
          vmovups zmmword ptr [r9-140h], zmm11
          vmovups zmmword ptr [r9-100h], zmm12
          vmovups zmmword ptr [r9-0C0h], zmm13
          vmovups zmmword ptr [r9-80h], zmm14
          vmovups zmmword ptr [r9-40h], zmm15
        }
      }
      return result;
    }
    if ( _RDI > (unsigned __int64)_RSI )
    {
      __asm
      {
        vmovups zmm4, zmmword ptr [rcx-80h]
        vmovups zmm5, zmmword ptr [rcx-40h]
      }
      _R9 &= 0xFFFFFFFFFFFFFF80LL;
      v90 = _RDI + a3 - _R9;
      _RCX -= v90;
      a3 = _R9 - _RDI;
      _R8 = _R9 + v90;
      do
      {
        __asm
        {
          prefetcht1 byte ptr [rcx-400h]
          prefetcht1 byte ptr [rcx-3C0h]
          prefetcht1 byte ptr [rcx-380h]
          prefetcht1 byte ptr [rcx-340h]
          prefetcht1 byte ptr [rcx-300h]
          prefetcht1 byte ptr [rcx-2C0h]
          prefetcht1 byte ptr [rcx-280h]
          prefetcht1 byte ptr [rcx-240h]
          vmovdqu64 zmm0, zmmword ptr [rcx-100h]
          vmovdqu64 zmm1, zmmword ptr [rcx-0C0h]
          vmovdqu64 zmm2, zmmword ptr [rcx-80h]
          vmovdqu64 zmm3, zmmword ptr [rcx-40h]
          vmovntdq zmmword ptr [r9-100h], zmm0
          vmovntdq zmmword ptr [r9-0C0h], zmm1
          vmovntdq zmmword ptr [r9-80h], zmm2
          vmovntdq zmmword ptr [r9-40h], zmm3
        }
        a3 -= 256LL;
        _RCX -= 256;
        _R9 -= 256LL;
      }
      while ( a3 > 0x100 );
      _mm_sfence();
      __asm
      {
        vmovups zmmword ptr [r8-80h], zmm4
        vmovups zmmword ptr [r8-40h], zmm5
      }
    }
    else
    {
      __asm
      {
        vmovups zmm4, zmmword ptr [rsi]
        vmovups zmm5, zmmword ptr [rsi+40h]
      }
      _R11 = _RDI;
      v82 = _RDI;
      _RDI = (_RDI & 0xFFFFFFFFFFFFFF80LL) + 128;
      v83 = v82 - _RDI;
      _RSI -= v83;
      a3 += v83;
      do
      {
        __asm
        {
          prefetcht1 byte ptr [rsi+200h]
          prefetcht1 byte ptr [rsi+240h]
          prefetcht1 byte ptr [rsi+280h]
          prefetcht1 byte ptr [rsi+2C0h]
          prefetcht1 byte ptr [rsi+300h]
          prefetcht1 byte ptr [rsi+340h]
          prefetcht1 byte ptr [rsi+380h]
          prefetcht1 byte ptr [rsi+3C0h]
          vmovdqu64 zmm0, zmmword ptr [rsi]
          vmovdqu64 zmm1, zmmword ptr [rsi+40h]
          vmovdqu64 zmm2, zmmword ptr [rsi+80h]
          vmovdqu64 zmm3, zmmword ptr [rsi+0C0h]
          vmovntdq zmmword ptr [rdi], zmm0
          vmovntdq zmmword ptr [rdi+40h], zmm1
          vmovntdq zmmword ptr [rdi+80h], zmm2
          vmovntdq zmmword ptr [rdi+0C0h], zmm3
        }
        a3 -= 256LL;
        _RSI += 256;
        _RDI += 256LL;
      }
      while ( a3 > 0x100 );
      _mm_sfence();
      __asm
      {
        vmovups zmmword ptr [r11], zmm4
        vmovups zmmword ptr [r11+40h], zmm5
      }
    }
  }
  if ( a3 <= 0x10 )
  {
    if ( (unsigned __int8)a3 < 8u )
    {
      if ( (unsigned __int8)a3 < 4u )
      {
        if ( (unsigned __int8)a3 < 2u )
        {
          if ( (_BYTE)a3 )
            *(_BYTE *)_RDI = *_RSI;
        }
        else
        {
          v28 = *((_WORD *)_RCX - 1);
          *(_WORD *)_RDI = *(_WORD *)_RSI;
          *(_WORD *)(_R9 - 2) = v28;
        }
      }
      else
      {
        v27 = *((_DWORD *)_RCX - 1);
        *(_DWORD *)_RDI = *(_DWORD *)_RSI;
        *(_DWORD *)(_R9 - 4) = v27;
      }
    }
    else
    {
      v26 = *((_QWORD *)_RCX - 1);
      *(_QWORD *)_RDI = *(_QWORD *)_RSI;
      *(_QWORD *)(_R9 - 8) = v26;
    }
  }
  else if ( a3 < 0x100 )
  {
    if ( (unsigned __int8)a3 < 0x80u )
    {
      if ( (unsigned __int8)a3 < 0x40u )
      {
        if ( (unsigned __int8)a3 < 0x20u )
        {
          __asm
          {
            vmovdqu xmm0, xmmword ptr [rsi]
            vmovdqu xmm1, xmmword ptr [rcx-10h]
            vmovdqu xmmword ptr [rdi], xmm0
            vmovdqu xmmword ptr [r9-10h], xmm1
          }
        }
        else
        {
          __asm
          {
            vmovdqu ymm0, ymmword ptr [rsi]
            vmovdqu ymm1, ymmword ptr [rcx-20h]
            vmovdqu ymmword ptr [rdi], ymm0
            vmovdqu ymmword ptr [r9-20h], ymm1
          }
        }
      }
      else
      {
        __asm
        {
          vmovdqu ymm0, ymmword ptr [rsi]
          vmovdqu ymm1, ymmword ptr [rsi+20h]
          vmovdqu ymm2, ymmword ptr [rcx-40h]
          vmovdqu ymm3, ymmword ptr [rcx-20h]
          vmovdqu ymmword ptr [rdi], ymm0
          vmovdqu ymmword ptr [rdi+20h], ymm1
          vmovdqu ymmword ptr [r9-40h], ymm2
          vmovdqu ymmword ptr [r9-20h], ymm3
        }
      }
    }
    else
    {
      __asm
      {
        vmovups zmm0, zmmword ptr [rsi]
        vmovups zmm1, zmmword ptr [rsi+40h]
        vmovups zmm2, zmmword ptr [rcx-80h]
        vmovups zmm3, zmmword ptr [rcx-40h]
        vmovups zmmword ptr [rdi], zmm0
        vmovups zmmword ptr [rdi+40h], zmm1
        vmovups zmmword ptr [r9-80h], zmm2
        vmovups zmmword ptr [r9-40h], zmm3
      }
    }
  }
  else
  {
    __asm
    {
      vmovups zmm0, zmmword ptr [rsi]
      vmovups zmm1, zmmword ptr [rsi+40h]
      vmovups zmm2, zmmword ptr [rsi+80h]
      vmovups zmm3, zmmword ptr [rsi+0C0h]
      vmovups zmm4, zmmword ptr [rcx-100h]
      vmovups zmm5, zmmword ptr [rcx-0C0h]
      vmovups zmm6, zmmword ptr [rcx-80h]
      vmovups zmm7, zmmword ptr [rcx-40h]
      vmovups zmmword ptr [rdi], zmm0
      vmovups zmmword ptr [rdi+40h], zmm1
      vmovups zmmword ptr [rdi+80h], zmm2
      vmovups zmmword ptr [rdi+0C0h], zmm3
      vmovups zmmword ptr [r9-100h], zmm4
      vmovups zmmword ptr [r9-0C0h], zmm5
      vmovups zmmword ptr [r9-80h], zmm6
      vmovups zmmword ptr [r9-40h], zmm7
    }
  }
  return result;
}
// 38430: unsupported processor register 'zmm0'
// BEFA8: using guessed type __int64 (__fastcall *off_BEFA8)();

//----- (0000000000038B90) ----------------------------------------------------
__int64 __fastcall sub_38B90(__int64 *a1, __int64 *a2, _QWORD *a3, __m128i a4, __m128i a5, __m128i a6, double a7, double a8)
{
  unsigned int v8; // ecx
  unsigned int v9; // eax
  __m128i v10; // xmm5
  __m128i v11; // xmm6
  __m128i v12; // xmm7
  __m128i v13; // xmm1
  __m128i v14; // xmm2
  __m128i v15; // xmm1
  unsigned __int64 v16; // rdx
  const __m128i *v17; // rsi
  const __m128i *v18; // rdi
  __int64 v19; // r8
  __int64 v20; // rcx
  __int64 v21; // rax
  unsigned int v22; // et0
  const __m128i *v23; // rt1
  __int64 result; // rax
  __m128i v25; // xmm1
  __m128i v26; // xmm2
  __m128i v27; // xmm0
  __m128i v28; // xmm1
  __m128i v29; // xmm2
  __m128i v30; // xmm1
  __m128i v31; // xmm0
  __m128i v32; // xmm1
  __m128i v33; // xmm2
  __m128i v34; // xmm1
  __int64 *v35; // r8
  __int64 v36; // rcx
  __int64 v37; // rdx
  __int64 v38; // rdi

  if ( (*(_DWORD *)(*a3 + 632LL) & 1) == 0 )
  {
    v8 = (unsigned __int8)a2 & 0x3F;
    v9 = (unsigned __int8)a1 & 0x3F;
    v10 = _mm_load_si128((const __m128i *)&xmmword_92620);
    v11 = _mm_load_si128((const __m128i *)&xmmword_92630);
    v12 = _mm_load_si128((const __m128i *)&xmmword_92640);
    if ( v8 <= 0x30 && v9 <= 0x30 )
    {
      v13.m128i_i64[0] = *a1;
      v14.m128i_i64[0] = *a2;
      v13.m128i_i64[1] = a1[1];
      v14.m128i_i64[1] = a2[1];
      v15 = _mm_or_si128(v13, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v13, v10), _mm_cmpgt_epi8(v11, v13)), v12));
      a6 = _mm_or_si128(v14, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v14, v10), _mm_cmpgt_epi8(v11, v14)), v12));
      a4 = _mm_cmpeq_epi8((__m128i)0LL, v15);
      a5 = _mm_sub_epi8(_mm_cmpeq_epi8(v15, a6), a4);
      v16 = (unsigned int)(_mm_movemask_epi8(a5) - 0xFFFF);
      if ( (_DWORD)v16 )
        goto LABEL_17;
      a2 += 2;
      a1 += 2;
    }
    v17 = (const __m128i *)((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL);
    v18 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL);
    v19 = 0LL;
    v20 = v8 & 0xF;
    v21 = v9 & 0xF;
    if ( (_DWORD)v20 != (_DWORD)v21 )
    {
      if ( (unsigned int)v20 <= (unsigned int)v21 )
      {
        v19 = 0xFFFFLL;
        v22 = v21;
        v21 = (unsigned int)v20;
        v20 = v22;
        v23 = v17;
        v17 = v18;
        v18 = v23;
      }
      return ((__int64 (__fastcall *)(const __m128i *, const __m128i *, __int64, __int64, __int64, double, double, double, double, double, double, double, double))((char *)dword_92650 + dword_92650[v21 + 15 - v20]))(
               v18,
               v17,
               0xFFFFLL,
               v20,
               v19,
               *(double *)a4.m128i_i64,
               *(double *)a5.m128i_i64,
               *(double *)a6.m128i_i64,
               a7,
               a8,
               *(double *)v10.m128i_i64,
               *(double *)v11.m128i_i64,
               *(double *)v12.m128i_i64);
    }
    v25 = _mm_load_si128(v17);
    v26 = _mm_load_si128(v18);
    v16 = (0xFFFFu >> v20)
        - ((unsigned int)_mm_movemask_epi8(
                           _mm_sub_epi8(
                             _mm_cmpeq_epi8(
                               _mm_or_si128(
                                 v25,
                                 _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v25, v10), _mm_cmpgt_epi8(v11, v25)), v12)),
                               _mm_or_si128(
                                 v26,
                                 _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v26, v10), _mm_cmpgt_epi8(v11, v26)), v12))),
                             _mm_cmpeq_epi8((__m128i)0LL, v25))) >> v20);
    if ( !(_DWORD)v16 )
    {
      v20 = 16LL;
      v27 = 0LL;
      while ( 1 )
      {
        v28 = _mm_load_si128((const __m128i *)((char *)v17 + v20));
        v29 = _mm_load_si128((const __m128i *)((char *)v18 + v20));
        v30 = _mm_or_si128(v28, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v28, v10), _mm_cmpgt_epi8(v11, v28)), v12));
        v31 = _mm_cmpeq_epi8(v27, v30);
        v16 = (unsigned int)(_mm_movemask_epi8(
                               _mm_sub_epi8(
                                 _mm_cmpeq_epi8(
                                   v30,
                                   _mm_or_si128(
                                     v29,
                                     _mm_and_si128(
                                       _mm_and_si128(_mm_cmpgt_epi8(v29, v10), _mm_cmpgt_epi8(v11, v29)),
                                       v12))),
                                 v31))
                           - 0xFFFF);
        if ( (_DWORD)v16 )
          break;
        v20 += 16LL;
        v32 = _mm_load_si128((const __m128i *)((char *)v17 + v20));
        v33 = _mm_load_si128((const __m128i *)((char *)v18 + v20));
        v34 = _mm_or_si128(v32, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v32, v10), _mm_cmpgt_epi8(v11, v32)), v12));
        v27 = _mm_cmpeq_epi8(v31, v34);
        v16 = (unsigned int)(_mm_movemask_epi8(
                               _mm_sub_epi8(
                                 _mm_cmpeq_epi8(
                                   v34,
                                   _mm_or_si128(
                                     v33,
                                     _mm_and_si128(
                                       _mm_and_si128(_mm_cmpgt_epi8(v33, v10), _mm_cmpgt_epi8(v11, v33)),
                                       v12))),
                                 v27))
                           - 0xFFFF);
        if ( (_DWORD)v16 )
          break;
        v20 += 16LL;
      }
      v21 = v20;
    }
    a1 = (__int64 *)((char *)v18->m128i_i64 + v21);
    a2 = (__int64 *)((char *)v17->m128i_i64 + v20);
LABEL_17:
    _BitScanForward64(&v16, v16);
    return (unsigned int)(dword_962A0[*((unsigned __int8 *)a1 + v16)] - dword_962A0[*((unsigned __int8 *)a2 + v16)]);
  }
  v35 = a1;
  if ( a1 == a2 )
    return 0LL;
  v36 = a3[14];
  v37 = 0LL;
  do
  {
    v38 = *((unsigned __int8 *)v35 + v37);
    result = (unsigned int)(*(_DWORD *)(v36 + 4 * v38) - *(_DWORD *)(v36 + 4LL * *((unsigned __int8 *)a2 + v37)));
    if ( (_DWORD)result )
      break;
    ++v37;
  }
  while ( (_BYTE)v38 );
  return result;
}
// 92620: using guessed type __int128 xmmword_92620;
// 92630: using guessed type __int128 xmmword_92630;
// 92640: using guessed type __int128 xmmword_92640;

//----- (000000000003ADE0) ----------------------------------------------------
__int64 __fastcall sub_3ADE0(__int64 *a1, __int64 *a2, __int64 a3, __m128i a4, __m128i a5, __m128i a6, double a7, double a8)
{
  unsigned int v8; // ecx
  unsigned int v9; // eax
  __m128i v10; // xmm5
  __m128i v11; // xmm6
  __m128i v12; // xmm7
  __m128i v13; // xmm1
  __m128i v14; // xmm2
  __m128i v15; // xmm1
  unsigned __int64 v16; // rdx
  const __m128i *v17; // rsi
  const __m128i *v18; // rdi
  __int64 v19; // r8
  __int64 v20; // rcx
  __int64 v21; // rax
  unsigned int v22; // et0
  const __m128i *v23; // rt1
  __m128i v25; // xmm1
  __m128i v26; // xmm2
  __m128i v27; // xmm0
  __m128i v28; // xmm1
  __m128i v29; // xmm2
  __m128i v30; // xmm1
  __m128i v31; // xmm0
  __m128i v32; // xmm1
  __m128i v33; // xmm2
  __m128i v34; // xmm1

  if ( (*(_DWORD *)(*(_QWORD *)a3 + 632LL) & 1) != 0 )
  {
    if ( a1 != a2 )
      JUMPOUT(0x488D9LL);
    JUMPOUT(0x488F0LL);
  }
  v8 = (unsigned __int8)a2 & 0x3F;
  v9 = (unsigned __int8)a1 & 0x3F;
  v10 = _mm_load_si128((const __m128i *)&xmmword_92620);
  v11 = _mm_load_si128((const __m128i *)&xmmword_92630);
  v12 = _mm_load_si128((const __m128i *)&xmmword_92640);
  if ( v8 <= 0x30 && v9 <= 0x30 )
  {
    v13.m128i_i64[0] = *a1;
    v14.m128i_i64[0] = *a2;
    v13.m128i_i64[1] = a1[1];
    v14.m128i_i64[1] = a2[1];
    v15 = _mm_or_si128(v13, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v13, v10), _mm_cmpgt_epi8(v11, v13)), v12));
    a6 = _mm_or_si128(v14, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v14, v10), _mm_cmpgt_epi8(v11, v14)), v12));
    a4 = _mm_cmpeq_epi8((__m128i)0LL, v15);
    a5 = _mm_sub_epi8(_mm_cmpeq_epi8(v15, a6), a4);
    v16 = (unsigned int)(_mm_movemask_epi8(a5) - 0xFFFF);
    if ( (_DWORD)v16 )
    {
LABEL_17:
      _BitScanForward64(&v16, v16);
      return (unsigned int)(dword_962A0[*((unsigned __int8 *)a1 + v16)] - dword_962A0[*((unsigned __int8 *)a2 + v16)]);
    }
    a2 += 2;
    a1 += 2;
  }
  v17 = (const __m128i *)((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL);
  v18 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL);
  v19 = 0LL;
  v20 = v8 & 0xF;
  v21 = v9 & 0xF;
  if ( (_DWORD)v20 == (_DWORD)v21 )
  {
    v25 = _mm_load_si128(v17);
    v26 = _mm_load_si128(v18);
    v16 = (0xFFFFu >> v20)
        - ((unsigned int)_mm_movemask_epi8(
                           _mm_sub_epi8(
                             _mm_cmpeq_epi8(
                               _mm_or_si128(
                                 v25,
                                 _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v25, v10), _mm_cmpgt_epi8(v11, v25)), v12)),
                               _mm_or_si128(
                                 v26,
                                 _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v26, v10), _mm_cmpgt_epi8(v11, v26)), v12))),
                             _mm_cmpeq_epi8((__m128i)0LL, v25))) >> v20);
    if ( !(_DWORD)v16 )
    {
      v20 = 16LL;
      v27 = 0LL;
      while ( 1 )
      {
        v28 = _mm_load_si128((const __m128i *)((char *)v17 + v20));
        v29 = _mm_load_si128((const __m128i *)((char *)v18 + v20));
        v30 = _mm_or_si128(v28, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v28, v10), _mm_cmpgt_epi8(v11, v28)), v12));
        v31 = _mm_cmpeq_epi8(v27, v30);
        v16 = (unsigned int)(_mm_movemask_epi8(
                               _mm_sub_epi8(
                                 _mm_cmpeq_epi8(
                                   v30,
                                   _mm_or_si128(
                                     v29,
                                     _mm_and_si128(
                                       _mm_and_si128(_mm_cmpgt_epi8(v29, v10), _mm_cmpgt_epi8(v11, v29)),
                                       v12))),
                                 v31))
                           - 0xFFFF);
        if ( (_DWORD)v16 )
          break;
        v20 += 16LL;
        v32 = _mm_load_si128((const __m128i *)((char *)v17 + v20));
        v33 = _mm_load_si128((const __m128i *)((char *)v18 + v20));
        v34 = _mm_or_si128(v32, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v32, v10), _mm_cmpgt_epi8(v11, v32)), v12));
        v27 = _mm_cmpeq_epi8(v31, v34);
        v16 = (unsigned int)(_mm_movemask_epi8(
                               _mm_sub_epi8(
                                 _mm_cmpeq_epi8(
                                   v34,
                                   _mm_or_si128(
                                     v33,
                                     _mm_and_si128(
                                       _mm_and_si128(_mm_cmpgt_epi8(v33, v10), _mm_cmpgt_epi8(v11, v33)),
                                       v12))),
                                 v27))
                           - 0xFFFF);
        if ( (_DWORD)v16 )
          break;
        v20 += 16LL;
      }
      v21 = v20;
    }
    a1 = (__int64 *)((char *)v18->m128i_i64 + v21);
    a2 = (__int64 *)((char *)v17->m128i_i64 + v20);
    goto LABEL_17;
  }
  if ( (unsigned int)v20 <= (unsigned int)v21 )
  {
    v19 = 0xFFFFLL;
    v22 = v21;
    v21 = (unsigned int)v20;
    v20 = v22;
    v23 = v17;
    v17 = v18;
    v18 = v23;
  }
  return ((__int64 (__fastcall *)(const __m128i *, const __m128i *, __int64, __int64, __int64, double, double, double, double, double, double, double, double))((char *)dword_92690 + dword_92690[v21 + 15 - v20]))(
           v18,
           v17,
           0xFFFFLL,
           v20,
           v19,
           *(double *)a4.m128i_i64,
           *(double *)a5.m128i_i64,
           *(double *)a6.m128i_i64,
           a7,
           a8,
           *(double *)v10.m128i_i64,
           *(double *)v11.m128i_i64,
           *(double *)v12.m128i_i64);
}
// 488C5: control flows out of bounds to 488D9
// 488BD: control flows out of bounds to 488F0
// 92620: using guessed type __int128 xmmword_92620;
// 92630: using guessed type __int128 xmmword_92630;
// 92640: using guessed type __int128 xmmword_92640;

//----- (000000000003CF34) ----------------------------------------------------
__int64 __fastcall sub_3CF34(const __m128i *a1, const __m128i *a2, __int64 a3, double a4, double a5, double a6, double a7)
{
  unsigned int v7; // ecx
  unsigned int v8; // eax
  __m128i v9; // xmm4
  __m128i v10; // xmm5
  __m128i v11; // xmm6
  __m128i v12; // xmm1
  __m128i v13; // xmm2
  __m128i v14; // xmm1
  unsigned __int64 v15; // rdx
  const __m128i *v16; // rsi
  const __m128i *v17; // rdi
  __int64 v18; // r8
  __int64 v19; // rcx
  __int64 v20; // rax
  unsigned int v21; // et0
  const __m128i *v22; // rt1
  __m128i v23; // xmm1
  __int64 result; // rax
  __m128i v25; // xmm1
  __m128i v26; // xmm2
  __int64 v27; // rdx
  __m128i v28; // xmm0
  __m128i v29; // xmm1
  __m128i v30; // xmm0
  __m128i v31; // xmm1
  unsigned __int8 v32; // cf
  __int64 v33; // rcx
  __m128i v34; // xmm0
  __m128i v35; // xmm1
  __m128i v36; // xmm0
  __m128i v37; // xmm1

  if ( (*(_DWORD *)(*(_QWORD *)a3 + 632LL) & 1) != 0 )
  {
    if ( a1 != a2 )
      JUMPOUT(0x488D9LL);
    JUMPOUT(0x488F0LL);
  }
  v7 = (unsigned __int8)a2 & 0x3F;
  v8 = (unsigned __int8)a1 & 0x3F;
  v9 = _mm_load_si128((const __m128i *)&xmmword_92620);
  v10 = _mm_load_si128((const __m128i *)&xmmword_92630);
  v11 = _mm_load_si128((const __m128i *)&xmmword_92640);
  if ( v7 <= 0x30 && v8 <= 0x30 )
  {
    v12 = _mm_loadu_si128(a1);
    v13 = _mm_loadu_si128(a2);
    v14 = _mm_or_si128(v12, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v12, v9), _mm_cmpgt_epi8(v10, v12)), v11));
    v15 = (unsigned int)(_mm_movemask_epi8(
                           _mm_sub_epi8(
                             _mm_cmpeq_epi8(
                               v14,
                               _mm_or_si128(
                                 v13,
                                 _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v13, v9), _mm_cmpgt_epi8(v10, v13)), v11))),
                             _mm_cmpeq_epi8((__m128i)0LL, v14)))
                       - 0xFFFF);
    if ( (_DWORD)v15 )
    {
LABEL_18:
      _BitScanForward64(&v15, v15);
      return (unsigned int)(dword_962A0[a1->m128i_u8[v15]] - dword_962A0[a2->m128i_u8[v15]]);
    }
    ++a2;
    ++a1;
  }
  v16 = (const __m128i *)((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL);
  v17 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL);
  v18 = 0LL;
  v19 = v7 & 0xF;
  v20 = v8 & 0xF;
  if ( (_DWORD)v19 != (_DWORD)v20 )
  {
    if ( (unsigned int)v19 <= (unsigned int)v20 )
    {
      v18 = 0xFFFFLL;
      v21 = v20;
      v20 = (unsigned int)v19;
      v19 = v21;
      v22 = v16;
      v16 = v17;
      v17 = v22;
    }
    v23 = _mm_load_si128(v16);
    return ((__int64 (__fastcall *)(const __m128i *, const __m128i *, __int64, __int64, __int64, double, double, double, double, double, double, double))((char *)dword_926D0 + dword_926D0[v20 + 15 - v19]))(
             v17,
             v16,
             0xFFFFLL,
             v19,
             v18,
             *(double *)_mm_cmpeq_epi8((__m128i)0LL, v23).m128i_i64,
             *(double *)v23.m128i_i64,
             *(double *)_mm_load_si128(v17).m128i_i64,
             a7,
             *(double *)v9.m128i_i64,
             *(double *)v10.m128i_i64,
             *(double *)v11.m128i_i64);
  }
  v25 = _mm_load_si128(v16);
  v26 = _mm_load_si128(v17);
  v15 = (0xFFFFu >> v19)
      - ((unsigned int)_mm_movemask_epi8(
                         _mm_sub_epi8(
                           _mm_cmpeq_epi8(
                             _mm_or_si128(
                               v25,
                               _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v25, v9), _mm_cmpgt_epi8(v10, v25)), v11)),
                             _mm_or_si128(
                               v26,
                               _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v26, v9), _mm_cmpgt_epi8(v10, v26)), v11))),
                           _mm_cmpeq_epi8((__m128i)0LL, v25))) >> v19);
  if ( (_DWORD)v15 )
  {
    a1 = (const __m128i *)((char *)v17 + v20);
    a2 = (const __m128i *)((char *)v16 + v19);
    goto LABEL_18;
  }
  v27 = 1LL;
  do
  {
    v28 = _mm_load_si128(&v17[v27]);
    v29 = _mm_load_si128(&v16[v27]);
    v30 = _mm_or_si128(v28, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v28, v9), _mm_cmpgt_epi8(v10, v28)), v11));
    v31 = _mm_or_si128(v29, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v29, v9), _mm_cmpgt_epi8(v10, v29)), v11));
    v33 = (unsigned int)_mm_cmpistri(v30, v31, 26);
    v32 = _mm_cmpistrc(v30, v31, 26);
    ++v27;
    if ( v32 | _mm_cmpistrz(v30, v31, 26) )
      break;
    v34 = _mm_load_si128(&v17[v27]);
    v35 = _mm_load_si128(&v16[v27]);
    v36 = _mm_or_si128(v34, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v34, v9), _mm_cmpgt_epi8(v10, v34)), v11));
    v37 = _mm_or_si128(v35, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v35, v9), _mm_cmpgt_epi8(v10, v35)), v11));
    v33 = (unsigned int)_mm_cmpistri(v36, v37, 26);
    v32 = _mm_cmpistrc(v36, v37, 26);
    ++v27;
  }
  while ( !(v32 | _mm_cmpistrz(v36, v37, 26)) );
  if ( v32 )
    result = (unsigned int)(dword_962A0[v17[v27 - 1].m128i_u8[v33]] - dword_962A0[v16[v27 - 1].m128i_u8[v33]]);
  else
    result = 0LL;
  return result;
}
// 488C5: control flows out of bounds to 488D9
// 488BD: control flows out of bounds to 488F0
// 92620: using guessed type __int128 xmmword_92620;
// 92630: using guessed type __int128 xmmword_92630;
// 92640: using guessed type __int128 xmmword_92640;

//----- (000000000003EAE4) ----------------------------------------------------
__int64 __fastcall sub_3EAE4(__int64 _RDI, __int64 _RSI, __int64 a3, __m128 _XMM0, double a5, double a6, double a7)
{
  unsigned int v7; // ecx
  unsigned int v8; // eax
  unsigned __int64 v28; // rdx
  __int64 v31; // r8
  __int64 v32; // rcx
  __int64 v33; // rax
  unsigned int v35; // et0
  unsigned __int64 v36; // rt1
  __int64 result; // rax
  unsigned int v57; // er9

  if ( (*(_DWORD *)(*(_QWORD *)a3 + 632LL) & 1) != 0 )
  {
    if ( _RDI != _RSI )
      JUMPOUT(0x488D9LL);
    JUMPOUT(0x488F0LL);
  }
  v7 = _RSI & 0x3F;
  v8 = _RDI & 0x3F;
  __asm
  {
    vmovdqa xmm4, cs:xmmword_92620
    vmovdqa xmm5, cs:xmmword_92710
    vmovdqa xmm6, cs:xmmword_92640
  }
  if ( v7 <= 0x30 && v8 <= 0x30 )
  {
    __asm
    {
      vmovdqu xmm1, xmmword ptr [rdi]
      vmovdqu xmm2, xmmword ptr [rsi]
      vpcmpgtb xmm7, xmm1, xmm4
      vpcmpgtb xmm8, xmm1, xmm5
      vpcmpgtb xmm9, xmm2, xmm4
      vpcmpgtb xmm10, xmm2, xmm5
      vpandn  xmm8, xmm8, xmm7
      vpandn  xmm10, xmm10, xmm9
      vpand   xmm8, xmm8, xmm6
      vpand   xmm10, xmm10, xmm6
      vpor    xmm1, xmm8, xmm1
      vpor    xmm2, xmm10, xmm2
      vpxor   xmm0, xmm0, xmm0
      vpcmpeqb xmm0, xmm0, xmm1
      vpcmpeqb xmm1, xmm1, xmm2
      vpsubb  xmm1, xmm1, xmm0
      vpmovmskb edx, xmm1
    }
    v28 = (unsigned int)(_EDX - 0xFFFF);
    if ( (_DWORD)v28 )
    {
LABEL_17:
      _BitScanForward64(&v28, v28);
      return (unsigned int)(dword_962A0[*(unsigned __int8 *)(_RDI + v28)] - dword_962A0[*(unsigned __int8 *)(_RSI + v28)]);
    }
    _RSI += 16LL;
    _RDI += 16LL;
  }
  _RSI = _RSI & 0xFFFFFFFFFFFFFFF0LL;
  _RDI = _RDI & 0xFFFFFFFFFFFFFFF0LL;
  v31 = 0LL;
  v32 = v7 & 0xF;
  v33 = v8 & 0xF;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  if ( (_DWORD)v32 != (_DWORD)v33 )
  {
    if ( (unsigned int)v32 <= (unsigned int)v33 )
    {
      v31 = 0xFFFFLL;
      v35 = v33;
      v33 = (unsigned int)v32;
      v32 = v35;
      v36 = _RSI;
      _RSI = _RDI;
      _RDI = v36;
    }
    __asm
    {
      vmovdqa xmm2, xmmword ptr [rdi]
      vmovdqa xmm1, xmmword ptr [rsi]
      vpcmpeqb xmm0, xmm0, xmm1
    }
    return ((__int64 (__fastcall *)(unsigned __int64, unsigned __int64, __int64, __int64, __int64, double, double, double, double, double, double, double))((char *)dword_92720 + dword_92720[v33 + 15 - v32]))(
             _RDI,
             _RSI,
             0xFFFFLL,
             v32,
             v31,
             *(double *)&_XMM0,
             *(double *)&_XMM1,
             *(double *)&_XMM2,
             a7,
             *(double *)&_XMM4,
             *(double *)&_XMM5,
             *(double *)&_XMM6);
  }
  __asm
  {
    vmovdqa xmm1, xmmword ptr [rsi]
    vpcmpeqb xmm0, xmm0, xmm1
    vmovdqa xmm2, xmmword ptr [rdi]
    vpcmpgtb xmm7, xmm1, xmm4
    vpcmpgtb xmm8, xmm1, xmm5
    vpcmpgtb xmm9, xmm2, xmm4
    vpcmpgtb xmm10, xmm2, xmm5
    vpandn  xmm8, xmm8, xmm7
    vpandn  xmm10, xmm10, xmm9
    vpand   xmm8, xmm8, xmm6
    vpand   xmm10, xmm10, xmm6
    vpor    xmm1, xmm8, xmm1
    vpor    xmm2, xmm10, xmm2
    vpcmpeqb xmm1, xmm1, xmm2
    vpsubb  xmm1, xmm1, xmm0
    vpmovmskb r9d, xmm1
  }
  v57 = _ER9 >> v32;
  v28 = (0xFFFFu >> v32) - v57;
  if ( (_DWORD)v28 )
  {
    _RDI = _RDI + v33;
    _RSI = _RSI + v32;
    goto LABEL_17;
  }
  _RDX = 16LL;
  do
  {
    __asm
    {
      vmovdqa xmm0, xmmword ptr [rdi+rdx]
      vmovdqa xmm1, xmmword ptr [rsi+rdx]
      vpcmpgtb xmm7, xmm0, xmm4
      vpcmpgtb xmm8, xmm0, xmm5
      vpcmpgtb xmm9, xmm1, xmm4
      vpcmpgtb xmm10, xmm1, xmm5
      vpandn  xmm8, xmm8, xmm7
      vpandn  xmm10, xmm10, xmm9
      vpand   xmm8, xmm8, xmm6
      vpand   xmm10, xmm10, xmm6
      vpor    xmm0, xmm8, xmm0
      vpor    xmm1, xmm10, xmm1
      vpcmpistri xmm0, xmm1, 1Ah
    }
    _RDX += 16LL;
    if ( 0xFFFFu >> v32 <= v57 )
      break;
    __asm
    {
      vmovdqa xmm0, xmmword ptr [rdi+rdx]
      vmovdqa xmm1, xmmword ptr [rsi+rdx]
      vpcmpgtb xmm7, xmm0, xmm4
      vpcmpgtb xmm8, xmm0, xmm5
      vpcmpgtb xmm9, xmm1, xmm4
      vpcmpgtb xmm10, xmm1, xmm5
      vpandn  xmm8, xmm8, xmm7
      vpandn  xmm10, xmm10, xmm9
      vpand   xmm8, xmm8, xmm6
      vpand   xmm10, xmm10, xmm6
      vpor    xmm0, xmm8, xmm0
      vpor    xmm1, xmm10, xmm1
      vpcmpistri xmm0, xmm1, 1Ah
    }
    _RDX += 16LL;
  }
  while ( 0xFFFFu >> v32 > v57 );
  if ( 0xFFFFu >> v32 >= v57 )
    result = 0LL;
  else
    result = (unsigned int)(dword_962A0[*(unsigned __int8 *)(_RDI + _RDX)]
                          - dword_962A0[*(unsigned __int8 *)(_RSI + _RDX)]);
  return result;
}
// 488C5: control flows out of bounds to 488D9
// 488BD: control flows out of bounds to 488F0
// 92620: using guessed type __int128 xmmword_92620;
// 92640: using guessed type __int128 xmmword_92640;

//----- (0000000000040380) ----------------------------------------------------
char *__fastcall sub_40380(const __m128i *a1, unsigned int a2)
{
  __m128i v2; // xmm1
  __m128i v3; // xmm1
  __m128i v4; // xmm1
  __m128i v5; // xmm4
  __int64 v6; // rax
  __m128i v8; // xmm4
  unsigned int v9; // ecx
  __m128i v10; // xmm4
  __m128i v11; // xmm0
  unsigned __int64 v12; // rax
  __m128i v13; // xmm2
  __m128i v14; // xmm3
  __m128i v15; // xmm4
  __m128i v16; // xmm0
  __m128i v17; // xmm4
  unsigned int v18; // er8
  __m128i v19; // xmm4
  unsigned int v20; // eax
  __m128i v21; // xmm4
  __m128i v22; // xmm3

  v2 = _mm_cvtsi32_si128(a2);
  v3 = _mm_unpacklo_epi8(v2, v2);
  v4 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v3, v3), 0);
  if ( ((unsigned __int16)a1 & 0xFFFu) > 0xFC0 )
  {
    v17 = _mm_load_si128((const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL));
    v18 = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v17, v4), _mm_cmpeq_epi8(v17, (__m128i)0LL)));
    v19 = _mm_load_si128((const __m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 16));
    v20 = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v19, v4), _mm_cmpeq_epi8(v19, (__m128i)0LL)));
    v21 = _mm_load_si128((const __m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 32));
    v22 = _mm_load_si128((const __m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 48));
    v12 = (((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v4, v22), _mm_cmpeq_epi8((__m128i)0LL, v22))) << 48) | v18 | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v21, v4), _mm_cmpeq_epi8(v21, (__m128i)0LL))) << 32) | ((unsigned __int64)v20 << 16)) >> ((unsigned __int8)a1 - ((unsigned __int8)a1 & 0xC0u));
    if ( !v12 )
    {
LABEL_5:
      a1 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL);
      do
      {
        a1 += 4;
        v13 = _mm_min_epu8(_mm_xor_si128(_mm_load_si128(a1 + 1), v4), a1[1]);
        v14 = _mm_min_epu8(_mm_xor_si128(_mm_load_si128(a1 + 2), v4), a1[2]);
        v15 = _mm_min_epu8(_mm_xor_si128(_mm_load_si128(a1 + 3), v4), a1[3]);
      }
      while ( !_mm_movemask_epi8(
                 _mm_cmpeq_epi8(
                   _mm_min_epu8(
                     _mm_min_epu8(_mm_min_epu8(_mm_min_epu8(_mm_xor_si128(_mm_load_si128(a1), v4), *a1), v13), v14),
                     v15),
                   (__m128i)0LL)) );
      v16 = _mm_load_si128(a1);
      v12 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v15, (__m128i)0LL)) << 48) | (unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v16, v4), _mm_cmpeq_epi8(v16, (__m128i)0LL))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v14, (__m128i)0LL)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v13, (__m128i)0LL)) << 16);
      goto LABEL_8;
    }
  }
  else
  {
    v5 = _mm_loadu_si128(a1);
    LODWORD(v6) = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v5, v4), _mm_cmpeq_epi8(v5, (__m128i)0LL)));
    if ( (_DWORD)v6 )
    {
      _BitScanForward((unsigned int *)&v6, v6);
      return (char *)a1 + v6;
    }
    v8 = _mm_loadu_si128(a1 + 1);
    v9 = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v8, v4), _mm_cmpeq_epi8(v8, (__m128i)0LL)));
    v10 = _mm_loadu_si128(a1 + 2);
    v11 = _mm_loadu_si128(a1 + 3);
    v12 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v11, v4), _mm_cmpeq_epi8((__m128i)0LL, v11))) << 48) | ((unsigned __int64)v9 << 16) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v10, v4), _mm_cmpeq_epi8(v10, (__m128i)0LL))) << 32);
    if ( !v12 )
      goto LABEL_5;
  }
LABEL_8:
  _BitScanForward64(&v12, v12);
  return (char *)a1 + v12;
}
// 403CA: variable 'v6' is possibly undefined

//----- (0000000000040590) ----------------------------------------------------
__int64 __fastcall sub_40590(unsigned __int64 _RDI, int _ESI)
{
  unsigned __int64 v12; // rcx
  __int128 v19; // rax

  __asm
  {
    vmovd   xmm0, esi
    vpxor   xmm9, xmm9, xmm9
    vpbroadcastb ymm0, xmm0
  }
  if ( (_RDI & 0x3F) <= 0x20 )
  {
    __asm
    {
      vmovdqu ymm8, ymmword ptr [rdi]
      vpcmpeqb ymm1, ymm0, ymm8
      vpcmpeqb ymm2, ymm9, ymm8
      vpor    ymm1, ymm2, ymm1
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
    {
LABEL_16:
      __asm { tzcnt   eax, eax }
      v19 = _RDI + _RAX;
      if ( (_BYTE)_ESI != *(_BYTE *)v19 )
        *(_QWORD *)&v19 = *((_QWORD *)&v19 + 1);
      __asm { vzeroupper }
      return v19;
    }
    _RDI = (_RDI + 32) & 0xFFFFFFFFFFFFFFE0LL;
LABEL_9:
    __asm
    {
      vmovdqa ymm8, ymmword ptr [rdi]
      vpcmpeqb ymm1, ymm0, ymm8
      vpcmpeqb ymm2, ymm9, ymm8
      vpor    ymm1, ymm2, ymm1
      vpmovmskb eax, ymm1
    }
    if ( !(_DWORD)_RAX )
    {
      __asm
      {
        vmovdqa ymm8, ymmword ptr [rdi+20h]
        vpcmpeqb ymm1, ymm0, ymm8
        vpcmpeqb ymm2, ymm9, ymm8
        vpor    ymm1, ymm2, ymm1
        vpmovmskb eax, ymm1
      }
      if ( (_DWORD)_RAX )
      {
LABEL_19:
        __asm { tzcnt   eax, eax }
        v19 = _RDI + _RAX + 32;
        if ( (_BYTE)_ESI != *(_BYTE *)v19 )
          *(_QWORD *)&v19 = *((_QWORD *)&v19 + 1);
        __asm { vzeroupper }
        return v19;
      }
      __asm
      {
        vmovdqa ymm8, ymmword ptr [rdi+40h]
        vpcmpeqb ymm1, ymm0, ymm8
        vpcmpeqb ymm2, ymm9, ymm8
        vpor    ymm1, ymm2, ymm1
        vpmovmskb eax, ymm1
      }
      if ( (_DWORD)_RAX )
      {
LABEL_22:
        __asm { tzcnt   eax, eax }
        v19 = _RDI + _RAX + 64;
        if ( (_BYTE)_ESI != *(_BYTE *)v19 )
          *(_QWORD *)&v19 = *((_QWORD *)&v19 + 1);
        __asm { vzeroupper }
        return v19;
      }
      __asm
      {
        vmovdqa ymm8, ymmword ptr [rdi+60h]
        vpcmpeqb ymm1, ymm0, ymm8
        vpcmpeqb ymm2, ymm9, ymm8
        vpor    ymm1, ymm2, ymm1
        vpmovmskb eax, ymm1
      }
      if ( (_DWORD)_RAX )
      {
LABEL_29:
        __asm { tzcnt   eax, eax }
        v19 = _RDI + _RAX + 96;
        if ( (_BYTE)_ESI != *(_BYTE *)v19 )
          *(_QWORD *)&v19 = *((_QWORD *)&v19 + 1);
        __asm { vzeroupper }
        return v19;
      }
      for ( _RDI = (_RDI + 128) & 0xFFFFFFFFFFFFFF80LL; ; _RDI += 128LL )
      {
        __asm
        {
          vmovdqa ymm5, ymmword ptr [rdi]
          vmovdqa ymm6, ymmword ptr [rdi+20h]
          vmovdqa ymm7, ymmword ptr [rdi+40h]
          vmovdqa ymm8, ymmword ptr [rdi+60h]
          vpcmpeqb ymm1, ymm0, ymm5
          vpcmpeqb ymm2, ymm0, ymm6
          vpcmpeqb ymm3, ymm0, ymm7
          vpcmpeqb ymm4, ymm0, ymm8
          vpcmpeqb ymm5, ymm9, ymm5
          vpcmpeqb ymm6, ymm9, ymm6
          vpcmpeqb ymm7, ymm9, ymm7
          vpcmpeqb ymm8, ymm9, ymm8
          vpor    ymm1, ymm5, ymm1
          vpor    ymm2, ymm6, ymm2
          vpor    ymm3, ymm7, ymm3
          vpor    ymm4, ymm8, ymm4
          vpor    ymm5, ymm2, ymm1
          vpor    ymm6, ymm4, ymm3
          vpor    ymm5, ymm6, ymm5
          vpmovmskb eax, ymm5
        }
        if ( _EAX )
          break;
      }
      __asm { vpmovmskb eax, ymm1 }
      if ( !(_DWORD)_RAX )
      {
        __asm { vpmovmskb eax, ymm2 }
        if ( !(_DWORD)_RAX )
        {
          __asm { vpmovmskb eax, ymm3 }
          if ( !(_DWORD)_RAX )
          {
            __asm { vpmovmskb eax, ymm4 }
            goto LABEL_29;
          }
          goto LABEL_22;
        }
        goto LABEL_19;
      }
    }
    goto LABEL_16;
  }
  v12 = _RDI & 0x1F;
  _RDI = _RDI & 0xFFFFFFFFFFFFFFE0LL;
  __asm
  {
    vmovdqu ymm8, ymmword ptr [rdi]
    vpcmpeqb ymm1, ymm0, ymm8
    vpcmpeqb ymm2, ymm9, ymm8
    vpor    ymm1, ymm2, ymm1
    vpmovmskb eax, ymm1
  }
  _RAX = (unsigned int)(_EAX >> v12);
  if ( !(_DWORD)_RAX )
  {
    _RDI = _RDI + 32;
    goto LABEL_9;
  }
  __asm { tzcnt   eax, eax }
  v19 = _RDI + v12 + _RAX;
  if ( (_BYTE)_ESI != *(_BYTE *)v19 )
    *(_QWORD *)&v19 = *((_QWORD *)&v19 + 1);
  __asm { vzeroupper }
  return v19;
}
// 40724: variable '_RAX' is possibly undefined

//----- (00000000000407C0) ----------------------------------------------------
unsigned __int64 __fastcall sub_407C0(unsigned __int64 _RDI, int _ESI)
{
  unsigned __int64 v12; // rcx
  unsigned __int64 result; // rax

  __asm
  {
    vmovd   xmm0, esi
    vpxor   xmm9, xmm9, xmm9
    vpbroadcastb ymm0, xmm0
  }
  if ( (_RDI & 0x3F) > 0x20 )
  {
    v12 = _RDI & 0x1F;
    _RDI = _RDI & 0xFFFFFFFFFFFFFFE0LL;
    __asm
    {
      vmovdqu ymm8, ymmword ptr [rdi]
      vpcmpeqb ymm1, ymm0, ymm8
      vpcmpeqb ymm2, ymm9, ymm8
      vpor    ymm1, ymm2, ymm1
      vpmovmskb eax, ymm1
    }
    _RAX = (unsigned int)(_EAX >> v12);
    if ( (_DWORD)_RAX )
    {
      __asm { tzcnt   eax, eax }
      result = _RDI + v12 + _RAX;
      __asm { vzeroupper }
      return result;
    }
    _RDI = _RDI + 32;
  }
  else
  {
    __asm
    {
      vmovdqu ymm8, ymmword ptr [rdi]
      vpcmpeqb ymm1, ymm0, ymm8
      vpcmpeqb ymm2, ymm9, ymm8
      vpor    ymm1, ymm2, ymm1
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
      goto LABEL_14;
    _RDI = (_RDI + 32) & 0xFFFFFFFFFFFFFFE0LL;
  }
  __asm
  {
    vmovdqa ymm8, ymmword ptr [rdi]
    vpcmpeqb ymm1, ymm0, ymm8
    vpcmpeqb ymm2, ymm9, ymm8
    vpor    ymm1, ymm2, ymm1
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_14;
  __asm
  {
    vmovdqa ymm8, ymmword ptr [rdi+20h]
    vpcmpeqb ymm1, ymm0, ymm8
    vpcmpeqb ymm2, ymm9, ymm8
    vpor    ymm1, ymm2, ymm1
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_15;
  __asm
  {
    vmovdqa ymm8, ymmword ptr [rdi+40h]
    vpcmpeqb ymm1, ymm0, ymm8
    vpcmpeqb ymm2, ymm9, ymm8
    vpor    ymm1, ymm2, ymm1
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_16;
  __asm
  {
    vmovdqa ymm8, ymmword ptr [rdi+60h]
    vpcmpeqb ymm1, ymm0, ymm8
    vpcmpeqb ymm2, ymm9, ymm8
    vpor    ymm1, ymm2, ymm1
    vpmovmskb eax, ymm1
  }
  if ( !(_DWORD)_RAX )
  {
    for ( _RDI = (_RDI + 128) & 0xFFFFFFFFFFFFFF80LL; ; _RDI += 128LL )
    {
      __asm
      {
        vmovdqa ymm5, ymmword ptr [rdi]
        vmovdqa ymm6, ymmword ptr [rdi+20h]
        vmovdqa ymm7, ymmword ptr [rdi+40h]
        vmovdqa ymm8, ymmword ptr [rdi+60h]
        vpcmpeqb ymm1, ymm0, ymm5
        vpcmpeqb ymm2, ymm0, ymm6
        vpcmpeqb ymm3, ymm0, ymm7
        vpcmpeqb ymm4, ymm0, ymm8
        vpcmpeqb ymm5, ymm9, ymm5
        vpcmpeqb ymm6, ymm9, ymm6
        vpcmpeqb ymm7, ymm9, ymm7
        vpcmpeqb ymm8, ymm9, ymm8
        vpor    ymm1, ymm5, ymm1
        vpor    ymm2, ymm6, ymm2
        vpor    ymm3, ymm7, ymm3
        vpor    ymm4, ymm8, ymm4
        vpor    ymm5, ymm2, ymm1
        vpor    ymm6, ymm4, ymm3
        vpor    ymm5, ymm6, ymm5
        vpmovmskb eax, ymm5
      }
      if ( _EAX )
        break;
    }
    __asm { vpmovmskb eax, ymm1 }
    if ( !(_DWORD)_RAX )
    {
      __asm { vpmovmskb eax, ymm2 }
      if ( !(_DWORD)_RAX )
      {
        __asm { vpmovmskb eax, ymm3 }
        if ( !(_DWORD)_RAX )
        {
          __asm { vpmovmskb eax, ymm4 }
          goto LABEL_21;
        }
LABEL_16:
        __asm { tzcnt   eax, eax }
        result = _RDI + _RAX + 64;
        __asm { vzeroupper }
        return result;
      }
LABEL_15:
      __asm { tzcnt   eax, eax }
      result = _RDI + _RAX + 32;
      __asm { vzeroupper }
      return result;
    }
LABEL_14:
    __asm { tzcnt   eax, eax }
    result = _RDI + _RAX;
    __asm { vzeroupper }
    return result;
  }
LABEL_21:
  __asm { tzcnt   eax, eax }
  result = _RDI + _RAX + 96;
  __asm { vzeroupper }
  return result;
}
// 40954: variable '_RAX' is possibly undefined

//----- (00000000000409B0) ----------------------------------------------------
int __fastcall sub_409B0(const __m128i *a1)
{
  unsigned int v1; // edx
  __m128i *v2; // rax
  __m128i v3; // xmm1
  __m128i v4; // xmm2
  __m128i v5; // xmm3
  __int64 v6; // rdx
  unsigned __int64 v7; // rdx

  if ( ((unsigned __int16)a1 & 0xFFFu) <= 0xFCFuLL )
  {
    v1 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), (__m128i)0LL));
    if ( v1 )
    {
      _BitScanForward((unsigned int *)&v2, v1);
      return (int)v2;
    }
    v3 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((char *)&word_10 + ((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL)));
    v4 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((char *)qword_20 + ((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL)));
    v5 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((char *)&dword_30 + ((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL)));
    v2 = (__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL);
    v6 = (__int64)((((unsigned int)_mm_movemask_epi8(v4) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v5) << 16)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v3) << 16)) >> ((unsigned __int8)a1 & 0xF0u ^ (unsigned __int8)a1);
    if ( !v6 )
      goto LABEL_8;
LABEL_5:
    _BitScanForward64((unsigned __int64 *)&v2, v6);
    return (int)v2;
  }
  v2 = (__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL);
  v6 = (__int64)((((unsigned int)_mm_movemask_epi8(
                                   _mm_cmpeq_epi8(
                                     (__m128i)0LL,
                                     *(__m128i *)((char *)qword_20 + ((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL)))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((char *)&dword_30 + ((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL)))) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((char *)&word_10 + ((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL)))) << 16)) >> ((unsigned __int8)a1 & 0xC0u ^ (unsigned __int8)a1);
  if ( v6 )
    goto LABEL_5;
  v3 = 0LL;
  v4 = 0LL;
  v5 = 0LL;
LABEL_8:
  while ( !_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(_mm_min_epu8(_mm_load_si128(v2 + 4), v2[5]), v2[6]), v2[7]), v5)) )
  {
    v2 += 8;
    if ( _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(_mm_min_epu8(_mm_load_si128(v2), v2[1]), v2[2]), v2[3]), v5)) )
      goto LABEL_12;
  }
  v2 += 4;
LABEL_12:
  _BitScanForward64(
    &v7,
    (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v4, v2[2])) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v5, v2[3])) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *v2)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v3, v2[1])) << 16));
  LODWORD(v2) = v7 + (_DWORD)v2 - (_DWORD)a1;
  return (int)v2;
}
// 10: using guessed type __int16 word_10;
// 20: using guessed type __int64 qword_20[];
// 30: using guessed type int dword_30;

//----- (0000000000040B50) ----------------------------------------------------
unsigned __int64 __fastcall sub_40B50(unsigned __int64 _RDI, __m128 _XMM0)
{
  unsigned __int64 v4; // rdx
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rdi
  unsigned __int64 result; // rax

  v4 = _RDI;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  if ( (_RDI & 0x3F) > 0x20 )
  {
    v7 = _RDI & 0x1F;
    v8 = _RDI & 0xFFFFFFFFFFFFFFE0LL;
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    _RAX = (unsigned int)(_EAX >> v7);
    if ( (_DWORD)_RAX )
    {
      __asm { tzcnt   eax, eax }
      result = v7 + v8 + _RAX - v4;
      __asm { vzeroupper }
      return result;
    }
    _RDI = v8 + 32;
  }
  else
  {
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
      goto LABEL_14;
    _RDI = (_RDI + 32) & 0xFFFFFFFFFFFFFFE0LL;
  }
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_14;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_15;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+40h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_16;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+60h]
    vpmovmskb eax, ymm1
  }
  if ( !(_DWORD)_RAX )
  {
    for ( _RDI = (_RDI + 128) & 0xFFFFFFFFFFFFFF80LL; ; _RDI += 128LL )
    {
      __asm
      {
        vmovdqa ymm1, ymmword ptr [rdi]
        vmovdqa ymm2, ymmword ptr [rdi+20h]
        vmovdqa ymm3, ymmword ptr [rdi+40h]
        vmovdqa ymm4, ymmword ptr [rdi+60h]
        vpminub ymm5, ymm2, ymm1
        vpminub ymm6, ymm4, ymm3
        vpminub ymm5, ymm6, ymm5
        vpcmpeqb ymm5, ymm0, ymm5
        vpmovmskb eax, ymm5
      }
      if ( _EAX )
        break;
    }
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymm1
      vpmovmskb eax, ymm1
    }
    if ( !(_DWORD)_RAX )
    {
      __asm
      {
        vpcmpeqb ymm2, ymm0, ymm2
        vpmovmskb eax, ymm2
      }
      if ( !(_DWORD)_RAX )
      {
        __asm
        {
          vpcmpeqb ymm3, ymm0, ymm3
          vpmovmskb eax, ymm3
        }
        if ( !(_DWORD)_RAX )
        {
          __asm
          {
            vpcmpeqb ymm4, ymm0, ymm4
            vpmovmskb eax, ymm4
          }
          goto LABEL_21;
        }
LABEL_16:
        __asm { tzcnt   eax, eax }
        result = _RDI + _RAX + 64 - v4;
        __asm { vzeroupper }
        return result;
      }
LABEL_15:
      __asm { tzcnt   eax, eax }
      result = _RDI + _RAX + 32 - v4;
      __asm { vzeroupper }
      return result;
    }
LABEL_14:
    __asm { tzcnt   eax, eax }
    result = _RDI + _RAX - v4;
    __asm { vzeroupper }
    return result;
  }
LABEL_21:
  __asm { tzcnt   eax, eax }
  result = _RDI + _RAX + 96 - v4;
  __asm { vzeroupper }
  return result;
}
// 40C64: variable '_RAX' is possibly undefined

//----- (0000000000040CF0) ----------------------------------------------------
__int64 __fastcall sub_40CF0(__int64 _RDI, unsigned __int64 _RSI, unsigned __int64 _RDX, __m128 _XMM0)
{
  __int64 result; // rax
  unsigned int v7; // ecx
  __int64 v54; // r9

  result = _RDI;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v7 = _RSI & 0x7F;
  if ( v7 <= 0x40 )
  {
    __asm
    {
      vmovdqu ymm3, ymmword ptr [rsi]
      vmovdqu ymm2, ymmword ptr [rsi+20h]
      vpcmpeqb ymm1, ymm0, ymm3
      vpmovmskb edx, ymm1
    }
    if ( (_DWORD)_RDX )
    {
LABEL_22:
      _BitScanForward((unsigned int *)&_RDX, _RDX);
      goto LABEL_23;
    }
    __asm
    {
      vmovdqu ymmword ptr [rdi], ymm3
      vpcmpeqb ymm1, ymm0, ymm2
      vpmovmskb edx, ymm1
    }
    if ( (_DWORD)_RDX )
    {
      _RSI += 32LL;
      _RDI += 32LL;
      goto LABEL_22;
    }
    _RSI = _RSI & 0xFFFFFFFFFFFFFFE0LL;
    _RCX = v7 & 0x1F;
    goto LABEL_5;
  }
  _RSI = _RSI & 0xFFFFFFFFFFFFFFE0LL;
  _RCX = v7 & 0x1F;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rsi]
    vpmovmskb edx, ymm1
  }
  _RDX = _RDX >> _RCX;
  if ( (_DWORD)_RDX )
  {
LABEL_21:
    _RSI = _RCX + _RSI;
    goto LABEL_22;
  }
  __asm
  {
    vpcmpeqb ymm2, ymm0, ymmword ptr [rsi+20h]
    vpmovmskb edx, ymm2
  }
  if ( !_EDX )
  {
    __asm
    {
      vmovdqu ymm2, ymmword ptr [rsi+rcx]
      vmovdqu ymmword ptr [rdi], ymm2
    }
LABEL_5:
    _RDI = _RDI - _RCX;
    _RCX = 32LL;
    __asm
    {
      vmovdqa ymm2, ymmword ptr [rsi+rcx]
      vmovdqu ymmword ptr [rdi+rcx], ymm2
      vmovdqa ymm2, ymmword ptr [rsi+rcx+20h]
      vpcmpeqb ymm1, ymm0, ymm2
      vpmovmskb edx, ymm1
    }
    _RCX = 64LL;
    if ( !(_DWORD)_RDX )
    {
      __asm
      {
        vmovdqu ymmword ptr [rdi+rcx], ymm2
        vmovdqa ymm3, ymmword ptr [rsi+rcx+20h]
        vpcmpeqb ymm1, ymm0, ymm3
        vpmovmskb edx, ymm1
      }
      _RCX = 96LL;
      if ( !(_DWORD)_RDX )
      {
        __asm
        {
          vmovdqu ymmword ptr [rdi+rcx], ymm3
          vmovdqa ymm4, ymmword ptr [rsi+rcx+20h]
          vpcmpeqb ymm1, ymm0, ymm4
          vpmovmskb edx, ymm1
        }
        _RCX = 128LL;
        if ( !(_DWORD)_RDX )
        {
          __asm
          {
            vmovdqu ymmword ptr [rdi+rcx], ymm4
            vmovdqa ymm2, ymmword ptr [rsi+rcx+20h]
            vpcmpeqb ymm1, ymm0, ymm2
            vpmovmskb edx, ymm1
          }
          _RCX = 160LL;
          if ( !(_DWORD)_RDX )
          {
            __asm
            {
              vmovdqu ymmword ptr [rdi+rcx], ymm2
              vmovdqa ymm2, ymmword ptr [rsi+rcx+20h]
              vpcmpeqb ymm1, ymm0, ymm2
              vpmovmskb edx, ymm1
            }
            _RCX = 192LL;
            if ( !(_DWORD)_RDX )
            {
              __asm
              {
                vmovdqa ymm3, ymmword ptr [rsi+rcx+20h]
                vmovdqu ymmword ptr [rdi+rcx], ymm2
                vpcmpeqb ymm1, ymm0, ymm3
                vpmovmskb edx, ymm1
              }
              _RCX = 224LL;
              if ( !(_DWORD)_RDX )
              {
                __asm { vmovdqu ymmword ptr [rdi+rcx], ymm3 }
                _RDX = _RSI;
                _RSI = (_RSI + 256) & 0xFFFFFFFFFFFFFF80LL;
                _RDI = _RDI - (_RDX - _RSI);
                __asm
                {
                  vmovdqa ymm4, ymmword ptr [rsi]
                  vmovdqa ymm5, ymmword ptr [rsi+20h]
                  vmovdqa ymm6, ymmword ptr [rsi+40h]
                  vmovdqa ymm7, ymmword ptr [rsi+60h]
                  vpminub ymm2, ymm4, ymm5
                  vpminub ymm3, ymm6, ymm7
                  vpminub ymm3, ymm3, ymm2
                  vpcmpeqb ymm3, ymm3, ymm1
                  vpmovmskb edx, ymm3
                }
                if ( !(_DWORD)_RDX )
                {
                  do
                  {
                    _RDI += 128LL;
                    _RSI += 128LL;
                    __asm
                    {
                      vmovdqu ymmword ptr [rdi-80h], ymm4
                      vmovdqa ymm4, ymmword ptr [rsi]
                      vmovdqu ymmword ptr [rdi-60h], ymm5
                      vmovdqa ymm5, ymmword ptr [rsi+20h]
                      vpminub ymm2, ymm4, ymm5
                      vmovdqu ymmword ptr [rdi-40h], ymm6
                      vmovdqa ymm6, ymmword ptr [rsi+40h]
                      vmovdqu ymmword ptr [rdi-20h], ymm7
                      vmovdqa ymm7, ymmword ptr [rsi+60h]
                      vpminub ymm3, ymm6, ymm7
                      vpminub ymm3, ymm3, ymm2
                      vpcmpeqb ymm3, ymm3, ymm1
                      vpmovmskb edx, ymm3
                    }
                  }
                  while ( !_EDX );
                }
                __asm
                {
                  vpcmpeqb ymm1, ymm0, ymm4
                  vpmovmskb edx, ymm1
                }
                if ( !(_DWORD)_RDX )
                {
                  __asm
                  {
                    vpcmpeqb ymm1, ymm0, ymm5
                    vpmovmskb ecx, ymm1
                  }
                  if ( _ECX )
                  {
                    _BitScanForward((unsigned int *)&_RDX, _ECX);
                    __asm { vmovdqu ymmword ptr [rdi], ymm4 }
                    _RSI += 32LL;
                    _RDI += 32LL;
                  }
                  else
                  {
                    __asm
                    {
                      vpcmpeqb ymm1, ymm0, ymm6
                      vpmovmskb edx, ymm1
                    }
                    if ( (_DWORD)_RDX )
                    {
                      _BitScanForward((unsigned int *)&_RDX, _RDX);
                      __asm
                      {
                        vmovdqu ymmword ptr [rdi], ymm4
                        vmovdqu ymmword ptr [rdi+20h], ymm5
                      }
                      _RSI += 64LL;
                      _RDI += 64LL;
                    }
                    else
                    {
                      __asm
                      {
                        vpcmpeqb ymm1, ymm0, ymm7
                        vpmovmskb ecx, ymm1
                      }
                      _BitScanForward((unsigned int *)&_RDX, _ECX);
                      __asm
                      {
                        vmovdqu ymmword ptr [rdi], ymm4
                        vmovdqu ymmword ptr [rdi+20h], ymm5
                        vmovdqu ymmword ptr [rdi+40h], ymm6
                      }
                      _RSI += 96LL;
                      _RDI += 96LL;
                    }
                  }
                  goto LABEL_23;
                }
                goto LABEL_22;
              }
            }
          }
        }
      }
    }
    _RDI = _RCX + _RDI;
    goto LABEL_21;
  }
  _BitScanForward(&_EDX, _EDX);
  _RSI = _RCX + _RSI;
  _RDX = _EDX + 32 - (unsigned int)_RCX;
LABEL_23:
  if ( (unsigned int)_RDX >= 0x20 )
  {
    __asm
    {
      vmovdqu ymm2, ymmword ptr [rsi]
      vmovdqu ymm3, ymmword ptr [rsi+rdx-1Fh]
      vmovdqu ymmword ptr [rdi], ymm2
      vmovdqu ymmword ptr [rdi+rdx-1Fh], ymm3
      vzeroupper
    }
  }
  else if ( (unsigned int)_RDX >= 0x10 )
  {
    __asm
    {
      vmovdqu xmm2, xmmword ptr [rsi]
      vmovdqu xmm3, xmmword ptr [rsi+rdx-0Fh]
      vmovdqu xmmword ptr [rdi], xmm2
      vmovdqu xmmword ptr [rdi+rdx-0Fh], xmm3
      vzeroupper
    }
  }
  else if ( (unsigned int)_RDX >= 8 )
  {
    v54 = *(_QWORD *)(_RSI + _RDX - 7);
    *(_QWORD *)_RDI = *(_QWORD *)_RSI;
    *(_QWORD *)(_RDI + _RDX - 7) = v54;
    __asm { vzeroupper }
  }
  else if ( (unsigned int)_RDX >= 4 )
  {
    *(_DWORD *)_RDI = *(_DWORD *)_RSI;
    *(_DWORD *)(_RDI + _RDX - 3) = *(_DWORD *)(_RSI + _RDX - 3);
    __asm { vzeroupper }
  }
  else if ( (_DWORD)_RDX == 3 )
  {
    *(_DWORD *)_RDI = *(_DWORD *)_RSI;
    __asm { vzeroupper }
  }
  else if ( (unsigned int)_RDX > 1 )
  {
    *(_WORD *)_RDI = *(_WORD *)_RSI;
    *(_BYTE *)(_RDI + 2) = 0;
    __asm { vzeroupper }
  }
  else if ( (_DWORD)_RDX == 1 )
  {
    *(_WORD *)_RDI = *(_WORD *)_RSI;
    __asm { vzeroupper }
  }
  else
  {
    *(_BYTE *)_RDI = 0;
    __asm { vzeroupper }
  }
  return result;
}
// 41014: variable '_RDX' is possibly undefined

//----- (0000000000041080) ----------------------------------------------------
_BYTE *__fastcall sub_41080(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2; // rdx
  int v3; // ecx
  bool v4; // zf
  unsigned __int64 v5; // rax
  unsigned __int64 *v6; // rsi
  unsigned __int64 *v7; // rsi
  _QWORD *v8; // rsi
  _BYTE *v9; // rdx

  v2 = a1;
  if ( ((unsigned __int8)a2 & 7) != 0 )
  {
    v3 = 8 - ((unsigned __int8)a2 & 7);
    while ( 1 )
    {
      v4 = *a2 == 0;
      *v2 = *a2;
      if ( v4 )
        break;
      ++a2;
      ++v2;
      if ( !--v3 )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    while ( 1 )
    {
      v5 = *(_QWORD *)a2;
      v6 = (unsigned __int64 *)(a2 + 8);
      if ( v5 < 0x101010101010101LL )
        break;
      if ( (v5 ^ (v5 - 0x101010101010101LL) | 0xFEFEFEFEFEFEFEFFLL) != -1LL )
        break;
      *(_QWORD *)v2 = v5;
      v2 += 8;
      v5 = *v6;
      v7 = v6 + 1;
      if ( v5 < 0x101010101010101LL )
        break;
      if ( (v5 ^ (v5 - 0x101010101010101LL) | 0xFEFEFEFEFEFEFEFFLL) != -1LL )
        break;
      *(_QWORD *)v2 = v5;
      v2 += 8;
      v5 = *v7;
      v8 = v7 + 1;
      if ( v5 < 0x101010101010101LL )
        break;
      if ( (v5 ^ (v5 - 0x101010101010101LL) | 0xFEFEFEFEFEFEFEFFLL) != -1LL )
        break;
      *(_QWORD *)v2 = v5;
      v2 += 8;
      v5 = *v8;
      a2 = v8 + 1;
      if ( v5 < 0x101010101010101LL || (v5 ^ (v5 - 0x101010101010101LL) | 0xFEFEFEFEFEFEFEFFLL) != -1LL )
        break;
      *(_QWORD *)v2 = v5;
      v2 += 8;
    }
    while ( 1 )
    {
      *v2 = v5;
      if ( !(_BYTE)v5 )
        break;
      v9 = v2 + 1;
      *v9 = BYTE1(v5);
      if ( !BYTE1(v5) )
        break;
      v2 = v9 + 1;
      v5 >>= 16;
    }
  }
  return a1;
}

//----- (0000000000041170) ----------------------------------------------------
_BYTE *__fastcall sub_41170(_BYTE *a1, _BYTE *a2)
{
  int v3; // ecx
  bool v4; // zf
  unsigned __int64 v5; // rax
  unsigned __int64 *v6; // rsi
  unsigned __int64 *v7; // rsi
  _QWORD *v8; // rsi

  if ( ((unsigned __int8)a2 & 7) != 0 )
  {
    v3 = 8 - ((unsigned __int8)a2 & 7);
    while ( 1 )
    {
      v4 = *a2 == 0;
      *a1 = *a2;
      if ( v4 )
        break;
      ++a2;
      ++a1;
      if ( !--v3 )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    while ( 1 )
    {
      v5 = *(_QWORD *)a2;
      v6 = (unsigned __int64 *)(a2 + 8);
      if ( v5 < 0x101010101010101LL )
        break;
      if ( (v5 ^ (v5 - 0x101010101010101LL) | 0xFEFEFEFEFEFEFEFFLL) != -1LL )
        break;
      *(_QWORD *)a1 = v5;
      a1 += 8;
      v5 = *v6;
      v7 = v6 + 1;
      if ( v5 < 0x101010101010101LL )
        break;
      if ( (v5 ^ (v5 - 0x101010101010101LL) | 0xFEFEFEFEFEFEFEFFLL) != -1LL )
        break;
      *(_QWORD *)a1 = v5;
      a1 += 8;
      v5 = *v7;
      v8 = v7 + 1;
      if ( v5 < 0x101010101010101LL )
        break;
      if ( (v5 ^ (v5 - 0x101010101010101LL) | 0xFEFEFEFEFEFEFEFFLL) != -1LL )
        break;
      *(_QWORD *)a1 = v5;
      a1 += 8;
      v5 = *v8;
      a2 = v8 + 1;
      if ( v5 < 0x101010101010101LL || (v5 ^ (v5 - 0x101010101010101LL) | 0xFEFEFEFEFEFEFEFFLL) != -1LL )
        break;
      *(_QWORD *)a1 = v5;
      a1 += 8;
    }
    while ( 1 )
    {
      *a1 = v5;
      if ( !(_BYTE)v5 )
        break;
      *++a1 = BYTE1(v5);
      if ( !BYTE1(v5) )
        break;
      ++a1;
      v5 >>= 16;
    }
  }
  return a1;
}

//----- (0000000000041260) ----------------------------------------------------
_QWORD *__fastcall sub_41260(_QWORD *a1, _BYTE *a2)
{
  unsigned __int64 v2; // rcx
  unsigned __int64 v3; // rdx
  __m128i *v4; // rsi
  __m128i v5; // xmm0
  int v6; // eax
  __int64 v7; // rsi
  unsigned __int64 v8; // rax
  __m128i v9; // xmm2
  __m128i v10; // xmm0
  __m128i v11; // xmm3
  __m128i v12; // xmm0
  __m128i v13; // xmm4
  __m128i v14; // xmm0
  __m128i v15; // xmm1
  __m128i v16; // xmm0
  __m128i v17; // xmm2
  __m128i v18; // xmm0
  __m128i v19; // xmm3
  __m128i v20; // xmm0
  unsigned __int64 v21; // rax
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  __m128i v24; // xmm6
  __m128i v25; // xmm7
  int v26; // eax
  __m128i v27; // xmm0
  __m128i v28; // xmm0
  __m128i v29; // xmm0
  __m128i v30; // xmm1
  __m128i v31; // xmm2
  __m128i v32; // xmm0
  __m128i v33; // xmm3
  __m128i v34; // xmm2
  __m128i v35; // xmm0
  __m128i v36; // xmm1
  __m128i v37; // xmm2
  __m128i v38; // xmm0
  __m128i v39; // xmm3
  __m128i v40; // xmm2
  unsigned __int64 v41; // rax
  unsigned __int64 v42; // rcx
  unsigned __int64 v43; // rax
  __m128i v44; // xmm3
  __m128i v45; // xmm4
  __m128i v46; // xmm5
  int v47; // eax
  __m128i v48; // xmm7
  __m128i v49; // xmm5
  __m128i v50; // xmm4
  __m128i v51; // xmm3
  __m128i v52; // xmm2
  __m128i v53; // xmm1
  __m128i v54; // xmm2
  __m128i v55; // xmm0
  __m128i v56; // xmm3
  __m128i v57; // xmm2
  __m128i v58; // xmm0
  __m128i v59; // xmm1
  __m128i v60; // xmm2
  __m128i v61; // xmm0
  __m128i v62; // xmm3
  __m128i v63; // xmm2
  unsigned __int64 v64; // rax
  unsigned __int64 v65; // rcx
  unsigned __int64 v66; // rax
  __m128i v67; // xmm3
  __m128i v68; // xmm4
  __m128i v69; // xmm5
  int v70; // eax
  __m128i v71; // xmm7
  __m128i v72; // xmm5
  __m128i v73; // xmm4
  __m128i v74; // xmm3
  __m128i v75; // xmm2
  __m128i v76; // xmm1
  __m128i v77; // xmm2
  __m128i v78; // xmm0
  __m128i v79; // xmm3
  __m128i v80; // xmm2
  __m128i v81; // xmm0
  __m128i v82; // xmm1
  __m128i v83; // xmm2
  __m128i v84; // xmm0
  __m128i v85; // xmm3
  __m128i v86; // xmm2
  unsigned __int64 v87; // rax
  unsigned __int64 v88; // rcx
  unsigned __int64 v89; // rax
  __m128i v90; // xmm3
  __m128i v91; // xmm4
  __m128i v92; // xmm5
  int v93; // eax
  __m128i v94; // xmm7
  __m128i v95; // xmm5
  __m128i v96; // xmm4
  __m128i v97; // xmm3
  __m128i v98; // xmm2
  __m128i v99; // xmm1
  __m128i v100; // xmm2
  __m128i v101; // xmm0
  __m128i v102; // xmm3
  __m128i v103; // xmm2
  __m128i v104; // xmm0
  __m128i v105; // xmm1
  __m128i v106; // xmm2
  __m128i v107; // xmm0
  __m128i v108; // xmm3
  __m128i v109; // xmm2
  unsigned __int64 v110; // rax
  unsigned __int64 v111; // rcx
  unsigned __int64 v112; // rax
  __m128i v113; // xmm3
  __m128i v114; // xmm4
  __m128i v115; // xmm5
  int v116; // eax
  __m128i v117; // xmm7
  __m128i v118; // xmm5
  __m128i v119; // xmm4
  __m128i v120; // xmm3
  __m128i v121; // xmm2
  __m128i v122; // xmm1
  __m128i v123; // xmm2
  __m128i v124; // xmm0
  __m128i v125; // xmm3
  __m128i v126; // xmm2
  __m128i v127; // xmm0
  __m128i v128; // xmm1
  __m128i v129; // xmm2
  __m128i v130; // xmm0
  __m128i v131; // xmm3
  __m128i v132; // xmm2
  unsigned __int64 v133; // rax
  unsigned __int64 v134; // rcx
  unsigned __int64 v135; // rax
  __m128i v136; // xmm3
  __m128i v137; // xmm4
  __m128i v138; // xmm5
  int v139; // eax
  __m128i v140; // xmm7
  __m128i v141; // xmm5
  __m128i v142; // xmm4
  __m128i v143; // xmm3
  __m128i v144; // xmm2
  __m128i v145; // xmm1
  __m128i v146; // xmm2
  __m128i v147; // xmm0
  __m128i v148; // xmm3
  __m128i v149; // xmm2
  __m128i v150; // xmm0
  __m128i v151; // xmm1
  __m128i v152; // xmm2
  __m128i v153; // xmm0
  __m128i v154; // xmm3
  __m128i v155; // xmm2
  unsigned __int64 v156; // rax
  unsigned __int64 v157; // rcx
  unsigned __int64 v158; // rax
  __m128i v159; // xmm3
  __m128i v160; // xmm4
  __m128i v161; // xmm5
  int v162; // eax
  __m128i v163; // xmm7
  __m128i v164; // xmm5
  __m128i v165; // xmm4
  __m128i v166; // xmm3
  __m128i v167; // xmm2
  int v168; // esi
  __m128i v169; // xmm1
  __m128i v170; // xmm2
  __m128i v171; // xmm0
  __m128i v172; // xmm3
  __m128i v173; // xmm2
  __m128i v174; // xmm0
  __m128i v175; // xmm1
  __m128i v176; // xmm2
  __m128i v177; // xmm0
  __m128i v178; // xmm3
  __m128i v179; // xmm2
  unsigned __int64 v180; // rax
  unsigned __int64 v181; // rcx
  unsigned __int64 v182; // rax
  __m128i v183; // xmm3
  __m128i v184; // xmm4
  __m128i v185; // xmm5
  int v186; // eax
  __m128i v187; // xmm7
  __m128i v188; // xmm5
  __m128i v189; // xmm4
  __m128i v190; // xmm3
  __m128i v191; // xmm2
  int v192; // esi
  __m128i v193; // xmm1
  __m128i v194; // xmm2
  __m128i v195; // xmm0
  __m128i v196; // xmm3
  __m128i v197; // xmm2
  __m128i v198; // xmm0
  __m128i v199; // xmm1
  __m128i v200; // xmm2
  __m128i v201; // xmm0
  __m128i v202; // xmm3
  __m128i v203; // xmm2
  unsigned __int64 v204; // rax
  unsigned __int64 v205; // rcx
  unsigned __int64 v206; // rax
  __m128i v207; // xmm3
  __m128i v208; // xmm4
  __m128i v209; // xmm5
  int v210; // eax
  __m128i v211; // xmm7
  __m128i v212; // xmm5
  __m128i v213; // xmm4
  __m128i v214; // xmm3
  __m128i v215; // xmm2
  __m128i v216; // xmm1
  __m128i v217; // xmm2
  __m128i v218; // xmm0
  __m128i v219; // xmm3
  __m128i v220; // xmm2
  __m128i v221; // xmm0
  __m128i v222; // xmm1
  __m128i v223; // xmm2
  __m128i v224; // xmm0
  __m128i v225; // xmm3
  __m128i v226; // xmm2
  unsigned __int64 v227; // rax
  unsigned __int64 v228; // rcx
  unsigned __int64 v229; // rax
  __m128i v230; // xmm3
  __m128i v231; // xmm4
  __m128i v232; // xmm5
  int v233; // eax
  __m128i v234; // xmm7
  __m128i v235; // xmm5
  __m128i v236; // xmm4
  __m128i v237; // xmm3
  __m128i v238; // xmm2
  __m128i v239; // xmm1
  __m128i v240; // xmm2
  __m128i v241; // xmm0
  __m128i v242; // xmm3
  __m128i v243; // xmm2
  __m128i v244; // xmm0
  __m128i v245; // xmm1
  __m128i v246; // xmm2
  __m128i v247; // xmm0
  __m128i v248; // xmm3
  __m128i v249; // xmm2
  unsigned __int64 v250; // rax
  unsigned __int64 v251; // rcx
  unsigned __int64 v252; // rax
  __m128i v253; // xmm3
  __m128i v254; // xmm4
  __m128i v255; // xmm5
  int v256; // eax
  __m128i v257; // xmm7
  __m128i v258; // xmm5
  __m128i v259; // xmm4
  __m128i v260; // xmm3
  __m128i v261; // xmm2
  __m128i v262; // xmm1
  __m128i v263; // xmm2
  __m128i v264; // xmm0
  __m128i v265; // xmm3
  __m128i v266; // xmm2
  __m128i v267; // xmm0
  __m128i v268; // xmm1
  __m128i v269; // xmm2
  __m128i v270; // xmm0
  __m128i v271; // xmm3
  __m128i v272; // xmm2
  unsigned __int64 v273; // rax
  unsigned __int64 v274; // rcx
  unsigned __int64 v275; // rax
  __m128i v276; // xmm3
  __m128i v277; // xmm4
  __m128i v278; // xmm5
  int v279; // eax
  __m128i v280; // xmm7
  __m128i v281; // xmm5
  __m128i v282; // xmm4
  __m128i v283; // xmm3
  __m128i v284; // xmm2
  __m128i v285; // xmm1
  __m128i v286; // xmm2
  __m128i v287; // xmm0
  __m128i v288; // xmm3
  __m128i v289; // xmm2
  __m128i v290; // xmm0
  __m128i v291; // xmm1
  __m128i v292; // xmm2
  __m128i v293; // xmm0
  __m128i v294; // xmm3
  __m128i v295; // xmm2
  unsigned __int64 v296; // rax
  unsigned __int64 v297; // rcx
  unsigned __int64 v298; // rax
  __m128i v299; // xmm3
  __m128i v300; // xmm4
  __m128i v301; // xmm5
  int v302; // eax
  __m128i v303; // xmm7
  __m128i v304; // xmm5
  __m128i v305; // xmm4
  __m128i v306; // xmm3
  __m128i v307; // xmm2
  __m128i v308; // xmm1
  __m128i v309; // xmm2
  __m128i v310; // xmm0
  __m128i v311; // xmm3
  __m128i v312; // xmm2
  __m128i v313; // xmm0
  __m128i v314; // xmm1
  __m128i v315; // xmm2
  __m128i v316; // xmm0
  __m128i v317; // xmm3
  __m128i v318; // xmm2
  unsigned __int64 v319; // rax
  unsigned __int64 v320; // rcx
  unsigned __int64 v321; // rax
  __m128i v322; // xmm3
  __m128i v323; // xmm4
  __m128i v324; // xmm5
  int v325; // eax
  __m128i v326; // xmm7
  __m128i v327; // xmm5
  __m128i v328; // xmm4
  __m128i v329; // xmm3
  __m128i v330; // xmm2
  __m128i v331; // xmm1
  __m128i v332; // xmm2
  __m128i v333; // xmm0
  __m128i v334; // xmm3
  __m128i v335; // xmm2
  __m128i v336; // xmm0
  __m128i v337; // xmm1
  __m128i v338; // xmm2
  __m128i v339; // xmm0
  __m128i v340; // xmm3
  __m128i v341; // xmm2
  unsigned __int64 v342; // rax
  unsigned __int64 v343; // rcx
  unsigned __int64 v344; // rax
  __m128i v345; // xmm3
  __m128i v346; // xmm4
  __m128i v347; // xmm5
  int v348; // eax
  __m128i v349; // xmm7
  __m128i v350; // xmm5
  __m128i v351; // xmm4
  __m128i v352; // xmm3
  __m128i v353; // xmm2
  __m128i v354; // xmm1
  __m128i v355; // xmm2
  __m128i v356; // xmm0
  __m128i v357; // xmm3
  __m128i v358; // xmm2
  __m128i v359; // xmm0
  __m128i v360; // xmm1
  __m128i v361; // xmm2
  __m128i v362; // xmm0
  __m128i v363; // xmm3
  __m128i v364; // xmm2
  unsigned __int64 v365; // rax
  unsigned __int64 v366; // rcx
  unsigned __int64 v367; // rax
  __m128i v368; // xmm3
  __m128i v369; // xmm4
  __m128i v370; // xmm5
  int v371; // eax
  __m128i v372; // xmm7
  __m128i v373; // xmm5
  __m128i v374; // xmm4
  __m128i v375; // xmm3
  __m128i v376; // xmm2

  v2 = (unsigned __int64)a2;
  v3 = (unsigned __int64)a1;
  if ( !*a2 )
    goto LABEL_198;
  if ( !a2[1] )
    goto LABEL_199;
  if ( !a2[2] )
    goto LABEL_200;
  if ( !a2[3] )
    goto LABEL_201;
  if ( !a2[4] )
    goto LABEL_202;
  if ( !a2[5] )
    goto LABEL_203;
  if ( !a2[6] )
  {
LABEL_204:
    *(_DWORD *)v3 = *(_DWORD *)v2;
    *(_DWORD *)(v3 + 3) = *(_DWORD *)(v2 + 3);
    return a1;
  }
  if ( !a2[7] )
  {
LABEL_189:
    *(_QWORD *)v3 = *(_QWORD *)v2;
    return a1;
  }
  if ( !a2[8] )
    goto LABEL_205;
  if ( !a2[9] )
    goto LABEL_206;
  if ( !a2[10] )
    goto LABEL_207;
  if ( !a2[11] )
    goto LABEL_208;
  if ( !a2[12] )
    goto LABEL_209;
  if ( !a2[13] )
    goto LABEL_210;
  if ( a2[14] )
  {
    if ( !a2[15] )
    {
LABEL_197:
      *(_QWORD *)v3 = *(_QWORD *)v2;
      *(_QWORD *)(v3 + 8) = *(_QWORD *)(v2 + 8);
      return a1;
    }
    v4 = (__m128i *)((unsigned __int64)(a2 + 16) & 0xFFFFFFFFFFFFFFF0LL);
    *a1 = *(_QWORD *)v2;
    v5 = _mm_cmpeq_epi8((__m128i)0LL, *v4);
    a1[1] = *(_QWORD *)(v2 + 8);
    v6 = _mm_movemask_epi8(v5);
    v7 = (__int64)v4->m128i_i64 - v2;
    if ( !v6 )
    {
      v3 = (unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL;
      v2 -= (unsigned __int64)a1 - v3;
      v8 = v2 & 0xF;
      if ( (v2 & 0xF) != 0 )
      {
        if ( v8 >= 8 )
        {
          switch ( v8 )
          {
            case 8uLL:
              v193 = *(__m128i *)(v2 - 8);
              v194 = *(__m128i *)(v2 + 8);
              while ( 1 )
              {
                v195 = _mm_cmpeq_epi8(v5, v194);
                v6 = _mm_movemask_epi8(v195);
                v196 = v194;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v194, v193, 8);
                v197 = *(__m128i *)(v2 + 24);
                v198 = _mm_cmpeq_epi8(v195, v197);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v198);
                v2 += 16LL;
                v199 = v197;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v197, v196, 8);
                v200 = *(__m128i *)(v2 + 24);
                v201 = _mm_cmpeq_epi8(v198, v200);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v201);
                v2 += 16LL;
                v202 = v200;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v200, v199, 8);
                v203 = *(__m128i *)(v2 + 24);
                v5 = _mm_cmpeq_epi8(v201, v203);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v203, v202, 8);
                v204 = v2 + 24;
                v205 = (v2 + 24) & 0xFFFFFFFFFFFFFFC0LL;
                v206 = v204 - v205;
                v2 = v205 - 8;
                v3 = v3 + 16 - v206;
                v193 = *(__m128i *)(v2 - 8);
                while ( 1 )
                {
                  v194 = *(__m128i *)(v2 + 8);
                  v207 = *(__m128i *)(v2 + 24);
                  v208 = *(__m128i *)(v2 + 40);
                  v209 = *(__m128i *)(v2 + 56);
                  v210 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v208, v209), _mm_min_epu8(v207, v194)), v5));
                  v211 = v209;
                  v212 = _mm_alignr_epi8(v209, v208, 8);
                  v213 = _mm_alignr_epi8(v208, v207, 8);
                  if ( v210 )
                    break;
                  v214 = _mm_alignr_epi8(v207, v194, 8);
                  v2 += 64LL;
                  v215 = _mm_alignr_epi8(v194, v193, 8);
                  v193 = v211;
                  *(__m128i *)(v3 + 48) = v212;
                  *(__m128i *)(v3 + 32) = v213;
                  *(__m128i *)(v3 + 16) = v214;
                  *(__m128i *)v3 = v215;
                  v3 += 64LL;
                }
              }
              v7 = 8LL;
              *(_QWORD *)v3 = *(_QWORD *)v2;
              break;
            case 9uLL:
              v216 = *(__m128i *)(v2 - 9);
              v217 = *(__m128i *)(v2 + 7);
              while ( 1 )
              {
                v218 = _mm_cmpeq_epi8(v5, v217);
                v6 = _mm_movemask_epi8(v218);
                v219 = v217;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v217, v216, 9);
                v220 = *(__m128i *)(v2 + 23);
                v221 = _mm_cmpeq_epi8(v218, v220);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v221);
                v2 += 16LL;
                v222 = v220;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v220, v219, 9);
                v223 = *(__m128i *)(v2 + 23);
                v224 = _mm_cmpeq_epi8(v221, v223);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v224);
                v2 += 16LL;
                v225 = v223;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v223, v222, 9);
                v226 = *(__m128i *)(v2 + 23);
                v5 = _mm_cmpeq_epi8(v224, v226);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v226, v225, 9);
                v227 = v2 + 23;
                v228 = (v2 + 23) & 0xFFFFFFFFFFFFFFC0LL;
                v229 = v227 - v228;
                v2 = v228 - 7;
                v3 = v3 + 16 - v229;
                v216 = *(__m128i *)(v2 - 9);
                while ( 1 )
                {
                  v217 = *(__m128i *)(v2 + 7);
                  v230 = *(__m128i *)(v2 + 23);
                  v231 = *(__m128i *)(v2 + 39);
                  v232 = *(__m128i *)(v2 + 55);
                  v233 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v231, v232), _mm_min_epu8(v230, v217)), v5));
                  v234 = v232;
                  v235 = _mm_alignr_epi8(v232, v231, 9);
                  v236 = _mm_alignr_epi8(v231, v230, 9);
                  if ( v233 )
                    break;
                  v237 = _mm_alignr_epi8(v230, v217, 9);
                  v2 += 64LL;
                  v238 = _mm_alignr_epi8(v217, v216, 9);
                  v216 = v234;
                  *(__m128i *)(v3 + 48) = v235;
                  *(__m128i *)(v3 + 32) = v236;
                  *(__m128i *)(v3 + 16) = v237;
                  *(__m128i *)v3 = v238;
                  v3 += 64LL;
                }
              }
              v7 = 7LL;
              *(_QWORD *)(v3 - 1) = *(_QWORD *)(v2 - 1);
              break;
            case 0xAuLL:
              v239 = *(__m128i *)(v2 - 10);
              v240 = *(__m128i *)(v2 + 6);
              while ( 1 )
              {
                v241 = _mm_cmpeq_epi8(v5, v240);
                v6 = _mm_movemask_epi8(v241);
                v242 = v240;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v240, v239, 10);
                v243 = *(__m128i *)(v2 + 22);
                v244 = _mm_cmpeq_epi8(v241, v243);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v244);
                v2 += 16LL;
                v245 = v243;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v243, v242, 10);
                v246 = *(__m128i *)(v2 + 22);
                v247 = _mm_cmpeq_epi8(v244, v246);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v247);
                v2 += 16LL;
                v248 = v246;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v246, v245, 10);
                v249 = *(__m128i *)(v2 + 22);
                v5 = _mm_cmpeq_epi8(v247, v249);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v249, v248, 10);
                v250 = v2 + 22;
                v251 = (v2 + 22) & 0xFFFFFFFFFFFFFFC0LL;
                v252 = v250 - v251;
                v2 = v251 - 6;
                v3 = v3 + 16 - v252;
                v239 = *(__m128i *)(v2 - 10);
                while ( 1 )
                {
                  v240 = *(__m128i *)(v2 + 6);
                  v253 = *(__m128i *)(v2 + 22);
                  v254 = *(__m128i *)(v2 + 38);
                  v255 = *(__m128i *)(v2 + 54);
                  v256 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v254, v255), _mm_min_epu8(v253, v240)), v5));
                  v257 = v255;
                  v258 = _mm_alignr_epi8(v255, v254, 10);
                  v259 = _mm_alignr_epi8(v254, v253, 10);
                  if ( v256 )
                    break;
                  v260 = _mm_alignr_epi8(v253, v240, 10);
                  v2 += 64LL;
                  v261 = _mm_alignr_epi8(v240, v239, 10);
                  v239 = v257;
                  *(__m128i *)(v3 + 48) = v258;
                  *(__m128i *)(v3 + 32) = v259;
                  *(__m128i *)(v3 + 16) = v260;
                  *(__m128i *)v3 = v261;
                  v3 += 64LL;
                }
              }
              v7 = 6LL;
              *(_QWORD *)(v3 - 2) = *(_QWORD *)(v2 - 2);
              break;
            case 0xBuLL:
              v262 = *(__m128i *)(v2 - 11);
              v263 = *(__m128i *)(v2 + 5);
              while ( 1 )
              {
                v264 = _mm_cmpeq_epi8(v5, v263);
                v6 = _mm_movemask_epi8(v264);
                v265 = v263;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v263, v262, 11);
                v266 = *(__m128i *)(v2 + 21);
                v267 = _mm_cmpeq_epi8(v264, v266);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v267);
                v2 += 16LL;
                v268 = v266;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v266, v265, 11);
                v269 = *(__m128i *)(v2 + 21);
                v270 = _mm_cmpeq_epi8(v267, v269);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v270);
                v2 += 16LL;
                v271 = v269;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v269, v268, 11);
                v272 = *(__m128i *)(v2 + 21);
                v5 = _mm_cmpeq_epi8(v270, v272);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v272, v271, 11);
                v273 = v2 + 21;
                v274 = (v2 + 21) & 0xFFFFFFFFFFFFFFC0LL;
                v275 = v273 - v274;
                v2 = v274 - 5;
                v3 = v3 + 16 - v275;
                v262 = *(__m128i *)(v2 - 11);
                while ( 1 )
                {
                  v263 = *(__m128i *)(v2 + 5);
                  v276 = *(__m128i *)(v2 + 21);
                  v277 = *(__m128i *)(v2 + 37);
                  v278 = *(__m128i *)(v2 + 53);
                  v279 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v277, v278), _mm_min_epu8(v276, v263)), v5));
                  v280 = v278;
                  v281 = _mm_alignr_epi8(v278, v277, 11);
                  v282 = _mm_alignr_epi8(v277, v276, 11);
                  if ( v279 )
                    break;
                  v283 = _mm_alignr_epi8(v276, v263, 11);
                  v2 += 64LL;
                  v284 = _mm_alignr_epi8(v263, v262, 11);
                  v262 = v280;
                  *(__m128i *)(v3 + 48) = v281;
                  *(__m128i *)(v3 + 32) = v282;
                  *(__m128i *)(v3 + 16) = v283;
                  *(__m128i *)v3 = v284;
                  v3 += 64LL;
                }
              }
              v7 = 5LL;
              *(_QWORD *)(v3 - 3) = *(_QWORD *)(v2 - 3);
              break;
            case 0xCuLL:
              v285 = *(__m128i *)(v2 - 12);
              v286 = *(__m128i *)(v2 + 4);
              while ( 1 )
              {
                v287 = _mm_cmpeq_epi8(v5, v286);
                v6 = _mm_movemask_epi8(v287);
                v288 = v286;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v286, v285, 12);
                v289 = *(__m128i *)(v2 + 20);
                v290 = _mm_cmpeq_epi8(v287, v289);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v290);
                v2 += 16LL;
                v291 = v289;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v289, v288, 12);
                v292 = *(__m128i *)(v2 + 20);
                v293 = _mm_cmpeq_epi8(v290, v292);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v293);
                v2 += 16LL;
                v294 = v292;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v292, v291, 12);
                v295 = *(__m128i *)(v2 + 20);
                v5 = _mm_cmpeq_epi8(v293, v295);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v295, v294, 12);
                v296 = v2 + 20;
                v297 = (v2 + 20) & 0xFFFFFFFFFFFFFFC0LL;
                v298 = v296 - v297;
                v2 = v297 - 4;
                v3 = v3 + 16 - v298;
                v285 = *(__m128i *)(v2 - 12);
                while ( 1 )
                {
                  v286 = *(__m128i *)(v2 + 4);
                  v299 = *(__m128i *)(v2 + 20);
                  v300 = *(__m128i *)(v2 + 36);
                  v301 = *(__m128i *)(v2 + 52);
                  v302 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v300, v301), _mm_min_epu8(v299, v286)), v5));
                  v303 = v301;
                  v304 = _mm_alignr_epi8(v301, v300, 12);
                  v305 = _mm_alignr_epi8(v300, v299, 12);
                  if ( v302 )
                    break;
                  v306 = _mm_alignr_epi8(v299, v286, 12);
                  v2 += 64LL;
                  v307 = _mm_alignr_epi8(v286, v285, 12);
                  v285 = v303;
                  *(__m128i *)(v3 + 48) = v304;
                  *(__m128i *)(v3 + 32) = v305;
                  *(__m128i *)(v3 + 16) = v306;
                  *(__m128i *)v3 = v307;
                  v3 += 64LL;
                }
              }
              v7 = 4LL;
              *(_DWORD *)v3 = *(_DWORD *)v2;
              break;
            case 0xDuLL:
              v308 = *(__m128i *)(v2 - 13);
              v309 = *(__m128i *)(v2 + 3);
              while ( 1 )
              {
                v310 = _mm_cmpeq_epi8(v5, v309);
                v6 = _mm_movemask_epi8(v310);
                v311 = v309;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v309, v308, 13);
                v312 = *(__m128i *)(v2 + 19);
                v313 = _mm_cmpeq_epi8(v310, v312);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v313);
                v2 += 16LL;
                v314 = v312;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v312, v311, 13);
                v315 = *(__m128i *)(v2 + 19);
                v316 = _mm_cmpeq_epi8(v313, v315);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v316);
                v2 += 16LL;
                v317 = v315;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v315, v314, 13);
                v318 = *(__m128i *)(v2 + 19);
                v5 = _mm_cmpeq_epi8(v316, v318);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v318, v317, 13);
                v319 = v2 + 19;
                v320 = (v2 + 19) & 0xFFFFFFFFFFFFFFC0LL;
                v321 = v319 - v320;
                v2 = v320 - 3;
                v3 = v3 + 16 - v321;
                v308 = *(__m128i *)(v2 - 13);
                while ( 1 )
                {
                  v309 = *(__m128i *)(v2 + 3);
                  v322 = *(__m128i *)(v2 + 19);
                  v323 = *(__m128i *)(v2 + 35);
                  v324 = *(__m128i *)(v2 + 51);
                  v325 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v323, v324), _mm_min_epu8(v322, v309)), v5));
                  v326 = v324;
                  v327 = _mm_alignr_epi8(v324, v323, 13);
                  v328 = _mm_alignr_epi8(v323, v322, 13);
                  if ( v325 )
                    break;
                  v329 = _mm_alignr_epi8(v322, v309, 13);
                  v2 += 64LL;
                  v330 = _mm_alignr_epi8(v309, v308, 13);
                  v308 = v326;
                  *(__m128i *)(v3 + 48) = v327;
                  *(__m128i *)(v3 + 32) = v328;
                  *(__m128i *)(v3 + 16) = v329;
                  *(__m128i *)v3 = v330;
                  v3 += 64LL;
                }
              }
              v7 = 3LL;
              *(_DWORD *)(v3 - 1) = *(_DWORD *)(v2 - 1);
              break;
            case 0xEuLL:
              v331 = *(__m128i *)(v2 - 14);
              v332 = *(__m128i *)(v2 + 2);
              while ( 1 )
              {
                v333 = _mm_cmpeq_epi8(v5, v332);
                v6 = _mm_movemask_epi8(v333);
                v334 = v332;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v332, v331, 14);
                v335 = *(__m128i *)(v2 + 18);
                v336 = _mm_cmpeq_epi8(v333, v335);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v336);
                v2 += 16LL;
                v337 = v335;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v335, v334, 14);
                v338 = *(__m128i *)(v2 + 18);
                v339 = _mm_cmpeq_epi8(v336, v338);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v339);
                v2 += 16LL;
                v340 = v338;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v338, v337, 14);
                v341 = *(__m128i *)(v2 + 18);
                v5 = _mm_cmpeq_epi8(v339, v341);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v341, v340, 14);
                v342 = v2 + 18;
                v343 = (v2 + 18) & 0xFFFFFFFFFFFFFFC0LL;
                v344 = v342 - v343;
                v2 = v343 - 2;
                v3 = v3 + 16 - v344;
                v331 = *(__m128i *)(v2 - 14);
                while ( 1 )
                {
                  v332 = *(__m128i *)(v2 + 2);
                  v345 = *(__m128i *)(v2 + 18);
                  v346 = *(__m128i *)(v2 + 34);
                  v347 = *(__m128i *)(v2 + 50);
                  v348 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v346, v347), _mm_min_epu8(v345, v332)), v5));
                  v349 = v347;
                  v350 = _mm_alignr_epi8(v347, v346, 14);
                  v351 = _mm_alignr_epi8(v346, v345, 14);
                  if ( v348 )
                    break;
                  v352 = _mm_alignr_epi8(v345, v332, 14);
                  v2 += 64LL;
                  v353 = _mm_alignr_epi8(v332, v331, 14);
                  v331 = v349;
                  *(__m128i *)(v3 + 48) = v350;
                  *(__m128i *)(v3 + 32) = v351;
                  *(__m128i *)(v3 + 16) = v352;
                  *(__m128i *)v3 = v353;
                  v3 += 64LL;
                }
              }
              v7 = 2LL;
              *(_DWORD *)(v3 - 2) = *(_DWORD *)(v2 - 2);
              break;
            default:
              v354 = *(__m128i *)(v2 - 15);
              v355 = *(__m128i *)(v2 + 1);
              while ( 1 )
              {
                v356 = _mm_cmpeq_epi8(v5, v355);
                v6 = _mm_movemask_epi8(v356);
                v357 = v355;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v355, v354, 15);
                v358 = *(__m128i *)(v2 + 17);
                v359 = _mm_cmpeq_epi8(v356, v358);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v359);
                v2 += 16LL;
                v360 = v358;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v358, v357, 15);
                v361 = *(__m128i *)(v2 + 17);
                v362 = _mm_cmpeq_epi8(v359, v361);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v362);
                v2 += 16LL;
                v363 = v361;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v361, v360, 15);
                v364 = *(__m128i *)(v2 + 17);
                v5 = _mm_cmpeq_epi8(v362, v364);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v364, v363, 15);
                v365 = v2 + 17;
                v366 = (v2 + 17) & 0xFFFFFFFFFFFFFFC0LL;
                v367 = v365 - v366;
                v2 = v366 - 1;
                v3 = v3 + 16 - v367;
                v354 = *(__m128i *)(v2 - 15);
                while ( 1 )
                {
                  v355 = *(__m128i *)(v2 + 1);
                  v368 = *(__m128i *)(v2 + 17);
                  v369 = *(__m128i *)(v2 + 33);
                  v370 = *(__m128i *)(v2 + 49);
                  v371 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v369, v370), _mm_min_epu8(v368, v355)), v5));
                  v372 = v370;
                  v373 = _mm_alignr_epi8(v370, v369, 15);
                  v374 = _mm_alignr_epi8(v369, v368, 15);
                  if ( v371 )
                    break;
                  v375 = _mm_alignr_epi8(v368, v355, 15);
                  v2 += 64LL;
                  v376 = _mm_alignr_epi8(v355, v354, 15);
                  v354 = v372;
                  *(__m128i *)(v3 + 48) = v373;
                  *(__m128i *)(v3 + 32) = v374;
                  *(__m128i *)(v3 + 16) = v375;
                  *(__m128i *)v3 = v376;
                  v3 += 64LL;
                }
              }
              v7 = 1LL;
              *(_DWORD *)(v3 - 3) = *(_DWORD *)(v2 - 3);
              break;
          }
        }
        else
        {
          switch ( v8 )
          {
            case 1uLL:
              v30 = *(__m128i *)(v2 - 1);
              v31 = *(__m128i *)(v2 + 15);
              while ( 1 )
              {
                v32 = _mm_cmpeq_epi8(v5, v31);
                v6 = _mm_movemask_epi8(v32);
                v33 = v31;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v31, v30, 1);
                v34 = *(__m128i *)(v2 + 31);
                v35 = _mm_cmpeq_epi8(v32, v34);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v35);
                v2 += 16LL;
                v36 = v34;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v34, v33, 1);
                v37 = *(__m128i *)(v2 + 31);
                v38 = _mm_cmpeq_epi8(v35, v37);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v38);
                v2 += 16LL;
                v39 = v37;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v37, v36, 1);
                v40 = *(__m128i *)(v2 + 31);
                v5 = _mm_cmpeq_epi8(v38, v40);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v40, v39, 1);
                v41 = v2 + 31;
                v42 = (v2 + 31) & 0xFFFFFFFFFFFFFFC0LL;
                v43 = v41 - v42;
                v2 = v42 - 15;
                v3 = v3 + 16 - v43;
                v30 = *(__m128i *)(v2 - 1);
                while ( 1 )
                {
                  v31 = *(__m128i *)(v2 + 15);
                  v44 = *(__m128i *)(v2 + 31);
                  v45 = *(__m128i *)(v2 + 47);
                  v46 = *(__m128i *)(v2 + 63);
                  v47 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v45, v46), _mm_min_epu8(v44, v31)), v5));
                  v48 = v46;
                  v49 = _mm_alignr_epi8(v46, v45, 1);
                  v50 = _mm_alignr_epi8(v45, v44, 1);
                  if ( v47 )
                    break;
                  v51 = _mm_alignr_epi8(v44, v31, 1);
                  v2 += 64LL;
                  v52 = _mm_alignr_epi8(v31, v30, 1);
                  v30 = v48;
                  *(__m128i *)(v3 + 48) = v49;
                  *(__m128i *)(v3 + 32) = v50;
                  *(__m128i *)(v3 + 16) = v51;
                  *(__m128i *)v3 = v52;
                  v3 += 64LL;
                }
              }
              v7 = 15LL;
              *(__m128i *)(v3 - 1) = _mm_loadu_si128((const __m128i *)(v2 - 1));
              break;
            case 2uLL:
              v53 = *(__m128i *)(v2 - 2);
              v54 = *(__m128i *)(v2 + 14);
              while ( 1 )
              {
                v55 = _mm_cmpeq_epi8(v5, v54);
                v6 = _mm_movemask_epi8(v55);
                v56 = v54;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v54, v53, 2);
                v57 = *(__m128i *)(v2 + 30);
                v58 = _mm_cmpeq_epi8(v55, v57);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v58);
                v2 += 16LL;
                v59 = v57;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v57, v56, 2);
                v60 = *(__m128i *)(v2 + 30);
                v61 = _mm_cmpeq_epi8(v58, v60);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v61);
                v2 += 16LL;
                v62 = v60;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v60, v59, 2);
                v63 = *(__m128i *)(v2 + 30);
                v5 = _mm_cmpeq_epi8(v61, v63);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v63, v62, 2);
                v64 = v2 + 30;
                v65 = (v2 + 30) & 0xFFFFFFFFFFFFFFC0LL;
                v66 = v64 - v65;
                v2 = v65 - 14;
                v3 = v3 + 16 - v66;
                v53 = *(__m128i *)(v2 - 2);
                while ( 1 )
                {
                  v54 = *(__m128i *)(v2 + 14);
                  v67 = *(__m128i *)(v2 + 30);
                  v68 = *(__m128i *)(v2 + 46);
                  v69 = *(__m128i *)(v2 + 62);
                  v70 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v68, v69), _mm_min_epu8(v67, v54)), v5));
                  v71 = v69;
                  v72 = _mm_alignr_epi8(v69, v68, 2);
                  v73 = _mm_alignr_epi8(v68, v67, 2);
                  if ( v70 )
                    break;
                  v74 = _mm_alignr_epi8(v67, v54, 2);
                  v2 += 64LL;
                  v75 = _mm_alignr_epi8(v54, v53, 2);
                  v53 = v71;
                  *(__m128i *)(v3 + 48) = v72;
                  *(__m128i *)(v3 + 32) = v73;
                  *(__m128i *)(v3 + 16) = v74;
                  *(__m128i *)v3 = v75;
                  v3 += 64LL;
                }
              }
              v7 = 14LL;
              *(__m128i *)(v3 - 2) = _mm_loadu_si128((const __m128i *)(v2 - 2));
              break;
            case 3uLL:
              v76 = *(__m128i *)(v2 - 3);
              v77 = *(__m128i *)(v2 + 13);
              while ( 1 )
              {
                v78 = _mm_cmpeq_epi8(v5, v77);
                v6 = _mm_movemask_epi8(v78);
                v79 = v77;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v77, v76, 3);
                v80 = *(__m128i *)(v2 + 29);
                v81 = _mm_cmpeq_epi8(v78, v80);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v81);
                v2 += 16LL;
                v82 = v80;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v80, v79, 3);
                v83 = *(__m128i *)(v2 + 29);
                v84 = _mm_cmpeq_epi8(v81, v83);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v84);
                v2 += 16LL;
                v85 = v83;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v83, v82, 3);
                v86 = *(__m128i *)(v2 + 29);
                v5 = _mm_cmpeq_epi8(v84, v86);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v86, v85, 3);
                v87 = v2 + 29;
                v88 = (v2 + 29) & 0xFFFFFFFFFFFFFFC0LL;
                v89 = v87 - v88;
                v2 = v88 - 13;
                v3 = v3 + 16 - v89;
                v76 = *(__m128i *)(v2 - 3);
                while ( 1 )
                {
                  v77 = *(__m128i *)(v2 + 13);
                  v90 = *(__m128i *)(v2 + 29);
                  v91 = *(__m128i *)(v2 + 45);
                  v92 = *(__m128i *)(v2 + 61);
                  v93 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v91, v92), _mm_min_epu8(v90, v77)), v5));
                  v94 = v92;
                  v95 = _mm_alignr_epi8(v92, v91, 3);
                  v96 = _mm_alignr_epi8(v91, v90, 3);
                  if ( v93 )
                    break;
                  v97 = _mm_alignr_epi8(v90, v77, 3);
                  v2 += 64LL;
                  v98 = _mm_alignr_epi8(v77, v76, 3);
                  v76 = v94;
                  *(__m128i *)(v3 + 48) = v95;
                  *(__m128i *)(v3 + 32) = v96;
                  *(__m128i *)(v3 + 16) = v97;
                  *(__m128i *)v3 = v98;
                  v3 += 64LL;
                }
              }
              v7 = 13LL;
              *(__m128i *)(v3 - 3) = _mm_loadu_si128((const __m128i *)(v2 - 3));
              break;
            case 4uLL:
              v99 = *(__m128i *)(v2 - 4);
              v100 = *(__m128i *)(v2 + 12);
              while ( 1 )
              {
                v101 = _mm_cmpeq_epi8(v5, v100);
                v6 = _mm_movemask_epi8(v101);
                v102 = v100;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v100, v99, 4);
                v103 = *(__m128i *)(v2 + 28);
                v104 = _mm_cmpeq_epi8(v101, v103);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v104);
                v2 += 16LL;
                v105 = v103;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v103, v102, 4);
                v106 = *(__m128i *)(v2 + 28);
                v107 = _mm_cmpeq_epi8(v104, v106);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v107);
                v2 += 16LL;
                v108 = v106;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v106, v105, 4);
                v109 = *(__m128i *)(v2 + 28);
                v5 = _mm_cmpeq_epi8(v107, v109);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v109, v108, 4);
                v110 = v2 + 28;
                v111 = (v2 + 28) & 0xFFFFFFFFFFFFFFC0LL;
                v112 = v110 - v111;
                v2 = v111 - 12;
                v3 = v3 + 16 - v112;
                v99 = *(__m128i *)(v2 - 4);
                while ( 1 )
                {
                  v100 = *(__m128i *)(v2 + 12);
                  v113 = *(__m128i *)(v2 + 28);
                  v114 = *(__m128i *)(v2 + 44);
                  v115 = *(__m128i *)(v2 + 60);
                  v116 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v114, v115), _mm_min_epu8(v113, v100)), v5));
                  v117 = v115;
                  v118 = _mm_alignr_epi8(v115, v114, 4);
                  v119 = _mm_alignr_epi8(v114, v113, 4);
                  if ( v116 )
                    break;
                  v120 = _mm_alignr_epi8(v113, v100, 4);
                  v2 += 64LL;
                  v121 = _mm_alignr_epi8(v100, v99, 4);
                  v99 = v117;
                  *(__m128i *)(v3 + 48) = v118;
                  *(__m128i *)(v3 + 32) = v119;
                  *(__m128i *)(v3 + 16) = v120;
                  *(__m128i *)v3 = v121;
                  v3 += 64LL;
                }
              }
              v7 = 12LL;
              *(__m128i *)(v3 - 4) = _mm_loadu_si128((const __m128i *)(v2 - 4));
              break;
            case 5uLL:
              v122 = *(__m128i *)(v2 - 5);
              v123 = *(__m128i *)(v2 + 11);
              while ( 1 )
              {
                v124 = _mm_cmpeq_epi8(v5, v123);
                v6 = _mm_movemask_epi8(v124);
                v125 = v123;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v123, v122, 5);
                v126 = *(__m128i *)(v2 + 27);
                v127 = _mm_cmpeq_epi8(v124, v126);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v127);
                v2 += 16LL;
                v128 = v126;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v126, v125, 5);
                v129 = *(__m128i *)(v2 + 27);
                v130 = _mm_cmpeq_epi8(v127, v129);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v130);
                v2 += 16LL;
                v131 = v129;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v129, v128, 5);
                v132 = *(__m128i *)(v2 + 27);
                v5 = _mm_cmpeq_epi8(v130, v132);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v132, v131, 5);
                v133 = v2 + 27;
                v134 = (v2 + 27) & 0xFFFFFFFFFFFFFFC0LL;
                v135 = v133 - v134;
                v2 = v134 - 11;
                v3 = v3 + 16 - v135;
                v122 = *(__m128i *)(v2 - 5);
                while ( 1 )
                {
                  v123 = *(__m128i *)(v2 + 11);
                  v136 = *(__m128i *)(v2 + 27);
                  v137 = *(__m128i *)(v2 + 43);
                  v138 = *(__m128i *)(v2 + 59);
                  v139 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v137, v138), _mm_min_epu8(v136, v123)), v5));
                  v140 = v138;
                  v141 = _mm_alignr_epi8(v138, v137, 5);
                  v142 = _mm_alignr_epi8(v137, v136, 5);
                  if ( v139 )
                    break;
                  v143 = _mm_alignr_epi8(v136, v123, 5);
                  v2 += 64LL;
                  v144 = _mm_alignr_epi8(v123, v122, 5);
                  v122 = v140;
                  *(__m128i *)(v3 + 48) = v141;
                  *(__m128i *)(v3 + 32) = v142;
                  *(__m128i *)(v3 + 16) = v143;
                  *(__m128i *)v3 = v144;
                  v3 += 64LL;
                }
              }
              v7 = 11LL;
              *(__m128i *)(v3 - 5) = _mm_loadu_si128((const __m128i *)(v2 - 5));
              break;
            case 6uLL:
              v145 = *(__m128i *)(v2 - 6);
              v146 = *(__m128i *)(v2 + 10);
              while ( 1 )
              {
                v147 = _mm_cmpeq_epi8(v5, v146);
                v6 = _mm_movemask_epi8(v147);
                v148 = v146;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v146, v145, 6);
                v149 = *(__m128i *)(v2 + 26);
                v150 = _mm_cmpeq_epi8(v147, v149);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v150);
                v2 += 16LL;
                v151 = v149;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v149, v148, 6);
                v152 = *(__m128i *)(v2 + 26);
                v153 = _mm_cmpeq_epi8(v150, v152);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v153);
                v2 += 16LL;
                v154 = v152;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v152, v151, 6);
                v155 = *(__m128i *)(v2 + 26);
                v5 = _mm_cmpeq_epi8(v153, v155);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v155, v154, 6);
                v156 = v2 + 26;
                v157 = (v2 + 26) & 0xFFFFFFFFFFFFFFC0LL;
                v158 = v156 - v157;
                v2 = v157 - 10;
                v3 = v3 + 16 - v158;
                v145 = *(__m128i *)(v2 - 6);
                while ( 1 )
                {
                  v146 = *(__m128i *)(v2 + 10);
                  v159 = *(__m128i *)(v2 + 26);
                  v160 = *(__m128i *)(v2 + 42);
                  v161 = *(__m128i *)(v2 + 58);
                  v162 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v160, v161), _mm_min_epu8(v159, v146)), v5));
                  v163 = v161;
                  v164 = _mm_alignr_epi8(v161, v160, 6);
                  v165 = _mm_alignr_epi8(v160, v159, 6);
                  if ( v162 )
                    break;
                  v166 = _mm_alignr_epi8(v159, v146, 6);
                  v2 += 64LL;
                  v167 = _mm_alignr_epi8(v146, v145, 6);
                  v145 = v163;
                  *(__m128i *)(v3 + 48) = v164;
                  *(__m128i *)(v3 + 32) = v165;
                  *(__m128i *)(v3 + 16) = v166;
                  *(__m128i *)v3 = v167;
                  v3 += 64LL;
                }
              }
              v168 = *(_DWORD *)(v2 + 6);
              *(_QWORD *)v3 = *(_QWORD *)v2;
              *(_DWORD *)(v3 + 6) = v168;
              v7 = 10LL;
              break;
            default:
              v169 = *(__m128i *)(v2 - 7);
              v170 = *(__m128i *)(v2 + 9);
              while ( 1 )
              {
                v171 = _mm_cmpeq_epi8(v5, v170);
                v6 = _mm_movemask_epi8(v171);
                v172 = v170;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v170, v169, 7);
                v173 = *(__m128i *)(v2 + 25);
                v174 = _mm_cmpeq_epi8(v171, v173);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v174);
                v2 += 16LL;
                v175 = v173;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v173, v172, 7);
                v176 = *(__m128i *)(v2 + 25);
                v177 = _mm_cmpeq_epi8(v174, v176);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v177);
                v2 += 16LL;
                v178 = v176;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v176, v175, 7);
                v179 = *(__m128i *)(v2 + 25);
                v5 = _mm_cmpeq_epi8(v177, v179);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v179, v178, 7);
                v180 = v2 + 25;
                v181 = (v2 + 25) & 0xFFFFFFFFFFFFFFC0LL;
                v182 = v180 - v181;
                v2 = v181 - 9;
                v3 = v3 + 16 - v182;
                v169 = *(__m128i *)(v2 - 7);
                while ( 1 )
                {
                  v170 = *(__m128i *)(v2 + 9);
                  v183 = *(__m128i *)(v2 + 25);
                  v184 = *(__m128i *)(v2 + 41);
                  v185 = *(__m128i *)(v2 + 57);
                  v186 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v184, v185), _mm_min_epu8(v183, v170)), v5));
                  v187 = v185;
                  v188 = _mm_alignr_epi8(v185, v184, 7);
                  v189 = _mm_alignr_epi8(v184, v183, 7);
                  if ( v186 )
                    break;
                  v190 = _mm_alignr_epi8(v183, v170, 7);
                  v2 += 64LL;
                  v191 = _mm_alignr_epi8(v170, v169, 7);
                  v169 = v187;
                  *(__m128i *)(v3 + 48) = v188;
                  *(__m128i *)(v3 + 32) = v189;
                  *(__m128i *)(v3 + 16) = v190;
                  *(__m128i *)v3 = v191;
                  v3 += 64LL;
                }
              }
              v192 = *(_DWORD *)(v2 + 5);
              *(_QWORD *)v3 = *(_QWORD *)v2;
              *(_DWORD *)(v3 + 5) = v192;
              v7 = 9LL;
              break;
          }
        }
      }
      else
      {
        v9 = *(__m128i *)(v2 + 16);
        *(_OWORD *)v3 = *(_OWORD *)v2;
        v10 = _mm_cmpeq_epi8(v5, v9);
        v6 = _mm_movemask_epi8(v10);
        v7 = 16LL;
        if ( !v6 )
        {
          v11 = *(__m128i *)(v2 + 32);
          *(__m128i *)((char *)&word_10 + ((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL)) = v9;
          v12 = _mm_cmpeq_epi8(v10, v11);
          v6 = _mm_movemask_epi8(v12);
          v7 = 32LL;
          if ( !v6 )
          {
            v13 = *(__m128i *)(v2 + 48);
            *(__m128i *)((char *)qword_20 + ((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL)) = v11;
            v14 = _mm_cmpeq_epi8(v12, v13);
            v6 = _mm_movemask_epi8(v14);
            v7 = 48LL;
            if ( !v6 )
            {
              v15 = *(__m128i *)(v2 + 64);
              *(__m128i *)((char *)&dword_30 + ((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL)) = v13;
              v16 = _mm_cmpeq_epi8(v14, v15);
              v6 = _mm_movemask_epi8(v16);
              v7 = 64LL;
              if ( !v6 )
              {
                v17 = *(__m128i *)(v2 + 80);
                *(__m128i *)((char *)&dword_40 + ((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL)) = v15;
                v18 = _mm_cmpeq_epi8(v16, v17);
                v6 = _mm_movemask_epi8(v18);
                v7 = 80LL;
                if ( !v6 )
                {
                  v19 = *(__m128i *)(v2 + 96);
                  *(__m128i *)((char *)&qword_50 + ((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL)) = v17;
                  v20 = _mm_cmpeq_epi8(v18, v19);
                  v6 = _mm_movemask_epi8(v20);
                  v7 = 96LL;
                  if ( !v6 )
                  {
                    *(__m128i *)((char *)&qword_60 + ((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL)) = v19;
                    v21 = v2;
                    v2 = (v2 + 112) & 0xFFFFFFFFFFFFFFC0LL;
                    v3 -= v21 - v2;
                    v7 = -64LL;
                    while ( 1 )
                    {
                      v22 = *(__m128i *)v2;
                      v23 = *(__m128i *)(v2 + 16);
                      v24 = *(__m128i *)(v2 + 32);
                      v25 = *(__m128i *)(v2 + 48);
                      v26 = _mm_movemask_epi8(
                              _mm_cmpeq_epi8(
                                _mm_min_epu8(_mm_min_epu8(v24, v25), _mm_min_epu8(*(__m128i *)v2, v23)),
                                v20));
                      v3 += 64LL;
                      v2 += 64LL;
                      if ( v26 )
                        break;
                      *(__m128i *)(v3 - 64) = v22;
                      *(__m128i *)(v3 - 48) = v23;
                      *(__m128i *)(v3 - 32) = v24;
                      *(__m128i *)(v3 - 16) = v25;
                    }
                    v27 = _mm_cmpeq_epi8(v20, v22);
                    v6 = _mm_movemask_epi8(v27);
                    if ( !v6 )
                    {
                      v28 = _mm_cmpeq_epi8(v27, v23);
                      v6 = _mm_movemask_epi8(v28);
                      *(__m128i *)(v3 - 64) = v22;
                      v7 = -48LL;
                      if ( !v6 )
                      {
                        v29 = _mm_cmpeq_epi8(v28, v24);
                        v6 = _mm_movemask_epi8(v29);
                        *(__m128i *)(v3 - 48) = v23;
                        v7 = -32LL;
                        if ( !v6 )
                        {
                          *(__m128i *)(v3 - 32) = v24;
                          LOWORD(v6) = _mm_movemask_epi8(_mm_cmpeq_epi8(v29, v25));
                          v7 = -16LL;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v3 += v7;
    v2 += v7;
    if ( (_BYTE)v6 )
    {
      if ( (v6 & 1) == 0 )
      {
        if ( (v6 & 2) == 0 )
        {
          if ( (v6 & 4) == 0 )
          {
            if ( (v6 & 8) == 0 )
            {
              if ( (v6 & 0x10) == 0 )
              {
                if ( (v6 & 0x20) == 0 )
                {
                  if ( (v6 & 0x40) == 0 )
                    goto LABEL_189;
                  goto LABEL_204;
                }
LABEL_203:
                *(_DWORD *)v3 = *(_DWORD *)v2;
                *(_WORD *)(v3 + 4) = *(_WORD *)(v2 + 4);
                return a1;
              }
LABEL_202:
              *(_DWORD *)v3 = *(_DWORD *)v2;
              *(_BYTE *)(v3 + 4) = *(_BYTE *)(v2 + 4);
              return a1;
            }
LABEL_201:
            *(_DWORD *)v3 = *(_DWORD *)v2;
            return a1;
          }
LABEL_200:
          *(_WORD *)v3 = *(_WORD *)v2;
          *(_BYTE *)(v3 + 2) = *(_BYTE *)(v2 + 2);
          return a1;
        }
LABEL_199:
        *(_WORD *)v3 = *(_WORD *)v2;
        return a1;
      }
LABEL_198:
      *(_BYTE *)v3 = *(_BYTE *)v2;
      return a1;
    }
    if ( (v6 & 0x100) == 0 )
    {
      if ( (v6 & 0x200) == 0 )
      {
        if ( (v6 & 0x400) == 0 )
        {
          if ( (v6 & 0x800) == 0 )
          {
            if ( (v6 & 0x1000) == 0 )
            {
              if ( (v6 & 0x2000) == 0 )
              {
                if ( (v6 & 0x4000) == 0 )
                  goto LABEL_197;
                goto LABEL_211;
              }
LABEL_210:
              *(_QWORD *)v3 = *(_QWORD *)v2;
              *(_QWORD *)(v3 + 6) = *(_QWORD *)(v2 + 6);
              return a1;
            }
LABEL_209:
            *(_QWORD *)v3 = *(_QWORD *)v2;
            *(_QWORD *)(v3 + 5) = *(_QWORD *)(v2 + 5);
            return a1;
          }
LABEL_208:
          *(_QWORD *)v3 = *(_QWORD *)v2;
          *(_DWORD *)(v3 + 8) = *(_DWORD *)(v2 + 8);
          return a1;
        }
LABEL_207:
        *(_QWORD *)v3 = *(_QWORD *)v2;
        *(_DWORD *)(v3 + 7) = *(_DWORD *)(v2 + 7);
        return a1;
      }
LABEL_206:
      *(_QWORD *)v3 = *(_QWORD *)v2;
      *(_DWORD *)(v3 + 6) = *(_DWORD *)(v2 + 6);
      return a1;
    }
LABEL_205:
    *(_QWORD *)v3 = *(_QWORD *)v2;
    *(_DWORD *)(v3 + 5) = *(_DWORD *)(v2 + 5);
    return a1;
  }
LABEL_211:
  *(_QWORD *)v3 = *(_QWORD *)v2;
  *(_QWORD *)(v3 + 7) = *(_QWORD *)(v2 + 7);
  return a1;
}
// 10: using guessed type __int16 word_10;
// 20: using guessed type __int64 qword_20[];
// 30: using guessed type int dword_30;
// 40: using guessed type int dword_40;
// 50: using guessed type __int64 qword_50;
// 60: using guessed type __int64 qword_60;

//----- (0000000000042A10) ----------------------------------------------------
unsigned __int64 __fastcall sub_42A10(_QWORD *a1, _BYTE *a2)
{
  unsigned __int64 v2; // rcx
  unsigned __int64 v3; // rdx
  __m128i *v4; // rsi
  __m128i v5; // xmm0
  int v6; // eax
  __int64 v7; // rsi
  unsigned __int64 v8; // rax
  __m128i v9; // xmm2
  __m128i v10; // xmm0
  __m128i v11; // xmm3
  __m128i v12; // xmm0
  __m128i v13; // xmm4
  __m128i v14; // xmm0
  __m128i v15; // xmm1
  __m128i v16; // xmm0
  __m128i v17; // xmm2
  __m128i v18; // xmm0
  __m128i v19; // xmm3
  __m128i v20; // xmm0
  unsigned __int64 v21; // rax
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  __m128i v24; // xmm6
  __m128i v25; // xmm7
  int v26; // eax
  __m128i v27; // xmm0
  __m128i v28; // xmm0
  __m128i v29; // xmm0
  __m128i v30; // xmm1
  __m128i v31; // xmm2
  __m128i v32; // xmm0
  __m128i v33; // xmm3
  __m128i v34; // xmm2
  __m128i v35; // xmm0
  __m128i v36; // xmm1
  __m128i v37; // xmm2
  __m128i v38; // xmm0
  __m128i v39; // xmm3
  __m128i v40; // xmm2
  unsigned __int64 v41; // rax
  unsigned __int64 v42; // rcx
  unsigned __int64 v43; // rax
  __m128i v44; // xmm3
  __m128i v45; // xmm4
  __m128i v46; // xmm5
  int v47; // eax
  __m128i v48; // xmm7
  __m128i v49; // xmm5
  __m128i v50; // xmm4
  __m128i v51; // xmm3
  __m128i v52; // xmm2
  __m128i v53; // xmm1
  __m128i v54; // xmm2
  __m128i v55; // xmm0
  __m128i v56; // xmm3
  __m128i v57; // xmm2
  __m128i v58; // xmm0
  __m128i v59; // xmm1
  __m128i v60; // xmm2
  __m128i v61; // xmm0
  __m128i v62; // xmm3
  __m128i v63; // xmm2
  unsigned __int64 v64; // rax
  unsigned __int64 v65; // rcx
  unsigned __int64 v66; // rax
  __m128i v67; // xmm3
  __m128i v68; // xmm4
  __m128i v69; // xmm5
  int v70; // eax
  __m128i v71; // xmm7
  __m128i v72; // xmm5
  __m128i v73; // xmm4
  __m128i v74; // xmm3
  __m128i v75; // xmm2
  __m128i v76; // xmm1
  __m128i v77; // xmm2
  __m128i v78; // xmm0
  __m128i v79; // xmm3
  __m128i v80; // xmm2
  __m128i v81; // xmm0
  __m128i v82; // xmm1
  __m128i v83; // xmm2
  __m128i v84; // xmm0
  __m128i v85; // xmm3
  __m128i v86; // xmm2
  unsigned __int64 v87; // rax
  unsigned __int64 v88; // rcx
  unsigned __int64 v89; // rax
  __m128i v90; // xmm3
  __m128i v91; // xmm4
  __m128i v92; // xmm5
  int v93; // eax
  __m128i v94; // xmm7
  __m128i v95; // xmm5
  __m128i v96; // xmm4
  __m128i v97; // xmm3
  __m128i v98; // xmm2
  __m128i v99; // xmm1
  __m128i v100; // xmm2
  __m128i v101; // xmm0
  __m128i v102; // xmm3
  __m128i v103; // xmm2
  __m128i v104; // xmm0
  __m128i v105; // xmm1
  __m128i v106; // xmm2
  __m128i v107; // xmm0
  __m128i v108; // xmm3
  __m128i v109; // xmm2
  unsigned __int64 v110; // rax
  unsigned __int64 v111; // rcx
  unsigned __int64 v112; // rax
  __m128i v113; // xmm3
  __m128i v114; // xmm4
  __m128i v115; // xmm5
  int v116; // eax
  __m128i v117; // xmm7
  __m128i v118; // xmm5
  __m128i v119; // xmm4
  __m128i v120; // xmm3
  __m128i v121; // xmm2
  __m128i v122; // xmm1
  __m128i v123; // xmm2
  __m128i v124; // xmm0
  __m128i v125; // xmm3
  __m128i v126; // xmm2
  __m128i v127; // xmm0
  __m128i v128; // xmm1
  __m128i v129; // xmm2
  __m128i v130; // xmm0
  __m128i v131; // xmm3
  __m128i v132; // xmm2
  unsigned __int64 v133; // rax
  unsigned __int64 v134; // rcx
  unsigned __int64 v135; // rax
  __m128i v136; // xmm3
  __m128i v137; // xmm4
  __m128i v138; // xmm5
  int v139; // eax
  __m128i v140; // xmm7
  __m128i v141; // xmm5
  __m128i v142; // xmm4
  __m128i v143; // xmm3
  __m128i v144; // xmm2
  __m128i v145; // xmm1
  __m128i v146; // xmm2
  __m128i v147; // xmm0
  __m128i v148; // xmm3
  __m128i v149; // xmm2
  __m128i v150; // xmm0
  __m128i v151; // xmm1
  __m128i v152; // xmm2
  __m128i v153; // xmm0
  __m128i v154; // xmm3
  __m128i v155; // xmm2
  unsigned __int64 v156; // rax
  unsigned __int64 v157; // rcx
  unsigned __int64 v158; // rax
  __m128i v159; // xmm3
  __m128i v160; // xmm4
  __m128i v161; // xmm5
  int v162; // eax
  __m128i v163; // xmm7
  __m128i v164; // xmm5
  __m128i v165; // xmm4
  __m128i v166; // xmm3
  __m128i v167; // xmm2
  int v168; // esi
  __m128i v169; // xmm1
  __m128i v170; // xmm2
  __m128i v171; // xmm0
  __m128i v172; // xmm3
  __m128i v173; // xmm2
  __m128i v174; // xmm0
  __m128i v175; // xmm1
  __m128i v176; // xmm2
  __m128i v177; // xmm0
  __m128i v178; // xmm3
  __m128i v179; // xmm2
  unsigned __int64 v180; // rax
  unsigned __int64 v181; // rcx
  unsigned __int64 v182; // rax
  __m128i v183; // xmm3
  __m128i v184; // xmm4
  __m128i v185; // xmm5
  int v186; // eax
  __m128i v187; // xmm7
  __m128i v188; // xmm5
  __m128i v189; // xmm4
  __m128i v190; // xmm3
  __m128i v191; // xmm2
  int v192; // esi
  __m128i v193; // xmm1
  __m128i v194; // xmm2
  __m128i v195; // xmm0
  __m128i v196; // xmm3
  __m128i v197; // xmm2
  __m128i v198; // xmm0
  __m128i v199; // xmm1
  __m128i v200; // xmm2
  __m128i v201; // xmm0
  __m128i v202; // xmm3
  __m128i v203; // xmm2
  unsigned __int64 v204; // rax
  unsigned __int64 v205; // rcx
  unsigned __int64 v206; // rax
  __m128i v207; // xmm3
  __m128i v208; // xmm4
  __m128i v209; // xmm5
  int v210; // eax
  __m128i v211; // xmm7
  __m128i v212; // xmm5
  __m128i v213; // xmm4
  __m128i v214; // xmm3
  __m128i v215; // xmm2
  __m128i v216; // xmm1
  __m128i v217; // xmm2
  __m128i v218; // xmm0
  __m128i v219; // xmm3
  __m128i v220; // xmm2
  __m128i v221; // xmm0
  __m128i v222; // xmm1
  __m128i v223; // xmm2
  __m128i v224; // xmm0
  __m128i v225; // xmm3
  __m128i v226; // xmm2
  unsigned __int64 v227; // rax
  unsigned __int64 v228; // rcx
  unsigned __int64 v229; // rax
  __m128i v230; // xmm3
  __m128i v231; // xmm4
  __m128i v232; // xmm5
  int v233; // eax
  __m128i v234; // xmm7
  __m128i v235; // xmm5
  __m128i v236; // xmm4
  __m128i v237; // xmm3
  __m128i v238; // xmm2
  __m128i v239; // xmm1
  __m128i v240; // xmm2
  __m128i v241; // xmm0
  __m128i v242; // xmm3
  __m128i v243; // xmm2
  __m128i v244; // xmm0
  __m128i v245; // xmm1
  __m128i v246; // xmm2
  __m128i v247; // xmm0
  __m128i v248; // xmm3
  __m128i v249; // xmm2
  unsigned __int64 v250; // rax
  unsigned __int64 v251; // rcx
  unsigned __int64 v252; // rax
  __m128i v253; // xmm3
  __m128i v254; // xmm4
  __m128i v255; // xmm5
  int v256; // eax
  __m128i v257; // xmm7
  __m128i v258; // xmm5
  __m128i v259; // xmm4
  __m128i v260; // xmm3
  __m128i v261; // xmm2
  __m128i v262; // xmm1
  __m128i v263; // xmm2
  __m128i v264; // xmm0
  __m128i v265; // xmm3
  __m128i v266; // xmm2
  __m128i v267; // xmm0
  __m128i v268; // xmm1
  __m128i v269; // xmm2
  __m128i v270; // xmm0
  __m128i v271; // xmm3
  __m128i v272; // xmm2
  unsigned __int64 v273; // rax
  unsigned __int64 v274; // rcx
  unsigned __int64 v275; // rax
  __m128i v276; // xmm3
  __m128i v277; // xmm4
  __m128i v278; // xmm5
  int v279; // eax
  __m128i v280; // xmm7
  __m128i v281; // xmm5
  __m128i v282; // xmm4
  __m128i v283; // xmm3
  __m128i v284; // xmm2
  __m128i v285; // xmm1
  __m128i v286; // xmm2
  __m128i v287; // xmm0
  __m128i v288; // xmm3
  __m128i v289; // xmm2
  __m128i v290; // xmm0
  __m128i v291; // xmm1
  __m128i v292; // xmm2
  __m128i v293; // xmm0
  __m128i v294; // xmm3
  __m128i v295; // xmm2
  unsigned __int64 v296; // rax
  unsigned __int64 v297; // rcx
  unsigned __int64 v298; // rax
  __m128i v299; // xmm3
  __m128i v300; // xmm4
  __m128i v301; // xmm5
  int v302; // eax
  __m128i v303; // xmm7
  __m128i v304; // xmm5
  __m128i v305; // xmm4
  __m128i v306; // xmm3
  __m128i v307; // xmm2
  __m128i v308; // xmm1
  __m128i v309; // xmm2
  __m128i v310; // xmm0
  __m128i v311; // xmm3
  __m128i v312; // xmm2
  __m128i v313; // xmm0
  __m128i v314; // xmm1
  __m128i v315; // xmm2
  __m128i v316; // xmm0
  __m128i v317; // xmm3
  __m128i v318; // xmm2
  unsigned __int64 v319; // rax
  unsigned __int64 v320; // rcx
  unsigned __int64 v321; // rax
  __m128i v322; // xmm3
  __m128i v323; // xmm4
  __m128i v324; // xmm5
  int v325; // eax
  __m128i v326; // xmm7
  __m128i v327; // xmm5
  __m128i v328; // xmm4
  __m128i v329; // xmm3
  __m128i v330; // xmm2
  __m128i v331; // xmm1
  __m128i v332; // xmm2
  __m128i v333; // xmm0
  __m128i v334; // xmm3
  __m128i v335; // xmm2
  __m128i v336; // xmm0
  __m128i v337; // xmm1
  __m128i v338; // xmm2
  __m128i v339; // xmm0
  __m128i v340; // xmm3
  __m128i v341; // xmm2
  unsigned __int64 v342; // rax
  unsigned __int64 v343; // rcx
  unsigned __int64 v344; // rax
  __m128i v345; // xmm3
  __m128i v346; // xmm4
  __m128i v347; // xmm5
  int v348; // eax
  __m128i v349; // xmm7
  __m128i v350; // xmm5
  __m128i v351; // xmm4
  __m128i v352; // xmm3
  __m128i v353; // xmm2
  __m128i v354; // xmm1
  __m128i v355; // xmm2
  __m128i v356; // xmm0
  __m128i v357; // xmm3
  __m128i v358; // xmm2
  __m128i v359; // xmm0
  __m128i v360; // xmm1
  __m128i v361; // xmm2
  __m128i v362; // xmm0
  __m128i v363; // xmm3
  __m128i v364; // xmm2
  unsigned __int64 v365; // rax
  unsigned __int64 v366; // rcx
  unsigned __int64 v367; // rax
  __m128i v368; // xmm3
  __m128i v369; // xmm4
  __m128i v370; // xmm5
  int v371; // eax
  __m128i v372; // xmm7
  __m128i v373; // xmm5
  __m128i v374; // xmm4
  __m128i v375; // xmm3
  __m128i v376; // xmm2

  v2 = (unsigned __int64)a2;
  v3 = (unsigned __int64)a1;
  if ( !*a2 )
    goto LABEL_198;
  if ( !a2[1] )
    goto LABEL_199;
  if ( !a2[2] )
    goto LABEL_200;
  if ( !a2[3] )
    goto LABEL_201;
  if ( !a2[4] )
    goto LABEL_202;
  if ( !a2[5] )
    goto LABEL_203;
  if ( !a2[6] )
  {
LABEL_204:
    *(_DWORD *)v3 = *(_DWORD *)v2;
    *(_DWORD *)(v3 + 3) = *(_DWORD *)(v2 + 3);
    return v3 + 6;
  }
  if ( !a2[7] )
  {
LABEL_189:
    *(_QWORD *)v3 = *(_QWORD *)v2;
    return v3 + 7;
  }
  if ( !a2[8] )
    goto LABEL_205;
  if ( !a2[9] )
    goto LABEL_206;
  if ( !a2[10] )
    goto LABEL_207;
  if ( !a2[11] )
    goto LABEL_208;
  if ( !a2[12] )
    goto LABEL_209;
  if ( !a2[13] )
    goto LABEL_210;
  if ( a2[14] )
  {
    if ( !a2[15] )
    {
LABEL_197:
      *(_QWORD *)v3 = *(_QWORD *)v2;
      *(_QWORD *)(v3 + 8) = *(_QWORD *)(v2 + 8);
      return v3 + 15;
    }
    v4 = (__m128i *)((unsigned __int64)(a2 + 16) & 0xFFFFFFFFFFFFFFF0LL);
    *a1 = *(_QWORD *)v2;
    v5 = _mm_cmpeq_epi8((__m128i)0LL, *v4);
    a1[1] = *(_QWORD *)(v2 + 8);
    v6 = _mm_movemask_epi8(v5);
    v7 = (__int64)v4->m128i_i64 - v2;
    if ( !v6 )
    {
      v3 = (unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL;
      v2 -= (unsigned __int64)a1 - v3;
      v8 = v2 & 0xF;
      if ( (v2 & 0xF) != 0 )
      {
        if ( v8 >= 8 )
        {
          switch ( v8 )
          {
            case 8uLL:
              v193 = *(__m128i *)(v2 - 8);
              v194 = *(__m128i *)(v2 + 8);
              while ( 1 )
              {
                v195 = _mm_cmpeq_epi8(v5, v194);
                v6 = _mm_movemask_epi8(v195);
                v196 = v194;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v194, v193, 8);
                v197 = *(__m128i *)(v2 + 24);
                v198 = _mm_cmpeq_epi8(v195, v197);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v198);
                v2 += 16LL;
                v199 = v197;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v197, v196, 8);
                v200 = *(__m128i *)(v2 + 24);
                v201 = _mm_cmpeq_epi8(v198, v200);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v201);
                v2 += 16LL;
                v202 = v200;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v200, v199, 8);
                v203 = *(__m128i *)(v2 + 24);
                v5 = _mm_cmpeq_epi8(v201, v203);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v203, v202, 8);
                v204 = v2 + 24;
                v205 = (v2 + 24) & 0xFFFFFFFFFFFFFFC0LL;
                v206 = v204 - v205;
                v2 = v205 - 8;
                v3 = v3 + 16 - v206;
                v193 = *(__m128i *)(v2 - 8);
                while ( 1 )
                {
                  v194 = *(__m128i *)(v2 + 8);
                  v207 = *(__m128i *)(v2 + 24);
                  v208 = *(__m128i *)(v2 + 40);
                  v209 = *(__m128i *)(v2 + 56);
                  v210 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v208, v209), _mm_min_epu8(v207, v194)), v5));
                  v211 = v209;
                  v212 = _mm_alignr_epi8(v209, v208, 8);
                  v213 = _mm_alignr_epi8(v208, v207, 8);
                  if ( v210 )
                    break;
                  v214 = _mm_alignr_epi8(v207, v194, 8);
                  v2 += 64LL;
                  v215 = _mm_alignr_epi8(v194, v193, 8);
                  v193 = v211;
                  *(__m128i *)(v3 + 48) = v212;
                  *(__m128i *)(v3 + 32) = v213;
                  *(__m128i *)(v3 + 16) = v214;
                  *(__m128i *)v3 = v215;
                  v3 += 64LL;
                }
              }
              v7 = 8LL;
              *(_QWORD *)v3 = *(_QWORD *)v2;
              break;
            case 9uLL:
              v216 = *(__m128i *)(v2 - 9);
              v217 = *(__m128i *)(v2 + 7);
              while ( 1 )
              {
                v218 = _mm_cmpeq_epi8(v5, v217);
                v6 = _mm_movemask_epi8(v218);
                v219 = v217;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v217, v216, 9);
                v220 = *(__m128i *)(v2 + 23);
                v221 = _mm_cmpeq_epi8(v218, v220);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v221);
                v2 += 16LL;
                v222 = v220;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v220, v219, 9);
                v223 = *(__m128i *)(v2 + 23);
                v224 = _mm_cmpeq_epi8(v221, v223);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v224);
                v2 += 16LL;
                v225 = v223;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v223, v222, 9);
                v226 = *(__m128i *)(v2 + 23);
                v5 = _mm_cmpeq_epi8(v224, v226);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v226, v225, 9);
                v227 = v2 + 23;
                v228 = (v2 + 23) & 0xFFFFFFFFFFFFFFC0LL;
                v229 = v227 - v228;
                v2 = v228 - 7;
                v3 = v3 + 16 - v229;
                v216 = *(__m128i *)(v2 - 9);
                while ( 1 )
                {
                  v217 = *(__m128i *)(v2 + 7);
                  v230 = *(__m128i *)(v2 + 23);
                  v231 = *(__m128i *)(v2 + 39);
                  v232 = *(__m128i *)(v2 + 55);
                  v233 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v231, v232), _mm_min_epu8(v230, v217)), v5));
                  v234 = v232;
                  v235 = _mm_alignr_epi8(v232, v231, 9);
                  v236 = _mm_alignr_epi8(v231, v230, 9);
                  if ( v233 )
                    break;
                  v237 = _mm_alignr_epi8(v230, v217, 9);
                  v2 += 64LL;
                  v238 = _mm_alignr_epi8(v217, v216, 9);
                  v216 = v234;
                  *(__m128i *)(v3 + 48) = v235;
                  *(__m128i *)(v3 + 32) = v236;
                  *(__m128i *)(v3 + 16) = v237;
                  *(__m128i *)v3 = v238;
                  v3 += 64LL;
                }
              }
              v7 = 7LL;
              *(_QWORD *)(v3 - 1) = *(_QWORD *)(v2 - 1);
              break;
            case 0xAuLL:
              v239 = *(__m128i *)(v2 - 10);
              v240 = *(__m128i *)(v2 + 6);
              while ( 1 )
              {
                v241 = _mm_cmpeq_epi8(v5, v240);
                v6 = _mm_movemask_epi8(v241);
                v242 = v240;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v240, v239, 10);
                v243 = *(__m128i *)(v2 + 22);
                v244 = _mm_cmpeq_epi8(v241, v243);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v244);
                v2 += 16LL;
                v245 = v243;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v243, v242, 10);
                v246 = *(__m128i *)(v2 + 22);
                v247 = _mm_cmpeq_epi8(v244, v246);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v247);
                v2 += 16LL;
                v248 = v246;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v246, v245, 10);
                v249 = *(__m128i *)(v2 + 22);
                v5 = _mm_cmpeq_epi8(v247, v249);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v249, v248, 10);
                v250 = v2 + 22;
                v251 = (v2 + 22) & 0xFFFFFFFFFFFFFFC0LL;
                v252 = v250 - v251;
                v2 = v251 - 6;
                v3 = v3 + 16 - v252;
                v239 = *(__m128i *)(v2 - 10);
                while ( 1 )
                {
                  v240 = *(__m128i *)(v2 + 6);
                  v253 = *(__m128i *)(v2 + 22);
                  v254 = *(__m128i *)(v2 + 38);
                  v255 = *(__m128i *)(v2 + 54);
                  v256 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v254, v255), _mm_min_epu8(v253, v240)), v5));
                  v257 = v255;
                  v258 = _mm_alignr_epi8(v255, v254, 10);
                  v259 = _mm_alignr_epi8(v254, v253, 10);
                  if ( v256 )
                    break;
                  v260 = _mm_alignr_epi8(v253, v240, 10);
                  v2 += 64LL;
                  v261 = _mm_alignr_epi8(v240, v239, 10);
                  v239 = v257;
                  *(__m128i *)(v3 + 48) = v258;
                  *(__m128i *)(v3 + 32) = v259;
                  *(__m128i *)(v3 + 16) = v260;
                  *(__m128i *)v3 = v261;
                  v3 += 64LL;
                }
              }
              v7 = 6LL;
              *(_QWORD *)(v3 - 2) = *(_QWORD *)(v2 - 2);
              break;
            case 0xBuLL:
              v262 = *(__m128i *)(v2 - 11);
              v263 = *(__m128i *)(v2 + 5);
              while ( 1 )
              {
                v264 = _mm_cmpeq_epi8(v5, v263);
                v6 = _mm_movemask_epi8(v264);
                v265 = v263;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v263, v262, 11);
                v266 = *(__m128i *)(v2 + 21);
                v267 = _mm_cmpeq_epi8(v264, v266);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v267);
                v2 += 16LL;
                v268 = v266;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v266, v265, 11);
                v269 = *(__m128i *)(v2 + 21);
                v270 = _mm_cmpeq_epi8(v267, v269);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v270);
                v2 += 16LL;
                v271 = v269;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v269, v268, 11);
                v272 = *(__m128i *)(v2 + 21);
                v5 = _mm_cmpeq_epi8(v270, v272);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v272, v271, 11);
                v273 = v2 + 21;
                v274 = (v2 + 21) & 0xFFFFFFFFFFFFFFC0LL;
                v275 = v273 - v274;
                v2 = v274 - 5;
                v3 = v3 + 16 - v275;
                v262 = *(__m128i *)(v2 - 11);
                while ( 1 )
                {
                  v263 = *(__m128i *)(v2 + 5);
                  v276 = *(__m128i *)(v2 + 21);
                  v277 = *(__m128i *)(v2 + 37);
                  v278 = *(__m128i *)(v2 + 53);
                  v279 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v277, v278), _mm_min_epu8(v276, v263)), v5));
                  v280 = v278;
                  v281 = _mm_alignr_epi8(v278, v277, 11);
                  v282 = _mm_alignr_epi8(v277, v276, 11);
                  if ( v279 )
                    break;
                  v283 = _mm_alignr_epi8(v276, v263, 11);
                  v2 += 64LL;
                  v284 = _mm_alignr_epi8(v263, v262, 11);
                  v262 = v280;
                  *(__m128i *)(v3 + 48) = v281;
                  *(__m128i *)(v3 + 32) = v282;
                  *(__m128i *)(v3 + 16) = v283;
                  *(__m128i *)v3 = v284;
                  v3 += 64LL;
                }
              }
              v7 = 5LL;
              *(_QWORD *)(v3 - 3) = *(_QWORD *)(v2 - 3);
              break;
            case 0xCuLL:
              v285 = *(__m128i *)(v2 - 12);
              v286 = *(__m128i *)(v2 + 4);
              while ( 1 )
              {
                v287 = _mm_cmpeq_epi8(v5, v286);
                v6 = _mm_movemask_epi8(v287);
                v288 = v286;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v286, v285, 12);
                v289 = *(__m128i *)(v2 + 20);
                v290 = _mm_cmpeq_epi8(v287, v289);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v290);
                v2 += 16LL;
                v291 = v289;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v289, v288, 12);
                v292 = *(__m128i *)(v2 + 20);
                v293 = _mm_cmpeq_epi8(v290, v292);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v293);
                v2 += 16LL;
                v294 = v292;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v292, v291, 12);
                v295 = *(__m128i *)(v2 + 20);
                v5 = _mm_cmpeq_epi8(v293, v295);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v295, v294, 12);
                v296 = v2 + 20;
                v297 = (v2 + 20) & 0xFFFFFFFFFFFFFFC0LL;
                v298 = v296 - v297;
                v2 = v297 - 4;
                v3 = v3 + 16 - v298;
                v285 = *(__m128i *)(v2 - 12);
                while ( 1 )
                {
                  v286 = *(__m128i *)(v2 + 4);
                  v299 = *(__m128i *)(v2 + 20);
                  v300 = *(__m128i *)(v2 + 36);
                  v301 = *(__m128i *)(v2 + 52);
                  v302 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v300, v301), _mm_min_epu8(v299, v286)), v5));
                  v303 = v301;
                  v304 = _mm_alignr_epi8(v301, v300, 12);
                  v305 = _mm_alignr_epi8(v300, v299, 12);
                  if ( v302 )
                    break;
                  v306 = _mm_alignr_epi8(v299, v286, 12);
                  v2 += 64LL;
                  v307 = _mm_alignr_epi8(v286, v285, 12);
                  v285 = v303;
                  *(__m128i *)(v3 + 48) = v304;
                  *(__m128i *)(v3 + 32) = v305;
                  *(__m128i *)(v3 + 16) = v306;
                  *(__m128i *)v3 = v307;
                  v3 += 64LL;
                }
              }
              v7 = 4LL;
              *(_DWORD *)v3 = *(_DWORD *)v2;
              break;
            case 0xDuLL:
              v308 = *(__m128i *)(v2 - 13);
              v309 = *(__m128i *)(v2 + 3);
              while ( 1 )
              {
                v310 = _mm_cmpeq_epi8(v5, v309);
                v6 = _mm_movemask_epi8(v310);
                v311 = v309;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v309, v308, 13);
                v312 = *(__m128i *)(v2 + 19);
                v313 = _mm_cmpeq_epi8(v310, v312);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v313);
                v2 += 16LL;
                v314 = v312;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v312, v311, 13);
                v315 = *(__m128i *)(v2 + 19);
                v316 = _mm_cmpeq_epi8(v313, v315);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v316);
                v2 += 16LL;
                v317 = v315;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v315, v314, 13);
                v318 = *(__m128i *)(v2 + 19);
                v5 = _mm_cmpeq_epi8(v316, v318);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v318, v317, 13);
                v319 = v2 + 19;
                v320 = (v2 + 19) & 0xFFFFFFFFFFFFFFC0LL;
                v321 = v319 - v320;
                v2 = v320 - 3;
                v3 = v3 + 16 - v321;
                v308 = *(__m128i *)(v2 - 13);
                while ( 1 )
                {
                  v309 = *(__m128i *)(v2 + 3);
                  v322 = *(__m128i *)(v2 + 19);
                  v323 = *(__m128i *)(v2 + 35);
                  v324 = *(__m128i *)(v2 + 51);
                  v325 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v323, v324), _mm_min_epu8(v322, v309)), v5));
                  v326 = v324;
                  v327 = _mm_alignr_epi8(v324, v323, 13);
                  v328 = _mm_alignr_epi8(v323, v322, 13);
                  if ( v325 )
                    break;
                  v329 = _mm_alignr_epi8(v322, v309, 13);
                  v2 += 64LL;
                  v330 = _mm_alignr_epi8(v309, v308, 13);
                  v308 = v326;
                  *(__m128i *)(v3 + 48) = v327;
                  *(__m128i *)(v3 + 32) = v328;
                  *(__m128i *)(v3 + 16) = v329;
                  *(__m128i *)v3 = v330;
                  v3 += 64LL;
                }
              }
              v7 = 3LL;
              *(_DWORD *)(v3 - 1) = *(_DWORD *)(v2 - 1);
              break;
            case 0xEuLL:
              v331 = *(__m128i *)(v2 - 14);
              v332 = *(__m128i *)(v2 + 2);
              while ( 1 )
              {
                v333 = _mm_cmpeq_epi8(v5, v332);
                v6 = _mm_movemask_epi8(v333);
                v334 = v332;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v332, v331, 14);
                v335 = *(__m128i *)(v2 + 18);
                v336 = _mm_cmpeq_epi8(v333, v335);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v336);
                v2 += 16LL;
                v337 = v335;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v335, v334, 14);
                v338 = *(__m128i *)(v2 + 18);
                v339 = _mm_cmpeq_epi8(v336, v338);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v339);
                v2 += 16LL;
                v340 = v338;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v338, v337, 14);
                v341 = *(__m128i *)(v2 + 18);
                v5 = _mm_cmpeq_epi8(v339, v341);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v341, v340, 14);
                v342 = v2 + 18;
                v343 = (v2 + 18) & 0xFFFFFFFFFFFFFFC0LL;
                v344 = v342 - v343;
                v2 = v343 - 2;
                v3 = v3 + 16 - v344;
                v331 = *(__m128i *)(v2 - 14);
                while ( 1 )
                {
                  v332 = *(__m128i *)(v2 + 2);
                  v345 = *(__m128i *)(v2 + 18);
                  v346 = *(__m128i *)(v2 + 34);
                  v347 = *(__m128i *)(v2 + 50);
                  v348 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v346, v347), _mm_min_epu8(v345, v332)), v5));
                  v349 = v347;
                  v350 = _mm_alignr_epi8(v347, v346, 14);
                  v351 = _mm_alignr_epi8(v346, v345, 14);
                  if ( v348 )
                    break;
                  v352 = _mm_alignr_epi8(v345, v332, 14);
                  v2 += 64LL;
                  v353 = _mm_alignr_epi8(v332, v331, 14);
                  v331 = v349;
                  *(__m128i *)(v3 + 48) = v350;
                  *(__m128i *)(v3 + 32) = v351;
                  *(__m128i *)(v3 + 16) = v352;
                  *(__m128i *)v3 = v353;
                  v3 += 64LL;
                }
              }
              v7 = 2LL;
              *(_DWORD *)(v3 - 2) = *(_DWORD *)(v2 - 2);
              break;
            default:
              v354 = *(__m128i *)(v2 - 15);
              v355 = *(__m128i *)(v2 + 1);
              while ( 1 )
              {
                v356 = _mm_cmpeq_epi8(v5, v355);
                v6 = _mm_movemask_epi8(v356);
                v357 = v355;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v355, v354, 15);
                v358 = *(__m128i *)(v2 + 17);
                v359 = _mm_cmpeq_epi8(v356, v358);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v359);
                v2 += 16LL;
                v360 = v358;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v358, v357, 15);
                v361 = *(__m128i *)(v2 + 17);
                v362 = _mm_cmpeq_epi8(v359, v361);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v362);
                v2 += 16LL;
                v363 = v361;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v361, v360, 15);
                v364 = *(__m128i *)(v2 + 17);
                v5 = _mm_cmpeq_epi8(v362, v364);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v364, v363, 15);
                v365 = v2 + 17;
                v366 = (v2 + 17) & 0xFFFFFFFFFFFFFFC0LL;
                v367 = v365 - v366;
                v2 = v366 - 1;
                v3 = v3 + 16 - v367;
                v354 = *(__m128i *)(v2 - 15);
                while ( 1 )
                {
                  v355 = *(__m128i *)(v2 + 1);
                  v368 = *(__m128i *)(v2 + 17);
                  v369 = *(__m128i *)(v2 + 33);
                  v370 = *(__m128i *)(v2 + 49);
                  v371 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v369, v370), _mm_min_epu8(v368, v355)), v5));
                  v372 = v370;
                  v373 = _mm_alignr_epi8(v370, v369, 15);
                  v374 = _mm_alignr_epi8(v369, v368, 15);
                  if ( v371 )
                    break;
                  v375 = _mm_alignr_epi8(v368, v355, 15);
                  v2 += 64LL;
                  v376 = _mm_alignr_epi8(v355, v354, 15);
                  v354 = v372;
                  *(__m128i *)(v3 + 48) = v373;
                  *(__m128i *)(v3 + 32) = v374;
                  *(__m128i *)(v3 + 16) = v375;
                  *(__m128i *)v3 = v376;
                  v3 += 64LL;
                }
              }
              v7 = 1LL;
              *(_DWORD *)(v3 - 3) = *(_DWORD *)(v2 - 3);
              break;
          }
        }
        else
        {
          switch ( v8 )
          {
            case 1uLL:
              v30 = *(__m128i *)(v2 - 1);
              v31 = *(__m128i *)(v2 + 15);
              while ( 1 )
              {
                v32 = _mm_cmpeq_epi8(v5, v31);
                v6 = _mm_movemask_epi8(v32);
                v33 = v31;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v31, v30, 1);
                v34 = *(__m128i *)(v2 + 31);
                v35 = _mm_cmpeq_epi8(v32, v34);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v35);
                v2 += 16LL;
                v36 = v34;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v34, v33, 1);
                v37 = *(__m128i *)(v2 + 31);
                v38 = _mm_cmpeq_epi8(v35, v37);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v38);
                v2 += 16LL;
                v39 = v37;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v37, v36, 1);
                v40 = *(__m128i *)(v2 + 31);
                v5 = _mm_cmpeq_epi8(v38, v40);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v40, v39, 1);
                v41 = v2 + 31;
                v42 = (v2 + 31) & 0xFFFFFFFFFFFFFFC0LL;
                v43 = v41 - v42;
                v2 = v42 - 15;
                v3 = v3 + 16 - v43;
                v30 = *(__m128i *)(v2 - 1);
                while ( 1 )
                {
                  v31 = *(__m128i *)(v2 + 15);
                  v44 = *(__m128i *)(v2 + 31);
                  v45 = *(__m128i *)(v2 + 47);
                  v46 = *(__m128i *)(v2 + 63);
                  v47 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v45, v46), _mm_min_epu8(v44, v31)), v5));
                  v48 = v46;
                  v49 = _mm_alignr_epi8(v46, v45, 1);
                  v50 = _mm_alignr_epi8(v45, v44, 1);
                  if ( v47 )
                    break;
                  v51 = _mm_alignr_epi8(v44, v31, 1);
                  v2 += 64LL;
                  v52 = _mm_alignr_epi8(v31, v30, 1);
                  v30 = v48;
                  *(__m128i *)(v3 + 48) = v49;
                  *(__m128i *)(v3 + 32) = v50;
                  *(__m128i *)(v3 + 16) = v51;
                  *(__m128i *)v3 = v52;
                  v3 += 64LL;
                }
              }
              v7 = 15LL;
              *(__m128i *)(v3 - 1) = _mm_loadu_si128((const __m128i *)(v2 - 1));
              break;
            case 2uLL:
              v53 = *(__m128i *)(v2 - 2);
              v54 = *(__m128i *)(v2 + 14);
              while ( 1 )
              {
                v55 = _mm_cmpeq_epi8(v5, v54);
                v6 = _mm_movemask_epi8(v55);
                v56 = v54;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v54, v53, 2);
                v57 = *(__m128i *)(v2 + 30);
                v58 = _mm_cmpeq_epi8(v55, v57);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v58);
                v2 += 16LL;
                v59 = v57;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v57, v56, 2);
                v60 = *(__m128i *)(v2 + 30);
                v61 = _mm_cmpeq_epi8(v58, v60);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v61);
                v2 += 16LL;
                v62 = v60;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v60, v59, 2);
                v63 = *(__m128i *)(v2 + 30);
                v5 = _mm_cmpeq_epi8(v61, v63);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v63, v62, 2);
                v64 = v2 + 30;
                v65 = (v2 + 30) & 0xFFFFFFFFFFFFFFC0LL;
                v66 = v64 - v65;
                v2 = v65 - 14;
                v3 = v3 + 16 - v66;
                v53 = *(__m128i *)(v2 - 2);
                while ( 1 )
                {
                  v54 = *(__m128i *)(v2 + 14);
                  v67 = *(__m128i *)(v2 + 30);
                  v68 = *(__m128i *)(v2 + 46);
                  v69 = *(__m128i *)(v2 + 62);
                  v70 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v68, v69), _mm_min_epu8(v67, v54)), v5));
                  v71 = v69;
                  v72 = _mm_alignr_epi8(v69, v68, 2);
                  v73 = _mm_alignr_epi8(v68, v67, 2);
                  if ( v70 )
                    break;
                  v74 = _mm_alignr_epi8(v67, v54, 2);
                  v2 += 64LL;
                  v75 = _mm_alignr_epi8(v54, v53, 2);
                  v53 = v71;
                  *(__m128i *)(v3 + 48) = v72;
                  *(__m128i *)(v3 + 32) = v73;
                  *(__m128i *)(v3 + 16) = v74;
                  *(__m128i *)v3 = v75;
                  v3 += 64LL;
                }
              }
              v7 = 14LL;
              *(__m128i *)(v3 - 2) = _mm_loadu_si128((const __m128i *)(v2 - 2));
              break;
            case 3uLL:
              v76 = *(__m128i *)(v2 - 3);
              v77 = *(__m128i *)(v2 + 13);
              while ( 1 )
              {
                v78 = _mm_cmpeq_epi8(v5, v77);
                v6 = _mm_movemask_epi8(v78);
                v79 = v77;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v77, v76, 3);
                v80 = *(__m128i *)(v2 + 29);
                v81 = _mm_cmpeq_epi8(v78, v80);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v81);
                v2 += 16LL;
                v82 = v80;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v80, v79, 3);
                v83 = *(__m128i *)(v2 + 29);
                v84 = _mm_cmpeq_epi8(v81, v83);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v84);
                v2 += 16LL;
                v85 = v83;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v83, v82, 3);
                v86 = *(__m128i *)(v2 + 29);
                v5 = _mm_cmpeq_epi8(v84, v86);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v86, v85, 3);
                v87 = v2 + 29;
                v88 = (v2 + 29) & 0xFFFFFFFFFFFFFFC0LL;
                v89 = v87 - v88;
                v2 = v88 - 13;
                v3 = v3 + 16 - v89;
                v76 = *(__m128i *)(v2 - 3);
                while ( 1 )
                {
                  v77 = *(__m128i *)(v2 + 13);
                  v90 = *(__m128i *)(v2 + 29);
                  v91 = *(__m128i *)(v2 + 45);
                  v92 = *(__m128i *)(v2 + 61);
                  v93 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v91, v92), _mm_min_epu8(v90, v77)), v5));
                  v94 = v92;
                  v95 = _mm_alignr_epi8(v92, v91, 3);
                  v96 = _mm_alignr_epi8(v91, v90, 3);
                  if ( v93 )
                    break;
                  v97 = _mm_alignr_epi8(v90, v77, 3);
                  v2 += 64LL;
                  v98 = _mm_alignr_epi8(v77, v76, 3);
                  v76 = v94;
                  *(__m128i *)(v3 + 48) = v95;
                  *(__m128i *)(v3 + 32) = v96;
                  *(__m128i *)(v3 + 16) = v97;
                  *(__m128i *)v3 = v98;
                  v3 += 64LL;
                }
              }
              v7 = 13LL;
              *(__m128i *)(v3 - 3) = _mm_loadu_si128((const __m128i *)(v2 - 3));
              break;
            case 4uLL:
              v99 = *(__m128i *)(v2 - 4);
              v100 = *(__m128i *)(v2 + 12);
              while ( 1 )
              {
                v101 = _mm_cmpeq_epi8(v5, v100);
                v6 = _mm_movemask_epi8(v101);
                v102 = v100;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v100, v99, 4);
                v103 = *(__m128i *)(v2 + 28);
                v104 = _mm_cmpeq_epi8(v101, v103);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v104);
                v2 += 16LL;
                v105 = v103;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v103, v102, 4);
                v106 = *(__m128i *)(v2 + 28);
                v107 = _mm_cmpeq_epi8(v104, v106);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v107);
                v2 += 16LL;
                v108 = v106;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v106, v105, 4);
                v109 = *(__m128i *)(v2 + 28);
                v5 = _mm_cmpeq_epi8(v107, v109);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v109, v108, 4);
                v110 = v2 + 28;
                v111 = (v2 + 28) & 0xFFFFFFFFFFFFFFC0LL;
                v112 = v110 - v111;
                v2 = v111 - 12;
                v3 = v3 + 16 - v112;
                v99 = *(__m128i *)(v2 - 4);
                while ( 1 )
                {
                  v100 = *(__m128i *)(v2 + 12);
                  v113 = *(__m128i *)(v2 + 28);
                  v114 = *(__m128i *)(v2 + 44);
                  v115 = *(__m128i *)(v2 + 60);
                  v116 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v114, v115), _mm_min_epu8(v113, v100)), v5));
                  v117 = v115;
                  v118 = _mm_alignr_epi8(v115, v114, 4);
                  v119 = _mm_alignr_epi8(v114, v113, 4);
                  if ( v116 )
                    break;
                  v120 = _mm_alignr_epi8(v113, v100, 4);
                  v2 += 64LL;
                  v121 = _mm_alignr_epi8(v100, v99, 4);
                  v99 = v117;
                  *(__m128i *)(v3 + 48) = v118;
                  *(__m128i *)(v3 + 32) = v119;
                  *(__m128i *)(v3 + 16) = v120;
                  *(__m128i *)v3 = v121;
                  v3 += 64LL;
                }
              }
              v7 = 12LL;
              *(__m128i *)(v3 - 4) = _mm_loadu_si128((const __m128i *)(v2 - 4));
              break;
            case 5uLL:
              v122 = *(__m128i *)(v2 - 5);
              v123 = *(__m128i *)(v2 + 11);
              while ( 1 )
              {
                v124 = _mm_cmpeq_epi8(v5, v123);
                v6 = _mm_movemask_epi8(v124);
                v125 = v123;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v123, v122, 5);
                v126 = *(__m128i *)(v2 + 27);
                v127 = _mm_cmpeq_epi8(v124, v126);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v127);
                v2 += 16LL;
                v128 = v126;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v126, v125, 5);
                v129 = *(__m128i *)(v2 + 27);
                v130 = _mm_cmpeq_epi8(v127, v129);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v130);
                v2 += 16LL;
                v131 = v129;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v129, v128, 5);
                v132 = *(__m128i *)(v2 + 27);
                v5 = _mm_cmpeq_epi8(v130, v132);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v132, v131, 5);
                v133 = v2 + 27;
                v134 = (v2 + 27) & 0xFFFFFFFFFFFFFFC0LL;
                v135 = v133 - v134;
                v2 = v134 - 11;
                v3 = v3 + 16 - v135;
                v122 = *(__m128i *)(v2 - 5);
                while ( 1 )
                {
                  v123 = *(__m128i *)(v2 + 11);
                  v136 = *(__m128i *)(v2 + 27);
                  v137 = *(__m128i *)(v2 + 43);
                  v138 = *(__m128i *)(v2 + 59);
                  v139 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v137, v138), _mm_min_epu8(v136, v123)), v5));
                  v140 = v138;
                  v141 = _mm_alignr_epi8(v138, v137, 5);
                  v142 = _mm_alignr_epi8(v137, v136, 5);
                  if ( v139 )
                    break;
                  v143 = _mm_alignr_epi8(v136, v123, 5);
                  v2 += 64LL;
                  v144 = _mm_alignr_epi8(v123, v122, 5);
                  v122 = v140;
                  *(__m128i *)(v3 + 48) = v141;
                  *(__m128i *)(v3 + 32) = v142;
                  *(__m128i *)(v3 + 16) = v143;
                  *(__m128i *)v3 = v144;
                  v3 += 64LL;
                }
              }
              v7 = 11LL;
              *(__m128i *)(v3 - 5) = _mm_loadu_si128((const __m128i *)(v2 - 5));
              break;
            case 6uLL:
              v145 = *(__m128i *)(v2 - 6);
              v146 = *(__m128i *)(v2 + 10);
              while ( 1 )
              {
                v147 = _mm_cmpeq_epi8(v5, v146);
                v6 = _mm_movemask_epi8(v147);
                v148 = v146;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v146, v145, 6);
                v149 = *(__m128i *)(v2 + 26);
                v150 = _mm_cmpeq_epi8(v147, v149);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v150);
                v2 += 16LL;
                v151 = v149;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v149, v148, 6);
                v152 = *(__m128i *)(v2 + 26);
                v153 = _mm_cmpeq_epi8(v150, v152);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v153);
                v2 += 16LL;
                v154 = v152;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v152, v151, 6);
                v155 = *(__m128i *)(v2 + 26);
                v5 = _mm_cmpeq_epi8(v153, v155);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v155, v154, 6);
                v156 = v2 + 26;
                v157 = (v2 + 26) & 0xFFFFFFFFFFFFFFC0LL;
                v158 = v156 - v157;
                v2 = v157 - 10;
                v3 = v3 + 16 - v158;
                v145 = *(__m128i *)(v2 - 6);
                while ( 1 )
                {
                  v146 = *(__m128i *)(v2 + 10);
                  v159 = *(__m128i *)(v2 + 26);
                  v160 = *(__m128i *)(v2 + 42);
                  v161 = *(__m128i *)(v2 + 58);
                  v162 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v160, v161), _mm_min_epu8(v159, v146)), v5));
                  v163 = v161;
                  v164 = _mm_alignr_epi8(v161, v160, 6);
                  v165 = _mm_alignr_epi8(v160, v159, 6);
                  if ( v162 )
                    break;
                  v166 = _mm_alignr_epi8(v159, v146, 6);
                  v2 += 64LL;
                  v167 = _mm_alignr_epi8(v146, v145, 6);
                  v145 = v163;
                  *(__m128i *)(v3 + 48) = v164;
                  *(__m128i *)(v3 + 32) = v165;
                  *(__m128i *)(v3 + 16) = v166;
                  *(__m128i *)v3 = v167;
                  v3 += 64LL;
                }
              }
              v168 = *(_DWORD *)(v2 + 6);
              *(_QWORD *)v3 = *(_QWORD *)v2;
              *(_DWORD *)(v3 + 6) = v168;
              v7 = 10LL;
              break;
            default:
              v169 = *(__m128i *)(v2 - 7);
              v170 = *(__m128i *)(v2 + 9);
              while ( 1 )
              {
                v171 = _mm_cmpeq_epi8(v5, v170);
                v6 = _mm_movemask_epi8(v171);
                v172 = v170;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v170, v169, 7);
                v173 = *(__m128i *)(v2 + 25);
                v174 = _mm_cmpeq_epi8(v171, v173);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v174);
                v2 += 16LL;
                v175 = v173;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v173, v172, 7);
                v176 = *(__m128i *)(v2 + 25);
                v177 = _mm_cmpeq_epi8(v174, v176);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v177);
                v2 += 16LL;
                v178 = v176;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v176, v175, 7);
                v179 = *(__m128i *)(v2 + 25);
                v5 = _mm_cmpeq_epi8(v177, v179);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v179, v178, 7);
                v180 = v2 + 25;
                v181 = (v2 + 25) & 0xFFFFFFFFFFFFFFC0LL;
                v182 = v180 - v181;
                v2 = v181 - 9;
                v3 = v3 + 16 - v182;
                v169 = *(__m128i *)(v2 - 7);
                while ( 1 )
                {
                  v170 = *(__m128i *)(v2 + 9);
                  v183 = *(__m128i *)(v2 + 25);
                  v184 = *(__m128i *)(v2 + 41);
                  v185 = *(__m128i *)(v2 + 57);
                  v186 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v184, v185), _mm_min_epu8(v183, v170)), v5));
                  v187 = v185;
                  v188 = _mm_alignr_epi8(v185, v184, 7);
                  v189 = _mm_alignr_epi8(v184, v183, 7);
                  if ( v186 )
                    break;
                  v190 = _mm_alignr_epi8(v183, v170, 7);
                  v2 += 64LL;
                  v191 = _mm_alignr_epi8(v170, v169, 7);
                  v169 = v187;
                  *(__m128i *)(v3 + 48) = v188;
                  *(__m128i *)(v3 + 32) = v189;
                  *(__m128i *)(v3 + 16) = v190;
                  *(__m128i *)v3 = v191;
                  v3 += 64LL;
                }
              }
              v192 = *(_DWORD *)(v2 + 5);
              *(_QWORD *)v3 = *(_QWORD *)v2;
              *(_DWORD *)(v3 + 5) = v192;
              v7 = 9LL;
              break;
          }
        }
      }
      else
      {
        v9 = *(__m128i *)(v2 + 16);
        *(_OWORD *)v3 = *(_OWORD *)v2;
        v10 = _mm_cmpeq_epi8(v5, v9);
        v6 = _mm_movemask_epi8(v10);
        v7 = 16LL;
        if ( !v6 )
        {
          v11 = *(__m128i *)(v2 + 32);
          *(__m128i *)((char *)&word_10 + ((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL)) = v9;
          v12 = _mm_cmpeq_epi8(v10, v11);
          v6 = _mm_movemask_epi8(v12);
          v7 = 32LL;
          if ( !v6 )
          {
            v13 = *(__m128i *)(v2 + 48);
            *(__m128i *)((char *)qword_20 + ((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL)) = v11;
            v14 = _mm_cmpeq_epi8(v12, v13);
            v6 = _mm_movemask_epi8(v14);
            v7 = 48LL;
            if ( !v6 )
            {
              v15 = *(__m128i *)(v2 + 64);
              *(__m128i *)((char *)&dword_30 + ((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL)) = v13;
              v16 = _mm_cmpeq_epi8(v14, v15);
              v6 = _mm_movemask_epi8(v16);
              v7 = 64LL;
              if ( !v6 )
              {
                v17 = *(__m128i *)(v2 + 80);
                *(__m128i *)((char *)&dword_40 + ((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL)) = v15;
                v18 = _mm_cmpeq_epi8(v16, v17);
                v6 = _mm_movemask_epi8(v18);
                v7 = 80LL;
                if ( !v6 )
                {
                  v19 = *(__m128i *)(v2 + 96);
                  *(__m128i *)((char *)&qword_50 + ((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL)) = v17;
                  v20 = _mm_cmpeq_epi8(v18, v19);
                  v6 = _mm_movemask_epi8(v20);
                  v7 = 96LL;
                  if ( !v6 )
                  {
                    *(__m128i *)((char *)&qword_60 + ((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL)) = v19;
                    v21 = v2;
                    v2 = (v2 + 112) & 0xFFFFFFFFFFFFFFC0LL;
                    v3 -= v21 - v2;
                    v7 = -64LL;
                    while ( 1 )
                    {
                      v22 = *(__m128i *)v2;
                      v23 = *(__m128i *)(v2 + 16);
                      v24 = *(__m128i *)(v2 + 32);
                      v25 = *(__m128i *)(v2 + 48);
                      v26 = _mm_movemask_epi8(
                              _mm_cmpeq_epi8(
                                _mm_min_epu8(_mm_min_epu8(v24, v25), _mm_min_epu8(*(__m128i *)v2, v23)),
                                v20));
                      v3 += 64LL;
                      v2 += 64LL;
                      if ( v26 )
                        break;
                      *(__m128i *)(v3 - 64) = v22;
                      *(__m128i *)(v3 - 48) = v23;
                      *(__m128i *)(v3 - 32) = v24;
                      *(__m128i *)(v3 - 16) = v25;
                    }
                    v27 = _mm_cmpeq_epi8(v20, v22);
                    v6 = _mm_movemask_epi8(v27);
                    if ( !v6 )
                    {
                      v28 = _mm_cmpeq_epi8(v27, v23);
                      v6 = _mm_movemask_epi8(v28);
                      *(__m128i *)(v3 - 64) = v22;
                      v7 = -48LL;
                      if ( !v6 )
                      {
                        v29 = _mm_cmpeq_epi8(v28, v24);
                        v6 = _mm_movemask_epi8(v29);
                        *(__m128i *)(v3 - 48) = v23;
                        v7 = -32LL;
                        if ( !v6 )
                        {
                          *(__m128i *)(v3 - 32) = v24;
                          LOWORD(v6) = _mm_movemask_epi8(_mm_cmpeq_epi8(v29, v25));
                          v7 = -16LL;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v3 += v7;
    v2 += v7;
    if ( (_BYTE)v6 )
    {
      if ( (v6 & 1) == 0 )
      {
        if ( (v6 & 2) == 0 )
        {
          if ( (v6 & 4) == 0 )
          {
            if ( (v6 & 8) == 0 )
            {
              if ( (v6 & 0x10) == 0 )
              {
                if ( (v6 & 0x20) == 0 )
                {
                  if ( (v6 & 0x40) == 0 )
                    goto LABEL_189;
                  goto LABEL_204;
                }
LABEL_203:
                *(_DWORD *)v3 = *(_DWORD *)v2;
                *(_WORD *)(v3 + 4) = *(_WORD *)(v2 + 4);
                return v3 + 5;
              }
LABEL_202:
              *(_DWORD *)v3 = *(_DWORD *)v2;
              *(_BYTE *)(v3 + 4) = *(_BYTE *)(v2 + 4);
              return v3 + 4;
            }
LABEL_201:
            *(_DWORD *)v3 = *(_DWORD *)v2;
            return v3 + 3;
          }
LABEL_200:
          *(_WORD *)v3 = *(_WORD *)v2;
          *(_BYTE *)(v3 + 2) = *(_BYTE *)(v2 + 2);
          return v3 + 2;
        }
LABEL_199:
        *(_WORD *)v3 = *(_WORD *)v2;
        return v3 + 1;
      }
LABEL_198:
      *(_BYTE *)v3 = *(_BYTE *)v2;
      return v3;
    }
    if ( (v6 & 0x100) == 0 )
    {
      if ( (v6 & 0x200) == 0 )
      {
        if ( (v6 & 0x400) == 0 )
        {
          if ( (v6 & 0x800) == 0 )
          {
            if ( (v6 & 0x1000) == 0 )
            {
              if ( (v6 & 0x2000) == 0 )
              {
                if ( (v6 & 0x4000) == 0 )
                  goto LABEL_197;
                goto LABEL_211;
              }
LABEL_210:
              *(_QWORD *)v3 = *(_QWORD *)v2;
              *(_QWORD *)(v3 + 6) = *(_QWORD *)(v2 + 6);
              return v3 + 13;
            }
LABEL_209:
            *(_QWORD *)v3 = *(_QWORD *)v2;
            *(_QWORD *)(v3 + 5) = *(_QWORD *)(v2 + 5);
            return v3 + 12;
          }
LABEL_208:
          *(_QWORD *)v3 = *(_QWORD *)v2;
          *(_DWORD *)(v3 + 8) = *(_DWORD *)(v2 + 8);
          return v3 + 11;
        }
LABEL_207:
        *(_QWORD *)v3 = *(_QWORD *)v2;
        *(_DWORD *)(v3 + 7) = *(_DWORD *)(v2 + 7);
        return v3 + 10;
      }
LABEL_206:
      *(_QWORD *)v3 = *(_QWORD *)v2;
      *(_DWORD *)(v3 + 6) = *(_DWORD *)(v2 + 6);
      return v3 + 9;
    }
LABEL_205:
    *(_QWORD *)v3 = *(_QWORD *)v2;
    *(_DWORD *)(v3 + 5) = *(_DWORD *)(v2 + 5);
    return v3 + 8;
  }
LABEL_211:
  *(_QWORD *)v3 = *(_QWORD *)v2;
  *(_QWORD *)(v3 + 7) = *(_QWORD *)(v2 + 7);
  return v3 + 14;
}
// 10: using guessed type __int16 word_10;
// 20: using guessed type __int64 qword_20[];
// 30: using guessed type int dword_30;
// 40: using guessed type int dword_40;
// 50: using guessed type __int64 qword_50;
// 60: using guessed type __int64 qword_60;

//----- (0000000000044220) ----------------------------------------------------
__int64 __fastcall sub_44220(__m128i *a1, const __m128i *a2)
{
  unsigned __int64 v2; // rcx
  unsigned __int64 v3; // rsi
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // rdx
  __m128i v6; // xmm0
  __int64 v7; // rdx
  __m128i *v8; // rdi
  __m128i v9; // xmm2
  __m128i v10; // xmm0
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  __m128i v13; // xmm3
  __m128i v14; // xmm0
  __m128i v15; // xmm4
  __m128i v16; // xmm0
  __m128i v17; // xmm1
  __m128i v18; // xmm0
  __m128i v19; // xmm2
  __m128i v20; // xmm0
  __m128i v21; // xmm3
  __m128i v22; // xmm0
  unsigned __int64 v23; // rdx
  unsigned __int64 v24; // rsi
  __m128i *v25; // rdi
  __m128i v26; // xmm4
  __m128i v27; // xmm5
  __m128i v28; // xmm6
  __m128i v29; // xmm7
  __m128i v30; // xmm2
  __m128i i; // xmm3
  __m128i v32; // xmm3
  __m128i v33; // xmm0
  __m128i v34; // xmm1
  __int64 v35; // rdx
  unsigned int v36; // ecx
  __int64 v37; // rdx
  unsigned int v38; // ecx
  unsigned __int64 v39; // rdx
  __int64 result; // rax
  __m128i v41; // xmm1
  __m128i v42; // xmm2
  unsigned __int64 v43; // rdx
  unsigned __int64 v44; // rdx

  v2 = (unsigned __int8)a2 & 0x3F;
  if ( v2 <= 0x20 )
  {
    v41 = _mm_loadu_si128(a2);
    v42 = _mm_loadu_si128(a2 + 1);
    v6 = _mm_cmpeq_epi8((__m128i)0LL, v41);
    v43 = (unsigned int)_mm_movemask_epi8(v6);
    if ( !(_DWORD)v43 )
    {
      v6 = _mm_cmpeq_epi8(v6, v42);
      *a1 = v41;
      v43 = (unsigned int)_mm_movemask_epi8(v6);
      if ( !(_DWORD)v43 )
      {
        v3 = (unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL;
        v4 = v2 & 0xF;
        goto LABEL_5;
      }
      ++a2;
      ++a1;
    }
    _BitScanForward64(&v43, v43);
    return ((__int64 (__fastcall *)(__m128i *, const __m128i *, double, double, double))((char *)dword_92760
                                                                                       + dword_92760[v43]))(
             a1,
             a2,
             *(double *)v6.m128i_i64,
             *(double *)v41.m128i_i64,
             *(double *)v42.m128i_i64);
  }
  v3 = (unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL;
  v4 = v2 & 0xF;
  v5 = (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)v3)) >> v4;
  if ( v5 )
  {
    _BitScanForward64(&v5, v5);
    return ((__int64 (__fastcall *)(__m128i *, unsigned __int64, double))((char *)dword_92760 + dword_92760[v5]))(
             a1,
             v4 + v3,
             0.0);
  }
  v6 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)(v3 + 16));
  LODWORD(v7) = _mm_movemask_epi8(v6);
  if ( (_DWORD)v7 )
  {
    _BitScanForward64((unsigned __int64 *)&v7, (unsigned int)v7);
    return ((__int64 (__fastcall *)(__m128i *, unsigned __int64))((char *)dword_92760 + dword_92760[v7 + 16 - v4]))(
             a1,
             v4 + v3);
  }
  *a1 = _mm_loadu_si128((const __m128i *)(v3 + v4));
LABEL_5:
  v8 = (__m128i *)((char *)a1 - v4);
  v9 = *(__m128i *)(v3 + 32);
  v8[1] = _mm_load_si128((const __m128i *)(v3 + 16));
  v10 = _mm_cmpeq_epi8(v6, v9);
  v11 = (unsigned int)_mm_movemask_epi8(v10);
  v12 = 2LL;
  if ( (_DWORD)v11 )
    goto LABEL_20;
  v13 = *(__m128i *)(v3 + 48);
  v8[2] = v9;
  v14 = _mm_cmpeq_epi8(v10, v13);
  v11 = (unsigned int)_mm_movemask_epi8(v14);
  v12 = 3LL;
  if ( (_DWORD)v11 )
    goto LABEL_20;
  v15 = *(__m128i *)(v3 + 64);
  v8[3] = v13;
  v16 = _mm_cmpeq_epi8(v14, v15);
  v11 = (unsigned int)_mm_movemask_epi8(v16);
  v12 = 4LL;
  if ( (_DWORD)v11 )
    goto LABEL_20;
  v17 = *(__m128i *)(v3 + 80);
  v8[4] = v15;
  v18 = _mm_cmpeq_epi8(v16, v17);
  v11 = (unsigned int)_mm_movemask_epi8(v18);
  v12 = 5LL;
  if ( (_DWORD)v11 )
    goto LABEL_20;
  v19 = *(__m128i *)(v3 + 96);
  v8[5] = v17;
  v20 = _mm_cmpeq_epi8(v18, v19);
  v11 = (unsigned int)_mm_movemask_epi8(v20);
  v12 = 6LL;
  if ( (_DWORD)v11
    || (v21 = *(__m128i *)(v3 + 112),
        v8[6] = v19,
        v22 = _mm_cmpeq_epi8(v20, v21),
        v11 = (unsigned int)_mm_movemask_epi8(v22),
        v12 = 7LL,
        (_DWORD)v11) )
  {
LABEL_20:
    _BitScanForward64(&v11, v11);
    result = ((__int64 (__fastcall *)(__m128i *, unsigned __int64))((char *)dword_92760 + dword_92760[v11]))(
               &v8[v12],
               v12 * 16 + v3);
  }
  else
  {
    v8[7] = v21;
    v23 = v3;
    v24 = (v3 + 128) & 0xFFFFFFFFFFFFFFC0LL;
    v25 = (__m128i *)((char *)v8 - (v23 - v24));
    v26 = *(__m128i *)v24;
    v27 = *(__m128i *)(v24 + 16);
    v28 = *(__m128i *)(v24 + 32);
    v29 = *(__m128i *)(v24 + 48);
    v30 = _mm_min_epu8(*(__m128i *)v24, v27);
    for ( i = _mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v28, v29), v30), v22);
          !_mm_movemask_epi8(i);
          i = _mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v32, v29), v30), v22) )
    {
      v25 += 4;
      v24 += 64LL;
      v25[-4] = v26;
      v26 = *(__m128i *)v24;
      v25[-3] = v27;
      v27 = *(__m128i *)(v24 + 16);
      v30 = _mm_min_epu8(v26, v27);
      v32 = *(__m128i *)(v24 + 32);
      v25[-2] = v28;
      v28 = v32;
      v25[-1] = v29;
      v29 = *(__m128i *)(v24 + 48);
    }
    v33 = _mm_cmpeq_epi8(v22, v26);
    v34 = _mm_cmpeq_epi8((__m128i)0LL, v27);
    LODWORD(v35) = _mm_movemask_epi8(v33);
    v36 = _mm_movemask_epi8(v34);
    if ( (_DWORD)v35 )
    {
      _BitScanForward64((unsigned __int64 *)&v35, (unsigned int)v35);
      result = ((__int64 (__fastcall *)(__m128i *, double, double, double, double, double, double, double))((char *)dword_92760 + dword_92760[v35]))(
                 v25,
                 *(double *)v33.m128i_i64,
                 *(double *)v34.m128i_i64,
                 *(double *)v30.m128i_i64,
                 *(double *)i.m128i_i64,
                 *(double *)v26.m128i_i64,
                 *(double *)v27.m128i_i64,
                 *(double *)v28.m128i_i64);
    }
    else if ( v36 )
    {
      _BitScanForward64(&v44, v36);
      *v25 = v26;
      result = ((__int64 (__fastcall *)(__m128i *, unsigned __int64, double, double, double, double, double, double, double))((char *)dword_92760 + dword_92760[v44]))(
                 &v25[1],
                 v24 + 16,
                 *(double *)v33.m128i_i64,
                 *(double *)v34.m128i_i64,
                 *(double *)v30.m128i_i64,
                 *(double *)i.m128i_i64,
                 *(double *)v26.m128i_i64,
                 *(double *)v27.m128i_i64,
                 *(double *)v28.m128i_i64);
    }
    else
    {
      LODWORD(v37) = _mm_movemask_epi8(_mm_cmpeq_epi8(v33, v28));
      v38 = _mm_movemask_epi8(_mm_cmpeq_epi8(v34, v29));
      if ( (_DWORD)v37 )
      {
        _BitScanForward64((unsigned __int64 *)&v37, (unsigned int)v37);
        *v25 = v26;
        v25[1] = v27;
        result = ((__int64 (__fastcall *)(__m128i *, unsigned __int64))((char *)dword_92760 + dword_92760[v37]))(
                   &v25[2],
                   v24 + 32);
      }
      else
      {
        _BitScanForward64(&v39, v38);
        *v25 = v26;
        v25[1] = v27;
        v25[2] = v28;
        result = ((__int64 (__fastcall *)(__m128i *, unsigned __int64))((char *)dword_92760 + dword_92760[v39]))(
                   &v25[3],
                   v24 + 48);
      }
    }
  }
  return result;
}

//----- (0000000000044850) ----------------------------------------------------
__int64 __fastcall sub_44850(__m128i *a1, const __m128i *a2)
{
  unsigned __int64 v2; // rcx
  unsigned __int64 v3; // rsi
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // rdx
  __m128i v6; // xmm0
  __int64 v7; // rdx
  __m128i *v8; // rdi
  __m128i v9; // xmm2
  __m128i v10; // xmm0
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  __m128i v13; // xmm3
  __m128i v14; // xmm0
  __m128i v15; // xmm4
  __m128i v16; // xmm0
  __m128i v17; // xmm1
  __m128i v18; // xmm0
  __m128i v19; // xmm2
  __m128i v20; // xmm0
  __m128i v21; // xmm3
  __m128i v22; // xmm0
  unsigned __int64 v23; // rdx
  unsigned __int64 v24; // rsi
  __m128i *v25; // rdi
  __m128i v26; // xmm4
  __m128i v27; // xmm5
  __m128i v28; // xmm6
  __m128i v29; // xmm7
  __m128i v30; // xmm2
  __m128i i; // xmm3
  __m128i v32; // xmm3
  __m128i v33; // xmm0
  __m128i v34; // xmm1
  __int64 v35; // rdx
  unsigned int v36; // ecx
  __int64 v37; // rdx
  unsigned int v38; // ecx
  unsigned __int64 v39; // rdx
  __int64 result; // rax
  __m128i v41; // xmm1
  __m128i v42; // xmm2
  unsigned __int64 v43; // rdx
  unsigned __int64 v44; // rdx

  v2 = (unsigned __int8)a2 & 0x3F;
  if ( v2 <= 0x20 )
  {
    v41 = _mm_loadu_si128(a2);
    v42 = _mm_loadu_si128(a2 + 1);
    v6 = _mm_cmpeq_epi8((__m128i)0LL, v41);
    v43 = (unsigned int)_mm_movemask_epi8(v6);
    if ( !(_DWORD)v43 )
    {
      v6 = _mm_cmpeq_epi8(v6, v42);
      *a1 = v41;
      v43 = (unsigned int)_mm_movemask_epi8(v6);
      if ( !(_DWORD)v43 )
      {
        v3 = (unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL;
        v4 = v2 & 0xF;
        goto LABEL_5;
      }
      ++a2;
      ++a1;
    }
    _BitScanForward64(&v43, v43);
    return ((__int64 (__fastcall *)(__m128i *, const __m128i *, double, double, double))((char *)dword_927E0
                                                                                       + dword_927E0[v43]))(
             a1,
             a2,
             *(double *)v6.m128i_i64,
             *(double *)v41.m128i_i64,
             *(double *)v42.m128i_i64);
  }
  v3 = (unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL;
  v4 = v2 & 0xF;
  v5 = (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)v3)) >> v4;
  if ( v5 )
  {
    _BitScanForward64(&v5, v5);
    return ((__int64 (__fastcall *)(__m128i *, unsigned __int64, double))((char *)dword_927E0 + dword_927E0[v5]))(
             a1,
             v4 + v3,
             0.0);
  }
  v6 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)(v3 + 16));
  LODWORD(v7) = _mm_movemask_epi8(v6);
  if ( (_DWORD)v7 )
  {
    _BitScanForward64((unsigned __int64 *)&v7, (unsigned int)v7);
    return ((__int64 (__fastcall *)(__m128i *, unsigned __int64))((char *)dword_927E0 + dword_927E0[v7 + 16 - v4]))(
             a1,
             v4 + v3);
  }
  *a1 = _mm_loadu_si128((const __m128i *)(v3 + v4));
LABEL_5:
  v8 = (__m128i *)((char *)a1 - v4);
  v9 = *(__m128i *)(v3 + 32);
  v8[1] = _mm_load_si128((const __m128i *)(v3 + 16));
  v10 = _mm_cmpeq_epi8(v6, v9);
  v11 = (unsigned int)_mm_movemask_epi8(v10);
  v12 = 2LL;
  if ( (_DWORD)v11 )
    goto LABEL_20;
  v13 = *(__m128i *)(v3 + 48);
  v8[2] = v9;
  v14 = _mm_cmpeq_epi8(v10, v13);
  v11 = (unsigned int)_mm_movemask_epi8(v14);
  v12 = 3LL;
  if ( (_DWORD)v11 )
    goto LABEL_20;
  v15 = *(__m128i *)(v3 + 64);
  v8[3] = v13;
  v16 = _mm_cmpeq_epi8(v14, v15);
  v11 = (unsigned int)_mm_movemask_epi8(v16);
  v12 = 4LL;
  if ( (_DWORD)v11 )
    goto LABEL_20;
  v17 = *(__m128i *)(v3 + 80);
  v8[4] = v15;
  v18 = _mm_cmpeq_epi8(v16, v17);
  v11 = (unsigned int)_mm_movemask_epi8(v18);
  v12 = 5LL;
  if ( (_DWORD)v11 )
    goto LABEL_20;
  v19 = *(__m128i *)(v3 + 96);
  v8[5] = v17;
  v20 = _mm_cmpeq_epi8(v18, v19);
  v11 = (unsigned int)_mm_movemask_epi8(v20);
  v12 = 6LL;
  if ( (_DWORD)v11
    || (v21 = *(__m128i *)(v3 + 112),
        v8[6] = v19,
        v22 = _mm_cmpeq_epi8(v20, v21),
        v11 = (unsigned int)_mm_movemask_epi8(v22),
        v12 = 7LL,
        (_DWORD)v11) )
  {
LABEL_20:
    _BitScanForward64(&v11, v11);
    result = ((__int64 (__fastcall *)(__m128i *, unsigned __int64))((char *)dword_927E0 + dword_927E0[v11]))(
               &v8[v12],
               v12 * 16 + v3);
  }
  else
  {
    v8[7] = v21;
    v23 = v3;
    v24 = (v3 + 128) & 0xFFFFFFFFFFFFFFC0LL;
    v25 = (__m128i *)((char *)v8 - (v23 - v24));
    v26 = *(__m128i *)v24;
    v27 = *(__m128i *)(v24 + 16);
    v28 = *(__m128i *)(v24 + 32);
    v29 = *(__m128i *)(v24 + 48);
    v30 = _mm_min_epu8(*(__m128i *)v24, v27);
    for ( i = _mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v28, v29), v30), v22);
          !_mm_movemask_epi8(i);
          i = _mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v32, v29), v30), v22) )
    {
      v25 += 4;
      v24 += 64LL;
      v25[-4] = v26;
      v26 = *(__m128i *)v24;
      v25[-3] = v27;
      v27 = *(__m128i *)(v24 + 16);
      v30 = _mm_min_epu8(v26, v27);
      v32 = *(__m128i *)(v24 + 32);
      v25[-2] = v28;
      v28 = v32;
      v25[-1] = v29;
      v29 = *(__m128i *)(v24 + 48);
    }
    v33 = _mm_cmpeq_epi8(v22, v26);
    v34 = _mm_cmpeq_epi8((__m128i)0LL, v27);
    LODWORD(v35) = _mm_movemask_epi8(v33);
    v36 = _mm_movemask_epi8(v34);
    if ( (_DWORD)v35 )
    {
      _BitScanForward64((unsigned __int64 *)&v35, (unsigned int)v35);
      result = ((__int64 (__fastcall *)(__m128i *, double, double, double, double, double, double, double))((char *)dword_927E0 + dword_927E0[v35]))(
                 v25,
                 *(double *)v33.m128i_i64,
                 *(double *)v34.m128i_i64,
                 *(double *)v30.m128i_i64,
                 *(double *)i.m128i_i64,
                 *(double *)v26.m128i_i64,
                 *(double *)v27.m128i_i64,
                 *(double *)v28.m128i_i64);
    }
    else if ( v36 )
    {
      _BitScanForward64(&v44, v36);
      *v25 = v26;
      result = ((__int64 (__fastcall *)(__m128i *, unsigned __int64, double, double, double, double, double, double, double))((char *)dword_927E0 + dword_927E0[v44]))(
                 &v25[1],
                 v24 + 16,
                 *(double *)v33.m128i_i64,
                 *(double *)v34.m128i_i64,
                 *(double *)v30.m128i_i64,
                 *(double *)i.m128i_i64,
                 *(double *)v26.m128i_i64,
                 *(double *)v27.m128i_i64,
                 *(double *)v28.m128i_i64);
    }
    else
    {
      LODWORD(v37) = _mm_movemask_epi8(_mm_cmpeq_epi8(v33, v28));
      v38 = _mm_movemask_epi8(_mm_cmpeq_epi8(v34, v29));
      if ( (_DWORD)v37 )
      {
        _BitScanForward64((unsigned __int64 *)&v37, (unsigned int)v37);
        *v25 = v26;
        v25[1] = v27;
        result = ((__int64 (__fastcall *)(__m128i *, unsigned __int64))((char *)dword_927E0 + dword_927E0[v37]))(
                   &v25[2],
                   v24 + 32);
      }
      else
      {
        _BitScanForward64(&v39, v38);
        *v25 = v26;
        v25[1] = v27;
        v25[2] = v28;
        result = ((__int64 (__fastcall *)(__m128i *, unsigned __int64))((char *)dword_927E0 + dword_927E0[v39]))(
                   &v25[3],
                   v24 + 48);
      }
    }
  }
  return result;
}

//----- (0000000000044F10) ----------------------------------------------------
__int64 __fastcall sub_44F10(__int64 _RDI, unsigned __int64 _RSI, unsigned __int64 _RDX, __m128 _XMM0)
{
  unsigned int v6; // ecx
  __int64 result; // rax
  __int64 v54; // r9

  __asm { vpxor   xmm0, xmm0, xmm0 }
  v6 = _RSI & 0x7F;
  if ( v6 <= 0x40 )
  {
    __asm
    {
      vmovdqu ymm3, ymmword ptr [rsi]
      vmovdqu ymm2, ymmword ptr [rsi+20h]
      vpcmpeqb ymm1, ymm0, ymm3
      vpmovmskb edx, ymm1
    }
    if ( (_DWORD)_RDX )
    {
LABEL_22:
      _BitScanForward((unsigned int *)&_RDX, _RDX);
      goto LABEL_23;
    }
    __asm
    {
      vmovdqu ymmword ptr [rdi], ymm3
      vpcmpeqb ymm1, ymm0, ymm2
      vpmovmskb edx, ymm1
    }
    if ( (_DWORD)_RDX )
    {
      _RSI += 32LL;
      _RDI += 32LL;
      goto LABEL_22;
    }
    _RSI = _RSI & 0xFFFFFFFFFFFFFFE0LL;
    _RCX = v6 & 0x1F;
    goto LABEL_5;
  }
  _RSI = _RSI & 0xFFFFFFFFFFFFFFE0LL;
  _RCX = v6 & 0x1F;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rsi]
    vpmovmskb edx, ymm1
  }
  _RDX = _RDX >> _RCX;
  if ( (_DWORD)_RDX )
  {
LABEL_21:
    _RSI = _RCX + _RSI;
    goto LABEL_22;
  }
  __asm
  {
    vpcmpeqb ymm2, ymm0, ymmword ptr [rsi+20h]
    vpmovmskb edx, ymm2
  }
  if ( !_EDX )
  {
    __asm
    {
      vmovdqu ymm2, ymmword ptr [rsi+rcx]
      vmovdqu ymmword ptr [rdi], ymm2
    }
LABEL_5:
    _RDI = _RDI - _RCX;
    _RCX = 32LL;
    __asm
    {
      vmovdqa ymm2, ymmword ptr [rsi+rcx]
      vmovdqu ymmword ptr [rdi+rcx], ymm2
      vmovdqa ymm2, ymmword ptr [rsi+rcx+20h]
      vpcmpeqb ymm1, ymm0, ymm2
      vpmovmskb edx, ymm1
    }
    _RCX = 64LL;
    if ( !(_DWORD)_RDX )
    {
      __asm
      {
        vmovdqu ymmword ptr [rdi+rcx], ymm2
        vmovdqa ymm3, ymmword ptr [rsi+rcx+20h]
        vpcmpeqb ymm1, ymm0, ymm3
        vpmovmskb edx, ymm1
      }
      _RCX = 96LL;
      if ( !(_DWORD)_RDX )
      {
        __asm
        {
          vmovdqu ymmword ptr [rdi+rcx], ymm3
          vmovdqa ymm4, ymmword ptr [rsi+rcx+20h]
          vpcmpeqb ymm1, ymm0, ymm4
          vpmovmskb edx, ymm1
        }
        _RCX = 128LL;
        if ( !(_DWORD)_RDX )
        {
          __asm
          {
            vmovdqu ymmword ptr [rdi+rcx], ymm4
            vmovdqa ymm2, ymmword ptr [rsi+rcx+20h]
            vpcmpeqb ymm1, ymm0, ymm2
            vpmovmskb edx, ymm1
          }
          _RCX = 160LL;
          if ( !(_DWORD)_RDX )
          {
            __asm
            {
              vmovdqu ymmword ptr [rdi+rcx], ymm2
              vmovdqa ymm2, ymmword ptr [rsi+rcx+20h]
              vpcmpeqb ymm1, ymm0, ymm2
              vpmovmskb edx, ymm1
            }
            _RCX = 192LL;
            if ( !(_DWORD)_RDX )
            {
              __asm
              {
                vmovdqa ymm3, ymmword ptr [rsi+rcx+20h]
                vmovdqu ymmword ptr [rdi+rcx], ymm2
                vpcmpeqb ymm1, ymm0, ymm3
                vpmovmskb edx, ymm1
              }
              _RCX = 224LL;
              if ( !(_DWORD)_RDX )
              {
                __asm { vmovdqu ymmword ptr [rdi+rcx], ymm3 }
                _RDX = _RSI;
                _RSI = (_RSI + 256) & 0xFFFFFFFFFFFFFF80LL;
                _RDI = _RDI - (_RDX - _RSI);
                __asm
                {
                  vmovdqa ymm4, ymmword ptr [rsi]
                  vmovdqa ymm5, ymmword ptr [rsi+20h]
                  vmovdqa ymm6, ymmword ptr [rsi+40h]
                  vmovdqa ymm7, ymmword ptr [rsi+60h]
                  vpminub ymm2, ymm4, ymm5
                  vpminub ymm3, ymm6, ymm7
                  vpminub ymm3, ymm3, ymm2
                  vpcmpeqb ymm3, ymm3, ymm1
                  vpmovmskb edx, ymm3
                }
                if ( !(_DWORD)_RDX )
                {
                  do
                  {
                    _RDI += 128LL;
                    _RSI += 128LL;
                    __asm
                    {
                      vmovdqu ymmword ptr [rdi-80h], ymm4
                      vmovdqa ymm4, ymmword ptr [rsi]
                      vmovdqu ymmword ptr [rdi-60h], ymm5
                      vmovdqa ymm5, ymmword ptr [rsi+20h]
                      vpminub ymm2, ymm4, ymm5
                      vmovdqu ymmword ptr [rdi-40h], ymm6
                      vmovdqa ymm6, ymmword ptr [rsi+40h]
                      vmovdqu ymmword ptr [rdi-20h], ymm7
                      vmovdqa ymm7, ymmword ptr [rsi+60h]
                      vpminub ymm3, ymm6, ymm7
                      vpminub ymm3, ymm3, ymm2
                      vpcmpeqb ymm3, ymm3, ymm1
                      vpmovmskb edx, ymm3
                    }
                  }
                  while ( !_EDX );
                }
                __asm
                {
                  vpcmpeqb ymm1, ymm0, ymm4
                  vpmovmskb edx, ymm1
                }
                if ( !(_DWORD)_RDX )
                {
                  __asm
                  {
                    vpcmpeqb ymm1, ymm0, ymm5
                    vpmovmskb ecx, ymm1
                  }
                  if ( _ECX )
                  {
                    _BitScanForward((unsigned int *)&_RDX, _ECX);
                    __asm { vmovdqu ymmword ptr [rdi], ymm4 }
                    _RSI += 32LL;
                    _RDI += 32LL;
                  }
                  else
                  {
                    __asm
                    {
                      vpcmpeqb ymm1, ymm0, ymm6
                      vpmovmskb edx, ymm1
                    }
                    if ( (_DWORD)_RDX )
                    {
                      _BitScanForward((unsigned int *)&_RDX, _RDX);
                      __asm
                      {
                        vmovdqu ymmword ptr [rdi], ymm4
                        vmovdqu ymmword ptr [rdi+20h], ymm5
                      }
                      _RSI += 64LL;
                      _RDI += 64LL;
                    }
                    else
                    {
                      __asm
                      {
                        vpcmpeqb ymm1, ymm0, ymm7
                        vpmovmskb ecx, ymm1
                      }
                      _BitScanForward((unsigned int *)&_RDX, _ECX);
                      __asm
                      {
                        vmovdqu ymmword ptr [rdi], ymm4
                        vmovdqu ymmword ptr [rdi+20h], ymm5
                        vmovdqu ymmword ptr [rdi+40h], ymm6
                      }
                      _RSI += 96LL;
                      _RDI += 96LL;
                    }
                  }
                  goto LABEL_23;
                }
                goto LABEL_22;
              }
            }
          }
        }
      }
    }
    _RDI = _RCX + _RDI;
    goto LABEL_21;
  }
  _BitScanForward(&_EDX, _EDX);
  _RSI = _RCX + _RSI;
  _RDX = _EDX + 32 - (unsigned int)_RCX;
LABEL_23:
  if ( (unsigned int)_RDX >= 0x20 )
  {
    __asm
    {
      vmovdqu ymm2, ymmword ptr [rsi]
      vmovdqu ymm3, ymmword ptr [rsi+rdx-1Fh]
      vmovdqu ymmword ptr [rdi], ymm2
      vmovdqu ymmword ptr [rdi+rdx-1Fh], ymm3
    }
    result = _RDI + _RDX;
    __asm { vzeroupper }
  }
  else if ( (unsigned int)_RDX >= 0x10 )
  {
    __asm
    {
      vmovdqu xmm2, xmmword ptr [rsi]
      vmovdqu xmm3, xmmword ptr [rsi+rdx-0Fh]
      vmovdqu xmmword ptr [rdi], xmm2
      vmovdqu xmmword ptr [rdi+rdx-0Fh], xmm3
    }
    result = _RDI + _RDX;
    __asm { vzeroupper }
  }
  else if ( (unsigned int)_RDX >= 8 )
  {
    v54 = *(_QWORD *)(_RSI + _RDX - 7);
    *(_QWORD *)_RDI = *(_QWORD *)_RSI;
    *(_QWORD *)(_RDI + _RDX - 7) = v54;
    result = _RDI + _RDX;
    __asm { vzeroupper }
  }
  else if ( (unsigned int)_RDX >= 4 )
  {
    *(_DWORD *)_RDI = *(_DWORD *)_RSI;
    *(_DWORD *)(_RDI + _RDX - 3) = *(_DWORD *)(_RSI + _RDX - 3);
    result = _RDI + _RDX;
    __asm { vzeroupper }
  }
  else if ( (_DWORD)_RDX == 3 )
  {
    *(_DWORD *)_RDI = *(_DWORD *)_RSI;
    result = _RDI + 3;
    __asm { vzeroupper }
  }
  else if ( (unsigned int)_RDX > 1 )
  {
    *(_WORD *)_RDI = *(_WORD *)_RSI;
    *(_BYTE *)(_RDI + 2) = 0;
    result = _RDI + 2;
    __asm { vzeroupper }
  }
  else if ( (_DWORD)_RDX == 1 )
  {
    *(_WORD *)_RDI = *(_WORD *)_RSI;
    result = _RDI + 1;
    __asm { vzeroupper }
  }
  else
  {
    *(_BYTE *)_RDI = 0;
    result = _RDI;
    __asm { vzeroupper }
  }
  return result;
}
// 45244: variable '_RDX' is possibly undefined

//----- (00000000000452C0) ----------------------------------------------------
const __m128i *__fastcall sub_452C0(__int64 a1, unsigned int a2)
{
  __m128i v2; // xmm1
  __m128i v3; // xmm1
  __m128i v4; // xmm1
  char v5; // cl
  __m128i v6; // xmm3
  const __m128i *v7; // rdi
  int v8; // eax
  int v9; // edx
  __m128i v10; // xmm0
  __m128i v11; // xmm3
  const __m128i *v13; // rdi

  v2 = _mm_cvtsi32_si128(a2);
  v3 = _mm_unpacklo_epi8(v2, v2);
  v4 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v3, v3), 0);
  v5 = a1 - (a1 & 0xF0);
  v6 = _mm_load_si128((const __m128i *)(a1 & 0xFFFFFFFFFFFFFFF0LL));
  v7 = (const __m128i *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 16);
  v8 = (-1 << v5) & _mm_movemask_epi8(_mm_cmpeq_epi8(v6, v4));
  v9 = (-1 << v5) & _mm_movemask_epi8(_mm_cmpeq_epi8(v6, (__m128i)0LL));
  if ( !v8 )
  {
    if ( v9 )
      return 0LL;
    do
    {
      v10 = _mm_load_si128(v7++);
      v11 = _mm_cmpeq_epi8(v10, (__m128i)0LL);
      v8 = _mm_movemask_epi8(_mm_cmpeq_epi8(v10, v4));
    }
    while ( !(v8 | _mm_movemask_epi8(v11)) );
    v9 = _mm_movemask_epi8(v11);
    if ( !v8 )
      return 0LL;
  }
  v13 = v7 - 1;
  if ( !v9 )
  {
    if ( (_BYTE)v8 )
    {
      if ( (v8 & 1) == 0 )
      {
        if ( (v8 & 2) == 0 )
        {
          if ( (v8 & 4) == 0 )
          {
            if ( (v8 & 8) != 0 )
              return (const __m128i *)&v13->m128i_i8[3];
            if ( (v8 & 0x10) == 0 )
            {
              if ( (v8 & 0x20) == 0 )
              {
                if ( (v8 & 0x40) == 0 )
                  return (const __m128i *)&v13->m128i_i8[7];
                return (const __m128i *)&v13->m128i_i8[6];
              }
              return (const __m128i *)&v13->m128i_i8[5];
            }
            return (const __m128i *)&v13->m128i_i8[4];
          }
          return (const __m128i *)&v13->m128i_i8[2];
        }
        return (const __m128i *)&v13->m128i_i8[1];
      }
      return v13;
    }
    if ( (v8 & 0x100) == 0 )
    {
      if ( (v8 & 0x200) == 0 )
      {
        if ( (v8 & 0x400) == 0 )
        {
          if ( (v8 & 0x800) != 0 )
            return (const __m128i *)&v13->m128i_i8[11];
          if ( (v8 & 0x1000) == 0 )
          {
            if ( (v8 & 0x2000) == 0 )
            {
              if ( (v8 & 0x4000) == 0 )
                return (const __m128i *)&v13->m128i_i8[15];
              return (const __m128i *)&v13->m128i_i8[14];
            }
            return (const __m128i *)&v13->m128i_i8[13];
          }
          return (const __m128i *)&v13->m128i_i8[12];
        }
        return (const __m128i *)&v13->m128i_i8[10];
      }
      return (const __m128i *)&v13->m128i_i8[9];
    }
    return (const __m128i *)&v13->m128i_i8[8];
  }
  if ( !(_BYTE)v8 )
  {
    if ( (_BYTE)v9 )
      return 0LL;
    if ( (v8 & 0xF00) == 0 )
    {
      if ( (v9 & 0xF00) != 0 )
        return 0LL;
      if ( (v8 & 0x1000) == 0 )
      {
        if ( (v9 & 0x1000) != 0 )
          return 0LL;
        if ( (v8 & 0x2000) == 0 )
        {
          if ( (v9 & 0x2000) != 0 )
            return 0LL;
          if ( (v8 & 0x4000) == 0 )
          {
            if ( (v9 & 0x4000) != 0 )
              return 0LL;
            return (const __m128i *)&v13->m128i_i8[15];
          }
          return (const __m128i *)&v13->m128i_i8[14];
        }
        return (const __m128i *)&v13->m128i_i8[13];
      }
      return (const __m128i *)&v13->m128i_i8[12];
    }
    if ( (v8 & 0x100) == 0 )
    {
      if ( (v9 & 0x100) != 0 )
        return 0LL;
      if ( (v8 & 0x200) == 0 )
      {
        if ( (v9 & 0x200) != 0 )
          return 0LL;
        if ( (v8 & 0x400) == 0 )
        {
          if ( (v9 & 0x400) != 0 )
            return 0LL;
          return (const __m128i *)&v13->m128i_i8[11];
        }
        return (const __m128i *)&v13->m128i_i8[10];
      }
      return (const __m128i *)&v13->m128i_i8[9];
    }
    return (const __m128i *)&v13->m128i_i8[8];
  }
  if ( (v8 & 0xF) == 0 )
  {
    if ( (v9 & 0xF) != 0 )
      return 0LL;
    if ( (v8 & 0x10) == 0 )
    {
      if ( (v9 & 0x10) != 0 )
        return 0LL;
      if ( (v8 & 0x20) == 0 )
      {
        if ( (v9 & 0x20) != 0 )
          return 0LL;
        if ( (v8 & 0x40) == 0 )
        {
          if ( (v9 & 0x40) == 0 )
            return (const __m128i *)&v13->m128i_i8[7];
          return 0LL;
        }
        return (const __m128i *)&v13->m128i_i8[6];
      }
      return (const __m128i *)&v13->m128i_i8[5];
    }
    return (const __m128i *)&v13->m128i_i8[4];
  }
  if ( (v8 & 1) != 0 )
    return v13;
  if ( (v9 & 1) != 0 )
    return 0LL;
  if ( (v8 & 2) != 0 )
    return (const __m128i *)&v13->m128i_i8[1];
  if ( (v9 & 2) != 0 )
    return 0LL;
  if ( (v8 & 4) != 0 )
    return (const __m128i *)&v13->m128i_i8[2];
  if ( (v9 & 4) != 0 )
    return 0LL;
  return (const __m128i *)&v13->m128i_i8[3];
}

//----- (00000000000455E0) ----------------------------------------------------
__int64 __fastcall sub_455E0(const __m128i *a1, const __m128i *a2, unsigned __int64 a3)
{
  signed __int64 v3; // rcx
  __int8 *v4; // rsi
  __int8 *v5; // rdi
  int v6; // edx
  unsigned __int64 v7; // rdi
  const __m128i *v8; // rsi
  int v9; // edx
  unsigned __int64 v10; // rdx
  __m128i *v11; // rsi
  unsigned __int64 v12; // rcx
  __int64 v13; // rdx
  __int64 v14; // rax
  __m128i v15; // xmm1
  int v16; // edx
  __m128i v17; // xmm0
  __m128i v18; // xmm2
  __m128i v19; // xmm2
  __m128i v20; // xmm2
  int v21; // edx
  __m128i v22; // xmm0
  __m128i v23; // xmm3
  int v24; // edx
  __m128i v25; // xmm3
  __m128i v26; // xmm3
  __m128i v27; // xmm2
  int v28; // edx
  __m128i v29; // xmm0
  __m128i v30; // xmm3
  int v31; // edx
  __m128i v32; // xmm3
  __m128i v33; // xmm3
  __m128i v34; // xmm2
  int v35; // edx
  __m128i v36; // xmm0
  __m128i v37; // xmm3
  int v38; // edx
  __m128i v39; // xmm3
  __m128i v40; // xmm3
  __m128i v41; // xmm2
  int v42; // edx
  __m128i v43; // xmm0
  __m128i v44; // xmm3
  int v45; // edx
  __m128i v46; // xmm3
  __m128i v47; // xmm3
  __m128i v48; // xmm2
  int v49; // edx
  __m128i v50; // xmm0
  __m128i v51; // xmm3
  int v52; // edx
  __m128i v53; // xmm3
  __m128i v54; // xmm3
  __m128i v55; // xmm2
  int v56; // edx
  __m128i v57; // xmm0
  __m128i v58; // xmm3
  int v59; // edx
  __m128i v60; // xmm3
  __m128i v61; // xmm3
  __m128i v62; // xmm2
  int v63; // edx
  __m128i v64; // xmm0
  __m128i v65; // xmm3
  int v66; // edx
  __m128i v67; // xmm3
  __m128i v68; // xmm3
  __m128i v69; // xmm2
  int v70; // edx
  __m128i v71; // xmm0
  __m128i v72; // xmm3
  int v73; // edx
  __m128i v74; // xmm3
  __m128i v75; // xmm3
  __m128i v76; // xmm2
  int v77; // edx
  __m128i v78; // xmm0
  __m128i v79; // xmm3
  int v80; // edx
  __m128i v81; // xmm3
  __m128i v82; // xmm3
  __m128i v83; // xmm2
  int v84; // edx
  __m128i v85; // xmm0
  __m128i v86; // xmm3
  int v87; // edx
  __m128i v88; // xmm3
  __m128i v89; // xmm3
  __m128i v90; // xmm2
  int v91; // edx
  __m128i v92; // xmm0
  __m128i v93; // xmm3
  int v94; // edx
  __m128i v95; // xmm3
  __m128i v96; // xmm3
  __m128i v97; // xmm2
  int v98; // edx
  __m128i v99; // xmm0
  __m128i v100; // xmm3
  int v101; // edx
  __m128i v102; // xmm3
  __m128i v103; // xmm3
  __m128i v104; // xmm2
  int v105; // edx
  __m128i v106; // xmm0
  __m128i v107; // xmm3
  int v108; // edx
  __m128i v109; // xmm3
  __m128i v110; // xmm3
  __m128i v111; // xmm2
  int v112; // edx
  __m128i v113; // xmm0
  __m128i v114; // xmm3
  int v115; // edx
  __m128i v116; // xmm3
  __m128i v117; // xmm3
  __m128i v118; // xmm2
  int v119; // edx
  __m128i v120; // xmm0
  __m128i v121; // xmm3
  int v122; // edx
  __m128i v123; // xmm3
  __m128i v124; // xmm3
  int v125; // er8
  unsigned int v127; // eax
  unsigned int v128; // ecx
  unsigned __int8 v129; // al
  bool v130; // cf
  unsigned int v131; // eax
  unsigned int v132; // ecx
  unsigned int v133; // eax
  unsigned int v134; // ecx
  unsigned __int8 v135; // al
  unsigned int v136; // eax
  unsigned int v137; // ecx

  v3 = a3;
  if ( a3 < 0x30 )
  {
    v4 = &a2->m128i_i8[a3];
    v5 = &a1->m128i_i8[a3];
    goto LABEL_209;
  }
  v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), _mm_loadu_si128(a2)));
  v7 = (unsigned __int64)&a1[1];
  v8 = a2 + 1;
  v9 = v6 - 0xFFFF;
  if ( v9 )
  {
LABEL_185:
    if ( (_BYTE)v9 )
    {
      if ( (v9 & 1) == 0 )
      {
        if ( (v9 & 2) == 0 )
        {
          if ( (v9 & 4) == 0 )
          {
            if ( (v9 & 8) == 0 )
            {
              if ( (v9 & 0x10) == 0 )
              {
                if ( (v9 & 0x20) == 0 )
                {
                  if ( (v9 & 0x40) == 0 )
                    return *(unsigned __int8 *)(v7 - 9) - (unsigned int)v8[-1].m128i_u8[7];
                  return *(unsigned __int8 *)(v7 - 10) - (unsigned int)v8[-1].m128i_u8[6];
                }
                return *(unsigned __int8 *)(v7 - 11) - (unsigned int)v8[-1].m128i_u8[5];
              }
              return *(unsigned __int8 *)(v7 - 12) - (unsigned int)v8[-1].m128i_u8[4];
            }
            return *(unsigned __int8 *)(v7 - 13) - (unsigned int)v8[-1].m128i_u8[3];
          }
          return *(unsigned __int8 *)(v7 - 14) - (unsigned int)v8[-1].m128i_u8[2];
        }
        return *(unsigned __int8 *)(v7 - 15) - (unsigned int)v8[-1].m128i_u8[1];
      }
    }
    else
    {
      v7 += 8LL;
      v8 = (const __m128i *)((char *)v8 + 8);
      if ( (v9 & 0x100) == 0 )
      {
        if ( (v9 & 0x200) == 0 )
        {
          if ( (v9 & 0x400) == 0 )
          {
            if ( (v9 & 0x800) == 0 )
            {
              if ( (v9 & 0x1000) == 0 )
              {
                if ( (v9 & 0x2000) == 0 )
                {
                  if ( (v9 & 0x4000) == 0 )
                    return *(unsigned __int8 *)(v7 - 9) - (unsigned int)v8[-1].m128i_u8[7];
                  return *(unsigned __int8 *)(v7 - 10) - (unsigned int)v8[-1].m128i_u8[6];
                }
                return *(unsigned __int8 *)(v7 - 11) - (unsigned int)v8[-1].m128i_u8[5];
              }
              return *(unsigned __int8 *)(v7 - 12) - (unsigned int)v8[-1].m128i_u8[4];
            }
            return *(unsigned __int8 *)(v7 - 13) - (unsigned int)v8[-1].m128i_u8[3];
          }
          return *(unsigned __int8 *)(v7 - 14) - (unsigned int)v8[-1].m128i_u8[2];
        }
        return *(unsigned __int8 *)(v7 - 15) - (unsigned int)v8[-1].m128i_u8[1];
      }
    }
    return *(unsigned __int8 *)(v7 - 16) - (unsigned int)v8[-1].m128i_u8[0];
  }
  v10 = v7 & 0xF;
  v7 ^= v10;
  v11 = (__m128i *)((char *)v8 - v10);
  v12 = v10 + v3;
  v13 = (unsigned __int8)v11 & 0xF;
  if ( ((unsigned __int8)v11 & 0xF) == 0 )
    goto LABEL_22;
  v11 = (__m128i *)(v13 ^ (unsigned __int64)v11);
  if ( (unsigned int)v13 < 8 )
  {
    if ( (_DWORD)v13 )
    {
      switch ( (_DWORD)v13 )
      {
        case 1:
          v130 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 1LL;
          if ( v130 )
          {
            v20 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v20, *v11, 1), *(__m128i *)v7);
            v21 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v20, 1), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32LL;
            v11 += 2;
            v9 = v21 - 0xFFFF;
            if ( !v9 )
            {
              v4 = &v11->m128i_i8[v3 + 1];
              v5 = (__int8 *)(v3 + v7);
              goto LABEL_209;
            }
          }
          else
          {
            v3 -= 32LL;
            v22 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 1), *(__m128i *)v7);
            v23 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 1), *(__m128i *)(v7 + 16));
            do
            {
              v130 = (unsigned __int64)v3 < 0x20;
              v3 -= 32LL;
              v24 = _mm_movemask_epi8(_mm_and_si128(v23, v22));
              v15 = v22;
              v25 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 1);
              v9 = v24 - (v130 + 0xFFFF);
              v22 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 1), *(__m128i *)(v7 + 32));
              v11 += 2;
              v23 = _mm_cmpeq_epi8(v25, *(__m128i *)(v7 + 48));
              v7 += 32LL;
            }
            while ( !v9 );
            v26 = _mm_and_si128(v23, v22);
            if ( v3 < 0 )
            {
              ++v9;
              v3 += 32LL;
            }
            if ( !v9 )
            {
              v15 = v22;
              v7 += 32LL;
              v11 += 2;
              v9 = _mm_movemask_epi8(v26) - 0xFFFF;
              if ( !v9 )
              {
                v4 = &v11->m128i_i8[v3 + 1];
                v5 = (__int8 *)(v3 + v7);
                goto LABEL_209;
              }
            }
          }
          break;
        case 2:
          v130 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 2LL;
          if ( v130 )
          {
            v27 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v27, *v11, 2), *(__m128i *)v7);
            v28 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v27, 2), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32LL;
            v11 += 2;
            v9 = v28 - 0xFFFF;
            if ( !v9 )
            {
              v4 = &v11->m128i_i8[v3 + 2];
              v5 = (__int8 *)(v3 + v7);
              goto LABEL_209;
            }
          }
          else
          {
            v3 -= 32LL;
            v29 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 2), *(__m128i *)v7);
            v30 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 2), *(__m128i *)(v7 + 16));
            do
            {
              v130 = (unsigned __int64)v3 < 0x20;
              v3 -= 32LL;
              v31 = _mm_movemask_epi8(_mm_and_si128(v30, v29));
              v15 = v29;
              v32 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 2);
              v9 = v31 - (v130 + 0xFFFF);
              v29 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 2), *(__m128i *)(v7 + 32));
              v11 += 2;
              v30 = _mm_cmpeq_epi8(v32, *(__m128i *)(v7 + 48));
              v7 += 32LL;
            }
            while ( !v9 );
            v33 = _mm_and_si128(v30, v29);
            if ( v3 < 0 )
            {
              ++v9;
              v3 += 32LL;
            }
            if ( !v9 )
            {
              v15 = v29;
              v7 += 32LL;
              v11 += 2;
              v9 = _mm_movemask_epi8(v33) - 0xFFFF;
              if ( !v9 )
              {
                v4 = &v11->m128i_i8[v3 + 2];
                v5 = (__int8 *)(v3 + v7);
                goto LABEL_209;
              }
            }
          }
          break;
        case 3:
          v130 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 3LL;
          if ( v130 )
          {
            v34 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v34, *v11, 3), *(__m128i *)v7);
            v35 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v34, 3), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32LL;
            v11 += 2;
            v9 = v35 - 0xFFFF;
            if ( !v9 )
            {
              v4 = &v11->m128i_i8[v3 + 3];
              v5 = (__int8 *)(v3 + v7);
              goto LABEL_209;
            }
          }
          else
          {
            v3 -= 32LL;
            v36 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 3), *(__m128i *)v7);
            v37 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 3), *(__m128i *)(v7 + 16));
            do
            {
              v130 = (unsigned __int64)v3 < 0x20;
              v3 -= 32LL;
              v38 = _mm_movemask_epi8(_mm_and_si128(v37, v36));
              v15 = v36;
              v39 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 3);
              v9 = v38 - (v130 + 0xFFFF);
              v36 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 3), *(__m128i *)(v7 + 32));
              v11 += 2;
              v37 = _mm_cmpeq_epi8(v39, *(__m128i *)(v7 + 48));
              v7 += 32LL;
            }
            while ( !v9 );
            v40 = _mm_and_si128(v37, v36);
            if ( v3 < 0 )
            {
              ++v9;
              v3 += 32LL;
            }
            if ( !v9 )
            {
              v15 = v36;
              v7 += 32LL;
              v11 += 2;
              v9 = _mm_movemask_epi8(v40) - 0xFFFF;
              if ( !v9 )
              {
                v4 = &v11->m128i_i8[v3 + 3];
                v5 = (__int8 *)(v3 + v7);
                goto LABEL_209;
              }
            }
          }
          break;
        case 4:
          v130 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 4LL;
          if ( v130 )
          {
            v41 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v41, *v11, 4), *(__m128i *)v7);
            v42 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v41, 4), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32LL;
            v11 += 2;
            v9 = v42 - 0xFFFF;
            if ( !v9 )
            {
              v4 = &v11->m128i_i8[v3 + 4];
              v5 = (__int8 *)(v3 + v7);
              goto LABEL_209;
            }
          }
          else
          {
            v3 -= 32LL;
            v43 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 4), *(__m128i *)v7);
            v44 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 4), *(__m128i *)(v7 + 16));
            do
            {
              v130 = (unsigned __int64)v3 < 0x20;
              v3 -= 32LL;
              v45 = _mm_movemask_epi8(_mm_and_si128(v44, v43));
              v15 = v43;
              v46 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 4);
              v9 = v45 - (v130 + 0xFFFF);
              v43 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 4), *(__m128i *)(v7 + 32));
              v11 += 2;
              v44 = _mm_cmpeq_epi8(v46, *(__m128i *)(v7 + 48));
              v7 += 32LL;
            }
            while ( !v9 );
            v47 = _mm_and_si128(v44, v43);
            if ( v3 < 0 )
            {
              ++v9;
              v3 += 32LL;
            }
            if ( !v9 )
            {
              v15 = v43;
              v7 += 32LL;
              v11 += 2;
              v9 = _mm_movemask_epi8(v47) - 0xFFFF;
              if ( !v9 )
              {
                v4 = &v11->m128i_i8[v3 + 4];
                v5 = (__int8 *)(v3 + v7);
                goto LABEL_209;
              }
            }
          }
          break;
        case 5:
          v130 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 5LL;
          if ( v130 )
          {
            v48 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v48, *v11, 5), *(__m128i *)v7);
            v49 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v48, 5), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32LL;
            v11 += 2;
            v9 = v49 - 0xFFFF;
            if ( !v9 )
            {
              v4 = &v11->m128i_i8[v3 + 5];
              v5 = (__int8 *)(v3 + v7);
              goto LABEL_209;
            }
          }
          else
          {
            v3 -= 32LL;
            v50 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 5), *(__m128i *)v7);
            v51 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 5), *(__m128i *)(v7 + 16));
            do
            {
              v130 = (unsigned __int64)v3 < 0x20;
              v3 -= 32LL;
              v52 = _mm_movemask_epi8(_mm_and_si128(v51, v50));
              v15 = v50;
              v53 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 5);
              v9 = v52 - (v130 + 0xFFFF);
              v50 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 5), *(__m128i *)(v7 + 32));
              v11 += 2;
              v51 = _mm_cmpeq_epi8(v53, *(__m128i *)(v7 + 48));
              v7 += 32LL;
            }
            while ( !v9 );
            v54 = _mm_and_si128(v51, v50);
            if ( v3 < 0 )
            {
              ++v9;
              v3 += 32LL;
            }
            if ( !v9 )
            {
              v15 = v50;
              v7 += 32LL;
              v11 += 2;
              v9 = _mm_movemask_epi8(v54) - 0xFFFF;
              if ( !v9 )
              {
                v4 = &v11->m128i_i8[v3 + 5];
                v5 = (__int8 *)(v3 + v7);
                goto LABEL_209;
              }
            }
          }
          break;
        case 6:
          v130 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 6LL;
          if ( v130 )
          {
            v55 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v55, *v11, 6), *(__m128i *)v7);
            v56 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v55, 6), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32LL;
            v11 += 2;
            v9 = v56 - 0xFFFF;
            if ( !v9 )
            {
              v4 = &v11->m128i_i8[v3 + 6];
              v5 = (__int8 *)(v3 + v7);
              goto LABEL_209;
            }
          }
          else
          {
            v3 -= 32LL;
            v57 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 6), *(__m128i *)v7);
            v58 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 6), *(__m128i *)(v7 + 16));
            do
            {
              v130 = (unsigned __int64)v3 < 0x20;
              v3 -= 32LL;
              v59 = _mm_movemask_epi8(_mm_and_si128(v58, v57));
              v15 = v57;
              v60 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 6);
              v9 = v59 - (v130 + 0xFFFF);
              v57 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 6), *(__m128i *)(v7 + 32));
              v11 += 2;
              v58 = _mm_cmpeq_epi8(v60, *(__m128i *)(v7 + 48));
              v7 += 32LL;
            }
            while ( !v9 );
            v61 = _mm_and_si128(v58, v57);
            if ( v3 < 0 )
            {
              ++v9;
              v3 += 32LL;
            }
            if ( !v9 )
            {
              v15 = v57;
              v7 += 32LL;
              v11 += 2;
              v9 = _mm_movemask_epi8(v61) - 0xFFFF;
              if ( !v9 )
              {
                v4 = &v11->m128i_i8[v3 + 6];
                v5 = (__int8 *)(v3 + v7);
                goto LABEL_209;
              }
            }
          }
          break;
        default:
          v130 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = (unsigned int)v13;
          if ( v130 )
          {
            v62 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v62, *v11, 7), *(__m128i *)v7);
            v63 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v62, 7), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32LL;
            v11 += 2;
            v9 = v63 - 0xFFFF;
            if ( !v9 )
            {
              v4 = &v11->m128i_i8[v3 + 7];
              v5 = (__int8 *)(v3 + v7);
              goto LABEL_209;
            }
            break;
          }
          v3 -= 32LL;
          v64 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 7), *(__m128i *)v7);
          v65 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 7), *(__m128i *)(v7 + 16));
          do
          {
            v130 = (unsigned __int64)v3 < 0x20;
            v3 -= 32LL;
            v66 = _mm_movemask_epi8(_mm_and_si128(v65, v64));
            v15 = v64;
            v67 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 7);
            v9 = v66 - (v130 + 0xFFFF);
            v64 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 7), *(__m128i *)(v7 + 32));
            v11 += 2;
            v65 = _mm_cmpeq_epi8(v67, *(__m128i *)(v7 + 48));
            v7 += 32LL;
          }
          while ( !v9 );
          v68 = _mm_and_si128(v65, v64);
          if ( v3 < 0 )
          {
            ++v9;
            v3 += 32LL;
          }
          if ( !v9 )
          {
            v15 = v64;
            v7 += 32LL;
            v11 += 2;
            v9 = _mm_movemask_epi8(v68) - 0xFFFF;
            if ( !v9 )
            {
              v4 = &v11->m128i_i8[v3 + 7];
              v5 = (__int8 *)(v3 + v7);
              goto LABEL_209;
            }
          }
          break;
      }
LABEL_182:
      v125 = _mm_movemask_epi8(v15) - 0xFFFF;
      if ( v125 )
      {
        --v11;
        v7 -= 16LL;
        LOWORD(v9) = v125;
      }
      v8 = (__m128i *)((char *)v11 + v14);
      goto LABEL_185;
    }
LABEL_22:
    v130 = v12 < 0x50;
    v3 = v12 - 48;
    if ( v130 )
    {
      v14 = 0LL;
      v15 = _mm_cmpeq_epi8(_mm_load_si128(v11), *(__m128i *)v7);
      v16 = _mm_movemask_epi8(_mm_and_si128(_mm_cmpeq_epi8(_mm_load_si128(v11 + 1), *(__m128i *)(v7 + 16)), v15));
      v7 += 32LL;
      v11 += 2;
      v9 = v16 - 0xFFFF;
      if ( !v9 )
      {
        v4 = &v11->m128i_i8[v3];
        v5 = (__int8 *)(v3 + v7);
        goto LABEL_209;
      }
    }
    else
    {
      v14 = 0LL;
      v17 = _mm_cmpeq_epi8(_mm_load_si128(v11), *(__m128i *)v7);
      v3 -= 32LL;
      v18 = _mm_cmpeq_epi8(_mm_load_si128(v11 + 1), *(__m128i *)(v7 + 16));
      do
      {
        v130 = (unsigned __int64)v3 < 0x20;
        v3 -= 32LL;
        v15 = v17;
        v9 = _mm_movemask_epi8(_mm_and_si128(v18, v17)) - (v130 + 0xFFFF);
        v17 = _mm_cmpeq_epi8(_mm_load_si128(v11 + 2), *(__m128i *)(v7 + 32));
        v18 = _mm_cmpeq_epi8(_mm_load_si128(v11 + 3), *(__m128i *)(v7 + 48));
        v7 += 32LL;
        v11 += 2;
      }
      while ( !v9 );
      v19 = _mm_and_si128(v18, v17);
      if ( v3 < 0 )
      {
        ++v9;
        v3 += 32LL;
      }
      if ( !v9 )
      {
        v15 = v17;
        v7 += 32LL;
        v11 += 2;
        v9 = _mm_movemask_epi8(v19) - 0xFFFF;
        if ( !v9 )
        {
          v4 = &v11->m128i_i8[v3];
          v5 = (__int8 *)(v3 + v7);
          goto LABEL_209;
        }
      }
    }
    goto LABEL_182;
  }
  switch ( (_DWORD)v13 )
  {
    case 8:
      v130 = v12 < 0x50;
      v3 = v12 - 48;
      v14 = 8LL;
      if ( v130 )
      {
        v69 = _mm_load_si128(v11 + 1);
        v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v69, *v11, 8), *(__m128i *)v7);
        v70 = _mm_movemask_epi8(
                _mm_and_si128(
                  _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v69, 8), *(__m128i *)(v7 + 16)),
                  v15));
        v7 += 32LL;
        v11 += 2;
        v9 = v70 - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 8];
        v5 = (__int8 *)(v3 + v7);
      }
      else
      {
        v3 -= 32LL;
        v71 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 8), *(__m128i *)v7);
        v72 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 8), *(__m128i *)(v7 + 16));
        do
        {
          v130 = (unsigned __int64)v3 < 0x20;
          v3 -= 32LL;
          v73 = _mm_movemask_epi8(_mm_and_si128(v72, v71));
          v15 = v71;
          v74 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 8);
          v9 = v73 - (v130 + 0xFFFF);
          v71 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 8), *(__m128i *)(v7 + 32));
          v11 += 2;
          v72 = _mm_cmpeq_epi8(v74, *(__m128i *)(v7 + 48));
          v7 += 32LL;
        }
        while ( !v9 );
        v75 = _mm_and_si128(v72, v71);
        if ( v3 < 0 )
        {
          ++v9;
          v3 += 32LL;
        }
        if ( v9 )
          goto LABEL_182;
        v15 = v71;
        v7 += 32LL;
        v11 += 2;
        v9 = _mm_movemask_epi8(v75) - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 8];
        v5 = (__int8 *)(v3 + v7);
      }
      break;
    case 9:
      v130 = v12 < 0x50;
      v3 = v12 - 48;
      v14 = 9LL;
      if ( v130 )
      {
        v76 = _mm_load_si128(v11 + 1);
        v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v76, *v11, 9), *(__m128i *)v7);
        v77 = _mm_movemask_epi8(
                _mm_and_si128(
                  _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v76, 9), *(__m128i *)(v7 + 16)),
                  v15));
        v7 += 32LL;
        v11 += 2;
        v9 = v77 - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 9];
        v5 = (__int8 *)(v3 + v7);
      }
      else
      {
        v3 -= 32LL;
        v78 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 9), *(__m128i *)v7);
        v79 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 9), *(__m128i *)(v7 + 16));
        do
        {
          v130 = (unsigned __int64)v3 < 0x20;
          v3 -= 32LL;
          v80 = _mm_movemask_epi8(_mm_and_si128(v79, v78));
          v15 = v78;
          v81 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 9);
          v9 = v80 - (v130 + 0xFFFF);
          v78 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 9), *(__m128i *)(v7 + 32));
          v11 += 2;
          v79 = _mm_cmpeq_epi8(v81, *(__m128i *)(v7 + 48));
          v7 += 32LL;
        }
        while ( !v9 );
        v82 = _mm_and_si128(v79, v78);
        if ( v3 < 0 )
        {
          ++v9;
          v3 += 32LL;
        }
        if ( v9 )
          goto LABEL_182;
        v15 = v78;
        v7 += 32LL;
        v11 += 2;
        v9 = _mm_movemask_epi8(v82) - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 9];
        v5 = (__int8 *)(v3 + v7);
      }
      break;
    case 0xA:
      v130 = v12 < 0x50;
      v3 = v12 - 48;
      v14 = 10LL;
      if ( v130 )
      {
        v83 = _mm_load_si128(v11 + 1);
        v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v83, *v11, 10), *(__m128i *)v7);
        v84 = _mm_movemask_epi8(
                _mm_and_si128(
                  _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v83, 10), *(__m128i *)(v7 + 16)),
                  v15));
        v7 += 32LL;
        v11 += 2;
        v9 = v84 - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 10];
        v5 = (__int8 *)(v3 + v7);
      }
      else
      {
        v3 -= 32LL;
        v85 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 10), *(__m128i *)v7);
        v86 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 10), *(__m128i *)(v7 + 16));
        do
        {
          v130 = (unsigned __int64)v3 < 0x20;
          v3 -= 32LL;
          v87 = _mm_movemask_epi8(_mm_and_si128(v86, v85));
          v15 = v85;
          v88 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 10);
          v9 = v87 - (v130 + 0xFFFF);
          v85 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 10), *(__m128i *)(v7 + 32));
          v11 += 2;
          v86 = _mm_cmpeq_epi8(v88, *(__m128i *)(v7 + 48));
          v7 += 32LL;
        }
        while ( !v9 );
        v89 = _mm_and_si128(v86, v85);
        if ( v3 < 0 )
        {
          ++v9;
          v3 += 32LL;
        }
        if ( v9 )
          goto LABEL_182;
        v15 = v85;
        v7 += 32LL;
        v11 += 2;
        v9 = _mm_movemask_epi8(v89) - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 10];
        v5 = (__int8 *)(v3 + v7);
      }
      break;
    case 0xB:
      v130 = v12 < 0x50;
      v3 = v12 - 48;
      v14 = 11LL;
      if ( v130 )
      {
        v90 = _mm_load_si128(v11 + 1);
        v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v90, *v11, 11), *(__m128i *)v7);
        v91 = _mm_movemask_epi8(
                _mm_and_si128(
                  _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v90, 11), *(__m128i *)(v7 + 16)),
                  v15));
        v7 += 32LL;
        v11 += 2;
        v9 = v91 - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 11];
        v5 = (__int8 *)(v3 + v7);
      }
      else
      {
        v3 -= 32LL;
        v92 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 11), *(__m128i *)v7);
        v93 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 11), *(__m128i *)(v7 + 16));
        do
        {
          v130 = (unsigned __int64)v3 < 0x20;
          v3 -= 32LL;
          v94 = _mm_movemask_epi8(_mm_and_si128(v93, v92));
          v15 = v92;
          v95 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 11);
          v9 = v94 - (v130 + 0xFFFF);
          v92 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 11), *(__m128i *)(v7 + 32));
          v11 += 2;
          v93 = _mm_cmpeq_epi8(v95, *(__m128i *)(v7 + 48));
          v7 += 32LL;
        }
        while ( !v9 );
        v96 = _mm_and_si128(v93, v92);
        if ( v3 < 0 )
        {
          ++v9;
          v3 += 32LL;
        }
        if ( v9 )
          goto LABEL_182;
        v15 = v92;
        v7 += 32LL;
        v11 += 2;
        v9 = _mm_movemask_epi8(v96) - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 11];
        v5 = (__int8 *)(v3 + v7);
      }
      break;
    case 0xC:
      v130 = v12 < 0x50;
      v3 = v12 - 48;
      v14 = 12LL;
      if ( v130 )
      {
        v97 = _mm_load_si128(v11 + 1);
        v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v97, *v11, 12), *(__m128i *)v7);
        v98 = _mm_movemask_epi8(
                _mm_and_si128(
                  _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v97, 12), *(__m128i *)(v7 + 16)),
                  v15));
        v7 += 32LL;
        v11 += 2;
        v9 = v98 - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 12];
        v5 = (__int8 *)(v3 + v7);
      }
      else
      {
        v3 -= 32LL;
        v99 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 12), *(__m128i *)v7);
        v100 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 12), *(__m128i *)(v7 + 16));
        do
        {
          v130 = (unsigned __int64)v3 < 0x20;
          v3 -= 32LL;
          v101 = _mm_movemask_epi8(_mm_and_si128(v100, v99));
          v15 = v99;
          v102 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 12);
          v9 = v101 - (v130 + 0xFFFF);
          v99 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 12), *(__m128i *)(v7 + 32));
          v11 += 2;
          v100 = _mm_cmpeq_epi8(v102, *(__m128i *)(v7 + 48));
          v7 += 32LL;
        }
        while ( !v9 );
        v103 = _mm_and_si128(v100, v99);
        if ( v3 < 0 )
        {
          ++v9;
          v3 += 32LL;
        }
        if ( v9 )
          goto LABEL_182;
        v15 = v99;
        v7 += 32LL;
        v11 += 2;
        v9 = _mm_movemask_epi8(v103) - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 12];
        v5 = (__int8 *)(v3 + v7);
      }
      break;
    case 0xD:
      v130 = v12 < 0x50;
      v3 = v12 - 48;
      v14 = 13LL;
      if ( v130 )
      {
        v104 = _mm_load_si128(v11 + 1);
        v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v104, *v11, 13), *(__m128i *)v7);
        v105 = _mm_movemask_epi8(
                 _mm_and_si128(
                   _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v104, 13), *(__m128i *)(v7 + 16)),
                   v15));
        v7 += 32LL;
        v11 += 2;
        v9 = v105 - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 13];
        v5 = (__int8 *)(v3 + v7);
      }
      else
      {
        v3 -= 32LL;
        v106 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 13), *(__m128i *)v7);
        v107 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 13), *(__m128i *)(v7 + 16));
        do
        {
          v130 = (unsigned __int64)v3 < 0x20;
          v3 -= 32LL;
          v108 = _mm_movemask_epi8(_mm_and_si128(v107, v106));
          v15 = v106;
          v109 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 13);
          v9 = v108 - (v130 + 0xFFFF);
          v106 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 13), *(__m128i *)(v7 + 32));
          v11 += 2;
          v107 = _mm_cmpeq_epi8(v109, *(__m128i *)(v7 + 48));
          v7 += 32LL;
        }
        while ( !v9 );
        v110 = _mm_and_si128(v107, v106);
        if ( v3 < 0 )
        {
          ++v9;
          v3 += 32LL;
        }
        if ( v9 )
          goto LABEL_182;
        v15 = v106;
        v7 += 32LL;
        v11 += 2;
        v9 = _mm_movemask_epi8(v110) - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 13];
        v5 = (__int8 *)(v3 + v7);
      }
      break;
    case 0xE:
      v130 = v12 < 0x50;
      v3 = v12 - 48;
      v14 = 14LL;
      if ( v130 )
      {
        v111 = _mm_load_si128(v11 + 1);
        v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v111, *v11, 14), *(__m128i *)v7);
        v112 = _mm_movemask_epi8(
                 _mm_and_si128(
                   _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v111, 14), *(__m128i *)(v7 + 16)),
                   v15));
        v7 += 32LL;
        v11 += 2;
        v9 = v112 - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 14];
        v5 = (__int8 *)(v3 + v7);
      }
      else
      {
        v3 -= 32LL;
        v113 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 14), *(__m128i *)v7);
        v114 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 14), *(__m128i *)(v7 + 16));
        do
        {
          v130 = (unsigned __int64)v3 < 0x20;
          v3 -= 32LL;
          v115 = _mm_movemask_epi8(_mm_and_si128(v114, v113));
          v15 = v113;
          v116 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 14);
          v9 = v115 - (v130 + 0xFFFF);
          v113 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 14), *(__m128i *)(v7 + 32));
          v11 += 2;
          v114 = _mm_cmpeq_epi8(v116, *(__m128i *)(v7 + 48));
          v7 += 32LL;
        }
        while ( !v9 );
        v117 = _mm_and_si128(v114, v113);
        if ( v3 < 0 )
        {
          ++v9;
          v3 += 32LL;
        }
        if ( v9 )
          goto LABEL_182;
        v15 = v113;
        v7 += 32LL;
        v11 += 2;
        v9 = _mm_movemask_epi8(v117) - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 14];
        v5 = (__int8 *)(v3 + v7);
      }
      break;
    default:
      v130 = v12 < 0x50;
      v3 = v12 - 48;
      v14 = (unsigned int)v13;
      if ( v130 )
      {
        v118 = _mm_load_si128(v11 + 1);
        v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v118, *v11, 15), *(__m128i *)v7);
        v119 = _mm_movemask_epi8(
                 _mm_and_si128(
                   _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v118, 15), *(__m128i *)(v7 + 16)),
                   v15));
        v7 += 32LL;
        v11 += 2;
        v9 = v119 - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 15];
        v5 = (__int8 *)(v3 + v7);
      }
      else
      {
        v3 -= 32LL;
        v120 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 15), *(__m128i *)v7);
        v121 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 15), *(__m128i *)(v7 + 16));
        do
        {
          v130 = (unsigned __int64)v3 < 0x20;
          v3 -= 32LL;
          v122 = _mm_movemask_epi8(_mm_and_si128(v121, v120));
          v15 = v120;
          v123 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 15);
          v9 = v122 - (v130 + 0xFFFF);
          v120 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 15), *(__m128i *)(v7 + 32));
          v11 += 2;
          v121 = _mm_cmpeq_epi8(v123, *(__m128i *)(v7 + 48));
          v7 += 32LL;
        }
        while ( !v9 );
        v124 = _mm_and_si128(v121, v120);
        if ( v3 < 0 )
        {
          ++v9;
          v3 += 32LL;
        }
        if ( v9 )
          goto LABEL_182;
        v15 = v120;
        v7 += 32LL;
        v11 += 2;
        v9 = _mm_movemask_epi8(v124) - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 15];
        v5 = (__int8 *)(v3 + v7);
      }
      break;
  }
LABEL_209:
  if ( (unsigned int)v3 >= 8 )
  {
    if ( (unsigned int)v3 < 0x10 )
    {
      switch ( (_DWORD)v3 )
      {
        case 8:
LABEL_271:
          v127 = *((_DWORD *)v5 - 2);
          v128 = *((_DWORD *)v4 - 2);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_272:
          v127 = *((_DWORD *)v5 - 1);
          v128 = *((_DWORD *)v4 - 1);
          if ( v127 != v128 )
            goto LABEL_316;
          return 0LL;
        case 9:
LABEL_283:
          v127 = *(_DWORD *)(v5 - 9);
          v128 = *(_DWORD *)(v4 - 9);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_284:
          v127 = *(_DWORD *)(v5 - 5);
          v128 = *(_DWORD *)(v4 - 5);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_285:
          v129 = *(v5 - 1);
          v130 = v129 < (unsigned __int8)*(v4 - 1);
          if ( v129 == *(v4 - 1) )
            return 0LL;
          return -v130 - ((unsigned int)v130 - 1);
        case 0xA:
LABEL_296:
          v127 = *(_DWORD *)(v5 - 10);
          v128 = *(_DWORD *)(v4 - 10);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_297:
          v127 = *(_DWORD *)(v5 - 6);
          v128 = *(_DWORD *)(v4 - 6);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_298:
          v131 = *((unsigned __int16 *)v5 - 1);
          v132 = *((unsigned __int16 *)v4 - 1);
          v130 = (unsigned __int8)v131 < (unsigned __int8)v132;
          if ( (_BYTE)v131 == (_BYTE)v132 )
          {
            v130 = v131 < v132;
            if ( v131 == v132 )
              return 0LL;
          }
          return -v130 - ((unsigned int)v130 - 1);
        case 0xB:
LABEL_310:
          v127 = *(_DWORD *)(v5 - 11);
          v128 = *(_DWORD *)(v4 - 11);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_311;
      }
      if ( (_DWORD)v3 != 12 )
      {
        if ( (_DWORD)v3 != 13 )
        {
          if ( (_DWORD)v3 != 14 )
          {
LABEL_309:
            v127 = *(_DWORD *)(v5 - 15);
            v128 = *(_DWORD *)(v4 - 15);
            if ( v127 != v128 )
              goto LABEL_316;
            goto LABEL_310;
          }
          goto LABEL_295;
        }
        goto LABEL_282;
      }
LABEL_270:
      v127 = *((_DWORD *)v5 - 3);
      v128 = *((_DWORD *)v4 - 3);
      if ( v127 != v128 )
        goto LABEL_316;
      goto LABEL_271;
    }
    if ( (unsigned int)v3 < 0x18 )
    {
      switch ( (_DWORD)v3 )
      {
        case 0x10:
LABEL_269:
          v127 = *((_DWORD *)v5 - 4);
          v128 = *((_DWORD *)v4 - 4);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_270;
        case 0x11:
LABEL_281:
          v127 = *(_DWORD *)(v5 - 17);
          v128 = *(_DWORD *)(v4 - 17);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_282:
          v127 = *(_DWORD *)(v5 - 13);
          v128 = *(_DWORD *)(v4 - 13);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_283;
        case 0x12:
LABEL_294:
          v127 = *(_DWORD *)(v5 - 18);
          v128 = *(_DWORD *)(v4 - 18);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_295:
          v127 = *(_DWORD *)(v5 - 14);
          v128 = *(_DWORD *)(v4 - 14);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_296;
        case 0x13:
LABEL_308:
          v127 = *(_DWORD *)(v5 - 19);
          v128 = *(_DWORD *)(v4 - 19);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_309;
      }
      if ( (_DWORD)v3 != 20 )
      {
        if ( (_DWORD)v3 != 21 )
        {
          if ( (_DWORD)v3 != 22 )
          {
LABEL_307:
            v127 = *(_DWORD *)(v5 - 23);
            v128 = *(_DWORD *)(v4 - 23);
            if ( v127 != v128 )
              goto LABEL_316;
            goto LABEL_308;
          }
          goto LABEL_293;
        }
        goto LABEL_280;
      }
LABEL_268:
      v127 = *((_DWORD *)v5 - 5);
      v128 = *((_DWORD *)v4 - 5);
      if ( v127 != v128 )
        goto LABEL_316;
      goto LABEL_269;
    }
    if ( (unsigned int)v3 < 0x20 )
    {
      switch ( (_DWORD)v3 )
      {
        case 0x18:
LABEL_267:
          v127 = *((_DWORD *)v5 - 6);
          v128 = *((_DWORD *)v4 - 6);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_268;
        case 0x19:
LABEL_279:
          v127 = *(_DWORD *)(v5 - 25);
          v128 = *(_DWORD *)(v4 - 25);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_280:
          v127 = *(_DWORD *)(v5 - 21);
          v128 = *(_DWORD *)(v4 - 21);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_281;
        case 0x1A:
LABEL_292:
          v127 = *(_DWORD *)(v5 - 26);
          v128 = *(_DWORD *)(v4 - 26);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_293:
          v127 = *(_DWORD *)(v5 - 22);
          v128 = *(_DWORD *)(v4 - 22);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_294;
        case 0x1B:
LABEL_306:
          v127 = *(_DWORD *)(v5 - 27);
          v128 = *(_DWORD *)(v4 - 27);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_307;
      }
      if ( (_DWORD)v3 != 28 )
      {
        if ( (_DWORD)v3 != 29 )
        {
          if ( (_DWORD)v3 != 30 )
          {
LABEL_305:
            v127 = *(_DWORD *)(v5 - 31);
            v128 = *(_DWORD *)(v4 - 31);
            if ( v127 != v128 )
              goto LABEL_316;
            goto LABEL_306;
          }
          goto LABEL_291;
        }
        goto LABEL_278;
      }
LABEL_266:
      v127 = *((_DWORD *)v5 - 7);
      v128 = *((_DWORD *)v4 - 7);
      if ( v127 != v128 )
        goto LABEL_316;
      goto LABEL_267;
    }
    if ( (unsigned int)v3 < 0x28 )
    {
      switch ( (_DWORD)v3 )
      {
        case ' ':
LABEL_265:
          v127 = *((_DWORD *)v5 - 8);
          v128 = *((_DWORD *)v4 - 8);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_266;
        case '!':
LABEL_277:
          v127 = *(_DWORD *)(v5 - 33);
          v128 = *(_DWORD *)(v4 - 33);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_278:
          v127 = *(_DWORD *)(v5 - 29);
          v128 = *(_DWORD *)(v4 - 29);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_279;
        case '"':
LABEL_290:
          v127 = *(_DWORD *)(v5 - 34);
          v128 = *(_DWORD *)(v4 - 34);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_291:
          v127 = *(_DWORD *)(v5 - 30);
          v128 = *(_DWORD *)(v4 - 30);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_292;
        case '#':
LABEL_304:
          v127 = *(_DWORD *)(v5 - 35);
          v128 = *(_DWORD *)(v4 - 35);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_305;
      }
      if ( (_DWORD)v3 != 36 )
      {
        if ( (_DWORD)v3 != 37 )
        {
          if ( (_DWORD)v3 != 38 )
          {
LABEL_303:
            v127 = *(_DWORD *)(v5 - 39);
            v128 = *(_DWORD *)(v4 - 39);
            if ( v127 != v128 )
              goto LABEL_316;
            goto LABEL_304;
          }
          goto LABEL_289;
        }
        goto LABEL_276;
      }
LABEL_264:
      v127 = *((_DWORD *)v5 - 9);
      v128 = *((_DWORD *)v4 - 9);
      if ( v127 != v128 )
        goto LABEL_316;
      goto LABEL_265;
    }
    if ( (_DWORD)v3 != 40 )
    {
      switch ( (_DWORD)v3 )
      {
        case ')':
          goto LABEL_275;
        case '*':
          goto LABEL_288;
        case '+':
LABEL_302:
          v127 = *(_DWORD *)(v5 - 43);
          v128 = *(_DWORD *)(v4 - 43);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_303;
      }
      if ( (_DWORD)v3 != 44 )
      {
        if ( (_DWORD)v3 != 45 )
        {
          if ( (_DWORD)v3 != 46 )
          {
            v127 = *(_DWORD *)(v5 - 47);
            v128 = *(_DWORD *)(v4 - 47);
            if ( v127 != v128 )
              goto LABEL_316;
            goto LABEL_302;
          }
          v127 = *(_DWORD *)(v5 - 46);
          v128 = *(_DWORD *)(v4 - 46);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_288:
          v127 = *(_DWORD *)(v5 - 42);
          v128 = *(_DWORD *)(v4 - 42);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_289:
          v127 = *(_DWORD *)(v5 - 38);
          v128 = *(_DWORD *)(v4 - 38);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_290;
        }
        v127 = *(_DWORD *)(v5 - 45);
        v128 = *(_DWORD *)(v4 - 45);
        if ( v127 != v128 )
          goto LABEL_316;
LABEL_275:
        v127 = *(_DWORD *)(v5 - 41);
        v128 = *(_DWORD *)(v4 - 41);
        if ( v127 != v128 )
          goto LABEL_316;
LABEL_276:
        v127 = *(_DWORD *)(v5 - 37);
        v128 = *(_DWORD *)(v4 - 37);
        if ( v127 != v128 )
          goto LABEL_316;
        goto LABEL_277;
      }
      v127 = *((_DWORD *)v5 - 11);
      v128 = *((_DWORD *)v4 - 11);
      if ( v127 != v128 )
        goto LABEL_316;
    }
    v127 = *((_DWORD *)v5 - 10);
    v128 = *((_DWORD *)v4 - 10);
    if ( v127 != v128 )
      goto LABEL_316;
    goto LABEL_264;
  }
  switch ( (_DWORD)v3 )
  {
    case 0:
      return 0LL;
    case 1:
      goto LABEL_285;
    case 2:
      goto LABEL_298;
  }
  if ( (_DWORD)v3 != 3 )
  {
    if ( (_DWORD)v3 != 4 )
    {
      if ( (_DWORD)v3 != 5 )
      {
        if ( (_DWORD)v3 != 6 )
        {
LABEL_311:
          v127 = *(_DWORD *)(v5 - 7);
          v128 = *(_DWORD *)(v4 - 7);
          if ( v127 == v128 )
            goto LABEL_312;
LABEL_316:
          v130 = (unsigned __int8)v127 < (unsigned __int8)v128;
          if ( (_BYTE)v127 == (_BYTE)v128 )
          {
            v130 = (unsigned __int16)v127 < (unsigned __int16)v128;
            if ( (_WORD)v127 == (_WORD)v128 )
            {
              v136 = HIWORD(v127);
              v137 = HIWORD(v128);
              v130 = (unsigned __int8)v136 < (unsigned __int8)v137;
              if ( (_BYTE)v136 == (_BYTE)v137 )
                v130 = v136 < v137;
            }
          }
          return -v130 - ((unsigned int)v130 - 1);
        }
        goto LABEL_297;
      }
      goto LABEL_284;
    }
    goto LABEL_272;
  }
LABEL_312:
  v133 = *(unsigned __int16 *)(v5 - 3);
  v134 = *(unsigned __int16 *)(v4 - 3);
  v130 = (unsigned __int8)v133 < (unsigned __int8)v134;
  if ( (_BYTE)v133 == (_BYTE)v134 )
  {
    v130 = v133 < v134;
    if ( v133 == v134 )
    {
      v135 = *(v5 - 1);
      v130 = v135 < (unsigned __int8)*(v4 - 1);
      if ( v135 == *(v4 - 1) )
        return 0LL;
    }
  }
  return -v130 - ((unsigned int)v130 - 1);
}

//----- (0000000000046D50) ----------------------------------------------------
_BYTE *__fastcall sub_46D50(__int64 a1, unsigned __int8 *a2)
{
  unsigned __int8 v2; // bl
  _BYTE *v3; // r13
  int v4; // eax
  int v5; // edx
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned __int64 v10; // r15
  __int64 v11; // r8
  __int64 v12; // r9
  unsigned __int64 v13; // r14
  _BYTE *v14; // r15
  __int64 k; // rax
  unsigned __int8 v16; // cl
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rbp
  __int64 v19; // rdx
  unsigned __int64 v20; // rbx
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // rax
  int v23; // edx
  int v24; // ebp
  int v25; // eax
  _BYTE *v26; // rcx
  int v27; // eax
  int v28; // edx
  int v29; // ebp
  int v30; // eax
  int v31; // eax
  _BYTE *v32; // rcx
  __m128i v33; // xmm1
  __m128i v34; // xmm1
  __m128i v35; // xmm1
  __m128i v36; // xmm4
  __int64 v37; // rax
  __m128i v38; // xmm4
  unsigned int v39; // ecx
  __m128i v40; // xmm4
  __m128i v41; // xmm0
  unsigned __int64 v42; // rax
  __m128i v43; // xmm2
  __m128i v44; // xmm3
  __m128i v45; // xmm4
  __m128i v46; // xmm0
  __m128i v47; // xmm4
  unsigned int v48; // er8
  __m128i v49; // xmm4
  unsigned int v50; // eax
  __m128i v51; // xmm4
  __m128i v52; // xmm3
  unsigned int v53; // eax
  unsigned int v54; // edx
  __m128i v55; // xmm1
  __m128i v56; // xmm2
  __m128i v57; // xmm1
  __m128i v58; // xmm2
  __m128i v59; // xmm1
  __m128i v60; // xmm2
  __m128i v61; // xmm6
  __m128i v62; // xmm0
  unsigned __int64 v63; // r8
  unsigned __int64 v64; // rax
  _BYTE *result; // rax
  unsigned __int8 v66; // dl
  __int64 v67; // rdx
  unsigned __int8 v68; // si
  unsigned __int8 v69; // cl
  __m128i v70; // xmm6
  __m128i v71; // xmm0
  unsigned __int64 j; // r8
  unsigned __int64 v73; // rax
  unsigned __int8 v74; // dl
  __int64 v75; // rdx
  unsigned __int8 v76; // cl
  __int64 v77; // r11
  __int64 v78; // r9
  unsigned __int64 v79; // rdi
  __m128i v80; // xmm0
  __m128i v81; // xmm10
  __m128i v82; // xmm6
  __m128i v83; // xmm9
  __m128i v84; // xmm3
  __m128i v85; // xmm8
  __m128i v86; // xmm4
  __m128i v87; // xmm5
  __m128i v88; // xmm8
  unsigned __int64 v89; // r8
  unsigned __int64 v90; // rcx
  _BYTE *v91; // rcx
  __int64 v92; // rax
  unsigned __int8 v93; // dl
  unsigned __int8 v94; // dl
  __m128i v95; // xmm3
  __m128i v96; // xmm5
  __m128i v97; // xmm8
  __m128i v98; // xmm7
  __m128i v99; // xmm3
  __m128i v100; // xmm5
  unsigned __int64 i; // r8
  unsigned __int64 v102; // rax
  _BYTE *v103; // rax
  unsigned __int8 v104; // dl
  __int64 v105; // rdx
  unsigned __int8 v106; // cl
  unsigned __int64 v107; // [rsp+8h] [rbp-150h]
  char v108[264]; // [rsp+10h] [rbp-148h] BYREF
  unsigned __int64 v109; // [rsp+118h] [rbp-40h]

  v53 = *a2;
  if ( !(_BYTE)v53 )
    return (_BYTE *)a1;
  v54 = a2[1];
  if ( !(_BYTE)v54 )
  {
    v68 = *a2;
    v33 = _mm_cvtsi32_si128((unsigned __int8)v53);
    v34 = _mm_unpacklo_epi8(v33, v33);
    v35 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v34, v34), 0);
    if ( ((unsigned __int16)a1 & 0xFFFu) > 0xFC0 )
    {
      v47 = _mm_load_si128((const __m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL));
      v48 = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v47, v35), _mm_cmpeq_epi8(v47, (__m128i)0LL)));
      v49 = _mm_load_si128((const __m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 16));
      v50 = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v49, v35), _mm_cmpeq_epi8(v49, (__m128i)0LL)));
      v51 = _mm_load_si128((const __m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 32));
      v52 = _mm_load_si128((const __m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 48));
      v42 = (((unsigned __int64)(unsigned int)_mm_movemask_epi8(
                                                _mm_or_si128(
                                                  _mm_cmpeq_epi8(v35, v52),
                                                  _mm_cmpeq_epi8((__m128i)0LL, v52))) << 48) | v48 | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v51, v35), _mm_cmpeq_epi8(v51, (__m128i)0LL))) << 32) | ((unsigned __int64)v50 << 16)) >> ((unsigned __int8)a1 - ((unsigned __int8)a1 & 0xC0u));
      if ( v42 )
        goto LABEL_104;
    }
    else
    {
      v36 = _mm_loadu_si128((const __m128i *)a1);
      LODWORD(v37) = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v36, v35), _mm_cmpeq_epi8(v36, (__m128i)0LL)));
      if ( (_DWORD)v37 )
      {
        _BitScanForward((unsigned int *)&v37, v37);
        result = (_BYTE *)(a1 + v37);
        if ( *result != v68 )
          result = 0LL;
        return result;
      }
      v38 = _mm_loadu_si128((const __m128i *)(a1 + 16));
      v39 = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v38, v35), _mm_cmpeq_epi8(v38, (__m128i)0LL)));
      v40 = _mm_loadu_si128((const __m128i *)(a1 + 32));
      v41 = _mm_loadu_si128((const __m128i *)(a1 + 48));
      v42 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v41, v35), _mm_cmpeq_epi8((__m128i)0LL, v41))) << 48) | ((unsigned __int64)v39 << 16) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v40, v35), _mm_cmpeq_epi8(v40, (__m128i)0LL))) << 32);
      if ( v42 )
        goto LABEL_104;
    }
    a1 &= 0xFFFFFFFFFFFFFFC0LL;
    do
    {
      a1 += 64LL;
      v43 = _mm_min_epu8(_mm_xor_si128(_mm_load_si128((const __m128i *)(a1 + 16)), v35), *(__m128i *)(a1 + 16));
      v44 = _mm_min_epu8(_mm_xor_si128(_mm_load_si128((const __m128i *)(a1 + 32)), v35), *(__m128i *)(a1 + 32));
      v45 = _mm_min_epu8(_mm_xor_si128(_mm_load_si128((const __m128i *)(a1 + 48)), v35), *(__m128i *)(a1 + 48));
    }
    while ( !_mm_movemask_epi8(
               _mm_cmpeq_epi8(
                 _mm_min_epu8(
                   _mm_min_epu8(
                     _mm_min_epu8(
                       _mm_min_epu8(_mm_xor_si128(_mm_load_si128((const __m128i *)a1), v35), *(__m128i *)a1),
                       v43),
                     v44),
                   v45),
                 (__m128i)0LL)) );
    v46 = _mm_load_si128((const __m128i *)a1);
    v42 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v45, (__m128i)0LL)) << 48) | (unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v46, v35), _mm_cmpeq_epi8(v46, (__m128i)0LL))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v44, (__m128i)0LL)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v43, (__m128i)0LL)) << 16);
LABEL_104:
    _BitScanForward64(&v42, v42);
    result = (_BYTE *)(a1 + v42);
    if ( *result != v68 )
      result = 0LL;
    return result;
  }
  v55 = _mm_cvtsi32_si128(v53);
  v56 = _mm_cvtsi32_si128(v54);
  v57 = _mm_unpacklo_epi8(v55, v55);
  v58 = _mm_unpacklo_epi8(v56, v56);
  v59 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v57, v57), 0);
  v60 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v58, v58), 0);
  if ( ((unsigned __int16)a1 & 0xFFFu) > 0xFBFuLL )
  {
    v95 = _mm_load_si128((const __m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL));
    v96 = _mm_load_si128((const __m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 16));
    v97 = _mm_or_si128(
            _mm_cmpeq_epi8(v95, (__m128i)0LL),
            _mm_min_epu8(
              _mm_cmpeq_epi8(v95, v60),
              _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) - 1)), v59)));
    v98 = _mm_or_si128(
            _mm_cmpeq_epi8(v96, (__m128i)0LL),
            _mm_min_epu8(
              _mm_cmpeq_epi8(v96, v60),
              _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 15)), v59)));
    v99 = _mm_load_si128((const __m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 32));
    v100 = _mm_load_si128((const __m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 48));
    for ( i = (((unsigned __int64)(unsigned int)_mm_movemask_epi8(
                                                  _mm_or_si128(
                                                    _mm_cmpeq_epi8((__m128i)0LL, v100),
                                                    _mm_min_epu8(
                                                      _mm_cmpeq_epi8(v100, v60),
                                                      _mm_cmpeq_epi8(
                                                        _mm_loadu_si128((const __m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL)
                                                                                        + 47)),
                                                        v59)))) << 48) | (unsigned int)_mm_movemask_epi8(v97) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v99, (__m128i)0LL), _mm_min_epu8(_mm_cmpeq_epi8(v99, v60), _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 31)), v59)))) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v98) << 16)) >> ((unsigned __int8)a1 - ((unsigned __int8)a1 & 0xC0u));
          i;
          i &= i - 1 )
    {
      _BitScanForward64(&v102, i);
      v103 = (_BYTE *)(a1 + v102);
      if ( !*v103 )
        return 0LL;
      if ( (_BYTE *)a1 != v103 )
      {
        v104 = a2[2];
        if ( !v104 )
          return v103 - 1;
        if ( v104 == v103[1] )
        {
          v105 = 0LL;
          do
          {
            v106 = a2[v105 + 3];
            if ( !v106 )
              return v103 - 1;
            ++v105;
          }
          while ( v106 == v103[v105 + 1] );
        }
      }
    }
    goto LABEL_26;
  }
  v61 = _mm_loadu_si128((const __m128i *)a1);
  v62 = _mm_loadu_si128((const __m128i *)(a1 + 16));
  v63 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(
                                           _mm_or_si128(
                                             _mm_min_epu8(
                                               _mm_cmpeq_epi8(v62, v59),
                                               _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)(a1 + 17)), v60)),
                                             _mm_cmpeq_epi8((__m128i)0LL, v62))) << 16) | (unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_min_epu8(_mm_cmpeq_epi8(v61, v59), _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)(a1 + 1)), v60)), _mm_cmpeq_epi8(v61, (__m128i)0LL)));
  if ( !v63 )
  {
LABEL_15:
    v70 = _mm_loadu_si128((const __m128i *)(a1 + 32));
    v71 = _mm_loadu_si128((const __m128i *)(a1 + 48));
    for ( j = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(
                                                 _mm_or_si128(
                                                   _mm_min_epu8(
                                                     _mm_cmpeq_epi8(v70, v59),
                                                     _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)(a1 + 33)), v60)),
                                                   _mm_cmpeq_epi8(v70, (__m128i)0LL))) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_min_epu8(_mm_cmpeq_epi8(v71, v59), _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)(a1 + 49)), v60)), _mm_cmpeq_epi8((__m128i)0LL, v71))) << 48);
          j;
          j &= j - 1 )
    {
      _BitScanForward64(&v73, j);
      result = (_BYTE *)(a1 + v73);
      if ( !*result )
        return 0LL;
      v74 = a2[2];
      if ( !v74 )
        return result;
      if ( v74 == result[2] )
      {
        v75 = 0LL;
        do
        {
          v76 = a2[v75 + 3];
          if ( !v76 )
            return result;
          ++v75;
        }
        while ( v76 == result[v75 + 2] );
      }
    }
LABEL_26:
    v77 = -512LL;
    v78 = a1;
    v79 = a1 & 0xFFFFFFFFFFFFFFC0LL;
    do
    {
      do
      {
LABEL_27:
        v80 = _mm_load_si128((const __m128i *)(v79 + 64));
        v81 = _mm_load_si128((const __m128i *)(v79 + 80));
        v82 = _mm_or_si128(_mm_xor_si128(_mm_loadu_si128((const __m128i *)(v79 + 63)), v59), _mm_xor_si128(v80, v60));
        v83 = _mm_load_si128((const __m128i *)(v79 + 96));
        v84 = _mm_or_si128(_mm_xor_si128(_mm_loadu_si128((const __m128i *)(v79 + 79)), v59), _mm_xor_si128(v81, v60));
        v85 = _mm_load_si128((const __m128i *)(v79 + 112));
        v79 += 64LL;
        v86 = _mm_or_si128(_mm_xor_si128(_mm_loadu_si128((const __m128i *)(v79 + 31)), v59), _mm_xor_si128(v83, v60));
        v87 = _mm_or_si128(_mm_xor_si128(_mm_loadu_si128((const __m128i *)(v79 + 47)), v59), _mm_xor_si128(v85, v60));
      }
      while ( !_mm_movemask_epi8(
                 _mm_cmpeq_epi8(
                   _mm_min_epu8(
                     _mm_min_epu8(_mm_min_epu8(_mm_min_epu8(v80, v81), v83), v85),
                     _mm_min_epu8(_mm_min_epu8(_mm_min_epu8(v84, v82), v86), v87)),
                   (__m128i)0LL)) );
      v88 = _mm_load_si128((const __m128i *)(v79 + 16));
      v89 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(
                                               _mm_or_si128(
                                                 _mm_cmpeq_epi8(v88, (__m128i)0LL),
                                                 _mm_min_epu8(
                                                   _mm_cmpeq_epi8(v88, v60),
                                                   _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)(v79 + 15)), v59)))) << 16) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(v86, *(__m128i *)(v79 + 32)), (__m128i)0LL)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(v82, *(__m128i *)v79), (__m128i)0LL)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(v87, *(__m128i *)(v79 + 48)), (__m128i)0LL)) << 48);
    }
    while ( !v89 );
    while ( 1 )
    {
      _BitScanForward64(&v90, v89);
      v91 = (_BYTE *)(v79 + v90);
      if ( !*v91 )
        return 0LL;
      v92 = 0LL;
      v93 = a2[2];
      if ( !v93 )
        return v91 - 1;
      if ( v93 == v91[1] )
      {
        do
        {
          v94 = a2[v92 + 3];
          if ( !v94 )
            return v91 - 1;
          ++v92;
        }
        while ( v94 == v91[v92 + 1] );
      }
      v77 += v92;
      if ( (__int64)(v79 - v78) < v77 )
        break;
      v89 &= v89 - 1;
      if ( !v89 )
        goto LABEL_27;
    }
    v2 = *a2;
    v109 = __readfsqword(0x28u);
    if ( !v2 )
      return (_BYTE *)v79;
    v3 = (_BYTE *)sub_9210(v79, v2);
    if ( v3 )
    {
      v4 = a2[1];
      if ( !(_BYTE)v4 )
        return v3;
      v5 = a2[2];
      if ( (_BYTE)v5 )
      {
        if ( a2[3] )
        {
          v107 = strlen((__int64)a2);
          v10 = sub_9040(v3, v107 | 0x200, v6, v7, v8, v9);
          if ( v107 <= v10 )
          {
            if ( (unsigned int)memcmp((__int64)v3, (__int64)a2, v107) )
            {
              if ( v107 <= 0x100 )
              {
                memset(v108, 0, 0x100uLL);
                v13 = v107 - 1;
                v14 = &v3[v10 - v107];
                if ( v107 - 1 > 1 )
                {
                  for ( k = 1LL; ; ++k )
                  {
                    v16 = a2[k];
                    v108[(unsigned __int8)(v16 - 8 * v2)] = k;
                    if ( v107 - 2 == k )
                      break;
                    v2 = v16;
                  }
                }
                v17 = v107;
                v18 = 0LL;
                v19 = (unsigned __int8)v108[(unsigned __int8)(a2[v107 - 1] - 8 * a2[v107 - 2])];
                v108[(unsigned __int8)(a2[v107 - 1] - 8 * a2[v107 - 2])] = v13;
                v20 = v13 - v19;
LABEL_65:
                if ( v3 > v14 )
                  goto LABEL_76;
                while ( 1 )
                {
                  do
                  {
                    do
                    {
                      v3 += v13;
                      v19 = 8LL * (unsigned __int8)*(v3 - 1);
                      v21 = (unsigned __int8)v108[(unsigned __int8)(*v3 - v19)];
                    }
                    while ( !v108[(unsigned __int8)(*v3 - v19)] && v3 <= v14 );
                    v3 -= v21;
                    if ( v13 > v21 )
                      goto LABEL_65;
                    if ( v13 <= 0xE || *(_QWORD *)&v3[v18] == *(_QWORD *)&a2[v18] )
                    {
                      if ( !(unsigned int)memcmp((__int64)v3, (__int64)a2, v13) )
                        return v3;
                      v22 = v18 - 8;
                      if ( v18 < 8 )
                        v22 = v107 - 9;
                      v18 = v22;
                    }
                    v3 += v20;
                  }
                  while ( v3 <= v14 );
LABEL_76:
                  v14 += sub_9040(&v14[v107], 2048LL, v19, v17, v11, v12);
                  if ( v3 > v14 )
                    return 0LL;
                }
              }
              return (_BYTE *)sub_23250((__int64)v3, v10, (__int64)a2, v107);
            }
            return v3;
          }
        }
        else
        {
          v27 = (v5 << 8) | (v4 << 16);
          v28 = (unsigned __int8)*v3;
          v29 = v27 | (v2 << 24);
          if ( *v3 )
          {
            v30 = 0;
            do
            {
              v31 = v28 | v30;
              v32 = v3++;
              v28 = (unsigned __int8)*v3;
              v30 = v31 << 8;
              if ( v29 == v30 )
                return v32 - 2;
            }
            while ( *v3 );
            if ( v29 == v30 )
              return v32 - 2;
          }
        }
      }
      else
      {
        v23 = (unsigned __int8)*v3;
        v24 = v4 | (v2 << 16);
        if ( *v3 )
        {
          v25 = 0;
          do
          {
            v26 = v3++;
            v25 = v23 | (v25 << 16);
            v23 = (unsigned __int8)*v3;
            if ( v24 == v25 )
              return v26 - 1;
          }
          while ( *v3 );
          if ( v24 == v25 )
            return v26 - 1;
        }
      }
    }
    return 0LL;
  }
  while ( 1 )
  {
    _BitScanForward64(&v64, v63);
    result = (_BYTE *)(a1 + v64);
    if ( !*result )
      return 0LL;
    v66 = a2[2];
    if ( !v66 )
      return result;
    if ( v66 == result[2] )
    {
      v67 = 0LL;
      do
      {
        v69 = a2[v67 + 3];
        if ( !v69 )
          return result;
        ++v67;
      }
      while ( v69 == result[v67 + 2] );
    }
    v63 &= v63 - 1;
    if ( !v63 )
      goto LABEL_15;
  }
}
// 23761: variable 'v6' is possibly undefined
// 23761: variable 'v7' is possibly undefined
// 23761: variable 'v8' is possibly undefined
// 23761: variable 'v9' is possibly undefined
// 238A7: variable 'v19' is possibly undefined
// 238A7: variable 'v17' is possibly undefined
// 238A7: variable 'v11' is possibly undefined
// 238A7: variable 'v12' is possibly undefined
// 4019F: variable 'v37' is possibly undefined
// 9040: using guessed type __int64 __fastcall sub_9040(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9210: using guessed type __int64 __fastcall sub_9210(_QWORD, _QWORD);

//----- (00000000000472A0) ----------------------------------------------------
_BYTE *__fastcall sub_472A0(__int64 a1, const __m128i *a2)
{
  __int64 v2; // rcx
  const __m128i *v3; // rax
  _BYTE *v4; // rax
  int v5; // edx
  __m128i v6; // xmm1
  const __m128i *v7; // rax
  __m128i v8; // xmm0
  signed int v9; // ecx
  __m128i v11; // xmm3
  int v12; // ecx
  int v13; // esi
  __m128i v14; // xmm0
  int v15; // ecx
  char v16[256]; // [rsp+0h] [rbp-100h] BYREF

  if ( !a2->m128i_i8[0] )
    return (_BYTE *)strlen(a1);
  v5 = (unsigned __int8)a2 & 0xF;
  if ( ((unsigned __int8)a2 & 0xF) != 0 )
  {
    v6 = _mm_shuffle_epi8(
           _mm_load_si128((const __m128i *)((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL)),
           _mm_loadu_si128((const __m128i *)((char *)&unk_92860 + ((unsigned __int8)a2 & 0xF))));
    if ( 16 - v5 == _mm_cmpistri(v6, v6, 58) )
    {
      v14 = _mm_load_si128((const __m128i *)(((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL) + 16));
      v15 = _mm_cmpistri(v14, v14, 58);
      if ( v15 + 16 - v5 > 16 )
      {
LABEL_19:
        memset(v16, 0, sizeof(v16));
        v2 = 0LL;
        v3 = a2;
        do
        {
          if ( !v3->m128i_i8[0] )
            break;
          LOBYTE(v2) = v3->m128i_i8[0];
          v16[v2] = v3->m128i_i8[0];
          LOBYTE(v2) = v3->m128i_i8[1];
          if ( !(_BYTE)v2 )
            break;
          v16[v2] = v2;
          LOBYTE(v2) = v3->m128i_i8[2];
          if ( !(_BYTE)v2 )
            break;
          v16[v2] = v2;
          LOBYTE(v2) = v3->m128i_i8[3];
          v3 = (const __m128i *)((char *)v3 + 4);
          v16[v2] = v2;
        }
        while ( (_BYTE)v2 );
        v4 = (_BYTE *)(a1 - 4);
        while ( 1 )
        {
          v4 += 4;
          LOBYTE(v2) = *v4;
          if ( v16[v2] == *v4 )
            return &v4[-a1];
          LOBYTE(v2) = v4[1];
          if ( v16[v2] == (_BYTE)v2 )
            goto LABEL_31;
          LOBYTE(v2) = v4[2];
          if ( v16[v2] == (_BYTE)v2 )
            goto LABEL_30;
          LOBYTE(v2) = v4[3];
          if ( v16[v2] == (_BYTE)v2 )
          {
            ++v4;
LABEL_30:
            ++v4;
LABEL_31:
            ++v4;
            return &v4[-a1];
          }
        }
      }
      if ( v15 )
        v6 = _mm_loadu_si128(a2);
    }
  }
  else
  {
    v6 = _mm_load_si128(a2);
    if ( _mm_cmpistri(v6, v6, 58) == 16 && a2[1].m128i_i8[0] )
      goto LABEL_19;
  }
  v7 = (const __m128i *)a1;
  if ( (a1 & 0xF) != 0 )
  {
    v8 = _mm_shuffle_epi8(
           _mm_load_si128((const __m128i *)(a1 & 0xFFFFFFFFFFFFFFF0LL)),
           _mm_loadu_si128((const __m128i *)((char *)&unk_92860 + (a1 & 0xF))));
    v9 = _mm_cmpistri(v6, v8, 2);
    if ( _mm_cmpistrc(v6, v8, 2) )
      return (_BYTE *)v9;
    v9 = _mm_cmpistri(v8, v8, 58);
    v7 = (const __m128i *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 16);
    if ( (int)(16 - (a1 & 0xF)) > v9 )
      return (_BYTE *)v9;
  }
  while ( 1 )
  {
    v11 = _mm_load_si128(v7);
    v12 = _mm_cmpistri(v6, v11, 2);
    v13 = _mm_cmpistrz(v6, v11, 2);
    if ( _mm_cmpistrc(v6, v11, 2) )
      return (char *)v7 + v12 - a1;
    if ( v13 )
      break;
    ++v7;
  }
  return (char *)v7 + _mm_cmpistri(v11, v11, 58) - a1;
}

//----- (00000000000473F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_473F0(unsigned __int64 _RDI, int _ESI, unsigned __int64 a3, __m128 _XMM0)
{
  unsigned __int64 result; // rax

  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovd   xmm1, esi
  }
  _RSI = _RDI + a3;
  result = _RDI;
  __asm { vpshufb xmm0, xmm1, xmm0 }
  if ( a3 < 0x10 )
  {
    if ( (unsigned __int8)a3 < 8u )
    {
      __asm { vmovd   ecx, xmm0 }
      if ( (unsigned __int8)a3 < 4u )
      {
        if ( (unsigned __int8)a3 < 2u )
        {
          if ( (_BYTE)a3 )
            *(_BYTE *)_RDI = _ECX;
        }
        else
        {
          *(_WORD *)_RDI = _ECX;
          *(_WORD *)(_RSI - 2) = _ECX;
        }
      }
      else
      {
        *(_DWORD *)_RDI = _ECX;
        *(_DWORD *)(_RSI - 4) = _ECX;
      }
    }
    else
    {
      __asm
      {
        vmovq   qword ptr [rdi], xmm0
        vmovq   qword ptr [rsi-8], xmm0
      }
    }
  }
  else
  {
    __asm { vbroadcastss zmm2, xmm0 }
    if ( a3 > 0x200 )
    {
      if ( a3 > (unsigned __int64)off_BEFA8 )
      {
        _RDI = (_RDI & 0xFFFFFFFFFFFFFF80LL) + 128;
        __asm
        {
          vmovups zmmword ptr [rax], zmm2
          vmovups zmmword ptr [rax+40h], zmm2
        }
        _RSI = _RSI - 512;
        do
        {
          __asm
          {
            vmovntdq zmmword ptr [rdi], zmm2
            vmovntdq zmmword ptr [rdi+40h], zmm2
            vmovntdq zmmword ptr [rdi+80h], zmm2
            vmovntdq zmmword ptr [rdi+0C0h], zmm2
            vmovntdq zmmword ptr [rdi+100h], zmm2
            vmovntdq zmmword ptr [rdi+140h], zmm2
            vmovntdq zmmword ptr [rdi+180h], zmm2
            vmovntdq zmmword ptr [rdi+1C0h], zmm2
          }
          _RDI += 512LL;
        }
        while ( _RDI < _RSI );
        _mm_sfence();
        __asm
        {
          vmovups zmmword ptr [rsi], zmm2
          vmovups zmmword ptr [rsi+40h], zmm2
          vmovups zmmword ptr [rsi+80h], zmm2
          vmovups zmmword ptr [rsi+0C0h], zmm2
          vmovups zmmword ptr [rsi+100h], zmm2
          vmovups zmmword ptr [rsi+140h], zmm2
          vmovups zmmword ptr [rsi+180h], zmm2
          vmovups zmmword ptr [rsi+1C0h], zmm2
        }
      }
      else if ( a3 > 0x400 )
      {
        _RSI = _RSI - 256;
        __asm { vmovups zmmword ptr [rax], zmm2 }
        _RDI = (_RDI & 0xFFFFFFFFFFFFFFC0LL) + 64;
        do
        {
          __asm
          {
            vmovaps zmmword ptr [rdi], zmm2
            vmovaps zmmword ptr [rdi+40h], zmm2
            vmovaps zmmword ptr [rdi+80h], zmm2
            vmovaps zmmword ptr [rdi+0C0h], zmm2
          }
          _RDI += 256LL;
        }
        while ( _RDI < _RSI );
        __asm
        {
          vmovups zmmword ptr [rsi], zmm2
          vmovups zmmword ptr [rsi+40h], zmm2
          vmovups zmmword ptr [rsi+80h], zmm2
          vmovups zmmword ptr [rsi+0C0h], zmm2
        }
      }
      else
      {
        __asm
        {
          vmovups zmmword ptr [rdi], zmm2
          vmovups zmmword ptr [rdi+40h], zmm2
          vmovups zmmword ptr [rdi+80h], zmm2
          vmovups zmmword ptr [rdi+0C0h], zmm2
          vmovups zmmword ptr [rdi+100h], zmm2
          vmovups zmmword ptr [rdi+140h], zmm2
          vmovups zmmword ptr [rdi+180h], zmm2
          vmovups zmmword ptr [rdi+1C0h], zmm2
          vmovups zmmword ptr [rsi-200h], zmm2
          vmovups zmmword ptr [rsi-1C0h], zmm2
          vmovups zmmword ptr [rsi-180h], zmm2
          vmovups zmmword ptr [rsi-140h], zmm2
          vmovups zmmword ptr [rsi-100h], zmm2
          vmovups zmmword ptr [rsi-0C0h], zmm2
          vmovups zmmword ptr [rsi-80h], zmm2
          vmovups zmmword ptr [rsi-40h], zmm2
        }
      }
    }
    else if ( a3 < 0x100 )
    {
      if ( (unsigned __int8)a3 < 0x80u )
      {
        if ( (unsigned __int8)a3 < 0x40u )
        {
          if ( (unsigned __int8)a3 < 0x20u )
          {
            __asm
            {
              vmovdqu xmmword ptr [rdi], xmm0
              vmovdqu xmmword ptr [rsi-10h], xmm0
            }
          }
          else
          {
            __asm
            {
              vmovdqu ymmword ptr [rdi], ymm2
              vmovdqu ymmword ptr [rsi-20h], ymm2
            }
          }
        }
        else
        {
          __asm
          {
            vmovups zmmword ptr [rdi], zmm2
            vmovups zmmword ptr [rsi-40h], zmm2
          }
        }
      }
      else
      {
        __asm
        {
          vmovups zmmword ptr [rdi], zmm2
          vmovups zmmword ptr [rdi+40h], zmm2
          vmovups zmmword ptr [rsi-80h], zmm2
          vmovups zmmword ptr [rsi-40h], zmm2
        }
      }
    }
    else
    {
      __asm
      {
        vmovups zmmword ptr [rdi], zmm2
        vmovups zmmword ptr [rdi+40h], zmm2
        vmovups zmmword ptr [rdi+80h], zmm2
        vmovups zmmword ptr [rdi+0C0h], zmm2
        vmovups zmmword ptr [rsi-100h], zmm2
        vmovups zmmword ptr [rsi-0C0h], zmm2
        vmovups zmmword ptr [rsi-80h], zmm2
        vmovups zmmword ptr [rsi-40h], zmm2
      }
    }
  }
  return result;
}
// 473F0: unsupported processor register 'zmm2'
// BEFA8: using guessed type __int64 (__fastcall *off_BEFA8)();

//----- (0000000000047670) ----------------------------------------------------
void sub_47670()
{
  JUMPOUT(0x47687LL);
}
// 4767A: control flows out of bounds to 47687

//----- (0000000000047680) ----------------------------------------------------
unsigned __int64 __fastcall sub_47680(unsigned __int64 a1, __int64 *a2, unsigned __int64 a3)
{
  unsigned __int64 result; // rax
  __int128 v4; // xmm1
  __int64 v5; // rcx
  __int64 v6; // rsi
  int v7; // ecx
  int v8; // esi
  __int16 v9; // cx
  __int16 v10; // si
  __int128 v11; // xmm1
  __int128 v12; // xmm2
  __int128 v13; // xmm3
  __int128 v14; // xmm4
  __int128 v15; // xmm5
  __int128 v16; // xmm6
  __int128 v17; // xmm7
  __int128 v18; // xmm2
  __int128 v19; // xmm3
  __int128 v20; // xmm4
  __int128 v21; // xmm5
  __int128 v22; // xmm6
  __int128 v23; // xmm7
  __int128 v24; // xmm8
  _OWORD *v26; // rcx
  unsigned __int64 v27; // r8
  __m128i *v29; // rdi
  unsigned __int64 v30; // rdx
  __m128i v31; // xmm0
  __m128i v32; // xmm1
  __m128i v33; // xmm2
  __m128i v34; // xmm3
  __int128 v35; // xmm4
  __int128 v36; // xmm5
  __int128 v37; // xmm6
  __int128 v38; // xmm7
  __int128 v39; // xmm8
  _OWORD *v40; // r11
  __int64 v41; // r8
  __m128i *v43; // r9
  unsigned __int64 v44; // rdx
  __m128i v45; // xmm0
  __m128i v46; // xmm1
  __m128i v47; // xmm2
  __m128i v48; // xmm3
  __m128i v49; // xmm0
  __m128i v50; // xmm1
  __m128i v51; // xmm2
  __m128i v52; // xmm3
  __m128i v53; // xmm0
  __m128i v54; // xmm1
  __m128i v55; // xmm2
  __m128i v56; // xmm3

  result = a1;
  if ( a3 < 0x10 )
  {
    if ( (unsigned __int8)a3 >= 8u )
    {
      v5 = *(__int64 *)((char *)a2 + a3 - 8);
      v6 = *a2;
      *(_QWORD *)(a1 + a3 - 8) = v5;
      *(_QWORD *)a1 = v6;
    }
    else if ( (unsigned __int8)a3 >= 4u )
    {
      v7 = *(_DWORD *)((char *)a2 + a3 - 4);
      v8 = *(_DWORD *)a2;
      *(_DWORD *)(a1 + a3 - 4) = v7;
      *(_DWORD *)a1 = v8;
    }
    else if ( (unsigned __int8)a3 > 1u )
    {
      v9 = *(_WORD *)((char *)a2 + a3 - 2);
      v10 = *(_WORD *)a2;
      *(_WORD *)(a1 + a3 - 2) = v9;
      *(_WORD *)a1 = v10;
    }
    else if ( (_BYTE)a3 )
    {
      *(_BYTE *)a1 = *(_BYTE *)a2;
    }
  }
  else if ( a3 > 0x20 )
  {
    if ( a3 > 0x80 )
    {
      if ( a1 > (unsigned __int64)a2 )
      {
        v35 = *(_OWORD *)a2;
        v36 = *((_OWORD *)a2 + 1);
        v37 = *((_OWORD *)a2 + 2);
        v38 = *((_OWORD *)a2 + 3);
        v39 = *(_OWORD *)((char *)a2 + a3 - 16);
        v40 = (_OWORD *)(a1 + a3 - 16);
        v41 = ((_BYTE)a1 + (_BYTE)a3 - 16) & 0xF;
        _RCX = (__m128i *)((char *)a2 + a3 - v41 - 16);
        v43 = (__m128i *)((char *)v40 - v41);
        v44 = a3 - v41;
        if ( v44 <= qword_C1260 || v43 < (__m128i *)&_RCX->m128i_i8[v44] )
        {
          do
          {
            v45 = *_RCX;
            v46 = _RCX[-1];
            v47 = _RCX[-2];
            v48 = _RCX[-3];
            _RCX -= 4;
            v44 -= 64LL;
            *v43 = v45;
            v43[-1] = v46;
            v43[-2] = v47;
            v43[-3] = v48;
            v43 -= 4;
          }
          while ( v44 > 0x40 );
          *(_OWORD *)a1 = v35;
          *(_OWORD *)(a1 + 16) = v36;
          *(_OWORD *)(a1 + 32) = v37;
          *(_OWORD *)(a1 + 48) = v38;
          *v40 = v39;
        }
        else
        {
          do
          {
            __asm
            {
              prefetcht0 byte ptr [rcx-80h]
              prefetcht0 byte ptr [rcx-0C0h]
            }
            v53 = *_RCX;
            v54 = _RCX[-1];
            v55 = _RCX[-2];
            v56 = _RCX[-3];
            _RCX -= 4;
            v44 -= 64LL;
            _mm_stream_si128(v43, v53);
            _mm_stream_si128(v43 - 1, v54);
            _mm_stream_si128(v43 - 2, v55);
            _mm_stream_si128(v43 - 3, v56);
            v43 -= 4;
          }
          while ( v44 > 0x40 );
          _mm_sfence();
          *(_OWORD *)a1 = v35;
          *(_OWORD *)(a1 + 16) = v36;
          *(_OWORD *)(a1 + 32) = v37;
          *(_OWORD *)(a1 + 48) = v38;
          *v40 = v39;
        }
      }
      else if ( (__int64 *)a1 != a2 )
      {
        v20 = *(_OWORD *)a2;
        v21 = *(_OWORD *)((char *)a2 + a3 - 16);
        v22 = *(_OWORD *)((char *)a2 + a3 - 32);
        v23 = *(_OWORD *)((char *)a2 + a3 - 48);
        v24 = *(_OWORD *)((char *)a2 + a3 - 64);
        v26 = (_OWORD *)(a1 + a3 - 16);
        v27 = (a1 & 0xF) - 16;
        _RSI = (__m128i *)((char *)a2 - v27);
        v29 = (__m128i *)(a1 - v27);
        v30 = v27 + a3;
        if ( v30 <= qword_C1260 || _RSI < (__m128i *)&v29->m128i_i8[v30] )
        {
          do
          {
            v31 = *_RSI;
            v32 = _RSI[1];
            v33 = _RSI[2];
            v34 = _RSI[3];
            _RSI += 4;
            v30 -= 64LL;
            *v29 = v31;
            v29[1] = v32;
            v29[2] = v33;
            v29[3] = v34;
            v29 += 4;
          }
          while ( v30 > 0x40 );
          *v26 = v21;
          *(v26 - 1) = v22;
          *(v26 - 2) = v23;
          *(v26 - 3) = v24;
          *(_OWORD *)a1 = v20;
        }
        else
        {
          do
          {
            __asm
            {
              prefetcht0 byte ptr [rsi+80h]
              prefetcht0 byte ptr [rsi+0C0h]
            }
            v49 = *_RSI;
            v50 = _RSI[1];
            v51 = _RSI[2];
            v52 = _RSI[3];
            _RSI += 4;
            v30 -= 64LL;
            _mm_stream_si128(v29, v49);
            _mm_stream_si128(v29 + 1, v50);
            _mm_stream_si128(v29 + 2, v51);
            _mm_stream_si128(v29 + 3, v52);
            v29 += 4;
          }
          while ( v30 > 0x40 );
          _mm_sfence();
          *v26 = v21;
          *(v26 - 1) = v22;
          *(v26 - 2) = v23;
          *(v26 - 3) = v24;
          *(_OWORD *)a1 = v20;
        }
      }
    }
    else
    {
      v11 = *((_OWORD *)a2 + 1);
      if ( a3 < 0x40 )
      {
        v18 = *(_OWORD *)((char *)a2 + a3 - 16);
        v19 = *(_OWORD *)((char *)a2 + a3 - 32);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v11;
        *(_OWORD *)(a1 + a3 - 16) = v18;
        *(_OWORD *)(a1 + a3 - 32) = v19;
      }
      else
      {
        v12 = *((_OWORD *)a2 + 2);
        v13 = *((_OWORD *)a2 + 3);
        v14 = *(_OWORD *)((char *)a2 + a3 - 16);
        v15 = *(_OWORD *)((char *)a2 + a3 - 32);
        v16 = *(_OWORD *)((char *)a2 + a3 - 48);
        v17 = *(_OWORD *)((char *)a2 + a3 - 64);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v11;
        *(_OWORD *)(a1 + 32) = v12;
        *(_OWORD *)(a1 + 48) = v13;
        *(_OWORD *)(a1 + a3 - 16) = v14;
        *(_OWORD *)(a1 + a3 - 32) = v15;
        *(_OWORD *)(a1 + a3 - 48) = v16;
        *(_OWORD *)(a1 + a3 - 64) = v17;
      }
    }
  }
  else
  {
    v4 = *(_OWORD *)((char *)a2 + a3 - 16);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)(a1 + a3 - 16) = v4;
  }
  return result;
}
// C1260: using guessed type __int64 qword_C1260;

//----- (0000000000047A40) ----------------------------------------------------
void sub_47A40()
{
  JUMPOUT(0x47A57LL);
}
// 47A4A: control flows out of bounds to 47A57

//----- (0000000000047A50) ----------------------------------------------------
__int64 *__fastcall sub_47A50(__int64 *_RDI, __int64 *_RSI, unsigned __int64 _RDX)
{
  __int64 *result; // rax
  __int64 v8; // rcx
  __int64 v9; // rsi
  int v10; // ecx
  int v11; // esi
  __int16 v12; // cx
  __int16 v13; // si
  __int64 v33; // r8
  unsigned __int64 v36; // rdx
  __int64 v47; // r8
  unsigned __int64 v50; // rdx

  result = _RDI;
  if ( _RDX < 0x20 )
  {
    if ( (unsigned __int8)_RDX >= 0x10u )
    {
      __asm
      {
        vmovdqu xmm0, xmmword ptr [rsi]
        vmovdqu xmm1, xmmword ptr [rsi+rdx-10h]
        vmovdqu xmmword ptr [rdi], xmm0
        vmovdqu xmmword ptr [rdi+rdx-10h], xmm1
      }
    }
    else if ( (unsigned __int8)_RDX >= 8u )
    {
      v8 = *(__int64 *)((char *)_RSI + _RDX - 8);
      v9 = *_RSI;
      *(__int64 *)((char *)_RDI + _RDX - 8) = v8;
      *_RDI = v9;
    }
    else if ( (unsigned __int8)_RDX >= 4u )
    {
      v10 = *(_DWORD *)((char *)_RSI + _RDX - 4);
      v11 = *(_DWORD *)_RSI;
      *(_DWORD *)((char *)_RDI + _RDX - 4) = v10;
      *(_DWORD *)_RDI = v11;
    }
    else if ( (unsigned __int8)_RDX > 1u )
    {
      v12 = *(_WORD *)((char *)_RSI + _RDX - 2);
      v13 = *(_WORD *)_RSI;
      *(_WORD *)((char *)_RDI + _RDX - 2) = v12;
      *(_WORD *)_RDI = v13;
    }
    else if ( (_BYTE)_RDX )
    {
      *(_BYTE *)_RDI = *(_BYTE *)_RSI;
    }
  }
  else if ( _RDX > 0x40 )
  {
    if ( _RDX > 0x100 )
    {
      if ( _RDI > _RSI )
      {
        __asm
        {
          vmovdqu ymm4, ymmword ptr [rsi]
          vmovdqu ymm5, ymmword ptr [rsi+20h]
          vmovdqu ymm6, ymmword ptr [rsi+40h]
          vmovdqu ymm7, ymmword ptr [rsi+60h]
          vmovdqu ymm8, ymmword ptr [rsi+rdx-20h]
        }
        _R11 = (char *)_RDI + _RDX - 32;
        v47 = ((_BYTE)_RDI + (_BYTE)_RDX - 32) & 0x1F;
        _RCX = (char *)_RSI + _RDX - v47 - 32;
        _R9 = &_R11[-v47];
        v50 = _RDX - v47;
        if ( v50 <= qword_C1260 || _R9 < &_RCX[v50] )
        {
          do
          {
            __asm
            {
              vmovdqu ymm0, ymmword ptr [rcx]
              vmovdqu ymm1, ymmword ptr [rcx-20h]
              vmovdqu ymm2, ymmword ptr [rcx-40h]
              vmovdqu ymm3, ymmword ptr [rcx-60h]
            }
            _RCX -= 128;
            v50 -= 128LL;
            __asm
            {
              vmovdqa ymmword ptr [r9], ymm0
              vmovdqa ymmword ptr [r9-20h], ymm1
              vmovdqa ymmword ptr [r9-40h], ymm2
              vmovdqa ymmword ptr [r9-60h], ymm3
            }
            _R9 -= 128;
          }
          while ( v50 > 0x80 );
          __asm
          {
            vmovdqu ymmword ptr [rdi], ymm4
            vmovdqu ymmword ptr [rdi+20h], ymm5
            vmovdqu ymmword ptr [rdi+40h], ymm6
            vmovdqu ymmword ptr [rdi+60h], ymm7
            vmovdqu ymmword ptr [r11], ymm8
            vzeroupper
          }
        }
        else
        {
          do
          {
            __asm
            {
              prefetcht0 byte ptr [rcx-100h]
              prefetcht0 byte ptr [rcx-140h]
              prefetcht0 byte ptr [rcx-180h]
              prefetcht0 byte ptr [rcx-1C0h]
              vmovdqu ymm0, ymmword ptr [rcx]
              vmovdqu ymm1, ymmword ptr [rcx-20h]
              vmovdqu ymm2, ymmword ptr [rcx-40h]
              vmovdqu ymm3, ymmword ptr [rcx-60h]
            }
            _RCX -= 128;
            v50 -= 128LL;
            __asm
            {
              vmovntdq ymmword ptr [r9], ymm0
              vmovntdq ymmword ptr [r9-20h], ymm1
              vmovntdq ymmword ptr [r9-40h], ymm2
              vmovntdq ymmword ptr [r9-60h], ymm3
            }
            _R9 -= 128;
          }
          while ( v50 > 0x80 );
          _mm_sfence();
          __asm
          {
            vmovdqu ymmword ptr [rdi], ymm4
            vmovdqu ymmword ptr [rdi+20h], ymm5
            vmovdqu ymmword ptr [rdi+40h], ymm6
            vmovdqu ymmword ptr [rdi+60h], ymm7
            vmovdqu ymmword ptr [r11], ymm8
            vzeroupper
          }
        }
      }
      else if ( _RDI != _RSI )
      {
        __asm
        {
          vmovdqu ymm4, ymmword ptr [rsi]
          vmovdqu ymm5, ymmword ptr [rsi+rdx-20h]
          vmovdqu ymm6, ymmword ptr [rsi+rdx-40h]
          vmovdqu ymm7, ymmword ptr [rsi+rdx-60h]
          vmovdqu ymm8, ymmword ptr [rsi+rdx-80h]
        }
        _R11 = _RDI;
        _RCX = (char *)_RDI + _RDX - 32;
        v33 = ((unsigned __int8)_RDI & 0x1F) - 32LL;
        _RSI = (char *)_RSI - v33;
        _RDI = (char *)_RDI - v33;
        v36 = v33 + _RDX;
        if ( v36 <= qword_C1260 || _RSI < &_RDI[v36] )
        {
          do
          {
            __asm
            {
              vmovdqu ymm0, ymmword ptr [rsi]
              vmovdqu ymm1, ymmword ptr [rsi+20h]
              vmovdqu ymm2, ymmword ptr [rsi+40h]
              vmovdqu ymm3, ymmword ptr [rsi+60h]
            }
            _RSI += 128;
            v36 -= 128LL;
            __asm
            {
              vmovdqa ymmword ptr [rdi], ymm0
              vmovdqa ymmword ptr [rdi+20h], ymm1
              vmovdqa ymmword ptr [rdi+40h], ymm2
              vmovdqa ymmword ptr [rdi+60h], ymm3
            }
            _RDI += 128;
          }
          while ( v36 > 0x80 );
          __asm
          {
            vmovdqu ymmword ptr [rcx], ymm5
            vmovdqu ymmword ptr [rcx-20h], ymm6
            vmovdqu ymmword ptr [rcx-40h], ymm7
            vmovdqu ymmword ptr [rcx-60h], ymm8
            vmovdqu ymmword ptr [r11], ymm4
            vzeroupper
          }
        }
        else
        {
          do
          {
            __asm
            {
              prefetcht0 byte ptr [rsi+100h]
              prefetcht0 byte ptr [rsi+140h]
              prefetcht0 byte ptr [rsi+180h]
              prefetcht0 byte ptr [rsi+1C0h]
              vmovdqu ymm0, ymmword ptr [rsi]
              vmovdqu ymm1, ymmword ptr [rsi+20h]
              vmovdqu ymm2, ymmword ptr [rsi+40h]
              vmovdqu ymm3, ymmword ptr [rsi+60h]
            }
            _RSI += 128;
            v36 -= 128LL;
            __asm
            {
              vmovntdq ymmword ptr [rdi], ymm0
              vmovntdq ymmword ptr [rdi+20h], ymm1
              vmovntdq ymmword ptr [rdi+40h], ymm2
              vmovntdq ymmword ptr [rdi+60h], ymm3
            }
            _RDI += 128;
          }
          while ( v36 > 0x80 );
          _mm_sfence();
          __asm
          {
            vmovdqu ymmword ptr [rcx], ymm5
            vmovdqu ymmword ptr [rcx-20h], ymm6
            vmovdqu ymmword ptr [rcx-40h], ymm7
            vmovdqu ymmword ptr [rcx-60h], ymm8
            vmovdqu ymmword ptr [r11], ymm4
            vzeroupper
          }
        }
      }
    }
    else if ( _RDX < 0x80 )
    {
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rsi]
        vmovdqu ymm1, ymmword ptr [rsi+20h]
        vmovdqu ymm2, ymmword ptr [rsi+rdx-20h]
        vmovdqu ymm3, ymmword ptr [rsi+rdx-40h]
        vmovdqu ymmword ptr [rdi], ymm0
        vmovdqu ymmword ptr [rdi+20h], ymm1
        vmovdqu ymmword ptr [rdi+rdx-20h], ymm2
        vmovdqu ymmword ptr [rdi+rdx-40h], ymm3
        vzeroupper
      }
    }
    else
    {
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rsi]
        vmovdqu ymm1, ymmword ptr [rsi+20h]
        vmovdqu ymm2, ymmword ptr [rsi+40h]
        vmovdqu ymm3, ymmword ptr [rsi+60h]
        vmovdqu ymm4, ymmword ptr [rsi+rdx-20h]
        vmovdqu ymm5, ymmword ptr [rsi+rdx-40h]
        vmovdqu ymm6, ymmword ptr [rsi+rdx-60h]
        vmovdqu ymm7, ymmword ptr [rsi+rdx-80h]
        vmovdqu ymmword ptr [rdi], ymm0
        vmovdqu ymmword ptr [rdi+20h], ymm1
        vmovdqu ymmword ptr [rdi+40h], ymm2
        vmovdqu ymmword ptr [rdi+60h], ymm3
        vmovdqu ymmword ptr [rdi+rdx-20h], ymm4
        vmovdqu ymmword ptr [rdi+rdx-40h], ymm5
        vmovdqu ymmword ptr [rdi+rdx-60h], ymm6
        vmovdqu ymmword ptr [rdi+rdx-80h], ymm7
        vzeroupper
      }
    }
  }
  else
  {
    __asm
    {
      vmovdqu ymm0, ymmword ptr [rsi]
      vmovdqu ymm1, ymmword ptr [rsi+rdx-20h]
      vmovdqu ymmword ptr [rdi], ymm0
      vmovdqu ymmword ptr [rdi+rdx-20h], ymm1
      vzeroupper
    }
  }
  return result;
}
// C1260: using guessed type __int64 qword_C1260;

//----- (0000000000047E80) ----------------------------------------------------
void sub_47E80()
{
  JUMPOUT(0x47E97LL);
}
// 47E8A: control flows out of bounds to 47E97

//----- (0000000000047E90) ----------------------------------------------------
__int64 *__fastcall sub_47E90(__int64 *_RDI, __int64 *_RSI, unsigned __int64 _RDX)
{
  __int64 *result; // rax
  __int64 v10; // rcx
  __int64 v11; // rsi
  int v12; // ecx
  int v13; // esi
  __int16 v14; // cx
  __int16 v15; // si
  __int64 v35; // r8
  unsigned __int64 v38; // rdx
  __int64 v49; // r8
  unsigned __int64 v52; // rdx

  result = _RDI;
  if ( _RDX < 0x40 )
  {
    if ( (unsigned __int8)_RDX >= 0x20u )
    {
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rsi]
        vmovdqu ymm1, ymmword ptr [rsi+rdx-20h]
        vmovdqu ymmword ptr [rdi], ymm0
        vmovdqu ymmword ptr [rdi+rdx-20h], ymm1
        vzeroupper
      }
    }
    else if ( (unsigned __int8)_RDX >= 0x10u )
    {
      __asm
      {
        vmovdqu xmm0, xmmword ptr [rsi]
        vmovdqu xmm1, xmmword ptr [rsi+rdx-10h]
        vmovdqu xmmword ptr [rdi], xmm0
        vmovdqu xmmword ptr [rdi+rdx-10h], xmm1
      }
    }
    else if ( (unsigned __int8)_RDX >= 8u )
    {
      v10 = *(__int64 *)((char *)_RSI + _RDX - 8);
      v11 = *_RSI;
      *(__int64 *)((char *)_RDI + _RDX - 8) = v10;
      *_RDI = v11;
    }
    else if ( (unsigned __int8)_RDX >= 4u )
    {
      v12 = *(_DWORD *)((char *)_RSI + _RDX - 4);
      v13 = *(_DWORD *)_RSI;
      *(_DWORD *)((char *)_RDI + _RDX - 4) = v12;
      *(_DWORD *)_RDI = v13;
    }
    else if ( (unsigned __int8)_RDX > 1u )
    {
      v14 = *(_WORD *)((char *)_RSI + _RDX - 2);
      v15 = *(_WORD *)_RSI;
      *(_WORD *)((char *)_RDI + _RDX - 2) = v14;
      *(_WORD *)_RDI = v15;
    }
    else if ( (_BYTE)_RDX )
    {
      *(_BYTE *)_RDI = *(_BYTE *)_RSI;
    }
  }
  else if ( _RDX > 0x80 )
  {
    if ( _RDX > 0x200 )
    {
      if ( _RDI > _RSI )
      {
        __asm
        {
          vmovdqu64 zmm4, zmmword ptr [rsi]
          vmovdqu64 zmm5, zmmword ptr [rsi+40h]
          vmovdqu64 zmm6, zmmword ptr [rsi+80h]
          vmovdqu64 zmm7, zmmword ptr [rsi+0C0h]
          vmovdqu64 zmm8, zmmword ptr [rsi+rdx-40h]
        }
        _R11 = (char *)_RDI + _RDX - 64;
        v49 = ((_BYTE)_RDI + (_BYTE)_RDX - 64) & 0x3F;
        _RCX = (char *)_RSI + _RDX - v49 - 64;
        _R9 = &_R11[-v49];
        v52 = _RDX - v49;
        if ( v52 <= qword_C1260 || _R9 < &_RCX[v52] )
        {
          do
          {
            __asm
            {
              vmovdqu64 zmm0, zmmword ptr [rcx]
              vmovdqu64 zmm1, zmmword ptr [rcx-40h]
              vmovdqu64 zmm2, zmmword ptr [rcx-80h]
              vmovdqu64 zmm3, zmmword ptr [rcx-0C0h]
            }
            _RCX -= 256;
            v52 -= 256LL;
            __asm
            {
              vmovdqa64 zmmword ptr [r9], zmm0
              vmovdqa64 zmmword ptr [r9-40h], zmm1
              vmovdqa64 zmmword ptr [r9-80h], zmm2
              vmovdqa64 zmmword ptr [r9-0C0h], zmm3
            }
            _R9 -= 256;
          }
          while ( v52 > 0x100 );
          __asm
          {
            vmovdqu64 zmmword ptr [rdi], zmm4
            vmovdqu64 zmmword ptr [rdi+40h], zmm5
            vmovdqu64 zmmword ptr [rdi+80h], zmm6
            vmovdqu64 zmmword ptr [rdi+0C0h], zmm7
            vmovdqu64 zmmword ptr [r11], zmm8
            vzeroupper
          }
        }
        else
        {
          do
          {
            __asm
            {
              prefetcht0 byte ptr [rcx-200h]
              prefetcht0 byte ptr [rcx-240h]
              prefetcht0 byte ptr [rcx-280h]
              prefetcht0 byte ptr [rcx-2C0h]
              prefetcht0 byte ptr [rcx-300h]
              prefetcht0 byte ptr [rcx-340h]
              prefetcht0 byte ptr [rcx-380h]
              prefetcht0 byte ptr [rcx-3C0h]
              vmovdqu64 zmm0, zmmword ptr [rcx]
              vmovdqu64 zmm1, zmmword ptr [rcx-40h]
              vmovdqu64 zmm2, zmmword ptr [rcx-80h]
              vmovdqu64 zmm3, zmmword ptr [rcx-0C0h]
            }
            _RCX -= 256;
            v52 -= 256LL;
            __asm
            {
              vmovntdq zmmword ptr [r9], zmm0
              vmovntdq zmmword ptr [r9-40h], zmm1
              vmovntdq zmmword ptr [r9-80h], zmm2
              vmovntdq zmmword ptr [r9-0C0h], zmm3
            }
            _R9 -= 256;
          }
          while ( v52 > 0x100 );
          _mm_sfence();
          __asm
          {
            vmovdqu64 zmmword ptr [rdi], zmm4
            vmovdqu64 zmmword ptr [rdi+40h], zmm5
            vmovdqu64 zmmword ptr [rdi+80h], zmm6
            vmovdqu64 zmmword ptr [rdi+0C0h], zmm7
            vmovdqu64 zmmword ptr [r11], zmm8
            vzeroupper
          }
        }
      }
      else if ( _RDI != _RSI )
      {
        __asm
        {
          vmovdqu64 zmm4, zmmword ptr [rsi]
          vmovdqu64 zmm5, zmmword ptr [rsi+rdx-40h]
          vmovdqu64 zmm6, zmmword ptr [rsi+rdx-80h]
          vmovdqu64 zmm7, zmmword ptr [rsi+rdx-0C0h]
          vmovdqu64 zmm8, zmmword ptr [rsi+rdx-100h]
        }
        _R11 = _RDI;
        _RCX = (char *)_RDI + _RDX - 64;
        v35 = ((unsigned __int8)_RDI & 0x3F) - 64LL;
        _RSI = (char *)_RSI - v35;
        _RDI = (char *)_RDI - v35;
        v38 = v35 + _RDX;
        if ( v38 <= qword_C1260 || _RSI < &_RDI[v38] )
        {
          do
          {
            __asm
            {
              vmovdqu64 zmm0, zmmword ptr [rsi]
              vmovdqu64 zmm1, zmmword ptr [rsi+40h]
              vmovdqu64 zmm2, zmmword ptr [rsi+80h]
              vmovdqu64 zmm3, zmmword ptr [rsi+0C0h]
            }
            _RSI += 256;
            v38 -= 256LL;
            __asm
            {
              vmovdqa64 zmmword ptr [rdi], zmm0
              vmovdqa64 zmmword ptr [rdi+40h], zmm1
              vmovdqa64 zmmword ptr [rdi+80h], zmm2
              vmovdqa64 zmmword ptr [rdi+0C0h], zmm3
            }
            _RDI += 256;
          }
          while ( v38 > 0x100 );
          __asm
          {
            vmovdqu64 zmmword ptr [rcx], zmm5
            vmovdqu64 zmmword ptr [rcx-40h], zmm6
            vmovdqu64 zmmword ptr [rcx-80h], zmm7
            vmovdqu64 zmmword ptr [rcx-0C0h], zmm8
            vmovdqu64 zmmword ptr [r11], zmm4
            vzeroupper
          }
        }
        else
        {
          do
          {
            __asm
            {
              prefetcht0 byte ptr [rsi+200h]
              prefetcht0 byte ptr [rsi+240h]
              prefetcht0 byte ptr [rsi+280h]
              prefetcht0 byte ptr [rsi+2C0h]
              prefetcht0 byte ptr [rsi+300h]
              prefetcht0 byte ptr [rsi+340h]
              prefetcht0 byte ptr [rsi+380h]
              prefetcht0 byte ptr [rsi+3C0h]
              vmovdqu64 zmm0, zmmword ptr [rsi]
              vmovdqu64 zmm1, zmmword ptr [rsi+40h]
              vmovdqu64 zmm2, zmmword ptr [rsi+80h]
              vmovdqu64 zmm3, zmmword ptr [rsi+0C0h]
            }
            _RSI += 256;
            v38 -= 256LL;
            __asm
            {
              vmovntdq zmmword ptr [rdi], zmm0
              vmovntdq zmmword ptr [rdi+40h], zmm1
              vmovntdq zmmword ptr [rdi+80h], zmm2
              vmovntdq zmmword ptr [rdi+0C0h], zmm3
            }
            _RDI += 256;
          }
          while ( v38 > 0x100 );
          _mm_sfence();
          __asm
          {
            vmovdqu64 zmmword ptr [rcx], zmm5
            vmovdqu64 zmmword ptr [rcx-40h], zmm6
            vmovdqu64 zmmword ptr [rcx-80h], zmm7
            vmovdqu64 zmmword ptr [rcx-0C0h], zmm8
            vmovdqu64 zmmword ptr [r11], zmm4
            vzeroupper
          }
        }
      }
    }
    else if ( _RDX < 0x100 )
    {
      __asm
      {
        vmovdqu64 zmm0, zmmword ptr [rsi]
        vmovdqu64 zmm1, zmmword ptr [rsi+40h]
        vmovdqu64 zmm2, zmmword ptr [rsi+rdx-40h]
        vmovdqu64 zmm3, zmmword ptr [rsi+rdx-80h]
        vmovdqu64 zmmword ptr [rdi], zmm0
        vmovdqu64 zmmword ptr [rdi+40h], zmm1
        vmovdqu64 zmmword ptr [rdi+rdx-40h], zmm2
        vmovdqu64 zmmword ptr [rdi+rdx-80h], zmm3
        vzeroupper
      }
    }
    else
    {
      __asm
      {
        vmovdqu64 zmm0, zmmword ptr [rsi]
        vmovdqu64 zmm1, zmmword ptr [rsi+40h]
        vmovdqu64 zmm2, zmmword ptr [rsi+80h]
        vmovdqu64 zmm3, zmmword ptr [rsi+0C0h]
        vmovdqu64 zmm4, zmmword ptr [rsi+rdx-40h]
        vmovdqu64 zmm5, zmmword ptr [rsi+rdx-80h]
        vmovdqu64 zmm6, zmmword ptr [rsi+rdx-0C0h]
        vmovdqu64 zmm7, zmmword ptr [rsi+rdx-100h]
        vmovdqu64 zmmword ptr [rdi], zmm0
        vmovdqu64 zmmword ptr [rdi+40h], zmm1
        vmovdqu64 zmmword ptr [rdi+80h], zmm2
        vmovdqu64 zmmword ptr [rdi+0C0h], zmm3
        vmovdqu64 zmmword ptr [rdi+rdx-40h], zmm4
        vmovdqu64 zmmword ptr [rdi+rdx-80h], zmm5
        vmovdqu64 zmmword ptr [rdi+rdx-0C0h], zmm6
        vmovdqu64 zmmword ptr [rdi+rdx-100h], zmm7
        vzeroupper
      }
    }
  }
  else
  {
    __asm
    {
      vmovdqu64 zmm0, zmmword ptr [rsi]
      vmovdqu64 zmm1, zmmword ptr [rsi+rdx-40h]
      vmovdqu64 zmmword ptr [rdi], zmm0
      vmovdqu64 zmmword ptr [rdi+rdx-40h], zmm1
      vzeroupper
    }
  }
  return result;
}
// 47E90: unsupported processor register 'zmm0'
// C1260: using guessed type __int64 qword_C1260;

//----- (00000000000483D0) ----------------------------------------------------
void sub_483D0()
{
  JUMPOUT(0x48408LL);
}
// 483E4: control flows out of bounds to 48408

//----- (00000000000483F0) ----------------------------------------------------
__m128i *__fastcall sub_483F0(__m128i *a1, unsigned int a2, unsigned __int64 a3)
{
  __m128i v3; // xmm0
  __m128i *result; // rax
  __m128i v5; // xmm0
  __m128i v6; // xmm0

  v3 = _mm_cvtsi32_si128(a2);
  result = a1;
  v5 = _mm_unpacklo_epi8(v3, v3);
  v6 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v5, v5), 0);
  if ( a3 < 0x10 )
    JUMPOUT(0x48515LL);
  if ( a3 > 0x20 )
    JUMPOUT(0x4849CLL);
  *(__m128i *)((char *)&a1[-1] + a3) = v6;
  *a1 = v6;
  return result;
}
// 4840C: control flows out of bounds to 48515
// 48416: control flows out of bounds to 4849C

//----- (0000000000048440) ----------------------------------------------------
__int64 __fastcall sub_48440(__int64 a1)
{
  return a1;
}

//----- (0000000000048460) ----------------------------------------------------
__m128i *__fastcall sub_48460(__m128i *a1, char a2, unsigned __int64 a3)
{
  __m128i v3; // xmm0
  __m128i *result; // rax
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  _OWORD *v7; // rcx
  unsigned __int64 i; // rdx

  v3 = _mm_cvtsi32_si128(a2);
  result = a1;
  v5 = _mm_unpacklo_epi8(v3, v3);
  v6 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v5, v5), 0);
  if ( a3 < 0x10 )
  {
    if ( (unsigned __int8)a3 >= 8u )
    {
      *(__int64 *)((char *)&a1->m128i_i64[-1] + a3) = v6.m128i_i64[0];
      a1->m128i_i64[0] = v6.m128i_i64[0];
    }
    else if ( (unsigned __int8)a3 >= 4u )
    {
      *(__int32 *)((char *)&a1->m128i_i32[-1] + a3) = v6.m128i_i32[0];
      a1->m128i_i32[0] = v6.m128i_i32[0];
    }
    else if ( (unsigned __int8)a3 > 1u )
    {
      *(__int16 *)((char *)&a1->m128i_i16[-1] + a3) = v6.m128i_i16[0];
      a1->m128i_i16[0] = v6.m128i_i16[0];
    }
    else if ( (_BYTE)a3 )
    {
      a1->m128i_i8[0] = v6.m128i_i8[0];
    }
  }
  else if ( a3 > 0x20 )
  {
    if ( a3 > qword_BEF80 )
    {
      memset(a1, a2, a3);
      result = a1;
    }
    else if ( a3 > 0x40 )
    {
      *a1 = v6;
      v7 = (_OWORD *)((unsigned __int64)&a1[4] & 0xFFFFFFFFFFFFFFC0LL);
      *(__m128i *)((char *)&a1[-1] + a3) = v6;
      a1[1] = v6;
      *(__m128i *)((char *)&a1[-2] + a3) = v6;
      a1[2] = v6;
      *(__m128i *)((char *)&a1[-3] + a3) = v6;
      a1[3] = v6;
      *(__m128i *)((char *)&a1[-4] + a3) = v6;
      for ( i = ((unsigned __int64)a1->m128i_u64 + a3) & 0xFFFFFFFFFFFFFFC0LL; (_OWORD *)i != v7; v7 += 4 )
      {
        *v7 = v6;
        v7[1] = v6;
        v7[2] = v6;
        v7[3] = v6;
      }
    }
    else
    {
      *a1 = v6;
      a1[1] = v6;
      *(__m128i *)((char *)&a1[-1] + a3) = v6;
      *(__m128i *)((char *)&a1[-2] + a3) = v6;
    }
  }
  else
  {
    *(__m128i *)((char *)&a1[-1] + a3) = v6;
    *a1 = v6;
  }
  return result;
}
// BEF80: using guessed type __int64 qword_BEF80;

//----- (0000000000048550) ----------------------------------------------------
void __fastcall sub_48550(__int64 a1, int _ESI)
{
  __asm
  {
    vmovd   xmm0, esi
    vpbroadcastd ymm0, xmm0
  }
  JUMPOUT(0x48580LL);
}
// 48564: control flows out of bounds to 48580

//----- (0000000000048570) ----------------------------------------------------
_QWORD *__fastcall sub_48570(_QWORD *_RDI, int _ESI, unsigned __int64 _RDX)
{
  _QWORD *result; // rax
  unsigned __int64 v7; // rdx

  __asm { vmovd   xmm0, esi }
  result = _RDI;
  __asm { vpbroadcastb ymm0, xmm0 }
  if ( _RDX < 0x20 )
  {
    if ( (unsigned __int8)_RDX >= 0x10u )
    {
      __asm
      {
        vmovdqu xmmword ptr [rdi+rdx-10h], xmm0
        vmovdqu xmmword ptr [rdi], xmm0
        vzeroupper
      }
    }
    else
    {
      __asm { vmovq   rcx, xmm0 }
      if ( (unsigned __int8)_RDX >= 8u )
      {
        *(_QWORD *)((char *)_RDI + _RDX - 8) = _RCX;
        *_RDI = _RCX;
        __asm { vzeroupper }
      }
      else if ( (unsigned __int8)_RDX >= 4u )
      {
        *(_DWORD *)((char *)_RDI + _RDX - 4) = _RCX;
        *(_DWORD *)_RDI = _RCX;
        __asm { vzeroupper }
      }
      else if ( (unsigned __int8)_RDX > 1u )
      {
        *(_WORD *)((char *)_RDI + _RDX - 2) = _RCX;
        *(_WORD *)_RDI = _RCX;
        __asm { vzeroupper }
      }
      else
      {
        if ( (_BYTE)_RDX )
          *(_BYTE *)_RDI = _RCX;
        __asm { vzeroupper }
      }
    }
  }
  else
  {
    if ( _RDX <= 0x40 )
    {
      __asm
      {
        vmovdqu ymmword ptr [rdi+rdx-20h], ymm0
        vmovdqu ymmword ptr [rdi], ymm0
        vzeroupper
      }
      return result;
    }
    if ( _RDX <= 0x80 )
    {
      __asm
      {
        vmovdqu ymmword ptr [rdi], ymm0
        vmovdqu ymmword ptr [rdi+20h], ymm0
        vmovdqu ymmword ptr [rdi+rdx-20h], ymm0
        vmovdqu ymmword ptr [rdi+rdx-40h], ymm0
      }
LABEL_6:
      __asm { vzeroupper }
      return result;
    }
    __asm { vmovdqu ymmword ptr [rdi], ymm0 }
    _RCX = (unsigned __int64)(_RDI + 16) & 0xFFFFFFFFFFFFFF80LL;
    __asm
    {
      vmovdqu ymmword ptr [rdi+rdx-20h], ymm0
      vmovdqu ymmword ptr [rdi+20h], ymm0
      vmovdqu ymmword ptr [rdi+rdx-40h], ymm0
      vmovdqu ymmword ptr [rdi+40h], ymm0
      vmovdqu ymmword ptr [rdi+rdx-60h], ymm0
      vmovdqu ymmword ptr [rdi+60h], ymm0
      vmovdqu ymmword ptr [rdi+rdx-80h], ymm0
    }
    v7 = ((unsigned __int64)_RDI + _RDX) & 0xFFFFFFFFFFFFFF80LL;
    if ( _RCX == v7 )
      goto LABEL_6;
    do
    {
      __asm
      {
        vmovdqa ymmword ptr [rcx], ymm0
        vmovdqa ymmword ptr [rcx+20h], ymm0
        vmovdqa ymmword ptr [rcx+40h], ymm0
        vmovdqa ymmword ptr [rcx+60h], ymm0
      }
      _RCX += 128LL;
    }
    while ( v7 != _RCX );
    __asm { vzeroupper }
  }
  return result;
}

//----- (00000000000486D0) ----------------------------------------------------
void __fastcall sub_486D0(__int64 a1, int _ESI)
{
  __asm
  {
    vmovd   xmm0, esi
    vpbroadcastd xmm0, xmm0
    vpbroadcastq zmm0, xmm0
  }
  JUMPOUT(0x48706LL);
}
// 486EA: control flows out of bounds to 48706
// 486D0: unsupported processor register 'zmm0'

//----- (00000000000486F0) ----------------------------------------------------
_QWORD *__fastcall sub_486F0(_QWORD *_RDI, int _ESI, unsigned __int64 _RDX)
{
  _QWORD *result; // rax
  unsigned __int64 v8; // rdx

  __asm { vmovd   xmm0, esi }
  result = _RDI;
  __asm
  {
    vpbroadcastb xmm0, xmm0
    vpbroadcastq zmm0, xmm0
  }
  if ( _RDX < 0x40 )
  {
    if ( (unsigned __int8)_RDX >= 0x20u )
    {
      __asm
      {
        vmovdqu ymmword ptr [rdi+rdx-20h], ymm0
        vmovdqu ymmword ptr [rdi], ymm0
        vzeroupper
      }
    }
    else if ( (unsigned __int8)_RDX >= 0x10u )
    {
      __asm
      {
        vmovdqu xmmword ptr [rdi+rdx-10h], xmm0
        vmovdqu xmmword ptr [rdi], xmm0
        vzeroupper
      }
    }
    else
    {
      __asm { vmovq   rcx, xmm0 }
      if ( (unsigned __int8)_RDX >= 8u )
      {
        *(_QWORD *)((char *)_RDI + _RDX - 8) = _RCX;
        *_RDI = _RCX;
        __asm { vzeroupper }
      }
      else if ( (unsigned __int8)_RDX >= 4u )
      {
        *(_DWORD *)((char *)_RDI + _RDX - 4) = _RCX;
        *(_DWORD *)_RDI = _RCX;
        __asm { vzeroupper }
      }
      else if ( (unsigned __int8)_RDX > 1u )
      {
        *(_WORD *)((char *)_RDI + _RDX - 2) = _RCX;
        *(_WORD *)_RDI = _RCX;
        __asm { vzeroupper }
      }
      else
      {
        if ( (_BYTE)_RDX )
          *(_BYTE *)_RDI = _RCX;
        __asm { vzeroupper }
      }
    }
  }
  else
  {
    if ( _RDX <= 0x80 )
    {
      __asm
      {
        vmovdqu64 zmmword ptr [rdi+rdx-40h], zmm0
        vmovdqu64 zmmword ptr [rdi], zmm0
        vzeroupper
      }
      return result;
    }
    if ( _RDX <= 0x100 )
    {
      __asm
      {
        vmovdqu64 zmmword ptr [rdi], zmm0
        vmovdqu64 zmmword ptr [rdi+40h], zmm0
        vmovdqu64 zmmword ptr [rdi+rdx-40h], zmm0
        vmovdqu64 zmmword ptr [rdi+rdx-80h], zmm0
      }
LABEL_6:
      __asm { vzeroupper }
      return result;
    }
    __asm { vmovdqu64 zmmword ptr [rdi], zmm0 }
    _RCX = (unsigned __int64)(_RDI + 32) & 0xFFFFFFFFFFFFFF00LL;
    __asm
    {
      vmovdqu64 zmmword ptr [rdi+rdx-40h], zmm0
      vmovdqu64 zmmword ptr [rdi+40h], zmm0
      vmovdqu64 zmmword ptr [rdi+rdx-80h], zmm0
      vmovdqu64 zmmword ptr [rdi+80h], zmm0
      vmovdqu64 zmmword ptr [rdi+rdx-0C0h], zmm0
      vmovdqu64 zmmword ptr [rdi+0C0h], zmm0
      vmovdqu64 zmmword ptr [rdi+rdx-100h], zmm0
    }
    v8 = ((unsigned __int64)_RDI + _RDX) & 0xFFFFFFFFFFFFFF00LL;
    if ( _RCX == v8 )
      goto LABEL_6;
    do
    {
      __asm
      {
        vmovdqa64 zmmword ptr [rcx], zmm0
        vmovdqa64 zmmword ptr [rcx+40h], zmm0
        vmovdqa64 zmmword ptr [rcx+80h], zmm0
        vmovdqa64 zmmword ptr [rcx+0C0h], zmm0
      }
      _RCX += 256LL;
    }
    while ( v8 != _RCX );
    __asm { vzeroupper }
  }
  return result;
}
// 486F0: unsupported processor register 'zmm0'

//----- (0000000000048900) ----------------------------------------------------
__int64 __fastcall sub_48900(int a1)
{
  __int64 v11; // rdi

  _RAX = 0x80000000LL;
  __asm { cpuid }
  if ( a1 <= 196 )
  {
    if ( a1 > 190 )
    {
      if ( (unsigned int)_RAX > 0x80000005 )
      {
        _RAX = 2147483654LL;
        __asm { cpuid }
        goto LABEL_6;
      }
    }
    else if ( (unsigned int)_RAX > 0x80000004 )
    {
      _RAX = 2147483653LL;
      __asm { cpuid }
      if ( a1 <= 187 )
        a1 += 3;
LABEL_6:
      v11 = (unsigned int)(a1 - 188);
      if ( (unsigned int)v11 <= 8 )
        __asm { jmp     rax }
      sub_CF00("! \"cannot happen\"", "../sysdeps/x86/cacheinfo.c", 433LL, "handle_amd");
    }
  }
  return 0LL;
}
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000048AE0) ----------------------------------------------------
__int64 __fastcall sub_48AE0(int a1)
{
  int v1; // er9
  int v2; // edi
  int v8; // edx
  int v9; // esi
  int v12; // eax
  int v13; // er9

  v1 = a1 - 185;
  v2 = 3 * ((a1 - 185) / 3);
  _RAX = 4LL;
  __asm { cpuid }
  v8 = _RAX & 0x1F;
  if ( (_RAX & 0x1F) == 0 )
    return 0LL;
  v9 = 0;
  while ( 1 )
  {
    v12 = (unsigned __int8)_RAX >> 5;
    if ( v8 == 1 && v12 == 1 )
    {
      if ( v2 == 3 )
        goto LABEL_10;
      goto LABEL_4;
    }
    if ( v8 != 2 || v12 != 1 )
      break;
    if ( !v2 )
      goto LABEL_10;
LABEL_4:
    ++v9;
    _RAX = 4LL;
    __asm { cpuid }
    v8 = _RAX & 0x1F;
    if ( (_RAX & 0x1F) == 0 )
      return 0LL;
  }
  if ( (v12 != 2 || v2 != 6) && (v12 != 3 || v2 != 9) )
    goto LABEL_4;
LABEL_10:
  v13 = v1 % 3;
  if ( !v13 )
    return ((_RBX & 0xFFF) + 1)
         * (((unsigned int)_RBX >> 22) + 1)
         * ((int)_RCX + 1)
         * ((((unsigned int)_RBX >> 12) & 0x3FF) + 1);
  if ( v13 == 1 )
    return ((unsigned int)_RBX >> 22) + 1;
  if ( v13 != 2 )
    sub_CF00("offset == 2", "../sysdeps/x86/cacheinfo.c", 478LL, "handle_zhaoxin");
  return (_RBX & 0xFFF) + 1;
}
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000048C20) ----------------------------------------------------
__int64 __fastcall sub_48C20(int a1, int a2, _BYTE *a3, _BYTE *a4)
{
  unsigned int v5; // edi
  int v7; // er10
  bool v9; // r12
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rax
  unsigned __int8 *v13; // rsi
  int v14; // edx
  int v21; // edx
  int v22; // esi
  int v25; // eax
  int v26; // eax
  int v27; // eax

  if ( a2 < 0 )
    return 0LL;
  v5 = a2;
  v7 = 3 * ((a1 - 185) / 3);
  if ( !a2 )
    return 0LL;
  v9 = dword_C134C == 6 && dword_C1348 == 15;
  while ( 1 )
  {
    if ( (_BYTE)v5 == 64 )
    {
      *a4 = 1;
      if ( v7 == 9 )
        return 0LL;
      goto LABEL_5;
    }
    if ( (unsigned __int8)v5 == 255 )
      break;
    if ( (unsigned __int8)v5 == 73 && v7 == 9 && v9 )
    {
      a1 -= 3;
      v7 = 6;
    }
    v10 = 68LL;
    v11 = 0LL;
    while ( 1 )
    {
      v12 = (v11 + v10) >> 1;
      v13 = (unsigned __int8 *)&unk_929C0 + 8 * v12;
      if ( (_BYTE)v5 == *v13 )
        break;
      if ( (unsigned __int8)v5 < *v13 )
        v10 = (v11 + v10) >> 1;
      else
        v11 = v12 + 1;
      if ( v10 <= v11 )
        goto LABEL_5;
    }
    v14 = v13[3];
    if ( v14 == v7 )
    {
      v27 = a1 - 185 - v7;
      if ( a1 - 185 == v7 )
        return *((unsigned int *)v13 + 1);
      if ( v27 == 1 )
        return v13[1];
      if ( v27 != 2 )
        sub_CF00("offset == 2", "../sysdeps/x86/cacheinfo.c", 240LL, "intel_check_word");
      return v13[2];
    }
    if ( (_BYTE)v14 == 6 )
    {
      v5 >>= 8;
      *a3 = 1;
      if ( !v5 )
        return 0LL;
    }
    else
    {
LABEL_5:
      v5 >>= 8;
      if ( !v5 )
        return 0LL;
    }
  }
  _RAX = 4LL;
  __asm { cpuid }
  v21 = _RAX & 0x1F;
  if ( (_RAX & 0x1F) == 0 )
    return 0LL;
  v22 = 0;
  while ( 1 )
  {
    v25 = (unsigned __int8)_RAX >> 5;
    if ( v21 == 1 && v25 == 1 )
    {
      if ( v7 == 3 )
        goto LABEL_33;
      goto LABEL_28;
    }
    if ( v21 != 2 || v25 != 1 )
      break;
    if ( !v7 )
      goto LABEL_33;
LABEL_28:
    ++v22;
    _RAX = 4LL;
    __asm { cpuid }
    v21 = _RAX & 0x1F;
    if ( (_RAX & 0x1F) == 0 )
      return 0LL;
  }
  if ( (v25 != 2 || v7 != 6) && (v25 != 3 || v7 != 9) && (v25 != 4 || v7 != 12) )
    goto LABEL_28;
LABEL_33:
  v26 = a1 - 185 - v7;
  if ( a1 - 185 == v7 )
    return ((((unsigned int)_RBX >> 12) & 0x3FF) + 1)
         * ((int)_RCX + 1)
         * ((_RBX & 0xFFF) + 1)
         * (((unsigned int)_RBX >> 22) + 1);
  if ( v26 == 1 )
    return ((unsigned int)_RBX >> 22) + 1;
  if ( v26 != 2 )
    sub_CF00("offset == 2", "../sysdeps/x86/cacheinfo.c", 192LL, "intel_check_word");
  return (_RBX & 0xFFF) + 1;
}
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// C1348: using guessed type int dword_C1348;
// C134C: using guessed type int dword_C134C;

//----- (0000000000048E90) ----------------------------------------------------
__int64 __fastcall sub_48E90(int a1)
{
  unsigned int v1; // er14
  int v7; // er15
  int v8; // esi
  __int64 result; // rax
  int v10; // [rsp+8h] [rbp-50h]
  unsigned int v11; // [rsp+Ch] [rbp-4Ch]
  unsigned __int8 v12; // [rsp+16h] [rbp-42h] BYREF
  char v13; // [rsp+17h] [rbp-41h] BYREF
  unsigned __int64 v14; // [rsp+18h] [rbp-40h]

  v14 = __readfsqword(0x28u);
  if ( (unsigned int)dword_C1344 <= 1 )
    return -1LL;
  v12 = 0;
  v1 = 1;
  v13 = 0;
  v11 = 1;
  while ( 1 )
  {
    _RAX = 2LL;
    __asm { cpuid }
    v10 = _RDX;
    v7 = _RCX;
    v8 = _RAX;
    if ( v1 == 1 )
    {
      LOBYTE(v8) = 0;
      v11 = (unsigned __int8)_RAX;
    }
    result = sub_48C20(a1, v8, &v13, &v12);
    if ( result )
      break;
    result = sub_48C20(a1, _RBX, &v13, &v12);
    if ( result )
      break;
    result = sub_48C20(a1, v7, &v13, &v12);
    if ( result )
      break;
    result = sub_48C20(a1, v10, &v13, &v12);
    if ( result )
      break;
    if ( v11 <= v1 )
    {
      if ( (unsigned int)(a1 - 191) <= 5 )
        result = -(__int64)v12;
      return result;
    }
    ++v1;
  }
  return result;
}
// C1344: using guessed type int dword_C1344;

//----- (0000000000048FC0) ----------------------------------------------------
__int64 __fastcall sub_48FC0(int a1)
{
  switch ( dword_C1340 )
  {
    case 1:
      return sub_48E90(a1);
    case 2:
      return sub_48900(a1);
    case 3:
      return sub_48AE0(a1);
  }
  return 0LL;
}
// C1340: using guessed type int dword_C1340;

//----- (0000000000049000) ----------------------------------------------------
__int64 __fastcall sub_49000(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_91D0(a1, a2, 4 * a3);
}
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);

//----- (0000000000049010) ----------------------------------------------------
__int64 __fastcall sub_49010(__int64 a1, __int64 *a2, void **a3, __int64 *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, __int64 a13, __int64 a14)
{
  u32 *v14; // r8
  __int64 v15; // rbx
  __int64 v16; // rsi
  void **v17; // rax
  void *v18; // rbp
  __int64 (__fastcall *v19)(void *, __int64 *, __int64 *, __int64, _QWORD, char *, _QWORD, __int64); // rbx
  __int64 v20; // r15
  __int64 v21; // r12
  unsigned __int64 v22; // rax
  double v23; // xmm4_8
  double v24; // xmm5_8
  __int64 v25; // rdi
  __int64 v26; // rdx
  __int64 v28; // rdx
  __int64 v29; // rax
  char *v30; // r11
  __int64 v31; // r12
  __int64 v32; // r15
  char *v34; // [rsp+8h] [rbp-1A8h]
  char v36[8]; // [rsp+20h] [rbp-190h] BYREF
  __int64 v37; // [rsp+28h] [rbp-188h] BYREF
  __int64 v38; // [rsp+30h] [rbp-180h] BYREF
  __int64 v39; // [rsp+38h] [rbp-178h] BYREF
  char *v40; // [rsp+40h] [rbp-170h]
  __int64 v41; // [rsp+48h] [rbp-168h]
  int v42; // [rsp+50h] [rbp-160h]
  __int64 *v43; // [rsp+58h] [rbp-158h]
  char v44; // [rsp+68h] [rbp-148h] BYREF
  char v45; // [rsp+168h] [rbp-48h] BYREF
  unsigned __int64 v46; // [rsp+170h] [rbp-40h]

  if ( !a4 )
    a4 = (__int64 *)&unk_C1268;
  v14 = (u32 *)__readfsqword(0xFFFFFFA8);
  v15 = *(_QWORD *)v14;
  v16 = (__int64)a3;
  v46 = __readfsqword(0x28u);
  v17 = *(void ***)(v15 + 40);
  v42 = 1;
  v41 = 1LL;
  v43 = a4;
  if ( !v17 )
  {
    a3 = &off_BAE20;
    v17 = &off_BAD80;
    if ( (void **)v15 != &off_BAE20 )
    {
      sub_49110(v15, a5, a6, a7, a8, a9, a10, a11, a12, v16, (__int64)&off_BAE20, (__int64)a4, v14, a14);
      v17 = *(void ***)(v15 + 40);
    }
  }
  v18 = *v17;
  v19 = (__int64 (__fastcall *)(void *, __int64 *, __int64 *, __int64, _QWORD, char *, _QWORD, __int64))*((_QWORD *)*v17 + 5);
  if ( *(_QWORD *)*v17 )
    v19 = (__int64 (__fastcall *)(void *, __int64 *, __int64 *, __int64, _QWORD, char *, _QWORD, __int64))(__readfsqword(0x30u) ^ __ROR8__(v19, 17));
  v20 = *a2;
  v37 = *a2;
  if ( a1 )
  {
    v39 = a1;
    v40 = (char *)(a1 + 4 * v16);
    if ( !v16 )
      return 0LL;
    do
    {
      v21 = v20 + sub_9040(v20, v16, a3, a4, v14, a14) + 1;
      sub_4F2B0((__int64)v19);
      v22 = v19(v18, &v39, &v37, v21, 0LL, v36, 0LL, 1LL);
      v20 = v37;
      v25 = v39;
      if ( (_DWORD)v22 != 4 && (_DWORD)v22 != 7 )
        break;
      if ( v37 != v21 )
        break;
      if ( !*(_BYTE *)(v21 - 1) )
        break;
      a3 = (void **)&v40[-v39];
      v16 = (__int64)&v40[-v39] >> 2;
    }
    while ( v16 );
    v26 = (v39 - a1) >> 2;
    *a2 = v37;
    v32 = v26;
    if ( (v22 & 0xFFFFFFFB) != 0 )
    {
      if ( (unsigned int)(v22 - 4) <= 3 )
        goto LABEL_21;
LABEL_25:
      sub_CF00(
        (__int64)"status == __GCONV_OK || status == __GCONV_EMPTY_INPUT || status == __GCONV_ILLEGAL_INPUT || status == _"
                 "_GCONV_INCOMPLETE_INPUT || status == __GCONV_FULL_OUTPUT",
        (__int64)"mbsrtowcs_l.c",
        0x96u,
        "__mbsrtowcs_l",
        a5,
        a6,
        a7,
        a8,
        v23,
        v24,
        a11,
        a12);
    }
    if ( !*(_DWORD *)(v25 - 4) )
    {
      if ( !v26 )
        sub_CF00(
          (__int64)"result > 0",
          (__int64)"mbsrtowcs_l.c",
          0x8Du,
          "__mbsrtowcs_l",
          a5,
          a6,
          a7,
          a8,
          v23,
          v24,
          a11,
          a12);
      if ( *(_DWORD *)v43 )
        sub_CF00(
          (__int64)"__mbsinit (data.__statep)",
          (__int64)"mbsrtowcs_l.c",
          0x8Eu,
          "__mbsrtowcs_l",
          a5,
          a6,
          a7,
          a8,
          v23,
          v24,
          a11,
          a12);
      *a2 = 0LL;
LABEL_19:
      --v32;
      goto LABEL_20;
    }
  }
  else
  {
    v29 = strlen(v20);
    v30 = &v44;
    v31 = v20 + v29 + 1;
    v32 = 0LL;
    v38 = *v43;
    v43 = &v38;
    v40 = &v45;
    do
    {
      v39 = (__int64)v30;
      v34 = v30;
      sub_4F2B0((__int64)v19);
      v22 = v19(v18, &v39, &v37, v31, 0LL, v36, 0LL, 1LL);
      v30 = v34;
      v32 += (v39 - (__int64)v34) >> 2;
    }
    while ( (_DWORD)v22 == 5 );
    if ( (v22 & 0xFFFFFFFB) == 0 )
    {
      if ( *(_DWORD *)(v39 - 4) )
        sub_CF00(
          (__int64)"((wchar_t *) data.__outbuf)[-1] == L'\\0'",
          (__int64)"mbsrtowcs_l.c",
          0x5Eu,
          "__mbsrtowcs_l",
          a5,
          a6,
          a7,
          a8,
          v23,
          v24,
          a11,
          a12);
      goto LABEL_19;
    }
  }
LABEL_20:
  if ( (_DWORD)v22 != 0 && (unsigned int)(v22 - 4) > 3 )
    goto LABEL_25;
LABEL_21:
  if ( (unsigned int)v22 > 7 || (v28 = 177LL, !_bittest64(&v28, v22)) )
  {
    v32 = -1LL;
    __writefsdword(0xFFFFFFC0, 0x54u);
  }
  return v32;
}
// 49791: variable 'a3' is possibly undefined
// 49791: variable 'a4' is possibly undefined
// 49791: variable 'v14' is possibly undefined
// 49791: variable 'a14' is possibly undefined
// 498A7: variable 'v23' is possibly undefined
// 498A7: variable 'v24' is possibly undefined
// 9040: using guessed type __int64 __fastcall sub_9040(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// BAD80: using guessed type void *off_BAD80;
// BAE20: using guessed type void *off_BAE20;

//----- (0000000000049040) ----------------------------------------------------
__int64 __fastcall sub_49040(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 *v6; // rbp
  __int64 v7; // rsi
  __int64 v8; // rdx
  __int64 v9; // rcx
  u32 *v10; // r8
  u32 v11; // er9
  __int64 result; // rax

  v6 = *(__int64 **)(a1 + 40);
  if ( v6 )
  {
    *(_QWORD *)(a1 + 40) = 0LL;
    v7 = v6[3];
    *(_QWORD *)(a1 + 32) = 0LL;
    sub_525E0(v6[2], v7, a3, a4, a5, a6);
    sub_525E0(*v6, v6[1], v8, v9, v10, v11);
    result = sub_21B70(v6);
  }
  return result;
}
// 49073: variable 'v8' is possibly undefined
// 49073: variable 'v9' is possibly undefined
// 49073: variable 'v10' is possibly undefined
// 49073: variable 'v11' is possibly undefined
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (0000000000049110) ----------------------------------------------------
unsigned __int64 __fastcall sub_49110(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, u32 *a13, u32 a14)
{
  __int64 *v15; // r12
  double v16; // xmm4_8
  double v17; // xmm5_8
  const char *v18; // r9
  char *v19; // rsi
  __int64 v20; // r8
  __int64 v21; // rax
  char *v22; // rdx
  char v23; // cl
  unsigned __int64 v24; // rdi
  void *v25; // rsp
  unsigned __int8 *v26; // rdx
  unsigned __int8 *v27; // r10
  __int64 v28; // rdx
  __int64 v29; // rcx
  u32 *v30; // r8
  u32 v31; // er9
  double v32; // xmm4_8
  double v33; // xmm5_8
  __int64 v34; // rdi
  __int64 v35; // rdx
  __int64 v36; // rcx
  u32 *v37; // r8
  u32 v38; // er9
  __int64 v39; // rdi
  unsigned __int8 *v41; // rax
  void *v42; // rsp
  unsigned __int64 v43; // rax
  signed __int64 v44; // r9
  unsigned int v45; // esi
  __int64 v46; // rdi
  unsigned __int8 v47[8]; // [rsp+0h] [rbp-50h] BYREF
  unsigned __int64 v48; // [rsp+8h] [rbp-48h] BYREF
  __int64 v49; // [rsp+10h] [rbp-40h] BYREF
  unsigned __int64 v50; // [rsp+18h] [rbp-38h]

  v50 = __readfsqword(0x28u);
  if ( !*(_QWORD *)(a1 + 40) )
  {
    v15 = (__int64 *)sub_22260(1uLL, 0x20uLL, a2, a3, a4, a5, a6, a7, a8, a9, a11, a12, a13, a14);
    if ( !v15 )
    {
LABEL_23:
      *(_QWORD *)(a1 + 40) = &off_BAD80;
      return v50 - __readfsqword(0x28u);
    }
    v18 = "TRANSLIT";
    v19 = *(char **)(a1 + 176);
    v20 = *(_DWORD *)(a1 + 52) != 0 ? 8 : 0;
    if ( !*(_DWORD *)(a1 + 52) )
      v18 = (const char *)&unk_A6E65;
    v21 = *v19;
    if ( (_BYTE)v21 )
    {
      v22 = *(char **)(a1 + 176);
      v23 = *v19;
      v24 = 0LL;
      do
      {
        ++v22;
        v24 += v23 == 47;
        v23 = *v22;
      }
      while ( *v22 );
      v25 = alloca(v20 + v22 - v19 + 11);
      v26 = v47;
      do
      {
        v27 = v26;
        ++v19;
        *v26++ = dword_968A0[v21];
        v21 = *v19;
      }
      while ( (_BYTE)v21 );
      if ( v24 > 1 )
        goto LABEL_11;
      *v26 = 47;
      if ( v24 )
      {
        v26 = v27 + 2;
        goto LABEL_11;
      }
      v41 = v26;
    }
    else
    {
      v42 = alloca(v20 + 11);
      v41 = v47;
      v47[0] = 47;
    }
    v41[1] = 47;
    v26 = v41 + 2;
    if ( v20 )
    {
      if ( (unsigned int)v20 >= 8 )
      {
        v43 = (unsigned __int64)(v41 + 10) & 0xFFFFFFFFFFFFFFF8LL;
        *(_QWORD *)v26 = *(_QWORD *)v18;
        *(_QWORD *)&v26[(unsigned int)v20 - 8] = *(_QWORD *)&v18[(unsigned int)v20 - 8];
        v44 = v18 - (const char *)&v26[-v43];
        if ( (((_DWORD)v20 + (_DWORD)v26 - (_DWORD)v43) & 0xFFFFFFF8) >= 8 )
        {
          v45 = 0;
          do
          {
            v46 = v45;
            v45 += 8;
            *(_QWORD *)(v43 + v46) = *(_QWORD *)(v44 + v46);
          }
          while ( v45 < (((_DWORD)v20 + (_DWORD)v26 - (_DWORD)v43) & 0xFFFFFFF8) );
        }
      }
      else if ( (v20 & 4) != 0 )
      {
        *(_DWORD *)v26 = *(_DWORD *)v18;
        *(_DWORD *)&v26[(unsigned int)v20 - 4] = *(_DWORD *)&v18[(unsigned int)v20 - 4];
      }
      else
      {
        *v26 = *v18;
        if ( (v20 & 2) != 0 )
          *(_WORD *)&v41[(unsigned int)v20] = *(_WORD *)&v18[(unsigned int)v20 - 2];
      }
      v26 += v20;
    }
LABEL_11:
    *v26 = 0;
    if ( !(unsigned int)sub_522D0("INTERNAL", v47, &v49, (__int64 *)&v48, 0, a2, a3, a4, a5, v16, v17, a8, a9) )
    {
      v34 = v49;
      if ( v48 <= 1 )
      {
        v15[1] = v48;
        *v15 = v34;
        if ( v34 )
        {
          if ( !(unsigned int)sub_522D0(v47, "INTERNAL", &v49, (__int64 *)&v48, 0, a2, a3, a4, a5, v32, v33, a8, a9) )
          {
            v39 = v49;
            if ( v48 <= 1 )
            {
              v15[3] = v48;
              v15[2] = v39;
              if ( v39 )
              {
LABEL_17:
                *(_QWORD *)(a1 + 40) = v15;
                *(_QWORD *)(a1 + 32) = sub_49040;
                return v50 - __readfsqword(0x28u);
              }
              goto LABEL_26;
            }
            sub_525E0(v49, v48, v35, v36, v37, v38);
          }
          v15[2] = 0LL;
LABEL_26:
          if ( *v15 )
            sub_525E0(*v15, v15[1], v35, v36, v37, v38);
LABEL_22:
          sub_21B70(v15);
          goto LABEL_23;
        }
LABEL_21:
        if ( v15[2] )
          goto LABEL_17;
        goto LABEL_22;
      }
      sub_525E0(v49, v48, v28, v29, v30, v31);
    }
    *v15 = 0LL;
    goto LABEL_21;
  }
  return v50 - __readfsqword(0x28u);
}
// 49399: conditional instruction was optimized away because of 'ecx.4 in (1..FF)'
// 49239: variable 'v16' is possibly undefined
// 49239: variable 'v17' is possibly undefined
// 4927D: variable 'v32' is possibly undefined
// 4927D: variable 'v33' is possibly undefined
// 49300: variable 'v28' is possibly undefined
// 49300: variable 'v29' is possibly undefined
// 49300: variable 'v30' is possibly undefined
// 49300: variable 'v31' is possibly undefined
// 49330: variable 'v35' is possibly undefined
// 49330: variable 'v36' is possibly undefined
// 49330: variable 'v37' is possibly undefined
// 49330: variable 'v38' is possibly undefined
// 9238: using guessed type __int64 __fastcall sub_9238(_QWORD);
// 9240: using guessed type __int64 __fastcall sub_9240(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// BAD80: using guessed type void *off_BAD80;

//----- (0000000000049450) ----------------------------------------------------
int __fastcall sub_49450(__m128i *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14)
{
  __int64 v14; // rbp
  const __m128i *v15; // rax
  __m128i v16; // xmm0
  __m128i v17; // xmm1
  __int64 v19; // rdx
  u32 *v20; // r8
  int v21; // eax
  __int64 v22; // rdx
  int v23; // eax
  bool v24; // of
  signed __int64 v25; // rax

  v14 = *(_QWORD *)__readfsqword(0xFFFFFFA0);
  v15 = *(const __m128i **)(v14 + 40);
  if ( !v15 )
  {
    v15 = (const __m128i *)&off_BAD80;
    if ( (void **)v14 != &off_BAE20 )
    {
      sub_49110(v14, a3, a4, a5, a6, a7, a8, a9, a10, a2, (__int64)&off_BAE20, a12, a13, a14);
      v15 = *(const __m128i **)(v14 + 40);
    }
  }
  v16 = _mm_loadu_si128(v15);
  *a1 = v16;
  v17 = _mm_loadu_si128(v15 + 1);
  a1[1] = v17;
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C14E8, 1, 0) )
      sub_1C7D0((volatile __int32 *)&dword_C14E8, a2, 1LL, a12, a13, a14);
  }
  else
  {
    _EDX = 1;
    __asm { cmpxchg cs:dword_C14E8, edx }
  }
  v19 = a1->m128i_i64[0];
  v20 = 0LL;
  if ( *(_QWORD *)a1->m128i_i64[0] )
  {
    v21 = *(_DWORD *)(v19 + 16);
    *(_DWORD *)(v19 + 16) = v21 + 1;
    LOBYTE(v20) = __OFADD__(1, v21);
  }
  v22 = a1[1].m128i_i64[0];
  if ( *(_QWORD *)v22 )
  {
    v23 = *(_DWORD *)(v22 + 16);
    v24 = __OFADD__(1, v23++);
    *(_DWORD *)(v22 + 16) = v23;
    LOBYTE(v23) = v24;
    v20 = (u32 *)(v23 | (unsigned int)v20);
  }
  LODWORD(v25) = __readfsdword(0x18u);
  if ( (_DWORD)v25 )
  {
    LODWORD(v25) = _InterlockedExchange((volatile __int32 *)&dword_C14E8, 0);
    if ( (int)v25 > 1 )
      v25 = sys_futex(&dword_C14E8, 129, 1u, 0LL, v20, a14);
  }
  else
  {
    --dword_C14E8;
  }
  if ( (_BYTE)v20 )
    sub_17110(
      (__int64)"Fatal glibc error: gconv module reference counter overflow\n",
      *(double *)v16.m128i_i64,
      *(double *)v17.m128i_i64,
      a5,
      a6,
      a7,
      a8,
      a9,
      a10);
  return v25;
}
// 494EC: variable 'v20' is possibly undefined
// 4954C: variable 'a12' is possibly undefined
// 4954C: variable 'a13' is possibly undefined
// 4954C: variable 'a14' is possibly undefined
// 49598: variable 'a7' is possibly undefined
// 49598: variable 'a8' is possibly undefined
// BAD80: using guessed type void *off_BAD80;
// BAE20: using guessed type void *off_BAE20;

//----- (00000000000495A0) ----------------------------------------------------
__int64 __fastcall sub_495A0(__int64 *a1, __int64 a2)
{
  __int64 v3; // rdx
  __int64 v4; // rcx
  u32 *v5; // r8
  u32 v6; // er9
  __int64 v7; // rdi
  __int64 result; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  u32 *v11; // r8
  u32 v12; // er9
  __int64 v13; // rdi
  unsigned __int64 v14; // [rsp+8h] [rbp-40h] BYREF
  __int64 v15[7]; // [rsp+10h] [rbp-38h] BYREF

  v15[1] = __readfsqword(0x28u);
  if ( (unsigned int)sub_522D0("INTERNAL", a2, v15, &v14, 0LL) )
    goto LABEL_9;
  v7 = v15[0];
  if ( v14 > 1 )
  {
    sub_525E0(v15[0], v14, v3, v4, v5, v6);
LABEL_9:
    *a1 = 0LL;
    return 1LL;
  }
  a1[1] = v14;
  *a1 = v7;
  if ( !v7 )
    return 1LL;
  result = sub_522D0(a2, "INTERNAL", v15, &v14, 0LL);
  if ( (_DWORD)result )
    goto LABEL_11;
  v13 = v15[0];
  if ( v14 > 1 )
  {
    sub_525E0(v15[0], v14, v9, v10, v11, v12);
LABEL_11:
    a1[2] = 0LL;
    goto LABEL_12;
  }
  a1[3] = v14;
  a1[2] = v13;
  if ( !v13 )
  {
LABEL_12:
    sub_525E0(*a1, a1[1], v9, v10, v11, v12);
    result = 1LL;
  }
  return result;
}
// 49660: variable 'v3' is possibly undefined
// 49660: variable 'v4' is possibly undefined
// 49660: variable 'v5' is possibly undefined
// 49660: variable 'v6' is possibly undefined
// 49678: variable 'v9' is possibly undefined
// 49678: variable 'v10' is possibly undefined
// 49678: variable 'v11' is possibly undefined
// 49678: variable 'v12' is possibly undefined
// 522D0: using guessed type __int64 __fastcall sub_522D0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000049A20) ----------------------------------------------------
unsigned __int64 __fastcall time(time_t *tloc)
{
  unsigned __int64 result; // rax

  if ( &dword_0 )
  {
    result = dword_0();
    if ( result <= 0xFFFFFFFFFFFFF000LL )
      return result;
    if ( result != -38LL )
      goto LABEL_6;
  }
  result = sys_time(tloc);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
LABEL_6:
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}
// 0: using guessed type __int64 (*dword_0)(void);

//----- (0000000000049A80) ----------------------------------------------------
unsigned __int64 __fastcall sub_49A80(pid_t a1, int *a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  unsigned __int64 result; // rax
  unsigned __int64 v12; // rax
  char v13; // r8
  double v14; // xmm4_8
  double v15; // xmm5_8
  unsigned int upid; // [rsp+8h] [rbp-18h]

  if ( __readfsdword(0x18u) )
  {
    sub_6B7F0(a4, a5, a6, a7, a8, a9, a10, a11);
    v12 = sys_wait4(a1, a2, a3, 0LL);
    if ( v12 > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)v12);
      LODWORD(v12) = -1;
    }
    upid = v12;
    sub_6B870(v13, a4, a5, a6, a7, v14, v15, a10, a11);
    result = upid;
  }
  else
  {
    result = sys_wait4(a1, a2, a3, 0LL);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)result);
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}
// 49AFE: variable 'v13' is possibly undefined
// 49AFE: variable 'v14' is possibly undefined
// 49AFE: variable 'v15' is possibly undefined

//----- (0000000000049B40) ----------------------------------------------------
void __fastcall __noreturn sub_49B40(int a1)
{
  unsigned __int64 v1; // rax
  unsigned int v2; // er8
  unsigned __int64 v3; // rax
  unsigned int v4; // er8

  v3 = sys_exit_group(a1);
  if ( v3 > 0xFFFFFFFFFFFFF000LL )
    __writefsdword(v4, -(int)v3);
  v1 = sys_exit(a1);
  if ( v1 > 0xFFFFFFFFFFFFF000LL )
    __writefsdword(v2, -(int)v1);
  __halt();
}
// 49B8A: variable 'v2' is possibly undefined
// 49B7B: variable 'v4' is possibly undefined

//----- (0000000000049B90) ----------------------------------------------------
__int64 __fastcall sub_49B90(void *a1)
{
  const char *v1; // r15
  __int64 v2; // rbx
  unsigned int v3; // er13
  __int64 v4; // rax
  __int64 v5; // r14
  void *v6; // rsp
  __int64 v7; // rax
  int v8; // eax
  struct stat v10; // [rsp+0h] [rbp-D0h] BYREF
  unsigned __int64 v11; // [rsp+98h] [rbp-38h]

  v1 = "/usr/lib/getconf";
  v2 = 16LL;
  v11 = __readfsqword(0x28u);
  v3 = __readfsdword(0xFFFFFFC0);
  v4 = sub_5DDD0("GETCONF_DIR");
  if ( v4 )
  {
    v1 = (const char *)v4;
    v2 = strlen(v4);
  }
  v5 = strlen((__int64)a1);
  v6 = alloca(v2 + v5 + 11);
  v7 = sub_91D0(&v10, v1, v2);
  qmemcpy((void *)v7, "/POSIX_V6_", 10);
  memcpy((void *)(v7 + 10), a1, v5 + 1);
  v8 = sub_4AA20(1u, (const char *)&v10, &v10);
  __writefsdword(0xFFFFFFC0, v3);
  return ((__int64)v8 >> 63) | 1;
}
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// 49B90: using guessed type __int64 __fastcall sub_49B90(void *);

//----- (0000000000049C90) ----------------------------------------------------
__int64 __fastcall sub_49C90(int a1, __int64 a2, int a3)
{
  unsigned int v3; // er12
  __int64 result; // rax
  int v5; // er8
  int v6; // edx
  signed __int64 v7; // rbx
  struct rlimit64 v8; // [rsp+0h] [rbp-68h] BYREF
  char v9[40]; // [rsp+10h] [rbp-58h] BYREF
  unsigned __int64 v10; // [rsp+38h] [rbp-30h]

  v10 = __readfsqword(0x28u);
  if ( (unsigned int)(a1 - 185) <= 0xE )
    return sub_48FC0(a1);
  if ( a1 != 34 )
  {
    if ( a1 <= 34 )
    {
      if ( !a1 )
      {
        v5 = sub_4BAC0(3u, &v8);
        result = (__int64)&loc_20000;
        if ( !v5 && v8.rlim_cur > (unsigned __int64)&byte_7FFFF )
          result = v8.rlim_cur >> 2;
        return result;
      }
      if ( a1 == 3 )
      {
        v3 = sub_4B910("/proc/sys/kernel/ngroups_max", 0, a3);
        result = 0x10000LL;
        if ( v3 != -1 )
          goto LABEL_25;
        return result;
      }
      goto LABEL_12;
    }
    if ( a1 <= 139 )
    {
      if ( a1 > 137 )
        return (__int64)&loc_31068 + 1;
    }
    else if ( a1 == 149 )
    {
      return (__int64)&loc_31068 + 1;
    }
LABEL_12:
    if ( (unsigned int)a1 <= 0xF6 )
      __asm { jmp     rax }
    __writefsdword(0xFFFFFFC0, 0x16u);
    return -1LL;
  }
  if ( !(unsigned int)sub_4BAC0(0xBu, &v8) )
    return v8.rlim_cur;
  v3 = sub_4B910("/proc/sys/kernel/rtsig-max", 0, v6);
  if ( v3 == -1 )
    return -1LL;
LABEL_25:
  while ( 1 )
  {
    v7 = sub_4BA60(v3, v9, 0x1FuLL);
    if ( v7 != -1 )
      break;
    if ( __readfsdword(0xFFFFFFC0) != 4 )
    {
      sub_4B7A0(v3);
      goto LABEL_12;
    }
  }
  sub_4B7A0(v3);
  if ( v7 <= 0 )
    goto LABEL_12;
  v9[v7] = 0;
  result = sub_5DE10((unsigned __int8 *)v9, (unsigned __int8 **)&v8, 0xAu);
  if ( (char *)v8.rlim_cur == v9 || *(_BYTE *)v8.rlim_cur && *(_BYTE *)v8.rlim_cur != 10 )
    goto LABEL_12;
  return result;
}
// 49E10: variable 'v6' is possibly undefined
// 7FFFF: using guessed type char byte_7FFFF;

//----- (000000000004A0C0) ----------------------------------------------------
unsigned __int64 sub_4A0C0()
{
  unsigned __int64 result; // rax

  result = sys_sched_yield();
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004A0F0) ----------------------------------------------------
__int64 __fastcall sub_4A0F0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, u32 *a13, __int64 a14)
{
  int v14; // ebp
  _QWORD *v15; // rax

  v14 = *(_DWORD *)a1 + 8;
  v15 = sub_21DF0(*(const char **)(a1 + 8), 32LL * v14, a11, a12, a13, a14, a2, a3, a4, a5, a6, a7, a8, a9);
  if ( !v15 )
    return 12LL;
  *(_DWORD *)a1 = v14;
  *(_QWORD *)(a1 + 8) = v15;
  return 0LL;
}

//----- (000000000004A130) ----------------------------------------------------
__int64 __fastcall sub_4A130(_OWORD *a1)
{
  __int64 result; // rax

  result = 0LL;
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  a1[3] = 0LL;
  a1[4] = 0LL;
  return result;
}

//----- (000000000004A150) ----------------------------------------------------
__int64 __fastcall sub_4A150(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  int v15; // eax
  __int64 v16; // rdi
  __int64 v17; // rbx
  unsigned int *v18; // rax

  v15 = *(_DWORD *)(a1 + 4);
  v16 = *(_QWORD *)(a1 + 8);
  if ( v15 > 0 )
  {
    v17 = 0LL;
    do
    {
      while ( 1 )
      {
        v18 = (unsigned int *)(v16 + 32 * v17);
        a3 = *v18;
        if ( (_DWORD)a3 != 2 )
          break;
        ++v17;
        sub_21B70(*((_QWORD *)v18 + 2), a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);
        v16 = *(_QWORD *)(a1 + 8);
        if ( *(_DWORD *)(a1 + 4) <= (int)v17 )
          goto LABEL_8;
      }
      if ( (_DWORD)a3 == 3 )
      {
        sub_21B70(*((_QWORD *)v18 + 1), a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);
        v16 = *(_QWORD *)(a1 + 8);
      }
      ++v17;
    }
    while ( *(_DWORD *)(a1 + 4) > (int)v17 );
  }
LABEL_8:
  sub_21B70(v16, a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);
  return 0LL;
}
// 4A179: variable 'a11' is possibly undefined
// 4A179: variable 'a12' is possibly undefined
// 4A179: variable 'a4' is possibly undefined
// 4A179: variable 'a5' is possibly undefined
// 4A179: variable 'a6' is possibly undefined
// 4A1B2: variable 'a3' is possibly undefined

//----- (000000000004A1C0) ----------------------------------------------------
__int64 __fastcall sub_4A1C0(__int64 a1, __int64 a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  unsigned int v11; // eax
  __int64 v12; // rcx
  __int64 v13; // r9
  double v14; // xmm4_8
  double v15; // xmm5_8
  u32 *v16; // r8
  __int64 result; // rax
  __int64 v18; // rdx
  _DWORD *v19; // rax
  int v20; // er8

  LOBYTE(v11) = sub_4A2C0(a2, a2, a3);
  v16 = (u32 *)v11;
  result = 9LL;
  if ( (_BYTE)v16 )
  {
    v18 = *(unsigned int *)(a1 + 4);
    if ( (_DWORD)v18 != *(_DWORD *)a1 )
    {
LABEL_3:
      v19 = (_DWORD *)(*(_QWORD *)(a1 + 8) + 32LL * (int)v18);
      *v19 = 0;
      v19[2] = a2;
      result = 0LL;
      *(_DWORD *)(a1 + 4) = v18 + 1;
      return result;
    }
    v20 = sub_4A0F0(a1, a4, a5, a6, a7, v14, v15, a10, a11, a2, v18, v12, v16, v13);
    result = 12LL;
    if ( !v20 )
    {
      LODWORD(v18) = *(_DWORD *)(a1 + 4);
      goto LABEL_3;
    }
  }
  return result;
}
// 4A1D6: variable 'v11' is possibly undefined
// 4A213: variable 'v14' is possibly undefined
// 4A213: variable 'v15' is possibly undefined
// 4A213: variable 'v12' is possibly undefined
// 4A213: variable 'v13' is possibly undefined

//----- (000000000004A230) ----------------------------------------------------
__int64 __fastcall sub_4A230(__int64 a1, __int64 a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  int v12; // edx
  __int64 v13; // rcx
  u32 *v14; // r8
  __int64 v15; // r9
  double v16; // xmm4_8
  double v17; // xmm5_8
  __int64 v18; // rdx
  _DWORD *v19; // rax
  __int64 result; // rax
  int v21; // er8

  if ( !sub_4A2C0(a2, a2, a3) || !sub_4A2C0(a3, a2, v12) )
    return 9LL;
  v18 = *(unsigned int *)(a1 + 4);
  if ( (_DWORD)v18 != *(_DWORD *)a1 )
    goto LABEL_4;
  v21 = sub_4A0F0(a1, a4, a5, a6, a7, v16, v17, a10, a11, a2, v18, v13, v14, v15);
  result = 12LL;
  if ( !v21 )
  {
    LODWORD(v18) = *(_DWORD *)(a1 + 4);
LABEL_4:
    v19 = (_DWORD *)(*(_QWORD *)(a1 + 8) + 32LL * (int)v18);
    *v19 = 1;
    v19[2] = a2;
    v19[3] = a3;
    result = 0LL;
    *(_DWORD *)(a1 + 4) = v18 + 1;
  }
  return result;
}
// 4A24E: variable 'v12' is possibly undefined
// 4A29B: variable 'v16' is possibly undefined
// 4A29B: variable 'v17' is possibly undefined
// 4A29B: variable 'v13' is possibly undefined
// 4A29B: variable 'v14' is possibly undefined
// 4A29B: variable 'v15' is possibly undefined

//----- (000000000004A2C0) ----------------------------------------------------
bool __fastcall sub_4A2C0(int a1, __int64 a2, int a3)
{
  __int64 v3; // rax

  v3 = sub_49C90(4, a2, a3);
  if ( a1 < 0 )
    return 0;
  if ( v3 < 0 )
    return 1;
  return a1 < v3;
}

//----- (000000000004A300) ----------------------------------------------------
__int64 __fastcall sub_4A300(pid_t *a1, __int64 a2, __int64 a3, char *a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  return sub_4A990(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, 0);
}

//----- (000000000004A320) ----------------------------------------------------
__int64 __fastcall sub_4A320(pid_t *a1, __int64 a2, __int64 a3, char *a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, int a15, __int64 a16)
{
  __int64 v18; // rbx
  __int64 v19; // rax
  unsigned __int64 v20; // rbp
  void *v21; // r12
  signed __int64 v22; // rax
  void *v23; // r8
  pid_t v24; // eax
  double v25; // xmm4_8
  double v26; // xmm5_8
  pid_t v27; // er13
  unsigned int v28; // er15
  signed __int64 v29; // rax
  sigset_t oset; // [rsp+30h] [rbp-258h] BYREF
  __int64 v34; // [rsp+B0h] [rbp-1D8h]
  __int64 v35; // [rsp+B8h] [rbp-1D0h]
  __int64 v36; // [rsp+C0h] [rbp-1C8h]
  char *v37; // [rsp+C8h] [rbp-1C0h]
  __int64 v38; // [rsp+D0h] [rbp-1B8h]
  __int64 v39; // [rsp+D8h] [rbp-1B0h]
  __int64 v40; // [rsp+E0h] [rbp-1A8h]
  int v41; // [rsp+E8h] [rbp-1A0h]
  int v42; // [rsp+ECh] [rbp-19Ch]
  char v43[344]; // [rsp+F0h] [rbp-198h] BYREF
  unsigned __int64 v44; // [rsp+248h] [rbp-40h]

  v18 = 0LL;
  v44 = __readfsqword(0x28u);
  do
  {
    v19 = v18++;
    if ( !*(_QWORD *)(a5 + 8 * v18 - 8) )
    {
      v20 = -(__int64)off_BF078 & ((unsigned __int64)&off_BF078[1386].r_addend + 8 * v19 + 7);
      v21 = mmap(0LL, v20, (4 * (_BYTE)dword_BF068) & 4 | 3u, 0x20022u, 0xFFFFFFFFuLL, 0LL);
      if ( v21 == (void *)-1LL )
        return __readfsdword(0xFFFFFFC0);
      v35 = a16;
      v42 = 0;
      v34 = a2;
      v36 = a3;
      if ( !a4 )
      {
        memset(v43, 0, 0x150uLL);
        a4 = v43;
      }
      v37 = a4;
      v38 = a5;
      v40 = a6;
      v39 = v18;
      v41 = a15;
      v22 = sys_rt_sigprocmask(0, (sigset_t *)&nset, &oset, 8uLL);
      v24 = sub_4CFE0((__int64)sub_4A5B0, (__int64)v21 + v20, 0x4111uLL, (__int64)&oset, v23);
      v27 = v24;
      if ( v24 <= 0 )
      {
        v28 = -v24;
      }
      else
      {
        v28 = v42;
        if ( v42 > 0 )
        {
          sub_49A80(v24, 0LL, 0, a7, a8, a9, a10, v25, v26, a13, a14);
          munmap(v21, v20);
LABEL_12:
          v29 = sys_rt_sigprocmask(2, &oset, 0LL, 8uLL);
          return v28;
        }
      }
      munmap(v21, v20);
      if ( !v28 && a1 )
        *a1 = v27;
      goto LABEL_12;
    }
  }
  while ( v18 != 2147483646 );
  v28 = 7;
  __writefsdword(0xFFFFFFC0, 7u);
  return v28;
}
// 4A48D: variable 'v23' is possibly undefined
// 4A566: variable 'v25' is possibly undefined
// 4A566: variable 'v26' is possibly undefined
// 90C0: using guessed type __int64 __fastcall sub_90C0(_QWORD, _QWORD);
// BF068: using guessed type int dword_BF068;
// BF078: using guessed type Elf64_Rela *off_BF078;

//----- (000000000004A5B0) ----------------------------------------------------
void __fastcall sub_4A5B0(__int64 a1)
{
  int v1; // ebx
  __int16 *v2; // rbp
  __int64 v3; // r14
  __int16 v4; // dx
  __int64 v5; // rax
  __int64 i; // r13
  _DWORD *v7; // rbx
  const __m128i *v8; // rsi
  unsigned int v9; // eax
  unsigned __int64 v10; // rax
  sigset_t v11; // [rsp+20h] [rbp-158h] BYREF
  __int64 v12[27]; // [rsp+A0h] [rbp-D8h] BYREF

  v1 = 1;
  v2 = *(__int16 **)(a1 + 152);
  v3 = *(_QWORD *)(a1 + 144);
  v12[19] = __readfsqword(0x28u);
  memset(v12, 0, 0x98uLL);
  sub_5D2B0(0, 0LL, &v11);
  v4 = *v2;
  while ( 1 )
  {
    v5 = 1LL << ((unsigned __int8)v1 - 1);
    if ( (v4 & 4) == 0 || (*((_QWORD *)v2 + 1) & v5) == 0 )
    {
      if ( (v11.__val[0] & v5) == 0 )
        goto LABEL_6;
      if ( (unsigned int)(v1 - 32) <= 1 )
      {
        v12[0] = 1LL;
        goto LABEL_4;
      }
      sub_5D090(v1, 0LL, (__int64)v12);
      if ( v12[0] == 1 )
        goto LABEL_5;
    }
    v12[0] = 0LL;
LABEL_4:
    sub_5D090(v1, (__int64)v12, 0LL);
LABEL_5:
    v4 = *v2;
LABEL_6:
    if ( ++v1 == 65 )
    {
      if ( (v4 & 0x30) == 16 )
      {
        if ( (unsigned int)sub_6EAC0(0, (struct sched_param *)v2 + 66) != -1 )
          goto LABEL_38;
        goto LABEL_25;
      }
      if ( (v4 & 0x20) == 0 )
        goto LABEL_14;
      if ( (unsigned int)sub_6EAF0(0, *((_DWORD *)v2 + 67), (struct sched_param *)v2 + 66) == -1 )
        goto LABEL_25;
LABEL_38:
      v4 = *v2;
LABEL_14:
      if ( (v4 & 0x80u) != 0 )
      {
        if ( (sub_6EA90() & 0x80000000) == 0LL )
        {
          v4 = *v2;
          goto LABEL_15;
        }
        goto LABEL_25;
      }
LABEL_15:
      if ( (v4 & 2) == 0 )
        goto LABEL_16;
      if ( (unsigned int)sub_6EA60(0, *((_DWORD *)v2 + 1)) )
      {
LABEL_25:
        v9 = __readfsdword(0xFFFFFFC0);
        if ( !v9 )
          v9 = 10;
      }
      else
      {
        v4 = *v2;
LABEL_16:
        if ( (v4 & 1) == 0 )
        {
LABEL_17:
          if ( v3 )
          {
            for ( i = 0LL; *(_DWORD *)(v3 + 4) > (int)i; ++i )
            {
              v7 = (_DWORD *)(*(_QWORD *)(v3 + 8) + 32 * i);
              if ( *v7 <= 4u )
                __asm { jmp     rax }
            }
          }
          v8 = (const __m128i *)a1;
          if ( (*(_BYTE *)v2 & 8) != 0 )
            v8 = (const __m128i *)(v2 + 68);
          sub_5D2B0(2, v8, 0LL);
          (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD))(a1 + 136))(
            *(_QWORD *)(a1 + 128),
            *(_QWORD *)(a1 + 160),
            *(_QWORD *)(a1 + 176));
          goto LABEL_25;
        }
        v10 = sys_setresuid((uid_t *)0xFFFFFFFFLL, (uid_t *)(unsigned int)sub_6EA20(), (uid_t *)0xFFFFFFFFLL);
        if ( v10 <= 0xFFFFFFFFFFFFF000LL )
        {
          if ( v10 )
            goto LABEL_25;
          v10 = sys_setresgid(0xFFFFFFFF, sub_6EA40(), 0xFFFFFFFF);
          if ( v10 <= 0xFFFFFFFFFFFFF000LL )
          {
            if ( !v10 )
              goto LABEL_17;
            goto LABEL_25;
          }
        }
        __writefsdword(0xFFFFFFC0, -(int)v10);
        v9 = __readfsdword(0xFFFFFFC0);
      }
      *(_DWORD *)(a1 + 188) = v9;
      sub_49B40(127);
    }
  }
}

//----- (000000000004A990) ----------------------------------------------------
__int64 __fastcall sub_4A990(pid_t *a1, __int64 a2, __int64 a3, char *a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, int a15)
{
  void *v15; // rax

  v15 = sub_6EA10;
  if ( (a15 & 1) == 0 )
    v15 = sub_6E5A0;
  return sub_4A320(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, (__int64)v15);
}

//----- (000000000004A9C0) ----------------------------------------------------
rlim64_t sub_4A9C0()
{
  rlim64_t result; // rax
  struct rlimit64 v1; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v2; // [rsp+18h] [rbp-10h]

  v2 = __readfsqword(0x28u);
  if ( (unsigned int)sub_4BAC0(6u, &v1) )
    result = -1LL;
  else
    result = v1.rlim_cur;
  return result;
}

//----- (000000000004AA20) ----------------------------------------------------
unsigned __int64 __fastcall sub_4AA20(unsigned int a1, const char *a2, struct stat *a3)
{
  unsigned __int64 result; // rax

  if ( a1 > 1 )
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    result = sys_stat(a2, a3);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)result);
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}

//----- (000000000004AA80) ----------------------------------------------------
unsigned __int64 __fastcall sub_4AA80(unsigned int a1, unsigned int a2, struct stat *a3)
{
  unsigned __int64 result; // rax

  if ( a1 > 1 )
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    result = sys_fstat(a2, a3);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)result);
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}

//----- (000000000004AAE0) ----------------------------------------------------
int open(const char *a1, int a2, ...)
{
  int v2; // edx
  double v3; // xmm0_8
  double v4; // xmm1_8
  double v5; // xmm2_8
  double v6; // xmm3_8
  double v7; // xmm6_8
  double v8; // xmm7_8
  int v9; // er10
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rax
  char v12; // r8
  double v13; // xmm4_8
  double v14; // xmm5_8
  int mode; // [rsp+Ch] [rbp-6Ch]
  int modea; // [rsp+Ch] [rbp-6Ch]

  v9 = a2 & 0x40;
  if ( (a2 & 0x40) != 0 || (a2 & 0x410000) == 4259840 )
    v9 = v2;
  if ( __readfsdword(0x18u) )
  {
    mode = v9;
    sub_6B7F0();
    v11 = sys_openat(-100, a1, a2, mode);
    if ( v11 > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)v11);
      LODWORD(v11) = -1;
    }
    modea = v11;
    sub_6B870(v12, v3, v4, v5, v6, v13, v14, v7, v8);
    LODWORD(v10) = modea;
  }
  else
  {
    v10 = sys_openat(-100, a1, a2, v9);
    if ( v10 > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)v10);
      LODWORD(v10) = -1;
    }
  }
  return v10;
}
// 4AB78: variable 'v2' is possibly undefined
// 4ABC3: variable 'v12' is possibly undefined
// 4ABC3: variable 'v3' is possibly undefined
// 4ABC3: variable 'v4' is possibly undefined
// 4ABC3: variable 'v5' is possibly undefined
// 4ABC3: variable 'v6' is possibly undefined
// 4ABC3: variable 'v13' is possibly undefined
// 4ABC3: variable 'v14' is possibly undefined
// 4ABC3: variable 'v7' is possibly undefined
// 4ABC3: variable 'v8' is possibly undefined

//----- (000000000004AC10) ----------------------------------------------------
int __fastcall sub_4AC10(unsigned int a1, char *a2, size_t a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rax
  char v13; // r8
  double v14; // xmm4_8
  double v15; // xmm5_8
  int fd; // [rsp+0h] [rbp-20h]

  LODWORD(v11) = __readfsdword(0x18u);
  if ( (_DWORD)v11 )
  {
    sub_6B7F0();
    v12 = sys_read(a1, a2, a3);
    if ( v12 > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)v12);
      LODWORD(v12) = -1;
    }
    fd = v12;
    sub_6B870(v13, a4, a5, a6, a7, v14, v15, a10, a11);
    LODWORD(v11) = fd;
  }
  else
  {
    __asm { syscall; LINUX - }
    if ( v11 > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, 0);
      LODWORD(v11) = -1;
    }
  }
  return v11;
}
// 4AC28: variable 'v11' is possibly undefined
// 4AC6C: variable 'v13' is possibly undefined
// 4AC6C: variable 'v14' is possibly undefined
// 4AC6C: variable 'v15' is possibly undefined

//----- (000000000004ACB0) ----------------------------------------------------
unsigned __int64 __fastcall send(unsigned int a1, const void *a2, size_t a3)
{
  double v3; // xmm0_8
  double v4; // xmm1_8
  double v5; // xmm2_8
  double v6; // xmm3_8
  double v7; // xmm6_8
  double v8; // xmm7_8
  unsigned __int64 result; // rax
  unsigned __int64 v10; // rax
  char v11; // r8
  double v12; // xmm4_8
  double v13; // xmm5_8
  unsigned __int64 fd; // [rsp+0h] [rbp-20h]

  if ( __readfsdword(0x18u) )
  {
    sub_6B7F0();
    v10 = sys_write(a1, (const char *)a2, a3);
    if ( v10 > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)v10);
      v10 = -1LL;
    }
    fd = v10;
    sub_6B870(v11, v3, v4, v5, v6, v12, v13, v7, v8);
    result = fd;
  }
  else
  {
    result = sys_write(a1, (const char *)a2, a3);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)result);
      result = -1LL;
    }
  }
  return result;
}
// 4AD0F: variable 'v11' is possibly undefined
// 4AD0F: variable 'v3' is possibly undefined
// 4AD0F: variable 'v4' is possibly undefined
// 4AD0F: variable 'v5' is possibly undefined
// 4AD0F: variable 'v6' is possibly undefined
// 4AD0F: variable 'v12' is possibly undefined
// 4AD0F: variable 'v13' is possibly undefined
// 4AD0F: variable 'v7' is possibly undefined
// 4AD0F: variable 'v8' is possibly undefined

//----- (000000000004AD50) ----------------------------------------------------
unsigned __int64 __fastcall sub_4AD50(unsigned int a1, off_t a2, unsigned int a3)
{
  unsigned __int64 result; // rax

  result = sys_lseek(a1, a2, a3);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004AD80) ----------------------------------------------------
unsigned __int64 __fastcall sub_4AD80(unsigned int a1, unsigned int a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  unsigned __int64 result; // rax
  unsigned __int64 v12; // rax
  char v13; // r8
  double v14; // xmm4_8
  double v15; // xmm5_8
  unsigned int arga; // [rsp+0h] [rbp-68h]

  if ( a2 != 7 && a2 != 38 )
    return sub_4B880(a1, a2, a3);
  if ( __readfsdword(0x18u) )
  {
    sub_6B7F0(a4, a5, a6, a7, a8, a9, a10, a11);
    v12 = sys_fcntl(a1, a2, a3);
    if ( v12 > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)v12);
      LODWORD(v12) = -1;
    }
    arga = v12;
    sub_6B870(v13, a4, a5, a6, a7, v14, v15, a10, a11);
    result = arga;
  }
  else
  {
    result = sys_fcntl(a1, a2, a3);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)result);
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}
// 4AE55: variable 'v13' is possibly undefined
// 4AE55: variable 'v14' is possibly undefined
// 4AE55: variable 'v15' is possibly undefined

//----- (000000000004AE80) ----------------------------------------------------
unsigned __int64 __fastcall close(unsigned int a1)
{
  double v1; // xmm0_8
  double v2; // xmm1_8
  double v3; // xmm2_8
  double v4; // xmm3_8
  double v5; // xmm4_8
  double v6; // xmm5_8
  double v7; // xmm6_8
  double v8; // xmm7_8
  unsigned __int64 result; // rax
  unsigned __int64 v10; // rax
  char v11; // r8
  double v12; // xmm4_8
  double v13; // xmm5_8
  unsigned int fd; // [rsp+0h] [rbp-Ch]

  if ( __readfsdword(0x18u) )
  {
    sub_6B7F0(v1, v2, v3, v4, v5, v6, v7, v8);
    v10 = sys_close(a1);
    if ( v10 > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)v10);
      LODWORD(v10) = -1;
    }
    fd = v10;
    sub_6B870(v11, v1, v2, v3, v4, v12, v13, v7, v8);
    result = fd;
  }
  else
  {
    result = sys_close(a1);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)result);
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}
// 4AEA8: variable 'v1' is possibly undefined
// 4AEA8: variable 'v2' is possibly undefined
// 4AEA8: variable 'v3' is possibly undefined
// 4AEA8: variable 'v4' is possibly undefined
// 4AEA8: variable 'v5' is possibly undefined
// 4AEA8: variable 'v6' is possibly undefined
// 4AEA8: variable 'v7' is possibly undefined
// 4AEA8: variable 'v8' is possibly undefined
// 4AECA: variable 'v11' is possibly undefined
// 4AECA: variable 'v12' is possibly undefined
// 4AECA: variable 'v13' is possibly undefined

//----- (000000000004AF10) ----------------------------------------------------
unsigned __int64 __fastcall sub_4AF10(unsigned int a1)
{
  unsigned __int64 result; // rax

  result = sys_dup(a1);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004AF40) ----------------------------------------------------
unsigned __int64 __fastcall sub_4AF40(unsigned int a1, unsigned int a2)
{
  unsigned __int64 result; // rax

  result = sys_dup2(a1, a2);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004AF70) ----------------------------------------------------
unsigned __int64 __fastcall sub_4AF70(int *a1, int a2)
{
  unsigned __int64 result; // rax

  result = sys_pipe2(a1, a2);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004AFA0) ----------------------------------------------------
unsigned __int64 __fastcall sub_4AFA0(const char *a1)
{
  unsigned __int64 result; // rax

  result = sys_chdir(a1);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004AFD0) ----------------------------------------------------
unsigned __int64 __fastcall sub_4AFD0(unsigned int a1)
{
  unsigned __int64 result; // rax

  result = sys_fchdir(a1);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004B000) ----------------------------------------------------
__int64 __fastcall sub_4B000(__int64 a1, unsigned __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14)
{
  __int64 v14; // r15
  unsigned __int64 v15; // r14
  int v16; // eax
  char *v17; // rbp
  unsigned __int64 v18; // rax
  __int64 v19; // rcx
  u32 *v20; // r8
  __int64 v21; // r9
  double v22; // xmm4_8
  double v23; // xmm5_8
  __int64 v24; // rdx
  char *v25; // r12
  unsigned int v26; // eax
  __int64 v28; // rdi
  __int64 v29; // rdx
  __int64 v30; // rcx
  u32 *v31; // r8
  u32 v32; // er9
  double v33; // xmm4_8
  double v34; // xmm5_8
  unsigned int v35; // edx
  __int64 v36; // r12
  __int64 v37; // rdx
  __int64 v38; // rcx
  u32 *v39; // r8
  __int64 v40; // r9
  double v41; // xmm4_8
  double v42; // xmm5_8
  unsigned int v43; // [rsp+0h] [rbp-138h]
  __int64 v44; // [rsp+18h] [rbp-120h]
  unsigned int v45; // [rsp+3Ch] [rbp-FCh]
  char *v46; // [rsp+40h] [rbp-F8h]
  unsigned __int64 v47; // [rsp+F8h] [rbp-40h]

  v14 = a1;
  v15 = a2;
  v47 = __readfsqword(0x28u);
  if ( a2 )
  {
    if ( a1 )
    {
      v17 = (char *)a1;
      goto LABEL_10;
    }
  }
  else
  {
    if ( a1 )
    {
      v14 = 0LL;
      __writefsdword(0xFFFFFFC0, 0x16u);
      return v14;
    }
    v16 = (unsigned int)sub_4BBD0(a3, a4, a5, a6, a7, a8, a9, a10);
    LODWORD(a2) = 4096;
    if ( v16 >= 4096 )
      LODWORD(a2) = v16;
    a2 = (int)a2;
  }
  v17 = (char *)sub_21500((u32 *)a2, a2, a11, a12, a13, a14, a3, a4, a5, a6, a7, a8, a9, a10);
  if ( !v17 )
    return 0LL;
LABEL_10:
  v18 = sys_getcwd(v17, a2);
  if ( v18 > 0xFFFFFFFFFFFFF000LL )
  {
    v26 = -(int)v18;
    __writefsdword(0xFFFFFFC0, v26);
    goto LABEL_21;
  }
  if ( (int)v18 <= 0 )
  {
    if ( !(_DWORD)v18 )
    {
LABEL_43:
      v24 = v15 | a1;
      goto LABEL_13;
    }
    v26 = __readfsdword(0xFFFFFFC0);
LABEL_21:
    if ( v26 != 36 )
    {
      if ( v26 == 34 && !(a1 | v15) )
        sub_CF00(
          (__int64)"errno != ERANGE || buf != NULL || size != 0",
          (__int64)"../sysdeps/unix/sysv/linux/getcwd.c",
          0x79u,
          "__getcwd",
          a3,
          a4,
          a5,
          a6,
          v22,
          v23,
          a9,
          a10);
      if ( !a1 )
      {
        sub_21B70(v17);
        return v14;
      }
      return 0LL;
    }
    goto LABEL_43;
  }
  v24 = v15 | a1;
  if ( *v17 == 47 )
  {
    if ( !v24 )
      v14 = (__int64)sub_21DF0(v17, (int)v18, 0LL, v19, v20, v21, a3, a4, a5, a6, v22, v23, a9, a10);
    if ( !v14 )
      v14 = (__int64)v17;
    return v14;
  }
LABEL_13:
  if ( v24 )
  {
    if ( v15 )
    {
      v44 = v15;
      v14 = (__int64)v17;
      v45 = __readfsdword(0xFFFFFFC0);
      goto LABEL_16;
    }
    __writefsdword(0xFFFFFFC0, 0x16u);
    return 0LL;
  }
  sub_21B70(v17);
  v45 = __readfsdword(0xFFFFFFC0);
  v17 = (char *)sub_21500(
                  (u32 *)((char *)&stru_1000.r_offset + 1),
                  a2,
                  v29,
                  v30,
                  v31,
                  v32,
                  a3,
                  a4,
                  a5,
                  a6,
                  v33,
                  v34,
                  a9,
                  a10);
  if ( !v17 )
    return 0LL;
  v44 = 4097LL;
  v14 = 0LL;
LABEL_16:
  v25 = &v17[v44];
  v17[v44 - 1] = 0;
  if ( (int)sub_6EB20(1u) < 0 || (int)sub_6EB20(1u) < 0 )
  {
    v35 = __readfsdword(0xFFFFFFC0);
    if ( !v14 )
    {
      v43 = v35;
      sub_21B70(v17);
      v35 = v43;
    }
    __writefsdword(0xFFFFFFC0, v35);
    if ( v15 && !a1 )
    {
      v28 = v14;
      v14 = 0LL;
      sub_21B70(v28);
      return v14;
    }
    return 0LL;
  }
  v46 = v25 - 1;
  if ( v46 == &v17[v44 - 1] )
  {
    *(v25 - 2) = 47;
    v46 = v25 - 2;
  }
  v36 = v25 - v46;
  sub_9050(v17, v46, v36);
  if ( !v15 )
    v14 = (__int64)sub_21DF0(v17, v36, v37, v38, v39, v40, a3, a4, a5, a6, v41, v42, a9, a10);
  if ( !v14 )
    v14 = (__int64)v17;
  __writefsdword(0xFFFFFFC0, v45);
  return v14;
}
// 4B058: variable 'a11' is possibly undefined
// 4B058: variable 'a12' is possibly undefined
// 4B058: variable 'a13' is possibly undefined
// 4B058: variable 'a14' is possibly undefined
// 4B058: variable 'a7' is possibly undefined
// 4B058: variable 'a8' is possibly undefined
// 4B504: variable 'v29' is possibly undefined
// 4B504: variable 'v30' is possibly undefined
// 4B504: variable 'v31' is possibly undefined
// 4B504: variable 'v32' is possibly undefined
// 4B504: variable 'v33' is possibly undefined
// 4B504: variable 'v34' is possibly undefined
// 4B553: variable 'v22' is possibly undefined
// 4B553: variable 'v23' is possibly undefined
// 4B5DB: variable 'v19' is possibly undefined
// 4B5DB: variable 'v20' is possibly undefined
// 4B5DB: variable 'v21' is possibly undefined
// 4B6DB: variable 'v37' is possibly undefined
// 4B6DB: variable 'v38' is possibly undefined
// 4B6DB: variable 'v39' is possibly undefined
// 4B6DB: variable 'v40' is possibly undefined
// 4B6DB: variable 'v41' is possibly undefined
// 4B6DB: variable 'v42' is possibly undefined
// 1000: using guessed type Elf64_Rela stru_1000;
// 9050: using guessed type __int64 __fastcall sub_9050(_QWORD, _QWORD, _QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (000000000004B740) ----------------------------------------------------
unsigned __int64 __fastcall sub_4B740(const char *a1)
{
  unsigned __int64 result; // rax

  result = sys_unlink(a1);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004B770) ----------------------------------------------------
unsigned __int64 __fastcall sub_4B770(const char *a1)
{
  unsigned __int64 result; // rax

  result = sys_rmdir(a1);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004B7A0) ----------------------------------------------------
unsigned __int64 __fastcall sub_4B7A0(unsigned int a1)
{
  unsigned __int64 result; // rax

  result = sys_close(a1);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000004B7D0) ----------------------------------------------------
unsigned __int64 __fastcall sub_4B7D0(unsigned int a1, unsigned int a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7)
{
  unsigned __int64 result; // rax
  unsigned __int64 arg; // [rsp+8h] [rbp-60h] BYREF
  int v9; // [rsp+10h] [rbp-58h]
  char *v10; // [rsp+18h] [rbp-50h]
  char *v11; // [rsp+20h] [rbp-48h]
  unsigned __int64 v12; // [rsp+28h] [rbp-40h]
  char v13; // [rsp+30h] [rbp-38h] BYREF
  unsigned __int64 v14; // [rsp+40h] [rbp-28h]

  v14 = a3;
  v12 = __readfsqword(0x28u);
  v9 = 16;
  v10 = &a7;
  v11 = &v13;
  if ( a2 != 9 )
  {
    result = sys_fcntl(a1, a2, a3);
    if ( result <= 0xFFFFFFFFFFFFF000LL )
      return result;
LABEL_7:
    __writefsdword(0xFFFFFFC0, -(int)result);
    return 0xFFFFFFFFLL;
  }
  result = sys_fcntl(a1, 0x10u, (unsigned __int64)&arg);
  if ( (unsigned int)result > 0xFFFFF000 )
    goto LABEL_7;
  result = HIDWORD(arg);
  if ( (_DWORD)arg == 2 )
    result = (unsigned int)-HIDWORD(arg);
  return result;
}

//----- (000000000004B880) ----------------------------------------------------
unsigned __int64 __fastcall sub_4B880(unsigned int a1, unsigned int a2, unsigned __int64 a3)
{
  unsigned __int64 result; // rax
  int v4; // [rsp+0h] [rbp-18h] BYREF
  unsigned int v5; // [rsp+4h] [rbp-14h]
  unsigned __int64 v6; // [rsp+8h] [rbp-10h]

  v6 = __readfsqword(0x28u);
  if ( a2 != 9 )
  {
    result = sys_fcntl(a1, a2, a3);
    if ( result <= 0xFFFFFFFFFFFFF000LL )
      return result;
LABEL_7:
    __writefsdword(0xFFFFFFC0, -(int)result);
    return 0xFFFFFFFFLL;
  }
  result = sys_fcntl(a1, 0x10u, (unsigned __int64)&v4);
  if ( (unsigned int)result > 0xFFFFF000 )
    goto LABEL_7;
  result = v5;
  if ( v4 == 2 )
    result = -v5;
  return result;
}

//----- (000000000004B910) ----------------------------------------------------
unsigned __int64 __fastcall sub_4B910(const char *filename, int flags, int a3)
{
  int v3; // er10
  unsigned __int64 result; // rax

  v3 = flags & 0x40;
  if ( (flags & 0x40) != 0 || (flags & 0x410000) == 4259840 )
    v3 = a3;
  result = sys_openat(-100, filename, flags, v3);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000004B9C0) ----------------------------------------------------
unsigned __int64 __fastcall sub_4B9C0(int a1, const char *a2, int a3, int a4)
{
  int v4; // er10
  unsigned __int64 result; // rax

  if ( (a3 & 0x40) != 0 || (v4 = 0, (a3 & 0x410000) == 4259840) )
    v4 = a4;
  result = sys_openat(a1, a2, a3, v4);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000004BA60) ----------------------------------------------------
unsigned __int64 __fastcall sub_4BA60(unsigned int a1, char *a2, size_t a3)
{
  unsigned __int64 result; // rax

  result = sys_read(a1, a2, a3);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004BA90) ----------------------------------------------------
unsigned __int64 __fastcall sub_4BA90(unsigned int a1, const char *a2, size_t a3)
{
  unsigned __int64 result; // rax

  result = sys_write(a1, a2, a3);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004BAC0) ----------------------------------------------------
unsigned __int64 __fastcall sub_4BAC0(unsigned int resource, struct rlimit64 *old_rlim)
{
  unsigned __int64 result; // rax

  result = sys_prlimit64(0, resource, 0LL, old_rlim);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000004BB00) ----------------------------------------------------
unsigned __int64 __fastcall sub_4BB00(__int64 a1)
{
  unsigned __int64 v2; // r12
  unsigned __int64 v3; // rdi
  int v5; // eax

  v2 = qword_C1718;
  if ( !qword_C1718 || dword_BF628 )
  {
    v5 = sub_6ED00(0LL);
    v2 = qword_C1718;
    if ( v5 < 0 )
      return -1LL;
  }
  if ( !a1 )
    return v2;
  if ( a1 <= 0 )
  {
    v3 = v2 + a1;
    if ( v2 < -a1 )
      goto LABEL_6;
  }
  else
  {
    v3 = v2 + a1;
    if ( __CFADD__(v2, a1) )
    {
LABEL_6:
      __writefsdword(0xFFFFFFC0, 0xCu);
      return -1LL;
    }
  }
  if ( (int)sub_6ED00(v3) < 0 )
    return -1LL;
  return v2;
}
// BF628: using guessed type int dword_BF628;
// C1718: using guessed type __int64 qword_C1718;

//----- (000000000004BBA0) ----------------------------------------------------
int ioctl(int fd, unsigned __int64 request, ...)
{
  unsigned __int64 v2; // rdx
  unsigned __int64 v3; // rax

  v3 = sys_ioctl(fd, request, v2);
  if ( v3 >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)v3);
    LODWORD(v3) = -1;
  }
  return v3;
}
// 4BBA9: variable 'v2' is possibly undefined

//----- (000000000004BBD0) ----------------------------------------------------
Elf64_Rela *__fastcall sub_4BBD0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  Elf64_Rela *result; // rax

  result = off_BF078;
  if ( !off_BF078 )
    sub_CF00(
      (__int64)"GLRO(dl_pagesize) != 0",
      (__int64)"../sysdeps/unix/sysv/linux/getpagesize.c",
      0x1Cu,
      "__getpagesize",
      a1,
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8);
  return result;
}
// BF078: using guessed type Elf64_Rela *off_BF078;

//----- (000000000004BC10) ----------------------------------------------------
__int64 sub_4BC10()
{
  bool v0; // sf
  __int64 result; // rax
  struct rlimit64 v2; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v3; // [rsp+18h] [rbp-10h]

  v3 = __readfsqword(0x28u);
  v0 = (sub_4BAC0(7u, &v2) & 0x80000000) != 0LL;
  result = 256LL;
  if ( !v0 )
    result = LODWORD(v2.rlim_cur);
  return result;
}
// 4BC10: using guessed type __int64 __fastcall sub_4BC10();

//----- (000000000004BC60) ----------------------------------------------------
void *__fastcall mmap(void *addr, unsigned __int64 a2, unsigned __int64 a3, unsigned int a4, unsigned __int64 a5, unsigned __int64 a6)
{
  void *result; // rax

  if ( (a6 & 0xFFF) != 0 )
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    return (void *)-1LL;
  }
  if ( !addr && (a3 & 4) != 0 && (dword_C1434 & 0x200) != 0 )
  {
    result = (void *)sys_mmap(0LL, a2, a3, a4 | 0x40, a5, a6);
    if ( (unsigned __int64)result <= 0xFFFFFFFFFFFFF000LL )
      return result;
    __writefsdword(0xFFFFFFC0, -(int)result);
  }
  result = (void *)sys_mmap((unsigned __int64)addr, a2, a3, a4, a5, a6);
  if ( (unsigned __int64)result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = (void *)-1LL;
  }
  return result;
}
// 4BC84: variable 'a3' is possibly undefined
// 4BC84: variable 'a5' is possibly undefined
// 4BC84: variable 'a6' is possibly undefined
// C1434: using guessed type int dword_C1434;

//----- (000000000004BD10) ----------------------------------------------------
unsigned __int64 __fastcall munmap(void *a1, size_t a2)
{
  unsigned __int64 result; // rax

  result = sys_munmap((unsigned __int64)a1, a2);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004BD40) ----------------------------------------------------
unsigned __int64 __fastcall sub_4BD40(unsigned __int64 a1, size_t a2, unsigned __int64 a3)
{
  unsigned __int64 result; // rax

  result = sys_mprotect(a1, a2, a3);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004BD70) ----------------------------------------------------
unsigned __int64 __fastcall sub_4BD70(unsigned __int64 a1, size_t a2, int a3)
{
  unsigned __int64 result; // rax

  result = sys_madvise(a1, a2, a3);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004BDA0) ----------------------------------------------------
__int64 __fastcall sub_4BDA0(__int64 a1, void (__fastcall *a2)(__int64, _QWORD), __int64 a3)
{
  unsigned int v3; // er13
  __int64 v6; // rsi
  __int64 v7; // rdi

  v3 = a3;
  if ( (*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFELL) != 0 || (v6 = 3LL, *(_QWORD *)(a1 + 16)) )
  {
    a2(a1, 0LL);
    if ( (*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFELL) != 0 )
      sub_4BDA0(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFELL, a2, v3 + 1);
    ((void (__fastcall *)(__int64, __int64, _QWORD))a2)(a1, 1LL, v3);
    v7 = *(_QWORD *)(a1 + 16);
    if ( v7 )
      sub_4BDA0(v7, a2, v3 + 1);
    a3 = v3;
    v6 = 2LL;
  }
  return ((__int64 (__fastcall *)(__int64, __int64, __int64))a2)(a1, v6, a3);
}

//----- (000000000004BE30) ----------------------------------------------------
__int64 __fastcall sub_4BE30(__int64 a1, void (__fastcall *a2)(__int64, __int64, __int64), __int64 a3)
{
  __int64 v6; // rsi
  __int64 v7; // rdi

  if ( (*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFELL) != 0 || (v6 = 3LL, *(_QWORD *)(a1 + 16)) )
  {
    ((void (__fastcall *)(__int64, _QWORD))a2)(a1, 0LL);
    if ( (*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFELL) != 0 )
      sub_4BE30(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFELL, a2, a3);
    a2(a1, 1LL, a3);
    v7 = *(_QWORD *)(a1 + 16);
    if ( v7 )
      sub_4BE30(v7, a2, a3);
    v6 = 2LL;
  }
  return ((__int64 (__fastcall *)(__int64, __int64))a2)(a1, v6);
}

//----- (000000000004BEC0) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_4BEC0(_QWORD *a1, double (__fastcall *a2)(_QWORD), double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10))(_QWORD, _QWORD)
{
  __int64 v11; // rdi
  double v12; // xmm0_8
  __int64 v13; // rdx
  unsigned __int64 v14; // rcx
  u32 *v15; // r8
  __int64 v16; // r9
  double v17; // xmm4_8
  double v18; // xmm5_8

  if ( (a1[1] & 0xFFFFFFFFFFFFFFFELL) != 0 )
  {
    ((void (*)(void))sub_4BEC0)();
    v11 = a1[2];
    if ( !v11 )
      goto LABEL_3;
LABEL_5:
    sub_4BEC0(v11, a2);
    goto LABEL_3;
  }
  v11 = a1[2];
  if ( v11 )
    goto LABEL_5;
LABEL_3:
  v12 = a2(*a1);
  return sub_21B70((__int64)a1, v12, a4, a5, a6, v17, v18, a9, a10, (__int64)a2, v13, v14, v15, v16);
}
// 4BEEE: variable 'v17' is possibly undefined
// 4BEEE: variable 'v18' is possibly undefined
// 4BEEE: variable 'v13' is possibly undefined
// 4BEEE: variable 'v14' is possibly undefined
// 4BEEE: variable 'v15' is possibly undefined
// 4BEEE: variable 'v16' is possibly undefined

//----- (000000000004BF10) ----------------------------------------------------
unsigned __int64 __fastcall sub_4BF10(__int64 a1, _QWORD *a2, unsigned __int64 *a3, int a4, int a5, int a6)
{
  unsigned __int64 v6; // rdi
  unsigned __int64 result; // rax
  __int64 v9; // rcx
  unsigned __int64 v10; // r10
  __int64 v11; // rsi
  unsigned __int64 v12; // r9
  __int64 v13; // rsi
  __int64 v14; // rdx

  v6 = a1 & 0xFFFFFFFFFFFFFFFELL;
  result = *(_QWORD *)(v6 + 8);
  v9 = *(_QWORD *)(v6 + 16);
  v10 = result & 0xFFFFFFFFFFFFFFFELL;
  if ( a6 != 1 )
  {
    if ( !v9 || !v10 || (*(_BYTE *)(v9 + 8) & 1) == 0 || (*(_BYTE *)(v10 + 8) & 1) == 0 )
      return result;
    result |= 1uLL;
    *(_QWORD *)(v6 + 8) = result;
    goto LABEL_14;
  }
  result |= 1uLL;
  *(_QWORD *)(v6 + 8) = result;
  if ( v9 )
LABEL_14:
    *(_QWORD *)(v9 + 8) &= 0xFFFFFFFFFFFFFFFELL;
  if ( v10 )
    *(_QWORD *)(v10 + 8) &= 0xFFFFFFFFFFFFFFFELL;
  if ( a2 )
  {
    result = *a2 & 0xFFFFFFFFFFFFFFFELL;
    v11 = *(_QWORD *)(result + 8);
    if ( (v11 & 1) != 0 )
    {
      v12 = *a3 & 0xFFFFFFFFFFFFFFFELL;
      if ( a4 > 0 == a5 > 0 )
      {
        *a3 = result | *a3 & 1;
        *(_QWORD *)(result + 8) = v11 & 0xFFFFFFFFFFFFFFFELL;
        *(_QWORD *)(v12 + 8) |= 1uLL;
        if ( a4 < 0 )
        {
          *(_QWORD *)(v12 + 8) = *(_QWORD *)(result + 16) | 1LL;
          *(_QWORD *)(result + 16) = v12;
        }
        else
        {
          v14 = *(_QWORD *)(result + 8) & 1LL;
          *(_QWORD *)(v12 + 16) = *(_QWORD *)(result + 8) & 0xFFFFFFFFFFFFFFFELL;
          *(_QWORD *)(result + 8) = v14 | v12;
        }
      }
      else
      {
        *(_QWORD *)(result + 8) = v11 | 1;
        *(_QWORD *)(v12 + 8) |= 1uLL;
        v13 = v9 & 1;
        *(_QWORD *)(v6 + 8) &= 0xFFFFFFFFFFFFFFFELL;
        if ( a4 < 0 )
        {
          *(_QWORD *)(result + 8) = *(_QWORD *)(result + 8) & 1LL | v9;
          *(_QWORD *)(v6 + 16) = v13 | result;
          *(_QWORD *)(v12 + 16) = v10;
          *(_QWORD *)(v6 + 8) = v12;
        }
        else
        {
          *(_QWORD *)(result + 16) = v10;
          *(_QWORD *)(v6 + 8) = result;
          *(_QWORD *)(v12 + 8) = *(_QWORD *)(v12 + 8) & 1LL | v9;
          *(_QWORD *)(v6 + 16) = v12 | v13;
        }
        result = *a3 & 1;
        *a3 = result | v6;
      }
    }
  }
  return result;
}

//----- (000000000004C080) ----------------------------------------------------
__int64 __fastcall sub_4C080(__int64 a1, __int64 *a2, __int64 (__fastcall *a3)(__int64, _QWORD), __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, __int64 a13, u32 a14)
{
  __int64 v14; // rbx
  __int64 *v15; // rbp
  u32 *v16; // r8
  unsigned int v17; // er13
  __int64 v18; // rdx
  __int64 *v19; // r12
  __int64 *v20; // r11
  _QWORD *v21; // rbx
  int v22; // er14
  __int64 v23; // rdx
  u32 *v24; // r8
  __int64 v25; // rax
  unsigned __int64 *v27; // [rsp+0h] [rbp-58h]
  __int64 *v28; // [rsp+0h] [rbp-58h]
  int v29; // [rsp+Ch] [rbp-4Ch]
  __int64 v30; // [rsp+10h] [rbp-48h]

  if ( !a2 )
    return 0LL;
  v14 = *a2;
  v15 = a2;
  if ( (*a2 & 0xFFFFFFFFFFFFFFFELL) != 0 )
    *(_QWORD *)((*a2 & 0xFFFFFFFFFFFFFFFELL) + 8) &= 0xFFFFFFFFFFFFFFFELL;
  v16 = 0LL;
  v17 = 0;
  v18 = 0LL;
  v19 = 0LL;
  while ( 1 )
  {
    v21 = (_QWORD *)(v14 & 0xFFFFFFFFFFFFFFFELL);
    if ( !v21 )
      break;
    v29 = (int)v16;
    v27 = (unsigned __int64 *)v18;
    v30 = (__int64)v21;
    v22 = a3(a1, *v21);
    if ( !v22 )
      return v30;
    a2 = v19;
    sub_4BF10(*v15, v19, v27, v17, v29, 0);
    if ( v22 >= 0 )
    {
      v20 = v21 + 2;
      if ( (v21[2] & 0xFFFFFFFFFFFFFFFELL) == 0 )
        goto LABEL_11;
    }
    else
    {
      v20 = v21 + 1;
      if ( (v21[1] & 0xFFFFFFFFFFFFFFFELL) == 0 )
      {
LABEL_11:
        v28 = v20;
        v25 = sub_21500((u32 *)&off_18, (__int64)v19, v23, a4, v24, a14, a5, a6, a7, a8, a9, a10, a11, a12);
        v30 = v25;
        if ( !v25 )
          return 0LL;
        *v28 = v25 | *v28 & 1;
        *(_QWORD *)v25 = a1;
        *(_QWORD *)(v25 + 8) = 1LL;
        *(_QWORD *)(v25 + 16) = 0LL;
        if ( v15 != v28 )
          sub_4BF10(*v28, v15, (unsigned __int64 *)v19, v22, v17, 1);
        return v30;
      }
    }
    v14 = *v20;
    v16 = (u32 *)v17;
    v18 = (__int64)v19;
    v17 = v22;
    v19 = v15;
    v15 = v20;
  }
  v30 = sub_21500((u32 *)&off_18, (__int64)a2, v18, a4, v16, a14, a5, a6, a7, a8, a9, a10, a11, a12);
  if ( !v30 )
    return 0LL;
  *v15 = v30 | *v15 & 1;
  *(_QWORD *)v30 = a1;
  *(_QWORD *)(v30 + 8) = 1LL;
  *(_QWORD *)(v30 + 16) = 0LL;
  return v30;
}
// 4C153: variable 'v23' is possibly undefined
// 4C153: variable 'a4' is possibly undefined
// 4C153: variable 'v24' is possibly undefined
// 4C153: variable 'a14' is possibly undefined
// 4C153: variable 'a9' is possibly undefined
// 4C153: variable 'a10' is possibly undefined
// 18: using guessed type void (__fastcall __noreturn *off_18)();

//----- (000000000004C220) ----------------------------------------------------
_QWORD *__fastcall sub_4C220(__int64 a1, _QWORD *a2, __int64 (__fastcall *a3)(__int64, _QWORD))
{
  _QWORD *v4; // rbx
  _QWORD *v5; // rdx
  _QWORD *v6; // rbx
  int v7; // eax

  if ( !a2 )
    return 0LL;
  v4 = (_QWORD *)(*a2 & 0xFFFFFFFFFFFFFFFELL);
  if ( !v4 )
    return 0LL;
  while ( 1 )
  {
    v7 = a3(a1, *v4);
    if ( !v7 )
      break;
    v5 = v4 + 1;
    v6 = v4 + 2;
    if ( v7 < 0 )
      v6 = v5;
    v4 = (_QWORD *)(*v6 & 0xFFFFFFFFFFFFFFFELL);
    if ( !v4 )
      return 0LL;
  }
  return v4;
}

//----- (000000000004C2A0) ----------------------------------------------------
unsigned __int64 __fastcall sub_4C2A0(__int64 a1, __int64 *a2, __int64 (__fastcall *a3)(__int64, __int64), double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  _BYTE *v11; // r9
  __int64 *v12; // r13
  unsigned __int64 v13; // r12
  __int64 *v14; // rax
  __int64 v15; // r14
  __int64 v16; // rsi
  int v17; // er15
  int v18; // eax
  __int64 v19; // rdx
  unsigned __int64 v20; // rcx
  double v21; // xmm4_8
  double v22; // xmm5_8
  int v23; // ebx
  void *v25; // rsp
  __int64 v26; // r8
  _QWORD *v27; // r14
  __int64 v28; // rsi
  __int64 *v29; // rbx
  __int64 v30; // rdi
  _QWORD *v31; // rdi
  void *v32; // rsp
  _BYTE *v33; // rax
  __int64 v34; // rdx
  __int64 v35; // r14
  __int64 *v36; // rbx
  __int64 v37; // r11
  unsigned __int64 v38; // rax
  unsigned __int64 v39; // rdx
  __int64 v40; // r8
  unsigned __int64 v41; // rsi
  unsigned __int64 v42; // r13
  __int64 v43; // rdx
  unsigned __int64 v44; // rdx
  __int64 v45; // rdx
  unsigned __int64 v46; // rdx
  __int64 v47; // rcx
  unsigned __int64 v48; // rsi
  __int64 v49; // rcx
  __int64 v50; // r11
  unsigned __int64 v51; // rcx
  __int64 v52; // rcx
  __int64 v53; // rcx
  unsigned __int64 v54; // rax
  _BYTE v55[15]; // [rsp+0h] [rbp-1B0h] BYREF
  __int64 (__fastcall *v56)(__int64, __int64); // [rsp+150h] [rbp-60h]
  __int64 v57; // [rsp+158h] [rbp-58h]
  void *v58; // [rsp+160h] [rbp-50h]
  int v59; // [rsp+16Ch] [rbp-44h]
  unsigned __int64 v60; // [rsp+178h] [rbp-38h]

  v57 = a1;
  v56 = a3;
  v11 = v55;
  v60 = __readfsqword(0x28u);
  if ( !a2 )
    return 0LL;
  v12 = a2;
  v13 = *a2 & 0xFFFFFFFFFFFFFFFELL;
  if ( !v13 )
    return 0LL;
  v59 = 40;
  v14 = (__int64 *)v13;
  v15 = 0LL;
  while ( 1 )
  {
    v16 = *v14;
    v58 = v11;
    v17 = v15;
    v18 = v56(v57, v16);
    v11 = v58;
    v23 = v18;
    if ( !v18 )
      break;
    if ( v59 == (_DWORD)v15 )
    {
      v59 += 20;
      v25 = alloca(8LL * v59 + 8);
      v11 = memcpy(v55, v58, 8 * v15);
    }
    *(_QWORD *)&v11[8 * v15] = v12;
    v13 = *v12 & 0xFFFFFFFFFFFFFFFELL;
    if ( v23 >= 0 )
    {
      v14 = *(__int64 **)(v13 + 16);
      v12 = (__int64 *)(v13 + 16);
      ++v15;
      if ( !v14 )
        return 0LL;
    }
    else
    {
      v12 = (__int64 *)(v13 + 8);
      ++v15;
      v14 = (__int64 *)(*(_QWORD *)(v13 + 8) & 0xFFFFFFFFFFFFFFFELL);
      if ( !v14 )
        return 0LL;
    }
  }
  v26 = *v12;
  v27 = (_QWORD *)(*v12 & 0xFFFFFFFFFFFFFFFELL);
  v28 = v27[1] & 0xFFFFFFFFFFFFFFFELL;
  if ( v27[2] )
  {
    if ( v28 )
    {
      v29 = v27 + 2;
      v20 = (unsigned __int64)v12;
      v19 = 8LL * v17;
      while ( 1 )
      {
        if ( v59 == v17 )
        {
          v59 += 20;
          v56 = (__int64 (__fastcall *)(__int64, __int64))v20;
          v57 = v26;
          v58 = (void *)v19;
          v32 = alloca(8LL * v59 + 8);
          v33 = memcpy(v55, v11, v19);
          v20 = (unsigned __int64)v56;
          v26 = v57;
          v19 = (__int64)v58;
          v11 = v33;
        }
        v30 = *v29;
        *(_QWORD *)&v11[v19] = v20;
        ++v17;
        v19 += 8LL;
        v31 = (_QWORD *)(v30 & 0xFFFFFFFFFFFFFFFELL);
        if ( (v31[1] & 0xFFFFFFFFFFFFFFFELL) == 0 )
          break;
        v20 = (unsigned __int64)v29;
        v29 = v31 + 1;
      }
      goto LABEL_20;
    }
  }
  else if ( v28 )
  {
    v31 = (_QWORD *)(*v12 & 0xFFFFFFFFFFFFFFFELL);
    goto LABEL_21;
  }
  v31 = (_QWORD *)(*v12 & 0xFFFFFFFFFFFFFFFELL);
LABEL_20:
  v28 = v31[2];
LABEL_21:
  if ( v17 )
  {
    v54 = **(_QWORD **)&v11[8 * v17 - 8] & 0xFFFFFFFFFFFFFFFELL;
    if ( v31 == *(_QWORD **)(v54 + 16) )
    {
      *(_QWORD *)(v54 + 16) = v28;
    }
    else
    {
      v19 = v28 | *(_QWORD *)(v54 + 8) & 1LL;
      *(_QWORD *)(v54 + 8) = v19;
    }
  }
  else
  {
    *v12 = v28 | v26 & 1;
  }
  if ( v27 != v31 )
    *v27 = *v31;
  if ( (v31[1] & 1) == 0 )
  {
    if ( v17 )
    {
      while ( 1 )
      {
        if ( v28 )
        {
          v34 = *(_QWORD *)(v28 + 8);
          if ( (v34 & 1) != 0 )
            goto LABEL_69;
        }
        v35 = v17;
        v36 = *(__int64 **)&v11[8 * v17 - 8];
        v37 = *v36;
        v38 = *v36 & 0xFFFFFFFFFFFFFFFELL;
        v39 = *(_QWORD *)(v38 + 8) & 0xFFFFFFFFFFFFFFFELL;
        v20 = v39;
        if ( v39 == v28 )
        {
          v46 = *(_QWORD *)(v38 + 16);
          v47 = *(_QWORD *)(v46 + 8);
          v41 = v47 & 0xFFFFFFFFFFFFFFFELL;
          if ( (v47 & 1) != 0 )
          {
            *(_QWORD *)(v46 + 8) = v41;
            ++v17;
            *(_QWORD *)(v38 + 8) |= 1uLL;
            v48 = *(_QWORD *)(v46 + 8) & 0xFFFFFFFFFFFFFFFELL;
            v49 = v38 | *(_QWORD *)(v46 + 8) & 1LL;
            *(_QWORD *)(v38 + 16) = v48;
            *(_QWORD *)(v46 + 8) = v49;
            v47 = *(_QWORD *)(v48 + 8);
            *v36 = v46 | v37 & 1;
            v36 = (__int64 *)(v46 + 8);
            v46 = v48;
            *(_QWORD *)&v11[8 * v35] = v36;
            v41 = v47 & 0xFFFFFFFFFFFFFFFELL;
          }
          if ( v41 )
          {
            v26 = *(_QWORD *)(v41 + 8);
            if ( (v26 & 1) != 0 )
            {
              v50 = *(_QWORD *)(v46 + 16);
              v11 = (_BYTE *)(*(_QWORD *)(v38 + 8) & 1LL);
              if ( v50 && (*(_BYTE *)(v50 + 8) & 1) != 0 )
              {
LABEL_60:
                v53 = v47 | 1;
                if ( v11 )
                  v41 = v53;
                *(_QWORD *)(v46 + 8) = v41;
                *(_QWORD *)(v38 + 8) &= 0xFFFFFFFFFFFFFFFELL;
                *(_QWORD *)(v50 + 8) &= 0xFFFFFFFFFFFFFFFELL;
                v20 = *(_QWORD *)(v46 + 8) & 1LL;
                v28 = *(_QWORD *)(v46 + 8) & 0xFFFFFFFFFFFFFFFELL;
                *(_QWORD *)(v38 + 16) = v28;
                *(_QWORD *)(v46 + 8) = v20 | v38;
                v19 = *v36 & 1 | v46;
                *v36 = v19;
                goto LABEL_39;
              }
              if ( v11 )
                v51 = v26 | 1;
              else
                v51 = v26 & 0xFFFFFFFFFFFFFFFELL;
              v26 &= 0xFFFFFFFFFFFFFFFELL;
              *(_QWORD *)(v41 + 8) = v51;
              v52 = *(_QWORD *)(v46 + 8);
              *(_QWORD *)(v38 + 16) = v26;
              v20 = *(_QWORD *)(v41 + 16) | v52 & 1;
              *(_QWORD *)(v46 + 8) = v20;
              *(_QWORD *)(v41 + 16) = v46;
              *(_QWORD *)(v41 + 8) = v38 | *(_QWORD *)(v41 + 8) & 1LL;
LABEL_38:
              v19 = *v36 & 1;
              v28 = v19 | v41;
              *v36 = v28;
              *(_QWORD *)(v38 + 8) &= 0xFFFFFFFFFFFFFFFELL;
              goto LABEL_39;
            }
          }
          v26 = *(_QWORD *)(v46 + 16);
          if ( v26 )
          {
            v50 = *(_QWORD *)(v46 + 16);
            if ( (*(_BYTE *)(v26 + 8) & 1) != 0 )
            {
              v11 = (_BYTE *)(*(_QWORD *)(v38 + 8) & 1LL);
              goto LABEL_60;
            }
          }
          v20 = v47 | 1;
          *(_QWORD *)(v46 + 8) = v20;
        }
        else
        {
          v40 = *(_QWORD *)(v39 + 8);
          v41 = *(_QWORD *)(v39 + 16);
          v42 = v40 & 0xFFFFFFFFFFFFFFFELL;
          if ( (v40 & 1) != 0 )
          {
            *(_QWORD *)(v39 + 8) = v42;
            ++v17;
            *(_QWORD *)(v38 + 8) = v41 | 1;
            *(_QWORD *)(v39 + 16) = v38;
            *v36 = v39 | v37 & 1;
            v36 = (__int64 *)(v39 + 16);
            v20 = v41 & 0xFFFFFFFFFFFFFFFELL;
            *(_QWORD *)&v11[8 * v35] = v39 + 16;
            v40 = *(_QWORD *)((v41 & 0xFFFFFFFFFFFFFFFELL) + 8);
            v41 = *(_QWORD *)((v41 & 0xFFFFFFFFFFFFFFFELL) + 16);
            v42 = v40 & 0xFFFFFFFFFFFFFFFELL;
          }
          if ( v41 )
          {
            v43 = *(_QWORD *)(v41 + 8);
            if ( (v43 & 1) != 0 )
            {
              v11 = (_BYTE *)(*(_QWORD *)(v38 + 8) & 1LL);
              if ( !v42 || (*(_BYTE *)(v42 + 8) & 1) == 0 )
              {
                v44 = v43 & 0xFFFFFFFFFFFFFFFELL;
                if ( v11 )
                  v44 = *(_QWORD *)(v41 + 8) | 1LL;
                *(_QWORD *)(v41 + 8) = v44;
                *(_QWORD *)(v38 + 8) = *(_QWORD *)(v41 + 16) | *(_QWORD *)(v38 + 8) & 1LL;
                v45 = *(_QWORD *)(v41 + 8) & 1LL;
                v26 = *(_QWORD *)(v41 + 8) & 0xFFFFFFFFFFFFFFFELL;
                *(_QWORD *)(v20 + 16) = v26;
                v20 |= v45;
                *(_QWORD *)(v41 + 8) = v20;
                *(_QWORD *)(v41 + 16) = v38;
                goto LABEL_38;
              }
LABEL_43:
              v26 = v40 | 1;
              if ( v11 )
                v42 = v26;
              *(_QWORD *)(v20 + 8) = v42;
              *(_QWORD *)(v38 + 8) &= 0xFFFFFFFFFFFFFFFELL;
              *(_QWORD *)((*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFFELL) + 8) &= 0xFFFFFFFFFFFFFFFELL;
              v19 = *(_QWORD *)(v38 + 8) & 1LL;
              v28 = v19 | v41;
              *(_QWORD *)(v38 + 8) = v28;
              *(_QWORD *)(v20 + 16) = v38;
              v20 |= *v36 & 1;
              *v36 = v20;
              goto LABEL_39;
            }
          }
          if ( v42 && (*(_BYTE *)(v42 + 8) & 1) != 0 )
          {
            v11 = (_BYTE *)(*(_QWORD *)(v38 + 8) & 1LL);
            goto LABEL_43;
          }
          v26 = v40 | 1;
          *(_QWORD *)(v20 + 8) = v26;
        }
        if ( !--v17 )
          break;
        v28 = v38;
      }
      v34 = *(_QWORD *)(v38 + 8);
      v28 = v38;
    }
    else
    {
      if ( !v28 )
        goto LABEL_39;
      v34 = *(_QWORD *)(v28 + 8);
    }
LABEL_69:
    v19 = v34 & 0xFFFFFFFFFFFFFFFELL;
    *(_QWORD *)(v28 + 8) = v19;
  }
LABEL_39:
  sub_21B70((__int64)v31, a4, a5, a6, a7, v21, v22, a10, a11, v28, v19, v20, (u32 *)v26, (__int64)v11);
  return v13;
}
// 4C5BE: variable 'v21' is possibly undefined
// 4C5BE: variable 'v22' is possibly undefined
// 4C5BE: variable 'v19' is possibly undefined
// 4C5BE: variable 'v20' is possibly undefined

//----- (000000000004C850) ----------------------------------------------------
__int64 __fastcall sub_4C850(__int64 a1, void (__fastcall *a2)(__int64, __int64, __int64), __int64 a3)
{
  __int64 result; // rax

  if ( a1 )
  {
    if ( a2 )
      result = sub_4BE30(a1, a2, a3);
  }
  return result;
}

//----- (000000000004C870) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_4C870(_QWORD *a1, double (__fastcall *a2)(_QWORD), double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10))(_QWORD, _QWORD)
{
  __int64 (__fastcall *result)(_QWORD, _QWORD); // rax

  if ( a1 )
    result = sub_4BEC0(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  return result;
}

//----- (000000000004C890) ----------------------------------------------------
char *__fastcall sub_4C890(unsigned int a1, char *a2, _QWORD *a3, char **a4, char *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  char *v15; // rbx
  char *v16; // r15
  __int64 v17; // rax
  double v18; // xmm4_8
  double v19; // xmm5_8
  signed __int64 v21; // rax
  char *v22; // r12
  signed __int64 v23; // rax
  signed __int64 v24; // rbx
  char *v25; // r14

  v15 = *a4;
  v16 = (char *)*a3;
  v17 = sub_9110(*a3, 10LL, &(*a4)[-*a3]);
  if ( v17 )
  {
LABEL_2:
    v15 = (char *)(v17 + 1);
    goto LABEL_3;
  }
  if ( v16 != a2 && v15 == a5 )
  {
    sub_9050(a2, v16, v15 - v16);
    *a4 = &(*a4)[(_QWORD)a2 - *a3];
    *a3 = a2;
    v21 = sub_4BA60(a1, *a4, v15 - *a4);
    if ( v21 < 0 )
      return 0LL;
    v15 = &(*a4)[v21];
    *a4 = v15;
    v16 = (char *)*a3;
    v17 = sub_9110(*a3, 10LL, &v15[-*a3]);
    if ( !v17 )
    {
      v22 = &a2[3 * (a5 - a2) / 4];
      do
      {
        if ( v15 != a5 )
        {
          v16 = (char *)*a3;
          goto LABEL_3;
        }
        *a4 = v22;
        v23 = sub_4BA60(a1, v22, a5 - v22);
        v24 = v23;
        if ( v23 < 0 )
          return 0LL;
        v25 = *a4;
        v17 = sub_9110(*a4, 10LL, v23);
        *v25 = 10;
        v15 = &(*a4)[v24];
        *a4 = v15;
      }
      while ( !v17 );
      v16 = (char *)*a3;
    }
    goto LABEL_2;
  }
LABEL_3:
  *a3 = v15;
  if ( *a4 < v15 )
    sub_CF00(
      (__int64)"*cp <= *re",
      (__int64)"../sysdeps/unix/sysv/linux/getsysstats.c",
      0x77u,
      "next_line",
      a6,
      a7,
      a8,
      a9,
      v18,
      v19,
      a12,
      a13);
  if ( *a4 == v16 )
    return 0LL;
  return v16;
}
// 4CA1B: variable 'v18' is possibly undefined
// 4CA1B: variable 'v19' is possibly undefined
// 9050: using guessed type __int64 __fastcall sub_9050(_QWORD, _QWORD, _QWORD);
// 9110: using guessed type __int64 __fastcall sub_9110(_QWORD, _QWORD, _QWORD);

//----- (000000000004CA20) ----------------------------------------------------
__int64 __fastcall sub_4CA20(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  unsigned __int64 v8; // rbx
  void *v9; // rsp
  char *v10; // rbx
  int v11; // edx
  int v12; // edx
  double v13; // xmm4_8
  double v14; // xmm5_8
  unsigned int v15; // er12
  char *v16; // r15
  unsigned __int64 v17; // r9
  unsigned __int64 v18; // rax
  int v19; // er8
  unsigned int v20; // er8
  unsigned __int64 v21; // rsi
  int v22; // edx
  unsigned int v23; // er14
  double v24; // xmm4_8
  double v25; // xmm5_8
  char **v26; // r9
  char *v27; // rax
  __time_t v29; // r15
  int v30; // eax
  unsigned int v31; // er10
  double v32; // xmm4_8
  double v33; // xmm5_8
  char **v34; // r9
  char *v35; // rax
  char v36[8]; // [rsp+0h] [rbp-80h] BYREF
  char **v37; // [rsp+8h] [rbp-78h]
  __time_t v38; // [rsp+10h] [rbp-70h]
  char **v39; // [rsp+18h] [rbp-68h]
  char *v40; // [rsp+20h] [rbp-60h] BYREF
  char *v41; // [rsp+28h] [rbp-58h] BYREF
  struct timespec tp; // [rsp+30h] [rbp-50h] BYREF
  unsigned __int64 v43; // [rsp+48h] [rbp-38h]

  v43 = __readfsqword(0x28u);
  sub_6E000(5, &tp);
  v38 = tp.tv_sec;
  if ( qword_C1278 != tp.tv_sec || (v15 = dword_BEFD0, dword_BEFD0 < 0) )
  {
    v8 = -(__int64)!sub_1C780(0x2000uLL) & 0xFFFFFFFFFFFFE200LL;
    v9 = alloca(v8 + 8208);
    v10 = &v36[v8 + 0x2000];
    v40 = v10;
    v41 = v10;
    LODWORD(v37) = sub_4B910("/sys/devices/system/cpu/online", (int)sub_80000, v11);
    if ( (_DWORD)v37 != -1 )
    {
      v15 = 0;
      v16 = sub_4C890((unsigned int)v37, v36, &v40, &v41, v10, a1, a2, a3, a4, v13, v14, a7, a8);
      if ( v16 )
      {
        while ( 1 )
        {
          v17 = sub_129A0(v16, (unsigned __int8 **)&tp, 0xAu);
          v18 = tp.tv_sec;
          if ( (char *)tp.tv_sec == v16 )
            break;
          v19 = v17;
          if ( *(_BYTE *)tp.tv_sec == 45 )
          {
            v29 = tp.tv_sec + 1;
            v39 = (char **)v17;
            v30 = sub_129A0((char *)(tp.tv_sec + 1), (unsigned __int8 **)&tp, 0xAu);
            LODWORD(v17) = (_DWORD)v39;
            v19 = v30;
            v18 = tp.tv_sec;
            if ( tp.tv_sec == v29 )
              break;
          }
          v20 = v15 + 1 - v17 + v19;
          v15 = v20;
          if ( (unsigned __int64)v41 > v18 )
          {
            v16 = (char *)v18;
            v21 = __readfsqword(0xFFFFFFF8);
            while ( (*(_BYTE *)(v21 + 2LL * *v16 + 1) & 0x20) != 0 )
            {
              if ( ++v16 == v41 )
                goto LABEL_11;
            }
            if ( v16 < v41 )
              continue;
          }
LABEL_11:
          LODWORD(v39) = v20;
          sub_4B7A0((unsigned int)v37);
          if ( (int)v39 > 0 )
            goto LABEL_17;
          goto LABEL_12;
        }
      }
      sub_4B7A0((unsigned int)v37);
    }
LABEL_12:
    v40 = v10;
    v41 = v10;
    v23 = sub_4B910("/proc/stat", (int)sub_80000, v12);
    if ( v23 == -1 )
    {
      v15 = 2;
      v31 = sub_4B910("/proc/cpuinfo", (int)sub_80000, v22);
      if ( v31 != -1 )
      {
        v15 = 0;
        v34 = &v41;
        while ( 1 )
        {
          v37 = v34;
          LODWORD(v39) = v31;
          v35 = sub_4C890(v31, v36, &v40, v34, v10, a1, a2, a3, a4, v32, v33, a7, a8);
          v31 = (unsigned int)v39;
          v34 = v37;
          if ( !v35 )
            break;
          v15 += memcmp(v35, "processor", 9uLL) == 0;
        }
        sub_4B7A0((unsigned int)v39);
      }
    }
    else
    {
      v15 = 0;
      v26 = &v41;
      while ( 1 )
      {
        v39 = v26;
        v27 = sub_4C890(v23, v36, &v40, v26, v10, a1, a2, a3, a4, v24, v25, a7, a8);
        v26 = v39;
        if ( !v27 || *v27 != 99 || v27[1] != 112 || v27[2] != 117 )
          break;
        v15 += (unsigned int)(v27[3] - 48) < 0xA;
      }
      sub_4B7A0(v23);
    }
LABEL_17:
    dword_BEFD0 = v15;
    qword_C1278 = v38;
  }
  return v15;
}
// 4CABA: variable 'v11' is possibly undefined
// 4CAE4: variable 'v13' is possibly undefined
// 4CAE4: variable 'v14' is possibly undefined
// 4CB9E: variable 'v12' is possibly undefined
// 4CBD3: variable 'v24' is possibly undefined
// 4CBD3: variable 'v25' is possibly undefined
// 4CCC0: variable 'v22' is possibly undefined
// 4CD14: variable 'v32' is possibly undefined
// 4CD14: variable 'v33' is possibly undefined
// BEFD0: using guessed type int dword_BEFD0;
// C1278: using guessed type __int64 qword_C1278;
// 4CA20: using guessed type char anonymous_0[8];

//----- (000000000004CD40) ----------------------------------------------------
__int64 __fastcall sub_4CD40(__int64 a1, unsigned __int8 **a2, int a3)
{
  unsigned int v3; // er12
  __int64 v4; // rdx
  __int64 v5; // rcx
  unsigned int *v6; // rbp
  u32 *v7; // r8
  u32 v8; // er9
  _BYTE *v9; // rax
  unsigned __int8 *v10; // rbx
  unsigned __int8 *v12[7]; // [rsp+0h] [rbp-38h] BYREF

  v3 = 0;
  v12[1] = (unsigned __int8 *)__readfsqword(0x28u);
  v6 = (unsigned int *)sub_6E270("/sys/devices/system/cpu", (__int64)a2, a3);
  if ( !v6 )
    return sub_4CA20();
  while ( 1 )
  {
    v9 = (_BYTE *)sub_6E3A0((__int64)v6, (__int64)a2, v4, v5, v7, v8);
    if ( !v9 )
      break;
    while ( v9[18] == 4 )
    {
      if ( v9[19] != 99 )
        break;
      if ( v9[20] != 112 )
        break;
      if ( v9[21] != 117 )
        break;
      v10 = v9 + 22;
      a2 = v12;
      if ( sub_129A0(v9 + 22, v12, 0xAu) == -1LL || v10 == v12[0] )
        break;
      v3 += *v12[0] == 0;
      v9 = (_BYTE *)sub_6E3A0((__int64)v6, (__int64)v12, v4, v5, v7, v8);
      if ( !v9 )
        goto LABEL_10;
    }
  }
LABEL_10:
  sub_6E2B0(v6);
  return v3;
}
// 4CD83: variable 'v4' is possibly undefined
// 4CD83: variable 'v5' is possibly undefined
// 4CD83: variable 'v7' is possibly undefined
// 4CD83: variable 'v8' is possibly undefined
// 4CA20: using guessed type __int64 sub_4CA20(void);

//----- (000000000004CE40) ----------------------------------------------------
__kernel_ulong_t sub_4CE40()
{
  __u32 v0; // ebx
  __kernel_ulong_t v1; // rbp
  unsigned __int64 i; // rax
  __kernel_ulong_t v3; // r8
  struct sysinfo v5; // [rsp+0h] [rbp-98h] BYREF
  unsigned __int64 v6; // [rsp+78h] [rbp-20h]

  v6 = __readfsqword(0x28u);
  sub_4D070(&v5);
  v0 = v5.mem_unit;
  v1 = v5.totalram;
  for ( i = (int)sub_4BBD0(); v0 > 1; i >>= 1 )
  {
    if ( i <= 1 )
      break;
    v0 >>= 1;
  }
  v3 = v1 * v0;
  if ( i > 1 )
  {
    do
    {
      i >>= 1;
      v3 >>= 1;
    }
    while ( i != 1 );
  }
  return v3;
}

//----- (000000000004CED0) ----------------------------------------------------
__kernel_ulong_t sub_4CED0()
{
  __u32 v0; // ebx
  __kernel_ulong_t v1; // rbp
  unsigned __int64 i; // rax
  __kernel_ulong_t v3; // r8
  struct sysinfo v5; // [rsp+0h] [rbp-98h] BYREF
  unsigned __int64 v6; // [rsp+78h] [rbp-20h]

  v6 = __readfsqword(0x28u);
  sub_4D070(&v5);
  v0 = v5.mem_unit;
  v1 = v5.freeram;
  for ( i = (int)sub_4BBD0(); v0 > 1; i >>= 1 )
  {
    if ( i <= 1 )
      break;
    v0 >>= 1;
  }
  v3 = v1 * v0;
  if ( i > 1 )
  {
    do
    {
      i >>= 1;
      v3 >>= 1;
    }
    while ( i != 1 );
  }
  return v3;
}

//----- (000000000004CF60) ----------------------------------------------------
__int64 sub_4CF60()
{
  __int64 result; // rax

  result = (unsigned int)dword_C12C0;
  if ( !dword_C12C0 )
    result = 100LL;
  return result;
}
// 4CF60: using guessed type __int64 __fastcall sub_4CF60();
// C12C0: using guessed type int dword_C12C0;

//----- (000000000004CF80) ----------------------------------------------------
void __fastcall sub_4CF80(__int64 a1, _QWORD *a2)
{
  void *v2; // rbp
  __int64 v3; // rax

  if ( a2 )
  {
    v2 = (void *)*a2;
    if ( *a2 )
    {
      v3 = sub_90E0(*a2, 47LL);
      if ( v3 )
        v2 = (void *)(v3 + 1);
      off_BEFD8 = v2;
      off_BEFE0 = (void *)*a2;
    }
  }
}
// 90E0: using guessed type __int64 __fastcall sub_90E0(_QWORD, _QWORD);
// BEFD8: using guessed type void *off_BEFD8;
// BEFE0: using guessed type void *off_BEFE0;

//----- (000000000004CFE0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_4CFE0(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, void *a5)
{
  __int64 result; // rax
  __int64 *v6; // rsi
  __int64 (__fastcall *v7)(); // [rsp-10h] [rbp-10h]
  void *v8; // [rsp-8h] [rbp-8h]

  LODWORD(result) = -22;
  if ( a1 )
  {
    if ( a2 )
    {
      v6 = (__int64 *)(a2 - 16);
      v6[1] = a4;
      *v6 = a1;
      result = sys_clone(a3, (unsigned __int64)v6, a5, v8);
      if ( result >= 0 )
      {
        if ( result )
          return result;
        result = sys_exit(v7());
      }
    }
  }
  __writefsdword(0xFFFFFFC0, -(int)result);
  return -1LL;
}
// 4D021: positive sp value 10 has been found
// 4D013: variable 'v8' is possibly undefined
// 4D021: variable 'v7' is possibly undefined

//----- (000000000004D040) ----------------------------------------------------
unsigned __int64 __fastcall sub_4D040(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, unsigned __int64 a5)
{
  unsigned __int64 result; // rax

  result = sys_mremap(a1, a2, a3, a4, a5);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004D070) ----------------------------------------------------
unsigned __int64 __fastcall sub_4D070(struct sysinfo *a1)
{
  unsigned __int64 result; // rax

  result = sys_sysinfo(a1);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004D0A0) ----------------------------------------------------
unsigned __int64 __fastcall accept(int a1, struct sockaddr *a2, int *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  unsigned __int64 result; // rax
  unsigned __int64 v12; // rax
  char v13; // r8
  double v14; // xmm4_8
  double v15; // xmm5_8
  unsigned int fd; // [rsp+0h] [rbp-1Ch]

  if ( __readfsdword(0x18u) )
  {
    sub_6B7F0(a4, a5, a6, a7, a8, a9, a10, a11);
    v12 = sys_accept(a1, a2, a3);
    if ( v12 > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)v12);
      LODWORD(v12) = -1;
    }
    fd = v12;
    sub_6B870(v13, a4, a5, a6, a7, v14, v15, a10, a11);
    result = fd;
  }
  else
  {
    result = sys_accept(a1, a2, a3);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)result);
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}
// 4D0FE: variable 'v13' is possibly undefined
// 4D0FE: variable 'v14' is possibly undefined
// 4D0FE: variable 'v15' is possibly undefined

//----- (000000000004D140) ----------------------------------------------------
unsigned __int64 __fastcall bind(int a1, struct sokaddr *a2, int a3)
{
  unsigned __int64 result; // rax

  result = sys_bind(a1, a2, a3);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004D170) ----------------------------------------------------
unsigned __int64 __fastcall listen(int a1, int a2)
{
  unsigned __int64 result; // rax

  result = sys_listen(a1, a2);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004D1A0) ----------------------------------------------------
unsigned __int64 __fastcall socket(int a1, int a2, int a3)
{
  unsigned __int64 result; // rax

  result = sys_socket(a1, a2, a3);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000004D210) ----------------------------------------------------
void __fastcall __noreturn sub_4D210(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  while ( 1 )
    sub_16EA0(1, "*** %s ***: terminated\n", a2, a3, a4, a5, a6, a7, a8, a9, a1);
}
// 4D235: variable 'a6' is possibly undefined
// 4D235: variable 'a7' is possibly undefined

//----- (000000000004D240) ----------------------------------------------------
__int64 __fastcall htonl(unsigned int a1)
{
  return _byteswap_ulong(a1);
}

//----- (000000000004D250) ----------------------------------------------------
__int16 __fastcall htons(__int16 a1)
{
  return __ROL2__(a1, 8);
}

//----- (000000000004D260) ----------------------------------------------------
void sub_4D260()
{
  ;
}

//----- (000000000004D270) ----------------------------------------------------
void **__fastcall sub_4D270(__int64 a1, __int64 a2)
{
  void **result; // rax
  void *v3; // rdx

  result = (void **)&unk_C1280;
  if ( a2 )
    result = &off_BF0E0 + 19 * a2 + 14;
  if ( !result[1] )
  {
    *(_DWORD *)result = 1;
    if ( !a1 )
      a1 = qword_C12A0;
    goto LABEL_6;
  }
  if ( a1 )
  {
    *(_DWORD *)result = 1;
LABEL_6:
    result[4] = (void *)a1;
    v3 = *(&off_BF0E0 + 19 * a2);
    result[2] = sub_4D260;
    result[1] = v3;
  }
  return result;
}
// BF0E0: using guessed type void *off_BF0E0;
// C12A0: using guessed type __int64 qword_C12A0;

//----- (000000000004D2F0) ----------------------------------------------------
__int64 __fastcall sub_4D2F0(unsigned __int64 a1)
{
  char *v1; // rbx
  _BOOL8 v2; // rbx
  __int64 result; // rax
  char *v4[4]; // [rsp+8h] [rbp-20h] BYREF

  sub_4E120(0, v4, 0LL);
  v1 = v4[0];
  sub_4E120(0x1Bu, v4, 0LL);
  v2 = v1 != 0LL;
  if ( 1 - v2 < a1 )
    sub_77200("Failed loading %lu audit modules, %lu are supported.\n", a1, 1 - v2);
  qword_C0348 = (__int64)v4[0];
  result = 144 * (2 * ((int)a1 + (int)v2) - 1) + LODWORD(v4[0]) + 144;
  qword_C0350 = result;
  return result;
}
// C0348: using guessed type __int64 qword_C0348;
// C0350: using guessed type __int64 qword_C0350;

//----- (000000000004D380) ----------------------------------------------------
unsigned __int64 __fastcall sub_4D380(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  unsigned __int64 result; // rax
  unsigned __int64 *v9; // rcx
  __int64 v10; // rsi
  unsigned __int64 i; // rdi

  if ( !byte_C0380 )
    return ++qword_C0388;
  result = qword_C0370 + 1;
  if ( qword_C0370 + 1 > (unsigned __int64)qword_C0388 )
    goto LABEL_12;
  v9 = (unsigned __int64 *)qword_C0378;
  v10 = 0LL;
  for ( i = *(_QWORD *)qword_C0378; ; i = *v9 )
  {
    while ( result - v10 < i )
    {
      if ( !v9[2 * (result - v10) + 3] )
        goto LABEL_11;
      if ( qword_C0388 + 1 < ++result )
        sub_CF00(
          (__int64)"result <= GL(dl_tls_max_dtv_idx) + 1",
          (__int64)"../elf/dl-tls.c",
          0x98u,
          "_dl_next_tls_modid",
          a1,
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8);
    }
    v9 = (unsigned __int64 *)v9[1];
    v10 += i;
    if ( !v9 )
      break;
  }
LABEL_11:
  if ( result > qword_C0388 )
  {
LABEL_12:
    if ( qword_C0388 + 1 != result )
      sub_CF00(
        (__int64)"result == GL(dl_tls_max_dtv_idx) + 1",
        (__int64)"../elf/dl-tls.c",
        0xA6u,
        "_dl_next_tls_modid",
        a1,
        a2,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8);
    byte_C0380 = 0;
    qword_C0388 = result;
  }
  return result;
}
// C0370: using guessed type __int64 qword_C0370;
// C0378: using guessed type __int64 qword_C0378;
// C0380: using guessed type char byte_C0380;
// C0388: using guessed type __int64 qword_C0388;

//----- (000000000004D500) ----------------------------------------------------
_QWORD *__fastcall sub_4D500(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, u32 *a13, u32 a14)
{
  unsigned __int64 v14; // r12
  __int64 v15; // rbx
  __int64 v16; // rax
  u32 *v17; // r8
  __int64 v18; // r9
  double v19; // xmm4_8
  double v20; // xmm5_8
  __int64 v21; // rbp
  __int64 v22; // rdx
  _QWORD *v23; // r12
  __int64 v24; // rbx
  _QWORD *v25; // rax
  __int64 v26; // rdx
  unsigned __int64 v27; // rcx
  u32 *v28; // r8
  __int64 v29; // r9
  double v30; // xmm4_8
  double v31; // xmm5_8
  _QWORD *result; // rax

  v14 = qword_C0358;
  v15 = qword_C0368;
  v16 = sub_21500((u32 *)(qword_C0368 + qword_C0358 + 8), a10, a11, a12, a13, a14, a1, a2, a3, a4, a5, a6, a7, a8);
  if ( !v16 )
    return 0LL;
  v21 = v16;
  v22 = (v16 + v14 - 1) % v14;
  v23 = (_QWORD *)(v15 + v14 * ((v16 + v14 - 1) / v14) - 2496);
  *v23 = 0LL;
  v23[311] = 0LL;
  memset(
    (void *)((unsigned __int64)(v23 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((unsigned int)v23 - (((_DWORD)v23 + 8) & 0xFFFFFFF8) + 2496) >> 3));
  v23[312] = v16;
  v24 = qword_C0388 + 14;
  v25 = (_QWORD *)sub_22260(qword_C0388 + 16, 0x10uLL, a1, a2, a3, a4, v19, v20, a7, a8, v22, 0LL, v17, v18);
  if ( v25 )
  {
    *v25 = v24;
    v23[1] = v25 + 2;
    result = v23;
  }
  else
  {
    sub_21B70(v21, a1, a2, a3, a4, v30, v31, a7, a8, 16LL, v26, v27, v28, v29);
    result = 0LL;
  }
  return result;
}
// 4D58F: variable 'v19' is possibly undefined
// 4D58F: variable 'v20' is possibly undefined
// 4D58F: variable 'v17' is possibly undefined
// 4D58F: variable 'v18' is possibly undefined
// 4D5B3: variable 'v30' is possibly undefined
// 4D5B3: variable 'v31' is possibly undefined
// 4D5B3: variable 'v26' is possibly undefined
// 4D5B3: variable 'v27' is possibly undefined
// 4D5B3: variable 'v28' is possibly undefined
// 4D5B3: variable 'v29' is possibly undefined
// C0358: using guessed type __int64 qword_C0358;
// C0368: using guessed type __int64 qword_C0368;
// C0388: using guessed type __int64 qword_C0388;

//----- (000000000004D9C0) ----------------------------------------------------
__int64 __fastcall sub_4D9C0(__int64 a1)
{
  unsigned __int64 v1; // rax
  _QWORD *v2; // rdx
  __int64 result; // rax
  unsigned __int64 *v4; // rsi
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // rdi

  v1 = *(_QWORD *)(a1 + 1112);
  if ( !v1 )
    return 0LL;
  v2 = (_QWORD *)__readfsqword(8u);
  if ( *v2 != qword_C0340 )
  {
    if ( v1 >= *(v2 - 2) )
      return 0LL;
    v4 = (unsigned __int64 *)qword_C0378;
    v5 = *(_QWORD *)(a1 + 1112);
    v6 = *(_QWORD *)qword_C0378;
    if ( v1 >= *(_QWORD *)qword_C0378 )
    {
      do
      {
        v4 = (unsigned __int64 *)v4[1];
        v5 -= v6;
        v6 = *v4;
      }
      while ( *v4 <= v5 );
    }
    if ( *v2 < v4[2 * v5 + 2] )
      return 0LL;
  }
  result = v2[2 * v1];
  if ( result == -1 )
    result = 0LL;
  return result;
}
// C0340: using guessed type __int64 qword_C0340;
// C0378: using guessed type __int64 qword_C0378;

//----- (000000000004DA40) ----------------------------------------------------
__int64 __fastcall sub_4DA40(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  unsigned __int64 v15; // rbp
  __int64 *i; // rbx
  __int64 result; // rax
  __int64 *v18; // rbx
  __int64 *v19; // rax
  double v20; // xmm4_8
  double v21; // xmm5_8
  void *v22; // rdi

  v15 = *(_QWORD *)(a1 + 1112);
  for ( i = (__int64 *)qword_C0378; ; i = (__int64 *)i[1] )
  {
    result = *i;
    if ( *i > v15 )
    {
      if ( !(_BYTE)a2 )
        return result;
      goto LABEL_6;
    }
    v15 -= result;
    if ( !i[1] )
      break;
  }
  if ( v15 )
    sub_CF00(
      (__int64)"idx == 0",
      (__int64)"../elf/dl-tls.c",
      0x3E2u,
      "_dl_add_to_slotinfo",
      a7,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14);
  v19 = (__int64 *)sub_21500((u32 *)&stru_3E8.r_info, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
  i[1] = (__int64)v19;
  if ( !v19 )
  {
    ++qword_C0340;
    sub_50110(12LL, "dlopen", 0LL, "cannot create TLS data structures", a7, a8, a9, a10, v20, v21, a13, a14);
  }
  *v19 = 62LL;
  i = v19;
  v19[1] = 0LL;
  v22 = v19 + 2;
  result = 0LL;
  memset(v22, 0, 0x3E0uLL);
  if ( (_BYTE)a2 )
  {
LABEL_6:
    v18 = &i[2 * v15];
    result = qword_C0340 + 1;
    v18[3] = a1;
    v18[2] = result;
  }
  return result;
}
// 4DB30: variable 'v20' is possibly undefined
// 4DB30: variable 'v21' is possibly undefined
// 3E8: using guessed type Elf64_Rela;
// C0340: using guessed type __int64 qword_C0340;
// C0378: using guessed type __int64 qword_C0378;

//----- (000000000004DB40) ----------------------------------------------------
__int64 __fastcall sub_4DB40(__int64 a1, unsigned __int64 *a2)
{
  __int64 result; // rax
  unsigned __int64 v3; // rdx

  result = *(unsigned int *)(a1 + 8);
  if ( (_DWORD)result == 3 )
  {
    *(_QWORD *)(a1 + 32) = a2;
  }
  else
  {
    v3 = *a2;
    if ( (_DWORD)result == 1 || (unsigned int)result > 1 )
    {
      if ( v3 >= *(_QWORD *)(a1 + 16) && v3 <= *(_QWORD *)(a1 + 24) )
      {
        *(_QWORD *)(a1 + 32) = v3;
        *(_BYTE *)(a1 + 40) = 1;
      }
    }
    else if ( (signed __int64)v3 >= *(_QWORD *)(a1 + 16) && (signed __int64)v3 <= *(_QWORD *)(a1 + 24) )
    {
      *(_QWORD *)(a1 + 32) = v3;
      *(_BYTE *)(a1 + 40) = 1;
    }
  }
  return result;
}

//----- (000000000004DBB0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_4DBB0()
{
  unsigned __int64 *v0; // r13
  unsigned __int8 *v1; // rbx
  unsigned __int8 v2; // di
  unsigned __int8 **v3; // r14
  __int64 result; // rax
  unsigned __int8 v5; // dl
  __int64 v6; // rcx
  __int64 v7; // rbp
  unsigned __int8 *v8; // rsi
  char v9; // dl
  char *v10; // r8
  const char *v11; // rcx
  _QWORD *v12; // r9
  int v13; // er10
  _BYTE *v14; // r11
  char v15; // di
  __int64 v16; // rsi
  char v17; // cl
  __int64 v18; // rbx
  char **v19; // rax
  unsigned __int64 v20; // rax
  __int64 v21; // r12
  unsigned __int64 v22; // r15
  unsigned __int8 *v24; // rbx
  char *v25; // rbp
  unsigned int v26; // er10
  __int64 v27; // rdx
  unsigned __int8 *v28; // r9
  unsigned __int8 v29; // di
  __int64 v30; // r12
  char **v31; // r11
  __int64 v32; // r8
  unsigned __int8 v33; // dl
  char v34; // cl
  unsigned __int8 *v35; // rdx
  char *v36; // r9
  char **v37; // rax
  unsigned __int64 v38; // rax
  __int64 *v39; // rsi
  _BYTE *v40; // rcx
  __int64 *v41; // rax
  __int64 v42; // rdx
  unsigned __int8 *v43; // rdx
  unsigned __int8 *v44; // rax
  unsigned __int8 i; // cl
  unsigned __int64 *v46; // r8
  char *v47; // [rsp+8h] [rbp-60h]
  __int64 v48; // [rsp+8h] [rbp-60h]
  unsigned __int8 *v49; // [rsp+8h] [rbp-60h]
  unsigned __int8 *v50; // [rsp+10h] [rbp-58h]
  unsigned __int8 *v51; // [rsp+18h] [rbp-50h]
  __int64 v52[8]; // [rsp+28h] [rbp-40h] BYREF

  result = sys_access("/etc/suid-debug", 0);
  if ( (unsigned int)result <= 0xFFFFF000 )
    dword_BD704 = 2;
  v0 = v46;
LABEL_3:
  if ( !v0 )
    return result;
  do
  {
    v1 = (unsigned __int8 *)*v0;
    if ( !*v0 )
      return result;
    v2 = *v1;
    v3 = (unsigned __int8 **)(v0 + 1);
    if ( *v1 != 61 && v2 )
    {
      result = 1LL;
      while ( 1 )
      {
        v5 = v1[result];
        v6 = result++;
        if ( !v5 )
          goto LABEL_24;
        if ( v5 == 61 )
          goto LABEL_10;
      }
    }
    v5 = *v1;
    v6 = 0LL;
LABEL_10:
    if ( v5 )
    {
      v7 = v6 + 1;
      result = *v1;
      v8 = (unsigned __int8 *)*v0;
      v9 = 71;
      v10 = (char *)&v1[v6 + 1];
      v11 = "GLIBC_TUNABLES";
      do
      {
        if ( !(_BYTE)result || v9 != (_BYTE)result )
          goto LABEL_15;
        v9 = v11[1];
        ++v8;
        ++v11;
        result = *v8;
      }
      while ( v9 );
      if ( (_BYTE)result != 61 )
      {
LABEL_15:
        v12 = &unk_BD0A8;
        v13 = 0;
        while ( 2 )
        {
          if ( !*(_BYTE *)v12 )
          {
            v14 = (_BYTE *)v12[1];
            if ( v14 )
            {
              v15 = *v14;
              v16 = v12[1];
              result = (__int64)v1;
              v17 = *v14;
              if ( *v14 )
              {
                while ( *(_BYTE *)result && *(_BYTE *)result == v17 )
                {
                  v17 = *(_BYTE *)++v16;
                  ++result;
                  if ( !v17 )
                    goto LABEL_26;
                }
                goto LABEL_23;
              }
LABEL_26:
              if ( *(_BYTE *)result == 61 )
              {
                result = *((unsigned int *)v12 + 1);
                if ( (_DWORD)result )
                {
LABEL_28:
                  if ( (_DWORD)result == 2 )
                  {
                    v18 = v13;
                    v19 = &(&off_BD080)[7 * v13];
                    if ( *((_DWORD *)v19 + 2) == 3 )
                    {
                      *((_BYTE *)v19 + 40) = 1;
                    }
                    else
                    {
                      v20 = sub_77370(v10, 0LL);
                      v10 = (char *)v52;
                      v52[0] = v20;
                    }
                    v0 = (unsigned __int64 *)v3;
                    result = sub_4DB40((__int64)&(&off_BD080)[7 * v18], (unsigned __int64 *)v10);
                    goto LABEL_3;
                  }
                }
                else
                {
                  result = *v0;
                  v39 = (__int64 *)v0;
                  v3 = (unsigned __int8 **)v0;
                  if ( *v0 )
                  {
                    v40 = (_BYTE *)v12[1];
                    if ( v15 )
                    {
LABEL_77:
                      while ( *(_BYTE *)result == v15 && *(_BYTE *)result )
                      {
                        v15 = *++v40;
                        ++result;
                        if ( !v15 )
                          goto LABEL_80;
                      }
                      goto LABEL_78;
                    }
                    while ( 1 )
                    {
LABEL_80:
                      if ( *(_BYTE *)result == 61 )
                      {
                        v41 = v39;
                        do
                        {
                          v42 = v41[1];
                          *v41++ = v42;
                        }
                        while ( v42 );
                        result = *v39;
                        if ( !*v39 )
                        {
LABEL_84:
                          result = *((unsigned int *)v12 + 1);
                          v3 = (unsigned __int8 **)v0;
                          goto LABEL_28;
                        }
                      }
                      else
                      {
LABEL_78:
                        result = v39[1];
                        ++v39;
                        if ( !result )
                          goto LABEL_84;
                      }
                      v15 = *v14;
                      v40 = v14;
                      if ( *v14 )
                        goto LABEL_77;
                    }
                  }
                }
              }
            }
          }
LABEL_23:
          ++v13;
          v12 += 7;
          if ( v13 == 30 )
            goto LABEL_24;
          continue;
        }
      }
      v21 = 0LL;
      while ( v2 )
        v2 = v1[++v21];
      v47 = v10;
      v22 = sub_4BB00(v21 + 1);
      if ( v22 == -1LL )
        sub_77200("sbrk() failure while processing tunables\n");
      result = v21 - 1;
      if ( v21 )
      {
        do
          *(_BYTE *)(v22 + result) = v1[result];
        while ( result-- != 0 );
LABEL_39:
        v24 = (unsigned __int8 *)(v22 + v7);
        v25 = v47;
        v26 = *v24;
        v50 = v24;
        if ( !(_BYTE)v26 )
          goto LABEL_46;
LABEL_40:
        while ( 2 )
        {
          if ( (_BYTE)v26 == 61 || (result = v26, v27 = 0LL, (_BYTE)v26 == 58) )
          {
            LOBYTE(result) = v26;
            v27 = 0LL;
LABEL_48:
            v28 = &v24[v27 + 1];
            v29 = *v28;
            if ( (_BYTE)result == 58 )
            {
              v26 = *v28;
              v24 += v27 + 1;
              continue;
            }
            v30 = 0LL;
            if ( v29 && v29 != 58 )
            {
              do
                v29 = v28[++v30];
              while ( v29 != 58 && v29 );
            }
            v31 = &off_BD080;
            v32 = 0LL;
            while ( 1 )
            {
              v33 = v26;
              result = 1LL;
              v34 = **v31;
              if ( v34 )
              {
                while ( v34 == v33 && v33 )
                {
                  v34 = (*v31)[result++];
                  v33 = v24[result - 1];
                  if ( !v34 )
                    goto LABEL_63;
                }
              }
              else
              {
LABEL_63:
                if ( v33 == 61 )
                {
                  result = *((unsigned int *)&off_BD080 + 14 * v32 + 11);
                  if ( (_DWORD)result )
                  {
                    v35 = &v28[v30];
                    v24 = v28;
                  }
                  else
                  {
                    if ( !v29 )
                    {
                      *v24 = 0;
                      goto LABEL_46;
                    }
                    v43 = &v28[v30 + 1];
                    v44 = v24;
                    for ( i = *v43; *v43; i = *v43 )
                    {
                      ++v43;
                      *v44++ = i;
                    }
                    *v44 = 0;
                    v35 = v24;
                    v30 = 0LL;
                    result = *((unsigned int *)&off_BD080 + 14 * v32 + 11);
                  }
                  if ( (_DWORD)result == 2 )
                  {
                    v36 = &v25[v28 - v50];
                    v37 = &(&off_BD080)[7 * v32];
                    v36[v30] = 0;
                    if ( *((_DWORD *)v37 + 2) == 3 )
                    {
                      *((_BYTE *)v37 + 40) = 1;
                    }
                    else
                    {
                      v51 = v35;
                      v48 = v32;
                      v38 = sub_77370(v36, 0LL);
                      v32 = v48;
                      v35 = v51;
                      v36 = (char *)v52;
                      v52[0] = v38;
                    }
                    v49 = v35;
                    result = sub_4DB40((__int64)&(&off_BD080)[7 * v32], (unsigned __int64 *)v36);
                    v35 = v49;
                  }
LABEL_61:
                  if ( !*v35 )
                    goto LABEL_46;
                  v24 += v30 + 1;
                  v26 = *v24;
                  goto LABEL_40;
                }
              }
              ++v32;
              v31 += 7;
              if ( v32 == 30 )
              {
                v35 = &v28[v30];
                v24 = v28;
                goto LABEL_61;
              }
            }
          }
          break;
        }
        while ( (_BYTE)result )
        {
          result = v24[++v27];
          if ( (_BYTE)result == 61 || (_BYTE)result == 58 )
            goto LABEL_48;
        }
LABEL_46:
        *v0++ = v22;
        goto LABEL_3;
      }
      if ( v22 )
        goto LABEL_39;
      *v0++ = 0LL;
      goto LABEL_3;
    }
LABEL_24:
    v0 = (unsigned __int64 *)v3;
  }
  while ( v3 );
  return result;
}
// 4E0F4: write access to const memory at BD704 has been detected
// 4DE3A: conditional instruction was optimized away because of 'al.1 in (==3A|==3D)'
// 4E0EE: conditional instruction was optimized away because of 'eax.4>=FFFFF001u'
// 4DBD3: variable 'v46' is possibly undefined
// 4DBB0: using guessed type __int64 __fastcall sub_4DBB0();
// BD080: using guessed type char *off_BD080;
// BD704: using guessed type int dword_BD704;
// BD7E0: using guessed type int dword_BD7E0;

//----- (000000000004E120) ----------------------------------------------------
__int64 __fastcall sub_4E120(unsigned int a1, char **a2, __int64 (__fastcall *a3)(char **))
{
  char **v3; // rax
  unsigned int v4; // er8
  char *v5; // rax
  __int64 result; // rax

  v3 = &(&off_BD080)[7 * a1];
  v4 = *((_DWORD *)v3 + 2);
  v5 = v3[4];
  if ( v4 > 2 || v4 )
    *a2 = v5;
  else
    *(_DWORD *)a2 = (_DWORD)v5;
  result = 7LL * a1;
  if ( LOBYTE((&off_BD080)[7 * a1 + 5]) )
  {
    if ( a3 )
      result = a3(&(&off_BD080)[7 * a1 + 4]);
  }
  return result;
}
// BD080: using guessed type char *off_BD080;

//----- (000000000004E190) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_4E190(__int64 *a1)
{
  __int64 result; // rax
  unsigned __int64 v2; // rax

  result = *a1;
  for ( qword_C1308 = (__int64)a1; result; a1 += 2 )
  {
    v2 = result - 3;
    if ( v2 <= 0x1E )
      __asm { jmp     rax }
    result = a1[2];
  }
  return result;
}
// 4E333: write access to const memory at BD7E0 has been detected
// 4E34F: write access to const memory at BD7A0 has been detected
// 4E36D: write access to const memory at BD7E0 has been detected
// 4E2E1: conditional instruction was optimized away because of '%var_38@4.1==0'
// 4E2F4: conditional instruction was optimized away because of '%var_46.1==0'
// 4E307: conditional instruction was optimized away because of '%var_45.1==0'
// 4E31A: conditional instruction was optimized away because of '%var_38@5.1==0'
// 4E32D: conditional instruction was optimized away because of '%var_38@6.1==0'
// 4E348: conditional instruction was optimized away because of '%var_38@7.1==0'
// BD7A0: using guessed type __int64 qword_BD7A0;
// BD7E0: using guessed type int dword_BD7E0;
// BF06C: using guessed type __int16 word_BF06C;
// BF078: using guessed type Elf64_Rela *off_BF078;
// C12C0: using guessed type int dword_C12C0;
// C12D0: using guessed type __int64 qword_C12D0;
// C12E8: using guessed type __int64 qword_C12E8;
// C12F0: using guessed type __int64 qword_C12F0;
// C1308: using guessed type __int64 qword_C1308;
// C14C0: using guessed type __int64 qword_C14C0;
// C14D0: using guessed type int dword_C14D0;

//----- (000000000004E5B0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
unsigned __int64 __fastcall sub_4E5B0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  _WORD *v8; // rax
  double v9; // xmm4_8
  double v10; // xmm5_8
  _BOOL4 v11; // edx
  __int64 *v12; // rbp
  __int64 v13; // rdi
  __int64 v14; // rcx
  __int64 i; // rsi
  __int64 v16; // rax
  int v17; // edx
  __int64 v18; // rdx
  __int64 v19; // rcx
  bool v20; // zf
  unsigned __int64 *v21; // rdx
  unsigned __int64 v22; // rax
  __int64 *v23; // rdx
  int v24; // eax
  __int64 *v25; // rsi
  __int64 v26; // rdx
  __int64 *v27; // rdx
  __int64 v28; // rdi
  __int64 *v29; // rsi
  __int64 v30; // rdx
  __int64 *v31; // rdx
  __int64 v32; // rdi
  __int64 *v33; // rsi
  __int64 v34; // rdx
  __int64 *v35; // rdx
  __int64 v36; // rdi
  __int64 *v37; // rsi
  __int64 v38; // rdx
  __int64 *v39; // rdx
  __int64 v40; // rdi
  __int64 *v41; // rsi
  __int64 v42; // rdx
  __int64 *v43; // rdx
  __int64 v44; // rdi
  __int64 v45; // rdx
  __int64 *v46; // rdx
  __int64 v47; // rdi
  __int64 *v48; // rdx
  __int64 *v49; // rax
  __int64 v50; // rax
  __int64 v51; // rax
  __int64 v52; // rdx
  __int64 v53; // rax
  __int64 v54; // rax
  __int64 v55; // rax
  const void *v56; // r12
  u32 *v57; // r13
  __int64 v58; // rdx
  __int64 v59; // rcx
  u32 *v60; // r8
  u32 v61; // er9
  double v62; // xmm4_8
  double v63; // xmm5_8
  void *v64; // rdi
  void *v65; // rax
  _QWORD *v66; // rdx
  __int64 *v67; // rax
  double v68; // xmm4_8
  double v69; // xmm5_8
  __int64 v70; // rax
  __int64 v71; // rsi
  __int64 v72; // rax
  __int64 *v73; // rax
  double v74; // xmm4_8
  double v75; // xmm5_8
  __int64 v76; // rax
  __int64 v77; // rsi
  __int64 v78; // rax
  __int64 *v79; // rax
  double v80; // xmm4_8
  double v81; // xmm5_8
  __int64 v82; // rax
  __int64 v83; // rsi
  __int64 v84; // rax
  __int64 *v85; // rax
  double v86; // xmm4_8
  double v87; // xmm5_8
  __int64 v88; // rax
  __int64 v89; // rsi
  __int64 v90; // rax
  __int64 *v91; // rax
  __int64 v92; // rax
  __int64 v93; // rax
  _WORD *v94; // rax
  double v95; // xmm4_8
  double v96; // xmm5_8
  _WORD *v97; // rax
  _BOOL4 v98; // edx
  _WORD *v99; // rax
  _BOOL4 v100; // edx
  _WORD *v101; // rax
  _BOOL4 v102; // edx
  _WORD *v103; // rax
  char *v104; // rbp
  char *v105; // rbp
  __int64 v106; // r13
  __int64 j; // rbx
  unsigned __int64 v108; // rax
  char v109; // si
  __int64 v110; // rdx
  unsigned __int64 v111; // rdx
  unsigned __int64 result; // rax
  __int64 v113; // r10
  unsigned __int64 v114; // rcx
  __int64 v115; // r11
  __int64 v116; // rdi
  char v117; // r8
  char v118; // si
  int v119; // er9
  unsigned int *v120; // [rsp+8h] [rbp-70h] BYREF
  __int128 v121; // [rsp+10h] [rbp-68h] BYREF
  __int64 v122; // [rsp+20h] [rbp-58h]
  char *v123; // [rsp+30h] [rbp-48h] BYREF
  __int64 v124; // [rsp+38h] [rbp-40h]
  __int64 v125; // [rsp+40h] [rbp-38h]

  qword_BF4C8 = sub_77EB0(a1, a2, a3, a4, a5, a6, a7, a8);
  qword_BF428 = qword_C1300;
  word_BF438 = qword_C12F8;
  v8 = sub_12350("LD_WARN");
  v11 = 0;
  if ( v8 )
    v11 = *(_BYTE *)v8 != 0;
  dword_C14A8 = v11;
  if ( qword_C12D0
    && (v12 = sub_74330((char *)&unk_A6E65, &unk_A6E65, 1, 0LL, 0, 0LL, a1, a2, a3, a4, v9, v10, a7, a8)) != 0LL )
  {
    v13 = qword_C12D0;
    v14 = 0LL;
    i = *(unsigned __int16 *)(qword_C12D0 + 56);
    v16 = qword_C12D0 + *(_QWORD *)(qword_C12D0 + 32);
    *((_WORD *)v12 + 348) = i;
    v12[85] = v16;
    if ( i )
    {
      do
      {
        while ( 1 )
        {
          v17 = *(_DWORD *)v16;
          if ( *(_DWORD *)v16 != 2 )
            break;
          v18 = *(_QWORD *)(v16 + 16);
          ++v14;
          v16 += 56LL;
          v12[2] = v18;
          *((_WORD *)v12 + 349) = *(_QWORD *)(v16 - 16) >> 4;
          if ( v14 == i )
            goto LABEL_12;
        }
        if ( v17 == 1 )
        {
          v110 = *(_QWORD *)(v16 + 16);
          if ( !*v12 )
            *v12 = v110;
          v111 = *(_QWORD *)(v16 + 40) + v110;
          if ( v111 >= v12[107] )
            v12[107] = v111;
          if ( (*(_BYTE *)(v16 + 4) & 1) != 0 && v111 >= v12[108] )
            v12[108] = v111;
        }
        else if ( v17 == 7 )
        {
          sub_CF00(
            (__int64)"ph->p_type != PT_TLS",
            (__int64)"setup-vdso.h",
            0x3Du,
            "setup_vdso",
            a1,
            a2,
            a3,
            a4,
            v9,
            v10,
            a7,
            a8);
        }
        ++v14;
        v16 += 56LL;
      }
      while ( v14 != i );
    }
LABEL_12:
    v19 = v13 - *v12;
    v12[107] += v19;
    v12[108] += v19;
    v20 = v12[2] + v19 == 0;
    v21 = (unsigned __int64 *)(v12[2] + v19);
    v12[106] = v13;
    *v12 = v19;
    v12[2] = (__int64)v21;
    if ( !v20 )
    {
      v22 = *v21;
      for ( i = (__int64)(v12 + 8); v22; v21 += 2 )
      {
        while ( v22 <= 0x22 )
        {
          *(_QWORD *)(i + 8 * v22) = v21;
LABEL_20:
          v22 = v21[2];
          v21 += 2;
          if ( !v22 )
            goto LABEL_21;
        }
        if ( 1879048191 - v22 > 0xF )
        {
          if ( (unsigned int)(2 * v22) > 0xFFFFFFF8 )
          {
            *(_QWORD *)(i + 8LL * (unsigned int)(50 - ((2 * (int)v22) >> 1))) = v21;
            goto LABEL_20;
          }
          if ( 1879047679 - v22 > 0xB )
          {
            if ( 1879047935 - v22 <= 0xA )
              *(_QWORD *)(i + 8 * (1879048001 - v22)) = v21;
          }
          else
          {
            *(_QWORD *)(i + 8 * (1879047733 - v22)) = v21;
          }
        }
        else
        {
          *(_QWORD *)(i + 8 * (1879048226 - v22)) = v21;
        }
        v22 = v21[2];
      }
LABEL_21:
      if ( v19 )
      {
        v23 = (__int64 *)v12[12];
        v24 = 0;
        if ( v23 )
        {
          qword_BD720[0] = *v23;
          qword_BD728 = v19 + v23[1];
          v12[12] = (__int64)qword_BD720;
          v24 = 1;
        }
        v25 = (__int64 *)v12[11];
        if ( v25 )
        {
          v26 = v24++;
          v27 = &qword_BD720[2 * v26];
          v28 = *v25;
          v27[1] = v19 + v25[1];
          *v27 = v28;
          v12[11] = (__int64)v27;
        }
        v29 = (__int64 *)v12[13];
        if ( v29 )
        {
          v30 = v24++;
          v31 = &qword_BD720[2 * v30];
          v32 = *v29;
          v31[1] = v19 + v29[1];
          *v31 = v32;
          v12[13] = (__int64)v31;
        }
        v33 = (__int64 *)v12[14];
        if ( v33 )
        {
          v34 = v24++;
          v35 = &qword_BD720[2 * v34];
          v36 = *v33;
          v35[1] = v19 + v33[1];
          *v35 = v36;
          v12[14] = (__int64)v35;
        }
        v37 = (__int64 *)v12[15];
        if ( v37 )
        {
          v38 = v24++;
          v39 = &qword_BD720[2 * v38];
          v40 = *v37;
          v39[1] = v19 + v37[1];
          *v39 = v40;
          v12[15] = (__int64)v39;
        }
        v41 = (__int64 *)v12[31];
        if ( v41 )
        {
          v42 = v24++;
          v43 = &qword_BD720[2 * v42];
          v44 = *v41;
          v43[1] = v19 + v41[1];
          *v43 = v44;
          v12[31] = (__int64)v43;
        }
        i = v12[58];
        if ( i )
        {
          v45 = v24++;
          v46 = &qword_BD720[2 * v45];
          v47 = *(_QWORD *)i;
          v46[1] = v19 + *(_QWORD *)(i + 8);
          *v46 = v47;
          v12[58] = (__int64)v46;
        }
        v48 = (__int64 *)v12[84];
        if ( v48 )
        {
          v49 = &qword_BD720[2 * v24];
          i = *v48;
          v49[1] = v48[1] + v19;
          *v49 = i;
          v12[84] = (__int64)v49;
        }
      }
      v50 = v12[28];
      if ( v50 && *(_QWORD *)(v50 + 8) != 7LL )
        sub_CF00(
          (__int64)"info[DT_PLTREL]->d_un.d_val == DT_RELA",
          (__int64)"get-dynamic-info.h",
          0x7Bu,
          "elf_get_dynamic_info",
          a1,
          a2,
          a3,
          a4,
          v9,
          v10,
          a7,
          a8);
      if ( v12[15] && *(_QWORD *)(v12[17] + 8) != 24LL )
        sub_CF00(
          (__int64)"info[DT_RELAENT]->d_un.d_val == sizeof (ElfW(Rela))",
          (__int64)"get-dynamic-info.h",
          0x83u,
          "elf_get_dynamic_info",
          a1,
          a2,
          a3,
          a4,
          v9,
          v10,
          a7,
          a8);
      v51 = v12[38];
      if ( v51 )
      {
        v52 = *(_QWORD *)(v51 + 8);
        *((_DWORD *)v12 + 250) = v52;
        if ( (v52 & 2) != 0 )
          v12[24] = v51;
        if ( (v52 & 4) != 0 )
          v12[30] = v51;
        if ( (v52 & 8) != 0 )
          v12[32] = v51;
      }
      v53 = v12[47];
      if ( v53 )
      {
        i = *(_QWORD *)(v53 + 8);
        *((_DWORD *)v12 + 249) = i;
        LOBYTE(v53) = i;
        if ( (i & 8) != 0 )
          *((_BYTE *)v12 + 800) = 1;
        if ( (dword_C14B4 & 0x40) != 0 )
        {
          i = (unsigned int)i & 0xF7FFF716;
          if ( (_DWORD)i )
          {
            sub_76EA0("\nWARNING: Unsupported flag value(s) of 0x%x in DT_FLAGS_1.\n", i);
            LODWORD(v53) = *((_DWORD *)v12 + 249);
          }
        }
        if ( (v53 & 1) != 0 )
          v12[32] = v12[47];
      }
      if ( v12[37] )
        v12[23] = 0LL;
    }
    sub_741B0((__int64)v12, a1, a2, a3, a4, v9, v10, a7, a8);
    v54 = v12[115];
    *((_BYTE *)v12 + 796) |= 4u;
    *((_DWORD *)v12 + 247) = 1;
    *(_DWORD *)(v54 + 8) = 1;
    *(_QWORD *)v54 = v12 + 5;
    v55 = v12[22];
    if ( v55 )
    {
      v56 = (const void *)(*(_QWORD *)(v12[13] + 8) + *(_QWORD *)(v55 + 8));
      v57 = (u32 *)(strlen((__int64)v56) + 1);
      v64 = (void *)sub_21500(v57, i, v58, v59, v60, v61, a1, a2, a3, a4, v62, v63, a7, a8);
      if ( !v64 )
        sub_77200("out of memory\n");
      v65 = memcpy(v64, v56, (size_t)v57);
      v66 = (_QWORD *)v12[7];
      v12[1] = (__int64)v65;
      *v66 = v65;
    }
    sub_74270(v12, 0LL);
    qword_C12C8 = (__int64)v12;
    qword_BF088 = 1LL;
  }
  else
  {
    v12 = (__int64 *)qword_C12C8;
    if ( !qword_C12C8 )
    {
      qword_BD7D8 = 0LL;
LABEL_146:
      qword_BD7D0 = 0LL;
LABEL_147:
      qword_BD7C8 = 0LL;
LABEL_148:
      qword_BD7C0 = 0LL;
LABEL_149:
      v93 = 0LL;
      goto LABEL_90;
    }
  }
  a1 = 0.0;
  v122 = 0LL;
  v121 = 0LL;
  BYTE4(v121) = 32;
  v123 = "LINUX_2.6";
  v124 = 0x103AE75F6LL;
  v125 = 0LL;
  v120 = (unsigned int *)&v121;
  v67 = (__int64 *)sub_73690(
                     "__vdso_clock_gettime",
                     (__int64)v12,
                     &v120,
                     (__int64 **)v12 + 115,
                     (const char **)&v123,
                     0,
                     (__m128)0LL,
                     a2,
                     a3,
                     a4,
                     v9,
                     v10,
                     a7,
                     a8,
                     0,
                     0LL);
  if ( v120 )
  {
    if ( *((_WORD *)v120 + 3) == 0xFFF1 || !v67 )
      v70 = 0LL;
    else
      v70 = *v67;
    v71 = qword_C12C8;
    v72 = *((_QWORD *)v120 + 1) + v70;
  }
  else
  {
    v71 = qword_C12C8;
    v72 = 0LL;
  }
  qword_BD7D8 = v72;
  if ( !v71 )
    goto LABEL_146;
  a1 = 0.0;
  v123 = "LINUX_2.6";
  v121 = 0LL;
  v122 = 0LL;
  BYTE4(v121) = 32;
  v124 = 0x103AE75F6LL;
  v125 = 0LL;
  v120 = (unsigned int *)&v121;
  v73 = (__int64 *)sub_73690(
                     "__vdso_gettimeofday",
                     v71,
                     &v120,
                     (__int64 **)(v71 + 920),
                     (const char **)&v123,
                     0,
                     (__m128)0LL,
                     a2,
                     a3,
                     a4,
                     v68,
                     v69,
                     a7,
                     a8,
                     0,
                     0LL);
  if ( v120 )
  {
    if ( *((_WORD *)v120 + 3) == 0xFFF1 || !v73 )
      v76 = 0LL;
    else
      v76 = *v73;
    v77 = qword_C12C8;
    v78 = *((_QWORD *)v120 + 1) + v76;
  }
  else
  {
    v77 = qword_C12C8;
    v78 = 0LL;
  }
  qword_BD7D0 = v78;
  if ( !v77 )
    goto LABEL_147;
  a1 = 0.0;
  v123 = "LINUX_2.6";
  v121 = 0LL;
  v122 = 0LL;
  BYTE4(v121) = 32;
  v124 = 0x103AE75F6LL;
  v125 = 0LL;
  v120 = (unsigned int *)&v121;
  v79 = (__int64 *)sub_73690(
                     "__vdso_time",
                     v77,
                     &v120,
                     (__int64 **)(v77 + 920),
                     (const char **)&v123,
                     0,
                     (__m128)0LL,
                     a2,
                     a3,
                     a4,
                     v74,
                     v75,
                     a7,
                     a8,
                     0,
                     0LL);
  if ( v120 )
  {
    if ( *((_WORD *)v120 + 3) == 0xFFF1 || !v79 )
      v82 = 0LL;
    else
      v82 = *v79;
    v83 = qword_C12C8;
    v84 = *((_QWORD *)v120 + 1) + v82;
  }
  else
  {
    v83 = qword_C12C8;
    v84 = 0LL;
  }
  qword_BD7C8 = v84;
  if ( !v83 )
    goto LABEL_148;
  a1 = 0.0;
  v123 = "LINUX_2.6";
  v121 = 0LL;
  v122 = 0LL;
  BYTE4(v121) = 32;
  v124 = 0x103AE75F6LL;
  v125 = 0LL;
  v120 = (unsigned int *)&v121;
  v85 = (__int64 *)sub_73690(
                     "__vdso_getcpu",
                     v83,
                     &v120,
                     (__int64 **)(v83 + 920),
                     (const char **)&v123,
                     0,
                     (__m128)0LL,
                     a2,
                     a3,
                     a4,
                     v80,
                     v81,
                     a7,
                     a8,
                     0,
                     0LL);
  if ( v120 )
  {
    if ( *((_WORD *)v120 + 3) == 0xFFF1 || !v85 )
      v88 = 0LL;
    else
      v88 = *v85;
    v89 = qword_C12C8;
    v90 = *((_QWORD *)v120 + 1) + v88;
  }
  else
  {
    v89 = qword_C12C8;
    v90 = 0LL;
  }
  qword_BD7C0 = v90;
  if ( !v89 )
    goto LABEL_149;
  a1 = 0.0;
  v123 = "LINUX_2.6";
  v121 = 0LL;
  v122 = 0LL;
  BYTE4(v121) = 32;
  v124 = 0x103AE75F6LL;
  v125 = 0LL;
  v120 = (unsigned int *)&v121;
  v91 = (__int64 *)sub_73690(
                     "__vdso_clock_getres",
                     v89,
                     &v120,
                     (__int64 **)(v89 + 920),
                     (const char **)&v123,
                     0,
                     (__m128)0LL,
                     a2,
                     a3,
                     a4,
                     v86,
                     v87,
                     a7,
                     a8,
                     0,
                     0LL);
  if ( !v120 )
    goto LABEL_149;
  if ( *((_WORD *)v120 + 3) == 0xFFF1 || !v91 )
    v92 = 0LL;
  else
    v92 = *v91;
  v93 = *((_QWORD *)v120 + 1) + v92;
LABEL_90:
  qword_BD7B8 = v93;
  v94 = sub_12350("LD_LIBRARY_PATH");
  sub_70840(v94, a1, a2, a3, a4, v95, v96, a7, a8);
  qword_C1318 = qword_C1320;
  v97 = sub_12350("LD_BIND_NOW");
  v98 = 1;
  if ( v97 )
    v98 = *(_BYTE *)v97 == 0;
  dword_C14B0 = v98;
  v99 = sub_12350("LD_BIND_NOT");
  v100 = 0;
  if ( v99 )
    v100 = *(_BYTE *)v99 != 0;
  dword_C1478 = v100;
  v101 = sub_12350("LD_DYNAMIC_WEAK");
  v102 = 1;
  if ( v101 )
    v102 = *(_BYTE *)v101 == 0;
  dword_C14AC = v102;
  v103 = sub_12350("LD_PROFILE_OUTPUT");
  qword_C1498 = (__int64)v103;
  if ( !v103 || !*(_BYTE *)v103 )
    qword_C1498 = (__int64)&aVarTmp[9];
  v104 = "GCONV_PATH";
  do
  {
    sub_5DBA0(v104);
    v104 = (char *)(sub_9060(v104, 0LL) + 1);
  }
  while ( v104 < &aGconvPath[300] );
  if ( qword_C14C0 && !*(_BYTE *)qword_C14C0 )
    qword_C14C0 = 0LL;
  v105 = (char *)sub_12350("LD_ASSUME_KERNEL");
  if ( v105 )
  {
    v106 = 0LL;
    for ( j = 0LL; ; ++j )
    {
      v108 = sub_77370(v105, &v123);
      if ( v108 > 0xFE || v123 == v105 )
        break;
      if ( j == 2 )
      {
        v106 |= v108;
LABEL_124:
        if ( v106 )
          dword_C1328 = v106;
        break;
      }
      v109 = *v123;
      if ( *v123 != 46 && v109 )
        break;
      v106 |= v108 << (-8 * (unsigned __int8)j + 16);
      if ( !v109 )
        goto LABEL_124;
      v105 = v123 + 1;
    }
  }
  if ( qword_C14C0 )
    qword_C14B8 = strlen(qword_C14C0);
  result = qword_C1300;
  v113 = qword_BF5F0;
  if ( qword_C1300 )
  {
    v114 = qword_C1300 + 56 * qword_C12F8;
    if ( qword_C1300 < v114 )
    {
      v115 = qword_BF5E8;
      v116 = qword_BF5F0;
      v117 = 0;
      v118 = 0;
      v119 = dword_BF068;
      do
      {
        while ( *(_DWORD *)result == 1685382481 )
        {
          v119 = *(_DWORD *)(result + 4);
          result += 56LL;
          v118 = 1;
          if ( result >= v114 )
            goto LABEL_136;
        }
        if ( *(_DWORD *)result == 1685382482 )
        {
          v115 = *(_QWORD *)(result + 16);
          v116 = *(_QWORD *)(result + 40);
          v117 = 1;
        }
        result += 56LL;
      }
      while ( result < v114 );
LABEL_136:
      if ( v118 )
        dword_BF068 = v119;
      if ( v117 )
      {
        qword_BF5E8 = v115;
        v113 = v116;
        qword_BF5F0 = v116;
      }
    }
  }
  if ( v113 )
    result = sub_747C0((__int64)&unk_BF180);
  return result;
}
// 4E77D: write access to const memory at BD720 has been detected
// 4E78B: write access to const memory at BD728 has been detected
// 4EB07: write access to const memory at BD7D8 has been detected
// 4EBA3: write access to const memory at BD7D0 has been detected
// 4EC40: write access to const memory at BD7C8 has been detected
// 4ECDC: write access to const memory at BD7C0 has been detected
// 4ED77: write access to const memory at BD7B8 has been detected
// 4F0B0: write access to const memory at BD7D8 has been detected
// 4F0BB: write access to const memory at BD7D0 has been detected
// 4F0C6: write access to const memory at BD7C8 has been detected
// 4F0D1: write access to const memory at BD7C0 has been detected
// 4E62E: variable 'v9' is possibly undefined
// 4E62E: variable 'v10' is possibly undefined
// 4EA20: variable 'v58' is possibly undefined
// 4EA20: variable 'v59' is possibly undefined
// 4EA20: variable 'v60' is possibly undefined
// 4EA20: variable 'v61' is possibly undefined
// 4EA20: variable 'v62' is possibly undefined
// 4EA20: variable 'v63' is possibly undefined
// 4EB6B: variable 'v68' is possibly undefined
// 4EB6B: variable 'v69' is possibly undefined
// 4EC07: variable 'v74' is possibly undefined
// 4EC07: variable 'v75' is possibly undefined
// 4ECA4: variable 'v80' is possibly undefined
// 4ECA4: variable 'v81' is possibly undefined
// 4ED40: variable 'v86' is possibly undefined
// 4ED40: variable 'v87' is possibly undefined
// 4ED86: variable 'v95' is possibly undefined
// 4ED86: variable 'v96' is possibly undefined
// 9060: using guessed type __int64 __fastcall sub_9060(_QWORD, _QWORD);
// BD720: using guessed type __int64 qword_BD720[];
// BD728: using guessed type __int64 qword_BD728;
// BD7B8: using guessed type __int64 qword_BD7B8;
// BD7C0: using guessed type __int64 qword_BD7C0;
// BD7C8: using guessed type __int64 qword_BD7C8;
// BD7D0: using guessed type __int64 qword_BD7D0;
// BD7D8: using guessed type __int64 qword_BD7D8;
// BD7E0: using guessed type int dword_BD7E0;
// BF068: using guessed type int dword_BF068;
// BF088: using guessed type __int64 qword_BF088;
// BF428: using guessed type __int64 qword_BF428;
// BF438: using guessed type __int16 word_BF438;
// BF4C8: using guessed type __int64 qword_BF4C8;
// BF5E8: using guessed type __int64 qword_BF5E8;
// BF5F0: using guessed type __int64 qword_BF5F0;
// C12C8: using guessed type __int64 qword_C12C8;
// C12D0: using guessed type __int64 qword_C12D0;
// C12F8: using guessed type __int64 qword_C12F8;
// C1300: using guessed type __int64 qword_C1300;
// C1318: using guessed type __int64 qword_C1318;
// C1320: using guessed type __int64 qword_C1320;
// C1328: using guessed type int dword_C1328;
// C1478: using guessed type int dword_C1478;
// C1498: using guessed type __int64 qword_C1498;
// C14A8: using guessed type int dword_C14A8;
// C14AC: using guessed type int dword_C14AC;
// C14B0: using guessed type int dword_C14B0;
// C14B4: using guessed type int dword_C14B4;
// C14B8: using guessed type __int64 qword_C14B8;
// C14C0: using guessed type __int64 qword_C14C0;

//----- (000000000004F240) ----------------------------------------------------
void *sub_4F240()
{
  return &unk_BF180;
}

//----- (000000000004F250) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 sub_4F250()
{
  __int64 result; // rax
  int v1; // ebx
  int v2; // er8
  int v3; // ebx

  result = (unsigned int)dword_C14D0;
  if ( !dword_C14D0 )
  {
    v1 = sub_6EA30();
    v2 = sub_6EA20();
    result = 1LL;
    if ( v1 == v2 )
    {
      v3 = sub_6EA50();
      result = v3 != (unsigned int)sub_6EA40();
    }
    dword_BD7E0 = result;
  }
  return result;
}
// 4F27A: write access to const memory at BD7E0 has been detected
// 4F250: using guessed type __int64 __fastcall sub_4F250();
// BD7E0: using guessed type int dword_BD7E0;
// C14D0: using guessed type int dword_C14D0;

//----- (000000000004F2B0) ----------------------------------------------------
void __fastcall sub_4F2B0(__int64 a1)
{
  __int64 retaddr; // [rsp+0h] [rbp+0h]

  if ( qword_C1488 )
    sub_77C60(retaddr, a1);
}
// C1488: using guessed type __int64 qword_C1488;

//----- (000000000004F2E0) ----------------------------------------------------
void __fastcall sub_4F2E0(char **a1)
{
  char *v1; // r12
  char v2; // r13
  char *v3; // rax
  char v4; // dl
  signed __int64 v5; // rax
  __int64 v6; // r14
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rax

  v1 = *a1;
  v2 = **a1;
  do
  {
    if ( v2 == 44 || !v2 )
    {
      v6 = 1LL;
    }
    else
    {
      v3 = v1;
      do
        v4 = *++v3;
      while ( v4 && v4 != 44 );
      v5 = v3 - v1;
      v6 = v5 + 1;
      if ( v2 == 45 )
      {
        v8 = v5 - 4;
        if ( v8 <= 0x17 )
          __asm { jmp     rax }
      }
      else
      {
        v7 = v5 - 4;
        if ( v7 <= 0x16 )
          __asm { jmp     rax }
      }
    }
    v1 += v6;
    v2 = *v1;
  }
  while ( *v1 );
}

//----- (000000000004FDD0) ----------------------------------------------------
__int64 __fastcall sub_4FDD0(const __m128i **a1)
{
  __int64 result; // rax

  if ( (unsigned int)sub_2BA10(*a1, byte_A6D55, 3uLL) )
  {
    if ( (unsigned int)sub_2BA10(*a1, "off", 4uLL) )
    {
      result = sub_2BA10(*a1, "permissive", 0xBuLL);
      if ( !(_DWORD)result )
        byte_C1470 |= 3u;
    }
    else
    {
      result = byte_C1470 & 0xFC | 2u;
      byte_C1470 = byte_C1470 & 0xFC | 2;
    }
  }
  else
  {
    result = byte_C1470 & 0xFC | 1u;
    byte_C1470 = byte_C1470 & 0xFC | 1;
  }
  return result;
}
// C1470: using guessed type char byte_C1470;

//----- (000000000004FE60) ----------------------------------------------------
__int64 __fastcall sub_4FE60(const __m128i **a1)
{
  __int64 result; // rax

  if ( (unsigned int)sub_2BA10(*a1, byte_A6D55, 3uLL) )
  {
    if ( (unsigned int)sub_2BA10(*a1, "off", 4uLL) )
    {
      result = sub_2BA10(*a1, "permissive", 0xBuLL);
      if ( !(_DWORD)result )
        byte_C1470 |= 0xCu;
    }
    else
    {
      result = byte_C1470 & 0xF3 | 8u;
      byte_C1470 = byte_C1470 & 0xF3 | 8;
    }
  }
  else
  {
    result = byte_C1470 & 0xF3 | 4u;
    byte_C1470 = byte_C1470 & 0xF3 | 4;
  }
  return result;
}
// C1470: using guessed type char byte_C1470;

//----- (000000000004FEF0) ----------------------------------------------------
__int64 sub_4FEF0()
{
  int v0; // edx
  char *v1; // rsi
  int v2; // er8
  unsigned int v3; // edi
  int v4; // edx
  char v5; // al
  char *v6; // rcx
  signed int v8; // eax
  unsigned int v9; // er12
  signed __int64 v10; // rbp
  char v11[64]; // [rsp+0h] [rbp-1E8h] BYREF
  struct old_utsname v12; // [rsp+40h] [rbp-1A8h] BYREF

  v1 = v12.release;
  if ( (unsigned int)sub_6E570(&v12) )
  {
    v8 = sub_4B910("/proc/sys/kernel/osrelease", 0, v0);
    v9 = v8;
    if ( v8 < 0 )
      return 0xFFFFFFFFLL;
    v10 = sub_4BA60(v8, v11, 0x40uLL);
    sub_4B7A0(v9);
    if ( v10 <= 0 )
      return 0xFFFFFFFFLL;
    v1 = v11;
    if ( v10 >= 63 )
      v10 = 63LL;
    v11[v10] = 0;
  }
  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    LOBYTE(v4) = *v1 - 48;
    if ( (unsigned __int8)v4 > 9u )
      break;
    v5 = v1[1];
    v6 = v1 + 1;
    v4 = (char)v4;
    if ( (unsigned __int8)(v5 - 48) <= 9u )
    {
      do
      {
        ++v6;
        v4 = (char)(v5 - 48) + 10 * v4;
        v5 = *v6;
      }
      while ( (unsigned __int8)(*v6 - 48) <= 9u );
    }
    ++v2;
    v1 = v6 + 1;
    v3 = v4 | (v3 << 8);
    if ( v5 != 46 )
    {
      if ( v2 == 3 )
        return v3;
      break;
    }
    if ( v2 == 3 )
      return v3;
  }
  v3 <<= 8 * (3 - v2);
  return v3;
}
// 4FFAB: variable 'v0' is possibly undefined
// 4FEF0: using guessed type __int64 __fastcall sub_4FEF0();

//----- (0000000000050000) ----------------------------------------------------
void __fastcall __noreturn sub_50000(__int64 a1, _BYTE *a2, const char *a3, __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  __int64 v12; // r9
  void *v15; // rax
  const char *v16; // rdx
  const char *v17; // r8
  const char *v18; // rsi
  char v20[1032]; // [rsp+10h] [rbp-428h] BYREF
  unsigned __int64 v21; // [rsp+418h] [rbp-20h]

  v12 = a4;
  v21 = __readfsqword(0x28u);
  v15 = &unk_A6E65;
  v16 = (const char *)&unk_A6E65;
  if ( (_DWORD)a1 )
  {
    v15 = (void *)sub_23140(a1, v20, 1024LL, a5, a6, a7, a8, a9, a10, a11, a12);
    v12 = a4;
    v16 = ": ";
  }
  v17 = ": ";
  if ( !*a2 )
    v17 = (const char *)&unk_A6E65;
  if ( !a3 )
    a3 = "error while loading shared libraries";
  v18 = (const char *)off_BEFD8;
  if ( !off_BEFD8 )
    v18 = "<program name unknown>";
  sub_77200(byte_94173, v18, a3, a2, v17, v12, v16, v15);
}
// BEFD8: using guessed type void *off_BEFD8;

//----- (00000000000500B0) ----------------------------------------------------
void __fastcall __noreturn sub_500B0(unsigned int a1, const __m128i *a2, const char *a3, __m128 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  __m128 **v12; // rdi
  __m128 *v13; // rax
  __int64 v14; // rdi
  __int64 v15; // rdx

  v12 = (__m128 **)__readfsqword(0xFFFFFFE0);
  if ( v12 )
  {
    v13 = *v12;
    a4 = (__m128)_mm_loadu_si128(a2);
    v14 = (__int64)(v12 + 2);
    *v13 = a4;
    v15 = a2[1].m128i_i64[0];
    a2 = (const __m128i *)(&dword_0 + 1);
    v13[1].m128_u64[0] = v15;
    **(_DWORD **)(v14 - 8) = a1;
    sub_5CFE0(v14);
  }
  sub_50000(a1, a2->m128i_i64[0], a3, a2->m128i_i64[1], *(double *)a4.m128_u64, a5, a6, a7, a8, a9, a10, a11);
}
// 500F9: variable 'a1' is possibly undefined
// 500FC: variable 'a3' is possibly undefined
// 500FC: variable 'a8' is possibly undefined
// 500FC: variable 'a9' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);

//----- (0000000000050110) ----------------------------------------------------
void __fastcall __noreturn sub_50110(__int64 a1, _BYTE *a2, const char *a3, const char *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  const char *v13; // rdx
  int v14; // ebp
  unsigned __int64 v15; // rbx

  v13 = a4;
  v14 = a1;
  v15 = __readfsqword(0xFFFFFFE0);
  if ( !a4 )
    v13 = "DYNAMIC LINKER BUG!!!";
  if ( v15 )
  {
    sub_78E60(*(const char ***)v15, (__int64)a2, (__int64)v13, a5, a6, a7, a8, a9, a10, a11, a12);
    a1 = v15 + 16;
    a2 = (_BYTE *)(&dword_0 + 1);
    **(_DWORD **)(v15 + 8) = v14;
    sub_5CFE0(v15 + 16);
  }
  sub_50000(a1, a2, a3, (__int64)v13, a5, a6, a7, a8, a9, a10, a11, a12);
}
// 50162: variable 'a3' is possibly undefined
// 50162: variable 'v13' is possibly undefined
// 50162: variable 'a9' is possibly undefined
// 50162: variable 'a10' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);

//----- (0000000000050170) ----------------------------------------------------
__int64 __fastcall sub_50170(__int64 a1, void (__fastcall *a2)(__int64), __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned int v6; // er12
  __int64 v8; // [rsp+0h] [rbp-118h]
  unsigned __int64 v9; // [rsp+8h] [rbp-110h]
  unsigned int v11; // [rsp+2Ch] [rbp-ECh] BYREF
  __int64 v12[2]; // [rsp+30h] [rbp-E8h] BYREF
  char v13[200]; // [rsp+40h] [rbp-D8h] BYREF
  unsigned __int64 v14; // [rsp+108h] [rbp-10h]

  v14 = __readfsqword(0x28u);
  v9 = __readfsqword(0xFFFFFFE0);
  if ( a1 )
  {
    v12[0] = a1;
    v12[1] = (__int64)&v11;
    __writefsqword(0xFFFFFFE0, (unsigned __int64)v12);
    v6 = sub_5CF30((__int64)v13, 0, a3, a4, a5, a6, a1);
    if ( v6 )
    {
      __writefsqword(0xFFFFFFE0, v9);
      v6 = v11;
    }
    else
    {
      a2(a3);
      __writefsqword(0xFFFFFFE0, v9);
      *(_QWORD *)(v8 + 16) = 0LL;
      *(_OWORD *)v8 = 0LL;
    }
  }
  else
  {
    __writefsqword(0xFFFFFFE0, 0LL);
    ((void (__fastcall *)(__int64, void (__fastcall *)(__int64), __int64, __int64, __int64, __int64))a2)(
      a3,
      a2,
      a3,
      a4,
      a5,
      a6);
    __writefsqword(0xFFFFFFE0, v9);
    v6 = 0;
  }
  return v6;
}
// 50210: variable 'v8' is possibly undefined

//----- (0000000000050290) ----------------------------------------------------
__int64 __fastcall sub_50290(_QWORD *a1, _QWORD *a2, bool *a3, void (__fastcall *a4)(__int64), __int64 a5, __int64 a6)
{
  __int64 result; // rax
  bool v8; // zf
  __int64 v9; // [rsp+0h] [rbp-38h] BYREF
  __int64 v10; // [rsp+8h] [rbp-30h]
  __int64 v11; // [rsp+10h] [rbp-28h]
  unsigned __int64 v12; // [rsp+18h] [rbp-20h]

  v12 = __readfsqword(0x28u);
  result = sub_50170((__int64)&v9, a4, a5, (__int64)a4, a5, a6);
  *a1 = v9;
  v8 = v11 == v10;
  *a2 = v10;
  *a3 = v8;
  return result;
}

//----- (0000000000050300) ----------------------------------------------------
void **__fastcall sub_50300(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  _QWORD *v8; // rax
  double v9; // xmm4_8
  double v10; // xmm5_8
  Elf64_Dyn *v11; // rdx
  _QWORD *v12; // r13
  _QWORD *v13; // rdi
  unsigned __int64 i; // rax
  __int64 v15; // rsi
  __int64 *v16; // rax
  __int64 *v17; // rdx
  __int64 v18; // r8
  __int64 v19; // rdi
  unsigned __int64 v20; // rbx
  char *v21; // rcx
  char *v22; // rdx
  __int64 v23; // r9
  __int64 v24; // rdx
  __int64 v25; // rdx
  unsigned __int64 v26; // r8
  _QWORD *v27; // r8
  unsigned __int64 v28; // r11
  unsigned __int64 v29; // r13
  unsigned __int64 v30; // r12
  __int64 v31; // rdx
  __int16 v32; // di
  void (*v33)(void); // rsi
  char v34; // al
  unsigned __int64 v35; // r15
  __int64 v36; // rbp
  unsigned __int64 v37; // r12
  unsigned __int64 v38; // rax
  __int64 v39; // rax
  _QWORD *v40; // rbx
  __int16 v41; // cx
  char v42; // al
  char v43; // dl
  __int64 v44; // rax
  __int64 (__fastcall *v45)(__int64, __int64); // rax
  void **result; // rax
  __int64 v47; // rdx
  unsigned __int64 v48; // r10
  unsigned __int64 v49; // r15
  __int64 v50; // rdx
  __int16 v51; // di
  void (*v52)(void); // rsi
  char v53; // al
  unsigned __int64 v54; // r8
  __int64 v55; // r12
  unsigned __int64 v56; // r15
  unsigned __int64 v57; // rbx
  unsigned __int64 v58; // rax
  __int64 v59; // rax
  _QWORD *v60; // rbp
  __int16 v61; // cx
  char v62; // dl
  __int64 v63; // rax
  _QWORD *v64; // [rsp+10h] [rbp-58h]

  v8 = sub_4F240();
  v11 = &stru_BDC38;
  v8[2] = &stru_BDC38;
  v12 = v8;
  v13 = v8 + 8;
  *v8 = 0LL;
  for ( i = stru_BDC38.d_tag; i; ++v11 )
  {
    while ( i <= 0x22 )
    {
      v13[i] = v11;
LABEL_8:
      i = v11[1].d_tag;
      ++v11;
      if ( !i )
        goto LABEL_9;
    }
    if ( 1879048191 - i > 0xF )
    {
      if ( (unsigned int)(2 * i) > 0xFFFFFFF8 )
      {
        v13[50 - ((2 * (int)i) >> 1)] = v11;
        goto LABEL_8;
      }
      if ( 1879047679 - i > 0xB )
      {
        if ( 1879047935 - i <= 0xA )
          v13[1879048001 - i] = v11;
      }
      else
      {
        v13[1879047733 - i] = v11;
      }
    }
    else
    {
      v13[1879048226 - i] = v11;
    }
    i = v11[1].d_tag;
  }
LABEL_9:
  v15 = v12[28];
  if ( v15 && *(_QWORD *)(v15 + 8) != 7LL )
    sub_CF00(
      (__int64)"info[DT_PLTREL]->d_un.d_val == DT_RELA",
      (__int64)"get-dynamic-info.h",
      0x7Bu,
      "elf_get_dynamic_info",
      a1,
      a2,
      a3,
      a4,
      v9,
      v10,
      a7,
      a8);
  v16 = (__int64 *)v12[15];
  if ( v16 && *(_QWORD *)(v12[17] + 8LL) != 24LL )
    sub_CF00(
      (__int64)"info[DT_RELAENT]->d_un.d_val == sizeof (ElfW(Rela))",
      (__int64)"get-dynamic-info.h",
      0x83u,
      "elf_get_dynamic_info",
      a1,
      a2,
      a3,
      a4,
      v9,
      v10,
      a7,
      a8);
  if ( v12[37] )
    sub_CF00(
      (__int64)"info[DT_RUNPATH] == NULL",
      (__int64)"get-dynamic-info.h",
      0x92u,
      "elf_get_dynamic_info",
      a1,
      a2,
      a3,
      a4,
      v9,
      v10,
      a7,
      a8);
  if ( v12[23] )
    sub_CF00(
      (__int64)"info[DT_RPATH] == NULL",
      (__int64)"get-dynamic-info.h",
      0x93u,
      "elf_get_dynamic_info",
      a1,
      a2,
      a3,
      a4,
      v9,
      v10,
      a7,
      a8);
  if ( v16 )
  {
    v17 = (__int64 *)v16[1];
    v18 = v12[49];
    v19 = *(_QWORD *)(v12[16] + 8LL);
    v20 = (unsigned __int64)v17;
    v16 = v17;
    v21 = (char *)v17 + v19;
    if ( v18 )
      v20 = (unsigned __int64)&v17[3 * *(_QWORD *)(v18 + 8)];
  }
  else
  {
    v20 = 0LL;
    v21 = 0LL;
    v19 = 0LL;
    v17 = 0LL;
  }
  if ( v15 )
  {
    v15 = *(_QWORD *)(v12[10] + 8LL);
    v22 = (char *)v17 + v19 + v15;
    if ( (char *)(v15 + *(_QWORD *)(v12[31] + 8LL)) != v21 )
      v21 = v22;
  }
  v23 = *(_QWORD *)(v12[14] + 8LL);
  if ( v12 )
  {
    if ( v12[72] )
    {
      v26 = v12[58];
      if ( !v26 )
        goto LABEL_64;
LABEL_28:
      if ( (unsigned __int64)v21 <= v20 )
        goto LABEL_53;
      v27 = v12;
      v28 = 0LL;
      v29 = 0LL;
      while ( 1 )
      {
        v30 = *(_QWORD *)(v20 + 8);
        if ( (_DWORD)v30 == 37 )
        {
          v28 = v20;
          if ( !v29 )
            v29 = v20;
        }
        else if ( (unsigned int)v30 == 8LL || (unsigned int)v30 == 38LL )
        {
          **(_QWORD **)v20 = *v27 + *(_QWORD *)(v20 + 16);
        }
        else if ( (_DWORD)v30 )
        {
          v31 = v23 + 24 * HIDWORD(v30);
          if ( v31 )
          {
            v32 = *(_WORD *)(v31 + 6);
            v33 = *(void (**)(void))(v31 + 8);
            v34 = *(_BYTE *)(v31 + 4) & 0xF;
            if ( v32 != -15 )
            {
              v33 = (void (*)(void))((char *)v33 + *v27);
              if ( v34 != 10 || !v32 )
                goto LABEL_37;
LABEL_80:
              v64 = v27;
              v33();
              v27 = v64;
              if ( (unsigned int)v30 > 0x25uLL )
                goto LABEL_81;
LABEL_38:
              __asm { jmp     rax }
            }
            if ( v34 == 10 )
              goto LABEL_80;
          }
LABEL_37:
          if ( (unsigned int)v30 > 0x25uLL )
            goto LABEL_81;
          goto LABEL_38;
        }
        v20 += 24LL;
        if ( (unsigned __int64)v21 <= v20 )
        {
          v35 = v29;
          v12 = v27;
          if ( !v35 || v35 > v28 )
            goto LABEL_53;
          v36 = v23;
          v37 = v28;
          while ( 2 )
          {
            while ( 1 )
            {
              v38 = *(_QWORD *)(v35 + 8);
              if ( (_DWORD)v38 == 37 )
                break;
              v35 += 24LL;
              if ( v35 > v37 )
                goto LABEL_53;
            }
            v39 = v36 + 24 * HIDWORD(v38);
            v40 = *(_QWORD **)v35;
            if ( v39 )
            {
              v41 = *(_WORD *)(v39 + 6);
              v15 = *(_QWORD *)(v39 + 8);
              v42 = *(_BYTE *)(v39 + 4) & 0xF;
              v43 = v42;
              if ( v41 != -15 )
              {
                v44 = *v12;
                if ( v43 == 10 && v41 )
                {
                  v15 += v44;
                  goto LABEL_77;
                }
LABEL_52:
                v45 = (__int64 (__fastcall *)(__int64, __int64))(*(_QWORD *)(v35 + 16) + v44);
                v35 += 24LL;
                *v40 = v45(v19, v15);
                if ( v35 > v37 )
                  goto LABEL_53;
                continue;
              }
              if ( v42 == 10 )
LABEL_77:
                ((void (*)(void))v15)();
            }
            break;
          }
          v44 = *v12;
          goto LABEL_52;
        }
      }
    }
    for ( ; (unsigned __int64)v16 < v20; *(_QWORD *)v15 = v25 )
    {
      v24 = *((unsigned int *)v16 + 2);
      v15 = *v16;
      if ( v24 != 38 && v24 != 8 )
        sub_CF00(
          (__int64)"ELFW(R_TYPE) (reloc->r_info) == R_X86_64_RELATIVE",
          (__int64)"../sysdeps/x86_64/dl-machine.h",
          0x21Du,
          "elf_machine_rela_relative",
          a1,
          a2,
          a3,
          a4,
          v9,
          v10,
          a7,
          a8);
      v25 = v16[2];
      v16 += 3;
    }
  }
  v26 = v12[58];
  if ( v26 )
    goto LABEL_28;
LABEL_64:
  v48 = 0LL;
  if ( (unsigned __int64)v21 > v20 )
  {
    v49 = v26;
    v27 = v12;
    do
    {
      v30 = *(_QWORD *)(v20 + 8);
      if ( (_DWORD)v30 == 37 )
      {
        v48 = v20;
        if ( !v49 )
          v49 = v20;
      }
      else if ( (unsigned int)v30 == 8LL || (unsigned int)v30 == 38LL )
      {
        **(_QWORD **)v20 = *v12 + *(_QWORD *)(v20 + 16);
      }
      else if ( (_DWORD)v30 )
      {
        v50 = v23 + 24 * HIDWORD(v30);
        if ( !v50 )
          goto LABEL_73;
        v51 = *(_WORD *)(v50 + 6);
        v52 = *(void (**)(void))(v50 + 8);
        v53 = *(_BYTE *)(v50 + 4) & 0xF;
        if ( v51 == -15 )
        {
          if ( v53 != 10 )
            goto LABEL_73;
        }
        else
        {
          v52 = (void (*)(void))((char *)v52 + *v12);
          if ( v53 != 10 || !v51 )
            goto LABEL_73;
        }
        v52();
        v27 = v12;
LABEL_73:
        if ( (unsigned int)v30 <= 0x25uLL )
          __asm { jmp     rax }
LABEL_81:
        sub_74830((__int64)v27, v30);
      }
      v20 += 24LL;
    }
    while ( (unsigned __int64)v21 > v20 );
    v54 = v49;
    if ( v49 )
    {
      if ( v49 <= v48 )
      {
        v55 = v23;
        v56 = v48;
        v57 = v54;
        while ( 1 )
        {
          v58 = *(_QWORD *)(v57 + 8);
          if ( (_DWORD)v58 == 37 )
            break;
LABEL_89:
          v57 += 24LL;
          if ( v57 > v56 )
            goto LABEL_53;
        }
        v59 = v55 + 24 * HIDWORD(v58);
        v60 = *(_QWORD **)v57;
        if ( !v59 )
          goto LABEL_102;
        v61 = *(_WORD *)(v59 + 6);
        v15 = *(_QWORD *)(v59 + 8);
        v62 = *(_BYTE *)(v59 + 4) & 0xF;
        if ( v61 == -15 )
        {
          if ( v62 != 10 )
            goto LABEL_102;
        }
        else
        {
          v63 = *v12;
          if ( v62 != 10 || !v61 )
            goto LABEL_94;
          v15 += v63;
        }
        ((void (__fastcall *)(__int64))v15)(v19);
LABEL_102:
        v63 = *v12;
LABEL_94:
        *v60 = ((__int64 (__fastcall *)(__int64, __int64))(*(_QWORD *)(v57 + 16) + v63))(v19, v15);
        goto LABEL_89;
      }
    }
  }
LABEL_53:
  *((_BYTE *)v12 + 796) |= 4u;
  result = sub_4D270(0LL, 0LL);
  v47 = v12[29];
  *((_DWORD *)result + 6) = 0;
  if ( v47 )
    *(_QWORD *)(v47 + 8) = result;
  return result;
}
// 50F1B: variable 'v9' is possibly undefined
// 50F1B: variable 'v10' is possibly undefined
// BDC38: using guessed type Elf64_Dyn stru_BDC38;

//----- (0000000000050FA0) ----------------------------------------------------
unsigned __int64 __fastcall sub_50FA0(char a1)
{
  unsigned __int64 result; // rax

  result = sub_5CE70();
  byte_BF9CA = a1;
  return result;
}
// BF9CA: using guessed type char byte_BF9CA;

//----- (0000000000050FC0) ----------------------------------------------------
void __fastcall sub_50FC0(unsigned int a1, _QWORD *a2, void *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  dword_BF628 = 0;
  if ( word_BF9C8 != word_BF06C )
    sub_5CED0();
  dword_C14E0 = a1;
  qword_C14D8 = (__int64)a2;
  qword_C1270 = a3;
  sub_4E5B0(a4, a5, a6, a7, a8, a9, a10, a11);
  sub_4CF80(a1, a2);
}
// 51001: variable 'a8' is possibly undefined
// 51001: variable 'a9' is possibly undefined
// 5CED0: using guessed type __int64 sub_5CED0(void);
// BF06C: using guessed type __int16 word_BF06C;
// BF628: using guessed type int dword_BF628;
// BF9C8: using guessed type __int16 word_BF9C8;
// C14D8: using guessed type __int64 qword_C14D8;
// C14E0: using guessed type int dword_C14E0;

//----- (0000000000051050) ----------------------------------------------------
__int64 __fastcall sub_51050(__int64 a1, __int64 **a2, char a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  unsigned __int8 *v12; // r13
  unsigned __int8 *v13; // r14
  int v14; // ebx
  bool v15; // zf
  unsigned int v16; // eax
  __int64 v18; // rax
  void *v19; // rsp
  __int64 v20; // rdx
  void *v21; // rsp
  __int64 v22; // r15
  __int64 v23; // r13
  __int64 *v24; // rax
  __int64 v25; // rdx
  __int64 v26; // rcx
  u32 *v27; // r8
  u32 v28; // er9
  __int64 v29; // rdi
  __int64 *v30; // r14
  __int64 *v31; // r14
  __int64 v32; // r13
  unsigned __int64 v33; // r15
  unsigned __int64 v34; // r12
  __int64 v35; // rax
  __int64 v36; // rax
  __int64 v37; // rsi
  int v38; // eax
  unsigned __int64 v39; // r12
  unsigned int v40; // er14
  __int64 *v41; // r13
  __int64 v42; // rdi
  __int64 **v43; // [rsp+0h] [rbp-70h] BYREF
  __int64 *v44; // [rsp+8h] [rbp-68h]
  unsigned int v45; // [rsp+10h] [rbp-60h]
  char v46; // [rsp+17h] [rbp-59h]
  __int64 v47; // [rsp+18h] [rbp-58h]
  __int64 v48; // [rsp+28h] [rbp-48h] BYREF
  __int64 v49[8]; // [rsp+30h] [rbp-40h] BYREF

  v12 = *(unsigned __int8 **)(a1 + 8);
  v13 = *(unsigned __int8 **)a1;
  v43 = a2;
  v49[1] = __readfsqword(0x28u);
  v14 = 2 * (*(_BYTE *)(a1 + 17) != 0);
  v15 = *v12 == 47;
  v46 = *(_BYTE *)(a1 + 16);
  if ( v15 && v12[1] == 47 && !v12[2] )
  {
    v47 = *(_QWORD *)(*(_QWORD *)__readfsqword(0xFFFFFFA0) + 176LL);
    v20 = strlen(v47);
    v21 = alloca(v20 + 11);
    v12 = (unsigned __int8 *)&v43;
    strcpy((char *)sub_91D0(&v43, v47, v20), "//");
  }
  if ( *v13 == 47 && v13[1] == 47 && !v13[2] )
  {
    v47 = *(_QWORD *)(*(_QWORD *)__readfsqword(0xFFFFFFA0) + 176LL);
    v18 = strlen(v47);
    v19 = alloca(v18 + 11);
    v13 = (unsigned __int8 *)&v43;
    strcpy((char *)sub_91D0(&v43, v47, v18), "//");
  }
  v16 = sub_522D0(v12, v13, &v48, v49, a3, a4, a5, a6, a7, a8, a9, a10, a11);
  v44 = 0LL;
  v45 = v16;
  if ( !v16 )
  {
    v22 = v49[0];
    v23 = 48 * v49[0];
    v24 = (__int64 *)sub_21500(48 * v49[0] + 16);
    v29 = v48;
    v44 = v24;
    v30 = v24;
    if ( v24 )
    {
      v24[1] = v48;
      *v24 = v22;
      sub_9190((__int64)(v24 + 2), 0LL, v23);
      if ( !v22 )
        goto LABEL_6;
      v31 = v30 + 7;
      v32 = 0LL;
      v33 = 0LL;
      while ( 1 )
      {
        v15 = v46 == 0;
        *(v31 - 1) = (__int64)v31;
        if ( v15 )
        {
          v34 = v49[0];
          if ( v49[0] - 1 <= v33 )
            goto LABEL_21;
        }
        else
        {
          v38 = sub_9150(*(_QWORD *)(v48 + v32 + 24), "INTERNAL", off_BDB00);
          v34 = v49[0];
          if ( !v38 )
            v14 |= 8u;
          if ( v49[0] - 1 <= v33 )
          {
LABEL_21:
            LODWORD(v44[6 * v33 + 4]) = v14 | 1;
            goto LABEL_6;
          }
        }
        v35 = v48;
        *((_DWORD *)v31 - 6) = v14;
        v47 = 8160 * *(_DWORD *)(v35 + v32 + 84);
        v36 = sub_21500(v47);
        v37 = v47;
        *(v31 - 5) = v36;
        if ( !v36 )
          break;
        ++v33;
        v31 += 6;
        v32 += 104LL;
        *(v31 - 10) = v37 + v36;
        if ( v34 <= v33 )
          goto LABEL_6;
      }
      v39 = v33 - 1;
      v40 = __readfsdword(0xFFFFFFC0);
      if ( v33 )
      {
        v41 = &v44[6 * v33 - 4];
        do
        {
          v42 = *v41;
          --v39;
          v41 -= 6;
          sub_21B70(v42);
        }
        while ( v39 != -1LL );
      }
      sub_21B70(v44);
      v29 = v48;
    }
    else
    {
      v40 = __readfsdword(0xFFFFFFC0);
    }
    sub_525E0(v29, v49[0], v25, v26, v27, v28);
    __writefsdword(0xFFFFFFC0, v40);
    v45 = 3;
    v44 = 0LL;
  }
LABEL_6:
  *v43 = v44;
  return v45;
}
// 510C4: variable 'a8' is possibly undefined
// 510C4: variable 'a9' is possibly undefined
// 51336: variable 'v25' is possibly undefined
// 51336: variable 'v26' is possibly undefined
// 51336: variable 'v27' is possibly undefined
// 51336: variable 'v28' is possibly undefined
// 9150: using guessed type __int64 __fastcall sub_9150(_QWORD, _QWORD, _QWORD);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// BDB00: using guessed type void **off_BDB00[6];

//----- (0000000000051370) ----------------------------------------------------
__int64 __fastcall sub_51370(_QWORD *a1, __int64 *a2, unsigned __int64 a3, __int64 *a4, __int64 a5, _QWORD *a6)
{
  __int64 v8; // rdx
  _QWORD *v9; // rax
  _QWORD *v10; // rax
  __int64 (__fastcall *v11)(_QWORD, _QWORD *, __int64 *, unsigned __int64, _QWORD, _QWORD *, _QWORD, _QWORD); // rbx
  __int64 v12; // r13
  __int64 result; // rax
  _DWORD *v14; // rcx
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // [rsp+10h] [rbp-48h]

  if ( a1 == (_QWORD *)-1LL )
    return 8LL;
  v16 = *a1 - 1LL;
  if ( !a6 )
    sub_CF00("irreversible != NULL", "gconv.c", 43LL, "__gconv");
  *a6 = 0LL;
  v8 = 0LL;
  if ( a4 )
    v8 = *a4;
  v9 = &a1[6 * v16];
  v9[2] = v8;
  v9[3] = a5;
  v10 = (_QWORD *)a1[1];
  v11 = (__int64 (__fastcall *)(_QWORD, _QWORD *, __int64 *, unsigned __int64, _QWORD, _QWORD *, _QWORD, _QWORD))v10[5];
  if ( *v10 )
    v11 = (__int64 (__fastcall *)(_QWORD, _QWORD *, __int64 *, unsigned __int64, _QWORD, _QWORD *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v11, 17));
  if ( a2 )
  {
    v12 = *a2;
    if ( *a2 )
    {
      if ( !a4 || !*a4 )
        sub_CF00("outbuf != NULL && *outbuf != NULL", "gconv.c", 73LL, "__gconv");
      while ( 1 )
      {
        sub_4F2B0((__int64)v11);
        result = v11(a1[1], a1 + 2, a2, a3, 0LL, a6, 0LL, 0LL);
        if ( (_DWORD)result != 4 || *a2 == v12 || a3 < *a2 + *(int *)(a1[1] + 72LL) )
          break;
        v12 = *a2;
      }
LABEL_16:
      if ( *a4 )
        *a4 = a1[6 * v16 + 2];
      return result;
    }
  }
  sub_4F2B0((__int64)v11);
  result = v11(a1[1], a1 + 2, 0LL, 0LL, 0LL, a6, (unsigned int)(a1[6 * v16 + 2] == 0LL) + 1, 0LL);
  if ( !(_DWORD)result )
  {
    v14 = (_DWORD *)a1 + 9;
    v15 = 0LL;
    do
    {
      *v14 = 0;
      ++v15;
      v14 += 12;
    }
    while ( v16 >= v15 );
  }
  if ( a4 )
    goto LABEL_16;
  return result;
}
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000051590) ----------------------------------------------------
__int64 __fastcall sub_51590(__int64 *a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 *v15; // rbx
  __int64 v16; // r12
  __int64 v17; // r13
  __int64 v18; // rdi
  __int64 v19; // rdx
  __int64 v20; // rcx
  u32 *v21; // r8
  u32 v22; // er9

  v15 = a1 + 2;
  v16 = a1[1];
  v17 = *a1;
  while ( (v15[2] & 1) == 0 )
  {
    v18 = *v15;
    v15 += 6;
    if ( v18 )
    {
      sub_21B70(v18, a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);
      if ( (*(_BYTE *)(v15 - 4) & 1) != 0 )
        break;
    }
  }
  sub_21B70((__int64)a1, a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);
  return sub_525E0(v16, v17, v19, v20, v21, v22);
}
// 515C2: variable 'a11' is possibly undefined
// 515C2: variable 'a12' is possibly undefined
// 515C2: variable 'a3' is possibly undefined
// 515C2: variable 'a4' is possibly undefined
// 515C2: variable 'a5' is possibly undefined
// 515C2: variable 'a6' is possibly undefined
// 515E5: variable 'v19' is possibly undefined
// 515E5: variable 'v20' is possibly undefined
// 515E5: variable 'v21' is possibly undefined
// 515E5: variable 'v22' is possibly undefined

//----- (00000000000515F0) ----------------------------------------------------
__int64 __fastcall sub_515F0(_QWORD *a1, _QWORD *a2)
{
  return sub_91B0(*a1, *a2);
}
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);

//----- (0000000000051600) ----------------------------------------------------
__int64 __fastcall sub_51600(_QWORD *a1, _QWORD *a2)
{
  __int64 result; // rax

  result = sub_91B0(*a1, *a2);
  if ( !(_DWORD)result )
    result = sub_91B0(a1[1], a2[1]);
  return result;
}
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);

//----- (0000000000051660) ----------------------------------------------------
__int64 __fastcall sub_51660(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 v10; // rdi
  void (__fastcall *v12)(__int64); // rbp
  __int64 result; // rax

  v10 = *(_QWORD *)a1;
  if ( v10 )
  {
    if ( (*(_DWORD *)(a1 + 16))-- == 1 )
    {
      v12 = (void (__fastcall *)(__int64))(__readfsqword(0x30u) ^ __ROR8__(*(_QWORD *)(a1 + 64), 17));
      if ( v12 )
      {
        sub_4F2B0((__int64)v12);
        v12(a1);
        v10 = *(_QWORD *)a1;
      }
      result = sub_5B0B0(v10);
      *(_QWORD *)a1 = 0LL;
    }
  }
  else if ( *(_QWORD *)(a1 + 64) )
  {
    sub_CF00(
      (__int64)"step->__end_fct == NULL",
      (__int64)"gconv_db.c",
      0xE2u,
      "__gconv_release_step",
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      a9);
  }
  return result;
}

//----- (00000000000516E0) ----------------------------------------------------
__int64 __fastcall sub_516E0(void *a1, __int64 a2, void *a3, void *a4, __int64 *a5, unsigned __int64 *a6)
{
  __int64 *v7; // rax
  __int64 v8; // rax
  unsigned __int64 v9; // r15
  __int64 v10; // r14
  unsigned __int64 *v11; // rax
  unsigned __int64 v12; // r13
  __int64 i; // rbx
  int v14; // eax
  void *v15; // rdi
  _QWORD *v16; // rax
  __int64 v17; // rdx
  __int64 v18; // r12
  __int64 v19; // rax
  __int64 v20; // r12
  unsigned int v21; // er8
  __int64 v22; // rax
  int v23; // er12
  __int64 j; // r13
  __int64 v25; // rbx
  __int64 v26; // r15
  int v27; // eax
  _BYTE *v28; // r14
  int v29; // er12
  __int64 v30; // r15
  int v31; // eax
  __int64 v32; // r15
  __int64 v33; // rax
  __int64 v34; // rdi
  __int64 v35; // rax
  __int64 v36; // rdx
  int v37; // esi
  int v38; // ecx
  __int64 k; // rax
  __int64 v40; // rax
  int v41; // edi
  int v42; // er8
  __int64 v43; // rsi
  __int64 v44; // rcx
  int v45; // edx
  int v46; // ecx
  int v47; // eax
  __int64 v48; // rax
  __int64 v49; // r13
  __int64 v50; // rax
  int v51; // edx
  __int64 v52; // rax
  unsigned __int64 v53; // r15
  unsigned __int64 v54; // r12
  __int64 v55; // r14
  unsigned __int64 v56; // rbx
  __int64 v57; // r15
  unsigned __int64 v58; // r13
  __int64 v59; // r12
  __int64 v60; // rax
  _BYTE *v61; // rdi
  _QWORD *v62; // rax
  _QWORD *v63; // rsi
  __int64 v64; // rax
  __int64 v65; // rsi
  __int64 v66; // rax
  int v67; // eax
  void *v68; // rax
  unsigned __int64 v69; // rbx
  void *v70; // rax
  int v71; // er8
  unsigned __int64 *v72; // r12
  int v73; // er15
  __int64 v74; // r13
  __int64 v75; // rdi
  __int64 v76; // rdi
  int v77; // er8
  __int64 v78; // rbx
  __int64 v79; // rax
  size_t v80; // r12
  _QWORD *v81; // rax
  _QWORD *v82; // r13
  void *v83; // rsi
  void *v84; // rax
  void *v85; // rax
  __int64 v86; // rax
  __int64 v88; // rax
  __int64 v89; // rdi
  __int64 v90; // rdi
  unsigned __int64 v91; // r13
  __int64 v92; // rbx
  __int64 v93; // rdi
  _BYTE *v94; // [rsp-Eh] [rbp-180h] BYREF
  __int64 v95; // [rsp-6h] [rbp-178h]
  int v96; // [rsp+2h] [rbp-170h]
  int v97; // [rsp+6h] [rbp-16Ch]
  __int64 v98; // [rsp+Ah] [rbp-168h]
  __int64 v99; // [rsp+12h] [rbp-160h]
  _QWORD *v100; // [rsp+1Ah] [rbp-158h] BYREF
  _QWORD v101[5]; // [rsp+32h] [rbp-140h] BYREF
  __int64 v102; // [rsp+5Ah] [rbp-118h] BYREF
  void *v103; // [rsp+72h] [rbp-100h] BYREF
  __int64 v104; // [rsp+7Ah] [rbp-F8h]
  __int64 v105; // [rsp+82h] [rbp-F0h]
  __int64 v106; // [rsp+8Ah] [rbp-E8h]
  __int64 v107; // [rsp+92h] [rbp-E0h]
  _QWORD *v108; // [rsp+9Ah] [rbp-D8h] BYREF
  __int64 *v109; // [rsp+B2h] [rbp-C0h]
  __int64 *v110; // [rsp+BAh] [rbp-B8h]
  void **v111; // [rsp+C2h] [rbp-B0h]
  void *v112; // [rsp+CAh] [rbp-A8h]
  void *v113; // [rsp+D2h] [rbp-A0h]
  __int64 v114; // [rsp+DAh] [rbp-98h]
  _QWORD *v115; // [rsp+E2h] [rbp-90h]
  void *v116; // [rsp+EAh] [rbp-88h]
  void *v117; // [rsp+F2h] [rbp-80h]
  unsigned __int64 *v118; // [rsp+FAh] [rbp-78h]
  __int64 (__fastcall *v119)(__int64); // [rsp+102h] [rbp-70h]
  void *v120; // [rsp+10Ah] [rbp-68h]
  void *v121; // [rsp+112h] [rbp-60h] BYREF
  void *v122; // [rsp+11Ah] [rbp-58h]
  __int64 v123; // [rsp+122h] [rbp-50h]
  __int64 v124; // [rsp+12Ah] [rbp-48h]
  unsigned __int64 v125; // [rsp+13Ah] [rbp-38h]

  v116 = a1;
  v114 = a2;
  v112 = a4;
  v109 = a5;
  v118 = a6;
  v125 = __readfsqword(0x28u);
  if ( a2 )
    a1 = (void *)a2;
  v113 = a1;
  if ( a4 )
  {
    v123 = 0LL;
    v124 = 0LL;
    v121 = v112;
    v122 = v113;
    v7 = sub_4C220((__int64)&v121, &qword_C1500, (__int64 (__fastcall *)(__int64, _QWORD))sub_51600);
    if ( v7 )
    {
LABEL_5:
      v8 = *v7;
      v9 = *(_QWORD *)(v8 + 24);
      v10 = *(_QWORD *)(v8 + 16);
      v11 = v118;
      *v109 = v10;
      v12 = v9 - 1;
      *v11 = v9;
      if ( !v9 )
        return 0;
      for ( i = v10 + 104 * v9 - 104; ; i -= 104LL )
      {
        v14 = *(_DWORD *)(i + 16);
        *(_DWORD *)(i + 16) = v14 + 1;
        if ( !v14 )
        {
          v15 = *(void **)(i + 8);
          if ( v15 )
          {
            v16 = (_QWORD *)sub_5AEB0(v15);
            *(_QWORD *)i = v16;
            if ( !v16 )
            {
              v91 = v12 + 1;
              --*(_DWORD *)(i + 16);
              if ( v9 > v91 )
              {
                v92 = v10 + 104 * v91;
                do
                {
                  v93 = v92;
                  ++v91;
                  v92 += 104LL;
                  sub_51660(v93);
                }
                while ( v9 > v91 );
              }
              return 1;
            }
            v17 = v16[3];
            v18 = v16[4];
            v19 = v16[5];
            *(_QWORD *)(i + 48) = 0LL;
            *(_QWORD *)(i + 56) = v18;
            *(_QWORD *)(i + 40) = v17;
            *(_QWORD *)(i + 64) = v19;
            v20 = __readfsqword(0x30u) ^ __ROR8__(v18, 17);
            if ( v20 )
            {
              sub_4F2B0(v20);
              ((void (__fastcall *)(__int64))v20)(i);
              v20 = *(_QWORD *)(i + 48);
            }
            *(_QWORD *)(i + 48) = __ROL8__(__readfsqword(0x30u) ^ v20, 17);
          }
        }
        if ( --v12 == -1LL )
          return 0;
      }
    }
    v111 = &v103;
    v103 = v112;
    v22 = strlen((__int64)v112);
    v105 = 0LL;
    v104 = v22;
    v106 = 0LL;
    v107 = 0LL;
    v108 = 0LL;
    v101[0] = a3;
    v101[2] = 0LL;
    v101[1] = strlen((__int64)a3);
    v101[3] = 0LL;
    v101[4] = 0LL;
    v102 = 0LL;
    v108 = v101;
    v110 = &v102;
  }
  else
  {
    v121 = a3;
    v123 = 0LL;
    v122 = v113;
    v124 = 0LL;
    v7 = sub_4C220((__int64)&v121, &qword_C1500, (__int64 (__fastcall *)(__int64, _QWORD))sub_51600);
    if ( v7 )
      goto LABEL_5;
    v103 = a3;
    v111 = &v103;
    v88 = strlen((__int64)a3);
    v105 = 0LL;
    v104 = v88;
    v106 = 0LL;
    v107 = 0LL;
    v108 = 0LL;
    v110 = (__int64 *)&v108;
    v112 = a3;
  }
  v23 = 0;
  LODWORD(v117) = 0x7FFFFFFF;
  v115 = 0LL;
  LODWORD(v119) = 0x7FFFFFFF;
  for ( j = (__int64)v111; ; v23 = *(_DWORD *)(j + 20) )
  {
    if ( v23 <= (int)v119 && (v23 != (_DWORD)v119 || *(_DWORD *)(j + 16) < (int)v117) )
    {
      v25 = qword_C14F0;
      if ( qword_C14F0 )
      {
        v26 = *(_QWORD *)j;
        while ( 1 )
        {
          v27 = sub_91B0(v26, *(_QWORD *)v25);
          if ( !v27 )
            break;
          if ( v27 >= 0 )
            v25 = *(_QWORD *)(v25 + 48);
          else
            v25 = *(_QWORD *)(v25 + 32);
          if ( !v25 )
            goto LABEL_18;
        }
        while ( 1 )
        {
          v28 = *(_BYTE **)(v25 + 8);
          if ( *v28 == 45 && !v28[1] )
            v28 = v113;
          v29 = *(_DWORD *)(v25 + 16) + v23;
          LODWORD(v120) = *(_DWORD *)(v25 + 20) + *(_DWORD *)(j + 16);
          if ( (unsigned int)sub_91B0(v28, v116) && (!v114 || (unsigned int)sub_91B0(v28, v114)) )
          {
            if ( (int)v119 > v29 || (_DWORD)v119 == v29 && (int)v117 > (int)v120 )
            {
              v32 = (__int64)v111;
              while ( (unsigned int)sub_91B0(v28, *(_QWORD *)v32) )
              {
                v32 = *(_QWORD *)(v32 + 40);
                if ( !v32 )
                {
                  v94 = v28;
                  v33 = strlen((__int64)v28);
                  v97 = v29;
                  v95 = v33;
                  v98 = v25;
                  v96 = (int)v120;
                  v99 = j;
                  v100 = 0LL;
                  *v110 = (__int64)&v94;
                  v110 = (__int64 *)&v100;
                  goto LABEL_34;
                }
              }
              if ( *(_DWORD *)(v32 + 20) > v29 || *(_DWORD *)(v32 + 20) == v29 && *(_DWORD *)(v32 + 16) > (int)v120 )
              {
                *(_QWORD *)(v32 + 24) = v25;
                v34 = (__int64)v111;
                *(_QWORD *)(v32 + 32) = j;
                do
                {
                  while ( 1 )
                  {
                    v35 = *(_QWORD *)(v34 + 24);
                    if ( v35 )
                      break;
                    v34 = *(_QWORD *)(v34 + 40);
                    if ( !v34 )
                      goto LABEL_65;
                  }
                  v36 = *(_QWORD *)(v34 + 32);
                  v37 = *(_DWORD *)(v35 + 16);
                  v38 = *(_DWORD *)(v35 + 20);
                  for ( k = *(_QWORD *)(v36 + 24); k; k = *(_QWORD *)(v36 + 24) )
                  {
                    v36 = *(_QWORD *)(v36 + 32);
                    v37 += *(_DWORD *)(k + 16);
                    v38 += *(_DWORD *)(k + 20);
                  }
                  *(_DWORD *)(v34 + 20) = v37;
                  *(_DWORD *)(v34 + 16) = v38;
                  v34 = *(_QWORD *)(v34 + 40);
                }
                while ( v34 );
LABEL_65:
                v40 = (__int64)v115;
                if ( v115 )
                {
                  v41 = (int)v119;
                  v42 = (int)v117;
                  do
                  {
                    while ( 1 )
                    {
                      v43 = *(_QWORD *)(v40 + 24);
                      v44 = *(_QWORD *)(v40 + 32);
                      v45 = *(_DWORD *)(v43 + 16) + *(_DWORD *)(v44 + 20);
                      v46 = *(_DWORD *)(v43 + 20) + *(_DWORD *)(v44 + 16);
                      *(_DWORD *)(v40 + 20) = v45;
                      *(_DWORD *)(v40 + 16) = v46;
                      if ( v45 >= v41 )
                        break;
                      v40 = *(_QWORD *)(v40 + 40);
                      v42 = v46;
                      v41 = v45;
                      if ( !v40 )
                        goto LABEL_73;
                    }
                    if ( v46 < v42 && v45 == v41 )
                      v42 = v46;
                    v40 = *(_QWORD *)(v40 + 40);
                  }
                  while ( v40 );
LABEL_73:
                  LODWORD(v119) = v41;
                  LODWORD(v117) = v42;
                }
              }
            }
          }
          else
          {
            if ( v115 )
            {
              v30 = (__int64)v115;
              while ( (unsigned int)sub_91B0(v28, *(_QWORD *)v30) )
              {
                v30 = *(_QWORD *)(v30 + 40);
                if ( !v30 )
                  goto LABEL_76;
              }
              if ( *(_DWORD *)(v30 + 20) > v29 || *(_DWORD *)(v30 + 20) == v29 && *(_DWORD *)(v30 + 16) > (int)v120 )
              {
                v47 = (int)v120;
                *(_QWORD *)(v30 + 24) = v25;
                *(_QWORD *)(v30 + 32) = j;
                *(_DWORD *)(v30 + 20) = v29;
                *(_DWORD *)(v30 + 16) = v47;
              }
            }
            else
            {
LABEL_76:
              v94 = v28;
              v48 = strlen((__int64)v28);
              v97 = v29;
              v95 = v48;
              v98 = v25;
              v96 = (int)v120;
              v99 = j;
              v100 = v115;
              v115 = &v94;
            }
            if ( (int)v119 > v29 )
            {
              LODWORD(v119) = v29;
              LODWORD(v117) = (_DWORD)v120;
            }
            else if ( (_DWORD)v119 == v29 )
            {
              v31 = (int)v120;
              if ( (int)v117 <= (int)v120 )
                v31 = (int)v117;
              LODWORD(v117) = v31;
            }
          }
LABEL_34:
          v25 = *(_QWORD *)(v25 + 40);
          if ( !v25 )
            break;
          v23 = *(_DWORD *)(j + 20);
        }
      }
    }
LABEL_18:
    j = *(_QWORD *)(j + 40);
    if ( !j )
      break;
  }
  v49 = (__int64)v115;
  if ( !v115 )
  {
    v55 = 0LL;
    v53 = 0LL;
    v77 = 1;
    *v109 = 0LL;
    *v118 = 0LL;
    goto LABEL_114;
  }
  v50 = v115[5];
  if ( v50 )
  {
    v51 = *((_DWORD *)v115 + 5);
    if ( *(_DWORD *)(v50 + 20) < v51 )
    {
      v49 = v115[5];
      v52 = *(_QWORD *)(v50 + 32);
      if ( v52 )
        goto LABEL_84;
LABEL_124:
      v55 = sub_21500(0LL);
      if ( v55 )
      {
        v53 = 0LL;
        *v118 = 0LL;
        goto LABEL_113;
      }
LABEL_125:
      v55 = 0LL;
      v53 = 0LL;
      v77 = 3;
      *v118 = 0LL;
      *v109 = 0LL;
      goto LABEL_114;
    }
    if ( *(_DWORD *)(v50 + 20) == v51 && *(_DWORD *)(v50 + 16) < *((_DWORD *)v115 + 4) )
      v49 = v115[5];
  }
  v52 = *(_QWORD *)(v49 + 32);
  if ( !v52 )
    goto LABEL_124;
LABEL_84:
  v53 = 0LL;
  do
  {
    v52 = *(_QWORD *)(v52 + 32);
    v54 = v53++;
  }
  while ( v52 );
  v55 = sub_21500(104 * v53);
  if ( !v55 )
    goto LABEL_125;
  *v118 = v53;
  if ( !v53 )
  {
LABEL_113:
    v77 = 0;
    *v109 = v55;
    goto LABEL_114;
  }
  v117 = 0LL;
  v120 = 0LL;
  v56 = v53;
  v57 = v49;
  v58 = v54;
  v59 = v55 + 104 * v54;
  while ( 1 )
  {
    if ( v58 )
    {
      *(_QWORD *)(v59 + 24) = **(_QWORD **)(v57 + 32);
    }
    else
    {
      v68 = sub_23100(v112);
      v120 = v68;
      *(_QWORD *)(v55 + 24) = v68;
      if ( !v68 )
      {
        v69 = 1LL;
        goto LABEL_106;
      }
    }
    if ( *v118 != v56 )
    {
      *(_QWORD *)(v59 + 32) = *(_QWORD *)(v55 + 104 * v56 + 24);
      goto LABEL_96;
    }
    v70 = sub_23100(*(void **)v57);
    v117 = v70;
    *(_QWORD *)(v59 + 32) = v70;
    if ( !v70 )
      break;
LABEL_96:
    *(_DWORD *)(v59 + 16) = 1;
    v60 = *(_QWORD *)(v57 + 24);
    *(_QWORD *)(v59 + 96) = 0LL;
    v61 = *(_BYTE **)(v60 + 24);
    if ( *v61 == 47 )
    {
      v62 = (_QWORD *)sub_5AEB0(v61);
      v63 = v62;
      if ( !v62 )
        break;
      *(_QWORD *)v59 = v62;
      *(_QWORD *)(v59 + 8) = *v62;
      *(_QWORD *)(v59 + 40) = v62[3];
      v64 = v62[4];
      v65 = v63[5];
      *(_QWORD *)(v59 + 48) = 0LL;
      *(_QWORD *)(v59 + 56) = v64;
      *(_QWORD *)(v59 + 64) = v65;
      v66 = __readfsqword(0x30u) ^ __ROR8__(v64, 17);
      if ( v66 )
      {
        v119 = (__int64 (__fastcall *)(__int64))v66;
        sub_4F2B0(v66);
        v67 = v119(v59);
        if ( v67 )
        {
          v71 = v67;
          v69 = v56 - 1;
          *(_QWORD *)(v59 + 64) = __ROL8__(__readfsqword(0x30u), 17);
          if ( *v118 <= v69 )
          {
            v89 = v55;
            LODWORD(v119) = v67;
            v55 = 0LL;
            v53 = 0LL;
            sub_21B70(v89);
            sub_21B70(v120);
            sub_21B70(v117);
            v77 = (int)v119;
            *v118 = 0LL;
            *v109 = 0LL;
            goto LABEL_114;
          }
          goto LABEL_107;
        }
        v66 = *(_QWORD *)(v59 + 48);
      }
      *(_QWORD *)(v59 + 48) = __ROL8__(__readfsqword(0x30u) ^ v66, 17);
    }
    else
    {
      sub_534E0((__int64)v61, v59);
    }
    v57 = *(_QWORD *)(v57 + 32);
    v59 -= 104LL;
    v56 = v58;
    if ( !v58 )
    {
      v53 = *v118;
      goto LABEL_113;
    }
    --v58;
  }
  v69 = v58 + 1;
LABEL_106:
  v71 = 0;
  if ( *v118 <= v69 )
  {
    v90 = v55;
    v53 = 0LL;
    v55 = 0LL;
    sub_21B70(v90);
    sub_21B70(v120);
    sub_21B70(v117);
    v77 = 1;
    *v118 = 0LL;
    *v109 = 0LL;
    goto LABEL_114;
  }
LABEL_107:
  v72 = v118;
  v73 = v71;
  v74 = v55 + 104 * v69;
  do
  {
    v75 = v74;
    ++v69;
    v74 += 104LL;
    sub_51660(v75);
  }
  while ( v69 < *v72 );
  v76 = v55;
  LODWORD(v119) = v73;
  v55 = 0LL;
  v53 = 0LL;
  sub_21B70(v76);
  sub_21B70(v120);
  sub_21B70(v117);
  v77 = (int)v119;
  *v118 = 0LL;
  *v109 = 0LL;
  if ( !v77 )
    v77 = 1;
LABEL_114:
  LODWORD(v120) = v77;
  v78 = strlen((__int64)v112) + 1;
  v79 = strlen((__int64)v113);
  v80 = v79 + 1;
  v81 = (_QWORD *)sub_21500(v78 + v79 + 33);
  v21 = (unsigned int)v120;
  v82 = v81;
  if ( v81 )
  {
    v83 = v112;
    *v81 = v81 + 4;
    v84 = (void *)sub_91D0(v81 + 4, v83, v78);
    v85 = memcpy(v84, v113, v80);
    v82[2] = v55;
    v82[1] = v85;
    v82[3] = v53;
    v86 = sub_4C080((__int64)v82, &qword_C1500, (__int64 (__fastcall *)(__int64, _QWORD))sub_51600);
    v21 = (unsigned int)v120;
    if ( !v86 )
    {
      sub_21B70(v82);
      v21 = (unsigned int)v120;
    }
  }
  return v21;
}
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// C14F0: using guessed type __int64 qword_C14F0;
// C1500: using guessed type __int64 qword_C1500;

//----- (00000000000521F0) ----------------------------------------------------
__int64 __fastcall sub_521F0(unsigned __int8 *a1, unsigned __int8 *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  unsigned __int8 *v10; // rbx
  unsigned __int8 *v12; // r12
  _QWORD *v13; // rax
  _QWORD *v14; // rax
  unsigned int v15; // [rsp+Ch] [rbp-4Ch] BYREF
  __int64 v16[9]; // [rsp+10h] [rbp-48h] BYREF

  v10 = a1;
  v16[3] = __readfsqword(0x28u);
  sub_53490(a3, a4, a5, a6, a7, a8, a9, a10);
  if ( !(unsigned int)sub_5A880(a1, a2, &v15) )
    return v15;
  v16[0] = (__int64)a2;
  v12 = a2;
  v13 = sub_4C220((__int64)v16, &qword_C14F8, (__int64 (__fastcall *)(__int64, _QWORD))sub_515F0);
  if ( v13 )
  {
    v12 = *(unsigned __int8 **)(*v13 + 8LL);
    if ( !v12 )
      v12 = a2;
  }
  v16[0] = (__int64)a1;
  v14 = sub_4C220((__int64)v16, &qword_C14F8, (__int64 (__fastcall *)(__int64, _QWORD))sub_515F0);
  if ( v14 )
  {
    a1 = *(unsigned __int8 **)(*v14 + 8LL);
    if ( !a1 )
      a1 = v10;
  }
  return sub_91B0(a1, v12);
}
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// C14F8: using guessed type __int64 qword_C14F8;

//----- (00000000000522D0) ----------------------------------------------------
__int64 __fastcall sub_522D0(unsigned __int8 *a1, unsigned __int8 *a2, __int64 *a3, __int64 *a4, char a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  __int64 v16; // rcx
  u32 *v17; // r8
  u32 v18; // er9
  u32 *v20; // r8
  u32 v21; // er9
  unsigned int v22; // er12
  _QWORD *v24; // rax
  _QWORD *v25; // rcx
  _QWORD *v26; // rax
  void *v27; // rcx
  __int64 v28; // r12
  u32 *v29; // r8
  u32 v30; // er9
  signed __int64 v31; // rax
  int v32; // eax
  int v33; // eax
  signed __int64 v34; // rax
  void *v35; // [rsp+8h] [rbp-60h]
  void *v36; // [rsp+8h] [rbp-60h]
  __int64 v37[11]; // [rsp+10h] [rbp-58h] BYREF

  v37[3] = __readfsqword(0x28u);
  sub_53490(a6, a7, a8, a9, a10, a11, a12, a13);
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C14E8, 1, 0) )
      sub_1C7D0((volatile __int32 *)&dword_C14E8, (__int64)a2, 1LL, v16, v17, v18);
  }
  else
  {
    _EDX = 1;
    __asm { cmpxchg cs:dword_C14E8, edx }
  }
  v22 = sub_5A920(a1, a2, a3, a4, a5);
  if ( v22 != 2 )
  {
    if ( !__readfsdword(0x18u) )
    {
      --dword_C14E8;
      return v22;
    }
    if ( _InterlockedExchange((volatile __int32 *)&dword_C14E8, 0) <= 1 )
      return v22;
LABEL_20:
    v31 = sys_futex(&dword_C14E8, 129, 1u, 0LL, v20, v21);
    return v22;
  }
  if ( !qword_C14F0 )
  {
    if ( !__readfsdword(0x18u) )
    {
      --dword_C14E8;
      return 1;
    }
    v22 = 1;
    if ( _InterlockedExchange((volatile __int32 *)&dword_C14E8, 0) <= 1 )
      return v22;
    goto LABEL_20;
  }
  v37[0] = (__int64)a2;
  v24 = sub_4C220((__int64)v37, &qword_C14F8, (__int64 (__fastcall *)(__int64, _QWORD))sub_515F0);
  v25 = v24;
  if ( v24 )
    v25 = *(_QWORD **)(*v24 + 8LL);
  v35 = v25;
  v37[0] = (__int64)a1;
  v26 = sub_4C220((__int64)v37, &qword_C14F8, (__int64 (__fastcall *)(__int64, _QWORD))sub_515F0);
  v27 = v35;
  v28 = (__int64)v26;
  if ( v26 )
    v28 = *(_QWORD *)(*v26 + 8LL);
  if ( (a5 & 1) != 0 )
  {
    if ( !(unsigned int)sub_91B0(a1, a2)
      || (v27 = v35, v28) && (v32 = sub_91B0(v28, a2), v27 = v35, !v32)
      || v27
      && ((v36 = v27, !(unsigned int)sub_91B0(a1, v27))
       || (v27 = v36, v28) && (v33 = sub_91B0(v28, v36), v27 = v36, !v33)) )
    {
      if ( !__readfsdword(0x18u) )
      {
        --dword_C14E8;
        return (unsigned int)-1;
      }
      v22 = -1;
      if ( _InterlockedExchange((volatile __int32 *)&dword_C14E8, 0) <= 1 )
        return v22;
      goto LABEL_20;
    }
  }
  v22 = sub_516E0(a1, v28, a2, v27, a3, (unsigned __int64 *)a4);
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedExchange((volatile __int32 *)&dword_C14E8, 0) > 1 )
      v34 = sys_futex(&dword_C14E8, 129, 1u, 0LL, v29, v30);
  }
  else
  {
    --dword_C14E8;
  }
  if ( !v22 )
    v22 = *a3 == 0;
  return v22;
}
// 5249A: variable 'v20' is possibly undefined
// 5249A: variable 'v21' is possibly undefined
// 524C4: variable 'v16' is possibly undefined
// 524C4: variable 'v17' is possibly undefined
// 524C4: variable 'v18' is possibly undefined
// 52592: variable 'v29' is possibly undefined
// 52592: variable 'v30' is possibly undefined
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// C14F0: using guessed type __int64 qword_C14F0;
// C14F8: using guessed type __int64 qword_C14F8;

//----- (00000000000525E0) ----------------------------------------------------
__int64 __fastcall sub_525E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 v8; // rbp
  __int64 v9; // rbx
  void (__fastcall *v11)(__int64); // r14
  __int64 v12; // rdi
  u32 *v13; // r8
  u32 v14; // er9
  signed __int64 v16; // rax

  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C14E8, 1, 0) )
      sub_1C7D0((volatile __int32 *)&dword_C14E8, a2, 1LL, a4, a5, a6);
  }
  else
  {
    _EDX = 1;
    __asm { cmpxchg cs:dword_C14E8, edx }
  }
  v8 = a2 - 1;
  if ( a2 )
  {
    v9 = a1 + 104 * a2 - 104;
    do
    {
      v12 = *(_QWORD *)v9;
      if ( *(_QWORD *)v9 )
      {
        if ( (*(_DWORD *)(v9 + 16))-- == 1 )
        {
          v11 = (void (__fastcall *)(__int64))(__readfsqword(0x30u) ^ __ROR8__(*(_QWORD *)(v9 + 64), 17));
          if ( v11 )
          {
            sub_4F2B0((__int64)v11);
            v11(v9);
            v12 = *(_QWORD *)v9;
          }
          sub_5B0B0(v12);
          *(_QWORD *)v9 = 0LL;
        }
      }
      else if ( *(_QWORD *)(v9 + 64) )
      {
        sub_CF00("step->__end_fct == NULL", "gconv_db.c", 226LL, "__gconv_release_step");
      }
      --v8;
      v9 -= 104LL;
    }
    while ( v8 != -1 );
  }
  sub_5AE00(a1);
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedExchange((volatile __int32 *)&dword_C14E8, 0) > 1 )
      v16 = sys_futex(&dword_C14E8, 129, 1u, 0LL, v13, v14);
  }
  else
  {
    --dword_C14E8;
  }
  return 0LL;
}
// 526FE: variable 'v13' is possibly undefined
// 526FE: variable 'v14' is possibly undefined
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000052730) ----------------------------------------------------
unsigned __int64 __fastcall sub_52730(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  __int64 v8; // r15
  __int64 v9; // r13
  __int64 v10; // rdx
  void *v11; // rsp
  double v12; // xmm4_8
  double v13; // xmm5_8
  __int64 v14; // rax
  __int64 v15; // r12
  int v16; // er14
  int v17; // ebx
  __int64 v18; // rax
  __int64 v19; // rdi
  __int64 v20; // rbx
  __int64 v21; // r15
  __int64 v22; // rax
  char *v23; // rax
  char *v24; // r15
  char *v25; // r8
  _QWORD *v26; // rbx
  int v27; // er12
  _BYTE *v28; // rax
  _BYTE *v29; // rax
  unsigned __int64 v30; // rdx
  bool v31; // cc
  _QWORD *v32; // rax
  char v34[15]; // [rsp-Eh] [rbp-80h] BYREF
  __int64 v35; // [rsp+12h] [rbp-60h] BYREF
  _QWORD *v36; // [rsp+1Ah] [rbp-58h]
  __int64 v37; // [rsp+22h] [rbp-50h]
  char *v38; // [rsp+2Ah] [rbp-48h]
  __int64 *v39; // [rsp+32h] [rbp-40h] BYREF
  unsigned __int64 v40; // [rsp+3Ah] [rbp-38h]

  v8 = qword_C1518;
  v40 = __readfsqword(0x28u);
  if ( qword_C1518 )
    sub_CF00("result == NULL", "gconv_conf.c", 438LL, "__gconv_get_path");
  v9 = qword_C1508;
  if ( qword_C1508 )
  {
    v10 = strlen(qword_C1508);
    v36 = (_QWORD *)(v10 + 16);
    v11 = alloca(v10 + 24);
    v39 = &v35;
    strcpy((char *)sub_91D0(&v35, v9, v10), ":/usr/lib/gconv");
    v14 = sub_4B000(0LL, 0LL, a1, a2, a3, a4, v12, v13, a7, a8);
    v9 = v14;
    if ( v14 )
    {
      v37 = strlen(v14);
      v38 = (char *)v39;
      v35 = v37 + 1;
    }
    else
    {
      v35 = 1LL;
      v37 = 0LL;
      v38 = (char *)v39;
    }
  }
  else
  {
    v35 = 1LL;
    v37 = 0LL;
    v36 = (_QWORD *)(byte_9 + 6);
    strcpy(v34, "/usr/lib/gconv");
    v38 = v34;
    v39 = (__int64 *)v34;
  }
  v15 = sub_9210(v38, 58LL);
  if ( v15 )
  {
    v16 = 1;
    while ( 1 )
    {
      v17 = v16 + 1;
      if ( v15 != v8 + 1 )
      {
        v17 = v16 + 2;
        ++v16;
      }
      v8 = v15;
      v18 = sub_9210(v15 + 1, 58LL);
      if ( !v18 )
        break;
      v15 = v18;
    }
    v19 = v17;
    v20 = v16;
    v21 = (v16 - 1) * v35;
    v22 = 2 * v19;
  }
  else
  {
    v21 = 0LL;
    v20 = 1LL;
    v22 = 4LL;
  }
  v23 = (char *)sub_21500((char *)&v36[v22] + v20 + v21);
  v36 = v23;
  if ( v23 )
  {
    qword_C1510 = 0LL;
    v24 = &v23[16 * v20 + 16];
    v25 = sub_6BC30(v38, (__int64)":", (_BYTE **)&v39);
    if ( !v25 )
      sub_CF00("elem != NULL", "gconv_conf.c", 500LL, "__gconv_get_path");
    v26 = v36;
    v27 = 0;
    do
    {
      *v26 = v24;
      if ( *v25 != 47 )
      {
        if ( !v9 )
          sub_CF00("cwd != NULL", "gconv_conf.c", 506LL, "__gconv_get_path");
        v38 = v25;
        v28 = (_BYTE *)sub_91D0(v24, v9, v37);
        *v28 = 47;
        v24 = v28 + 1;
      }
      v29 = (_BYTE *)sub_90F0(v24);
      if ( *(v29 - 1) != 47 )
        *v29++ = 47;
      v30 = (unsigned __int64)&v29[-*v26];
      v31 = v30 <= qword_C1510;
      v26[1] = v30;
      if ( !v31 )
        qword_C1510 = v30;
      *v29 = 0;
      v24 = v29 + 1;
      ++v27;
      v26 += 2;
      v25 = sub_6BC30(0LL, (__int64)":", (_BYTE **)&v39);
    }
    while ( v25 );
    v32 = &v36[2 * v27];
    *v32 = 0LL;
    v32[1] = 0LL;
  }
  else
  {
    v36 = &unk_94A50;
  }
  qword_C1518 = (__int64)v36;
  sub_21B70(v9);
  return v40 - __readfsqword(0x28u);
}
// 527D7: variable 'v12' is possibly undefined
// 527D7: variable 'v13' is possibly undefined
// 90F0: using guessed type __int64 __fastcall sub_90F0(_QWORD);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// 9210: using guessed type __int64 __fastcall sub_9210(_QWORD, _QWORD);
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// C1508: using guessed type __int64 qword_C1508;
// C1510: using guessed type __int64 qword_C1510;
// C1518: using guessed type __int64 qword_C1518;

//----- (0000000000052AD0) ----------------------------------------------------
void __fastcall sub_52AD0(__int64 a1, int a2)
{
  _QWORD *v2; // rbp
  __int64 v3; // r12
  __int64 *v4; // rbx
  __int64 *v5; // rbp
  int v6; // eax
  __int64 v7; // r15
  int v8; // eax

  v2 = (_QWORD *)qword_C14F0;
  if ( qword_C14F0 )
  {
    v3 = *(_QWORD *)a1;
    v4 = &qword_C14F0;
    while ( 1 )
    {
      v6 = sub_91B0(v3, *v2);
      if ( !v6 )
        break;
      v4 = v2 + 4;
      v5 = v2 + 6;
      if ( v6 >= 0 )
        v4 = v5;
      v2 = (_QWORD *)*v4;
      if ( !*v4 )
        goto LABEL_12;
    }
    v7 = *(_QWORD *)(a1 + 8);
    while ( (unsigned int)sub_91B0(v7, v2[1]) )
    {
      v4 = v2 + 5;
      v2 = (_QWORD *)v2[5];
      if ( !v2 )
        goto LABEL_12;
      while ( (unsigned int)sub_91B0(v3, *v2) )
      {
        v4 = v2 + 5;
        v2 = (_QWORD *)v2[5];
        if ( !v2 )
          goto LABEL_12;
      }
    }
    v8 = *((_DWORD *)v2 + 4);
    if ( *(_DWORD *)(a1 + 16) < v8 || *(_DWORD *)(a1 + 16) == v8 && *(_DWORD *)(a1 + 20) < *((_DWORD *)v2 + 5) )
    {
      *(_QWORD *)(a1 + 32) = v2[4];
      *(_QWORD *)(a1 + 48) = v2[6];
      *(_QWORD *)(a1 + 40) = v2[5];
      *v4 = a1;
      sub_21B70(v2);
    }
    else if ( a2 )
    {
      sub_21B70(a1);
    }
  }
  else
  {
    v4 = &qword_C14F0;
LABEL_12:
    *v4 = a1;
  }
}
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// C14F0: using guessed type __int64 qword_C14F0;

//----- (0000000000052BE0) ----------------------------------------------------
_QWORD *__fastcall sub_52BE0(void *a1, __int64 a2, __int64 a3)
{
  size_t v3; // r13
  _QWORD *result; // rax
  _QWORD *v5; // rbp
  char *v6; // rax

  v3 = a3 - (_QWORD)a1;
  result = (_QWORD *)sub_21500(a3 - (_QWORD)a1 + 16);
  if ( result )
  {
    v5 = result;
    v6 = (char *)memcpy(result + 2, a1, v3);
    *v5 = v6;
    v5[1] = &v6[a2 - (_QWORD)a1];
    result = (_QWORD *)sub_4C080((__int64)v5, &qword_C14F8, (__int64 (__fastcall *)(__int64, _QWORD))sub_515F0);
    if ( !result || v5 != (_QWORD *)*result )
      result = (_QWORD *)sub_21B70(v5);
  }
  return result;
}
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// C14F8: using guessed type __int64 qword_C14F8;

//----- (0000000000052C70) ----------------------------------------------------
unsigned __int64 __fastcall sub_52C70(char *a1, __int64 a2, __int64 a3, int a4, __int64 a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  char *v13; // r13
  __int64 v15; // rdx
  char v16; // al
  unsigned __int8 *i; // r12
  unsigned __int8 *v18; // rax
  __int64 v19; // rdx
  unsigned __int8 *v20; // rdi
  char j; // al
  __int64 v22; // r9
  signed __int8 v23; // al
  unsigned __int8 *v24; // r14
  _BYTE *v25; // r15
  __int64 v26; // rdx
  signed __int8 v27; // al
  signed __int8 *v28; // rdx
  signed __int8 *v29; // rcx
  int v30; // eax
  __int64 v31; // rcx
  char v32; // al
  int v33; // er14
  size_t v34; // rdx
  void *v35; // rsp
  __int64 v36; // rdx
  u32 *v37; // r8
  double v38; // xmm4_8
  double v39; // xmm5_8
  char *v41; // rax
  __int64 v42; // rax
  __int64 v43; // r8
  __int64 v44; // r9
  __int64 v45; // rax
  __int64 v46; // r8
  __int64 v47; // r9
  __int64 v48; // rdi
  __int64 v49; // rax
  __int64 v50; // r8
  __int64 v51; // rax
  _BYTE v52[8]; // [rsp+0h] [rbp-90h] BYREF
  __int64 v53; // [rsp+8h] [rbp-88h]
  __int64 v54; // [rsp+10h] [rbp-80h]
  __int64 v55; // [rsp+18h] [rbp-78h]
  char *v56; // [rsp+20h] [rbp-70h]
  __int64 v57; // [rsp+28h] [rbp-68h]
  __int64 v58; // [rsp+30h] [rbp-60h]
  __int64 v59; // [rsp+38h] [rbp-58h]
  unsigned __int8 *v60[3]; // [rsp+40h] [rbp-50h] BYREF
  unsigned __int64 v61; // [rsp+58h] [rbp-38h]

  v13 = a1;
  v58 = a2;
  v15 = *a1;
  LODWORD(v59) = a4;
  v61 = __readfsqword(0x28u);
  if ( (byte_971A0[2 * v15 + 1] & 0x20) != 0 )
  {
    do
    {
      v15 = *++v13;
      v16 = v15;
    }
    while ( (byte_971A0[2 * v15 + 1] & 0x20) != 0 );
  }
  else
  {
    v16 = v15;
  }
  if ( v16 )
  {
    for ( i = (unsigned __int8 *)v13; ; v15 = (char)*i )
    {
      v18 = i++;
      if ( (byte_971A0[2 * v15 + 1] & 0x20) != 0 )
        break;
      *(i - 1) = dword_968A0[v15];
      if ( !*i )
        return v61 - __readfsqword(0x28u);
    }
    v19 = (char)v18[1];
    *v18 = 0;
    v20 = i;
    for ( j = v19; (byte_971A0[2 * v19 + 1] & 0x20) != 0; j = v19 )
      v19 = (char)*++v20;
    v22 = (__int64)i;
    if ( j )
    {
      while ( 1 )
      {
        v24 = v20;
        v25 = (_BYTE *)v22;
        ++v20;
        ++v22;
        if ( (byte_971A0[2 * v19 + 1] & 0x20) != 0 )
          break;
        *(_BYTE *)(v22 - 1) = dword_968A0[v19];
        v23 = v24[1];
        if ( !v23 )
          return v61 - __readfsqword(0x28u);
        v19 = v23;
      }
      *v25 = 0;
      do
      {
        v26 = (char)*++v24;
        v27 = v26;
      }
      while ( (byte_971A0[2 * v26 + 1] & 0x20) != 0 );
      v28 = (signed __int8 *)v22;
      if ( v27 )
      {
        while ( 1 )
        {
          v29 = v28;
          ++v24;
          *v28++ = v27;
          v27 = *v24;
          if ( !*v24 )
            break;
          if ( (byte_971A0[2 * v27 + 1] & 0x20) != 0 )
          {
            *v28 = 0;
            v55 = v22;
            v56 = v29 + 2;
            v30 = sub_5DE10(v24, v60, 0xAu);
            v31 = (__int64)v56;
            LODWORD(v57) = v30;
            v22 = v55;
            if ( v60[0] == v24 || v30 <= 0 )
              LODWORD(v57) = 1;
            goto LABEL_24;
          }
        }
      }
      *v28 = 0;
      v31 = (__int64)(v28 + 1);
      LODWORD(v57) = 1;
LABEL_24:
      v32 = v25[1];
      if ( v32 )
      {
        v33 = 3;
        if ( v32 == 47 )
          a3 = 0LL;
        v54 = v31 - v22;
        if ( v31 - v22 > 3 )
          v33 = 3 * (*(_DWORD *)(v31 - 4) != 7303982);
        v55 = v22;
        v56 = (char *)v31;
        v34 = sub_9040(v13, i - (unsigned __int8 *)v13, v28, v31, a5, v22);
        v35 = alloca(v34 + 9);
        v52[v34] = 0;
        v60[0] = (unsigned __int8 *)memcpy(v52, v13, v34);
        if ( !sub_4C220((__int64)v60, &qword_C14F8, (__int64 (__fastcall *)(__int64, _QWORD))sub_515F0) )
        {
          v53 = v55;
          v41 = (char *)sub_22260(
                          1uLL,
                          v33 + a3 + v56 - v13 + 56,
                          a6,
                          a7,
                          a8,
                          a9,
                          v38,
                          v39,
                          a12,
                          a13,
                          v36,
                          v56 - v13,
                          v37,
                          v55);
          if ( v41 )
          {
            v56 = v41;
            *(_QWORD *)v41 = v41 + 56;
            v42 = sub_91D0(v41 + 56, v13, i - (unsigned __int8 *)v13);
            v43 = (__int64)v56;
            v44 = v53;
            *((_QWORD *)v56 + 1) = v42;
            v55 = v43;
            v56 = (char *)v44;
            v45 = sub_91D0(v42, i, v44 - (_QWORD)i);
            v46 = v55;
            v47 = (__int64)v56;
            v48 = v45;
            LODWORD(v45) = v57;
            *(_QWORD *)(v55 + 24) = v48;
            *(_DWORD *)(v46 + 16) = v45;
            *(_DWORD *)(v46 + 20) = v59;
            if ( a3 )
            {
              v57 = v47;
              v59 = v46;
              v51 = sub_91D0(v48, v58, a3);
              v47 = v57;
              v46 = v59;
              v48 = v51;
            }
            v59 = v46;
            v49 = sub_91D0(v48, v47, v54);
            v50 = v59;
            if ( v33 )
              *(_DWORD *)(v49 - 1) = 7303982;
            sub_52AD0(v50, 1);
          }
        }
      }
    }
  }
  return v61 - __readfsqword(0x28u);
}
// 52E62: variable 'v28' is possibly undefined
// 52E62: variable 'a5' is possibly undefined
// 52EF4: variable 'v38' is possibly undefined
// 52EF4: variable 'v39' is possibly undefined
// 52EF4: variable 'v36' is possibly undefined
// 52EF4: variable 'v37' is possibly undefined
// 9040: using guessed type __int64 __fastcall sub_9040(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// C14F8: using guessed type __int64 qword_C14F8;

//----- (0000000000052FD0) ----------------------------------------------------
unsigned __int64 __fastcall sub_52FD0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  unsigned int v8; // ebx
  double v9; // xmm4_8
  double v10; // xmm5_8
  __int64 v12; // rax
  void *v13; // rsp
  unsigned __int64 *i; // rsi
  double v15; // xmm4_8
  double v16; // xmm5_8
  int *v17; // rax
  u32 *v18; // r8
  u32 v19; // er9
  double v20; // xmm4_8
  double v21; // xmm5_8
  int *v22; // r12
  int v23; // eax
  int v24; // edx
  __int64 v25; // r14
  char *v26; // r13
  char *v27; // rax
  char *v28; // rdx
  __int64 v29; // rax
  char *v30; // rdi
  __int64 v31; // rdi
  __int64 v32; // rdx
  __int64 v33; // rcx
  u32 *v34; // r8
  u32 v35; // er9
  __int64 v36; // rsi
  unsigned __int64 *v37; // r14
  char **v38; // r13
  __int64 v39; // rdi
  const char *v40; // r13
  char *v41; // r15
  __int64 v42; // r14
  __int64 v43; // rax
  _QWORD *v44; // rbx
  __int64 v45; // r12
  int v46; // eax
  char *v47; // rax
  __int64 v48; // rax
  char *v49; // r13
  char *v50; // rdx
  unsigned __int64 *v51; // rax
  char *v52; // rdx
  char *v53; // rcx
  unsigned __int64 **v54; // r13
  int v55; // eax
  int v56; // ecx
  char v57[8]; // [rsp+0h] [rbp-A0h] BYREF
  char *v58; // [rsp+8h] [rbp-98h]
  char *v59; // [rsp+10h] [rbp-90h]
  unsigned int v60; // [rsp+1Ch] [rbp-84h]
  __int64 v61; // [rsp+20h] [rbp-80h]
  __int64 v62; // [rsp+28h] [rbp-78h]
  unsigned __int64 *v63; // [rsp+30h] [rbp-70h]
  char **v64; // [rsp+38h] [rbp-68h]
  char *v65; // [rsp+48h] [rbp-58h] BYREF
  unsigned __int64 v66[3]; // [rsp+50h] [rbp-50h] BYREF
  unsigned __int64 v67; // [rsp+68h] [rbp-38h]

  v67 = __readfsqword(0x28u);
  v8 = __readfsdword(0xFFFFFFC0);
  v60 = v8;
  if ( (unsigned int)sub_5A660(a1, a2, a3, a4, a5, a6, a7, a8) )
  {
    sub_52730(a1, a2, a3, a4, v9, v10, a7, a8);
    v12 = qword_C1518;
    v63 = *(unsigned __int64 **)qword_C1518;
    if ( v63 )
    {
      v62 = 16LL;
      v64 = &v65;
      do
      {
        v61 = *(_QWORD *)(v12 + 8);
        v13 = alloca(v61 + 22);
        i = (unsigned __int64 *)"rce";
        strcpy((char *)sub_91D0(v57, v63, v61), "gconv-modules");
        v17 = (int *)sub_140F0(v57, "rce", a1, a2, a3, a4, v15, v16, a7, a8);
        v65 = 0LL;
        v66[0] = 0LL;
        v22 = v17;
        if ( v17 )
        {
          v23 = *v17;
          v24 = v23;
          BYTE1(v24) = BYTE1(v23) | 0x80;
          *v22 = v24;
          if ( (v23 & 0x10) != 0 )
          {
            v31 = 0LL;
          }
          else
          {
            do
            {
              i = v66;
              v25 = sub_69FB0((const char **)v64, v66, 0xAu, (__int64)v22, v18, v19, a1, a2, a3, a4, v20, v21, a7, a8);
              if ( v25 < 0 )
                break;
              v26 = v65;
              i = (unsigned __int64 *)(qword_20 + 3);
              v27 = (char *)sub_9210(v65, 35LL);
              v28 = v27;
              if ( v27 )
              {
                *v27 = 0;
              }
              else
              {
                v47 = &v26[v25 - 1];
                if ( *v47 == 10 )
                  *v47 = 0;
              }
              while ( (byte_971A0[2 * *v26 + 1] & 0x20) != 0 )
                ++v26;
              if ( v28 != v26 )
              {
                v29 = *v26;
                v30 = v26;
                if ( (_BYTE)v29 )
                {
                  do
                  {
                    if ( (byte_971A0[2 * v29 + 1] & 0x20) != 0 )
                      break;
                    v29 = *++v30;
                  }
                  while ( (_BYTE)v29 );
                  if ( v30 - v26 == 5 )
                  {
                    if ( *(_DWORD *)v26 == 1634298977 && v26[4] == 115 )
                    {
                      while ( 1 )
                      {
                        v48 = *v30;
                        if ( (byte_971A0[2 * v48 + 1] & 0x20) == 0 )
                          break;
                        ++v30;
                      }
                      if ( (_BYTE)v48 )
                      {
                        v49 = v30;
                        while ( 1 )
                        {
                          v50 = v49++;
                          if ( (byte_971A0[2 * v48 + 1] & 0x20) != 0 )
                            break;
                          *(v49 - 1) = dword_968A0[v48];
                          v48 = *v49;
                          if ( !(_BYTE)v48 )
                            goto LABEL_21;
                        }
                        v51 = (unsigned __int64 *)v50[1];
                        *v50 = 0;
                        v52 = v49;
                        for ( i = v51; (byte_971A0[2 * (_QWORD)v51 + 1] & 0x20) != 0; i = v51 )
                          v51 = (unsigned __int64 *)*++v52;
                        v53 = v49;
                        if ( (_BYTE)i )
                        {
                          do
                          {
                            if ( (byte_971A0[2 * (_QWORD)v51 + 1] & 0x20) != 0 )
                              break;
                            i = (unsigned __int64 *)dword_968A0;
                            ++v52;
                            *v53++ = dword_968A0[(_QWORD)v51];
                            v51 = (unsigned __int64 *)*v52;
                          }
                          while ( (_BYTE)v51 );
                          if ( v53 != v49 )
                          {
                            *v53 = 0;
                            if ( qword_C14F0 )
                            {
                              v58 = v49;
                              v54 = (unsigned __int64 **)qword_C14F0;
                              v59 = v53;
                              while ( 1 )
                              {
                                i = *v54;
                                v55 = sub_91B0(v30, *v54);
                                if ( !v55 )
                                  break;
                                if ( v55 >= 0 )
                                {
                                  v54 = (unsigned __int64 **)v54[6];
                                  if ( !v54 )
                                    goto LABEL_62;
                                }
                                else
                                {
                                  v54 = (unsigned __int64 **)v54[4];
                                  if ( !v54 )
                                  {
LABEL_62:
                                    v53 = v59;
                                    v49 = v58;
                                    goto LABEL_63;
                                  }
                                }
                              }
                            }
                            else
                            {
LABEL_63:
                              i = (unsigned __int64 *)v49;
                              sub_52BE0(v30, (__int64)v49, (__int64)(v53 + 1));
                            }
                          }
                        }
                      }
                    }
                  }
                  else if ( v30 - v26 == 6 && *(_DWORD *)v26 == 1969516397 && *((_WORD *)v26 + 2) == 25964 )
                  {
                    v56 = dword_C1520;
                    i = v63;
                    ++dword_C1520;
                    sub_52C70(v30, (__int64)v63, v61, v56, (__int64)v18, a1, a2, a3, a4, v20, v21, a7, a8);
                  }
                }
              }
LABEL_21:
              ;
            }
            while ( (*(_BYTE *)v22 & 0x10) == 0 );
            v31 = (__int64)v65;
          }
          sub_21B70(v31);
          sub_137F0(v22, (__int64)i, v32, v33, v34, v35);
        }
        v12 = v62 + qword_C1518;
        v36 = *(_QWORD *)(v62 + qword_C1518);
        v62 += 16LL;
        v63 = (unsigned __int64 *)v36;
      }
      while ( v36 );
    }
    v37 = (unsigned __int64 *)off_BF640;
    v38 = &off_BF640[84];
    do
    {
      while ( 1 )
      {
        v66[0] = *v37;
        if ( !sub_4C220((__int64)v66, &qword_C14F8, (__int64 (__fastcall *)(__int64, _QWORD))sub_515F0) )
          break;
        v37 += 7;
        if ( v38 == (char **)v37 )
          goto LABEL_29;
      }
      v39 = (__int64)v37;
      v37 += 7;
      sub_52AD0(v39, 0);
    }
    while ( v38 != (char **)v37 );
LABEL_29:
    v40 = "UCS4//";
    do
    {
      v41 = (char *)v40;
      v42 = sub_9060(v40, 0LL) + 1;
      v43 = sub_9060(v42, 0LL);
      v44 = (_QWORD *)qword_C14F0;
      v45 = v43;
      v40 = (const char *)(v43 + 1);
LABEL_31:
      if ( v44 )
      {
        while ( 1 )
        {
          v46 = sub_91B0(v41, *v44);
          if ( !v46 )
            break;
          if ( v46 < 0 )
          {
            v44 = (_QWORD *)v44[4];
            goto LABEL_31;
          }
          v44 = (_QWORD *)v44[6];
          if ( !v44 )
            goto LABEL_35;
        }
      }
      else
      {
LABEL_35:
        sub_52BE0(v41, v42, (__int64)v40);
      }
    }
    while ( *(_BYTE *)(v45 + 1) );
    __writefsdword(0xFFFFFFC0, v60);
  }
  else
  {
    __writefsdword(0xFFFFFFC0, v8);
  }
  return v67 - __readfsqword(0x28u);
}
// 53037: variable 'v9' is possibly undefined
// 53037: variable 'v10' is possibly undefined
// 530C3: variable 'v15' is possibly undefined
// 530C3: variable 'v16' is possibly undefined
// 5310F: variable 'v18' is possibly undefined
// 5310F: variable 'v19' is possibly undefined
// 5310F: variable 'v20' is possibly undefined
// 5310F: variable 'v21' is possibly undefined
// 531C7: variable 'v32' is possibly undefined
// 531C7: variable 'v33' is possibly undefined
// 531C7: variable 'v34' is possibly undefined
// 531C7: variable 'v35' is possibly undefined
// 20: using guessed type __int64 qword_20[];
// 9060: using guessed type __int64 __fastcall sub_9060(_QWORD, _QWORD);
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// 9210: using guessed type __int64 __fastcall sub_9210(_QWORD, _QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// BF640: using guessed type char *off_BF640[2];
// C14F0: using guessed type __int64 qword_C14F0;
// C14F8: using guessed type __int64 qword_C14F8;
// C1518: using guessed type __int64 qword_C1518;
// C1520: using guessed type int dword_C1520;

//----- (0000000000053490) ----------------------------------------------------
unsigned __int64 __fastcall sub_53490(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  unsigned __int64 result; // rax

  result = (unsigned int)dword_C1524;
  if ( !dword_C1524 )
  {
    result = sub_52FD0(a1, a2, a3, a4, a5, a6, a7, a8);
    dword_C1524 |= 2u;
  }
  return result;
}
// 9220: using guessed type __int64 __fastcall sub_9220(_QWORD, _QWORD);
// C1524: using guessed type int dword_C1524;

//----- (00000000000534E0) ----------------------------------------------------
__int64 __fastcall sub_534E0(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  const char *v11; // rsi
  const char **v12; // rbp
  __int64 v13; // rbx
  double v14; // xmm4_8
  double v15; // xmm5_8
  char **v16; // rbx
  char *v17; // rax
  char *v18; // rax
  __int64 result; // rax

  v11 = "=INTERNAL->ucs4";
  v12 = (const char **)&off_BD820;
  v13 = 0LL;
  while ( (unsigned int)sub_91B0(a1, v11) )
  {
    if ( ++v13 == 12 )
      sub_CF00(
        (__int64)"cnt < sizeof (map) / sizeof (map[0])",
        (__int64)"gconv_builtin.c",
        0x46u,
        "__gconv_get_builtin_trans",
        a3,
        a4,
        a5,
        a6,
        v14,
        v15,
        a9,
        a10);
    v11 = *v12;
    v12 += 4;
  }
  *(_QWORD *)(a2 + 56) = 0LL;
  v16 = &(&off_BD800)[4 * v13];
  *(_QWORD *)(a2 + 64) = 0LL;
  v17 = v16[1];
  *(_QWORD *)a2 = 0LL;
  *(_QWORD *)(a2 + 8) = 0LL;
  *(_QWORD *)(a2 + 40) = v17;
  v18 = v16[2];
  *(_DWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 48) = v18;
  *(_DWORD *)(a2 + 72) = *((char *)v16 + 24);
  *(_DWORD *)(a2 + 76) = *((char *)v16 + 25);
  *(_DWORD *)(a2 + 80) = *((char *)v16 + 26);
  result = (unsigned int)*((char *)v16 + 27);
  *(_DWORD *)(a2 + 84) = result;
  return result;
}
// 53548: variable 'v14' is possibly undefined
// 53548: variable 'v15' is possibly undefined
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// BD800: using guessed type char *off_BD800;
// BD820: using guessed type char *off_BD820;

//----- (00000000000535D0) ----------------------------------------------------
__int64 __fastcall sub_535D0(__int64 a1, char a2)
{
  __int64 result; // rax

  result = (unsigned __int8)a2;
  if ( a2 < 0 )
    result = 0xFFFFFFFFLL;
  return result;
}

//----- (00000000000535F0) ----------------------------------------------------
__int64 __fastcall sub_535F0(__int64 a1, unsigned __int64 *a2, __int64 *a3, unsigned __int64 a4, unsigned __int64 *a5, __int64 *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16)
{
  unsigned __int64 *v19; // rax
  unsigned __int64 v20; // rbx
  int *v21; // rcx
  int v22; // edi
  unsigned __int64 v23; // rdx
  __int64 v24; // rax
  __int64 *v25; // r14
  __int64 v26; // rbp
  __int64 v27; // rax
  __int64 v28; // rcx
  __int64 v29; // rax
  __int64 v30; // rcx
  __int64 v31; // rax
  unsigned __int64 v32; // r15
  unsigned int v33; // er13
  unsigned int v34; // eax
  unsigned __int64 v35; // rsi
  __int64 *v36; // r14
  __int64 v38; // rdx
  __int64 v39; // r15
  __int64 v40; // rdi
  __int64 v41; // rdx
  unsigned __int64 v42; // rdx
  __int64 v43; // rsi
  unsigned __int64 v44; // rax
  _DWORD *v45; // rcx
  __int64 v46; // rdx
  int v47; // edx
  __int64 *v48; // [rsp+0h] [rbp-98h]
  unsigned __int64 v50; // [rsp+8h] [rbp-90h]
  __int64 (__fastcall *v51)(__int64, __int64 *, __int64 *, unsigned __int64, _QWORD, __int64 *, _QWORD, _QWORD); // [rsp+10h] [rbp-88h]
  __int64 v52; // [rsp+18h] [rbp-80h]
  unsigned __int64 *v53; // [rsp+20h] [rbp-78h]
  unsigned __int64 v54; // [rsp+28h] [rbp-70h]
  __int64 v55; // [rsp+30h] [rbp-68h]
  __int64 *v56; // [rsp+40h] [rbp-58h]
  __int64 v57; // [rsp+48h] [rbp-50h]
  __int64 v58[9]; // [rsp+50h] [rbp-48h] BYREF

  v53 = a5;
  v58[1] = __readfsqword(0x28u);
  v51 = 0LL;
  v57 = a1 + 104;
  v56 = (__int64 *)(a2 + 6);
  if ( (a2[2] & 1) == 0 )
  {
    v51 = *(__int64 (__fastcall **)(__int64, __int64 *, __int64 *, unsigned __int64, _QWORD, __int64 *, _QWORD, _QWORD))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v51 = (__int64 (__fastcall *)(__int64, __int64 *, __int64 *, unsigned __int64, _QWORD, __int64 *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(*(_QWORD *)(a1 + 144), 17));
  }
  if ( !(_DWORD)a15 )
  {
    v19 = a5;
    if ( !a5 )
      v19 = a2;
    v20 = *v19;
    v50 = a2[1];
    if ( !a16 || (v21 = (int *)a2[4], v22 = *v21, LODWORD(v23) = *v21 & 7, !(_DWORD)v23) )
    {
      v48 = a3;
      v25 = a6;
      while ( 1 )
      {
LABEL_18:
        v52 = 0LL;
        v26 = *v48;
        if ( v25 )
          v52 = *v25;
        v27 = v50 - v20;
        if ( (__int64)(v50 - v20) > (__int64)(a4 - v26) )
          v27 = a4 - v26;
        v28 = v27 / 4;
        if ( v27 / 4 )
        {
          v29 = 0LL;
          do
          {
            *(_DWORD *)(v20 + 4 * v29) = _byteswap_ulong(*(_DWORD *)(v26 + 4 * v29));
            ++v29;
          }
          while ( v28 != v29 );
          v30 = 4 * v28;
          v31 = v26 + v30;
          v32 = v20 + v30;
        }
        else
        {
          v32 = v20;
          v31 = *v48;
        }
        v33 = 4;
        *v48 = v31;
        if ( v31 != a4 )
          v33 = v50 < v32 + 4 ? 5 : 7;
        if ( v53 )
        {
          *v53 = v32;
          return v33;
        }
        ++*((_DWORD *)a2 + 5);
        if ( (a2[2] & 1) != 0 )
        {
          *a2 = v32;
          v36 = v48;
          goto LABEL_37;
        }
        v55 = a4 - v26;
        if ( v20 >= v32 )
          goto LABEL_36;
        v54 = a4;
        v58[0] = *a2;
        sub_4F2B0((__int64)v51);
        v34 = v51(v57, v56, v58, v32, 0LL, v25, 0LL, a16);
        a4 = v54;
        if ( v34 == 4 )
        {
          if ( v33 != 5 )
          {
LABEL_36:
            v36 = v48;
            goto LABEL_37;
          }
        }
        else
        {
          v35 = v58[0];
          if ( v58[0] != v32 )
          {
            v38 = 0LL;
            if ( v25 )
              v38 = *v25;
            if ( v38 == v52 )
            {
              *v48 -= v32 - v58[0];
            }
            else
            {
              v39 = v55;
              if ( (__int64)(v58[0] - v20) <= v55 )
                v39 = v58[0] - v20;
              v40 = v39 / 4;
              if ( v39 / 4 )
              {
                v41 = 0LL;
                do
                {
                  *(_DWORD *)(v20 + 4 * v41) = _byteswap_ulong(*(_DWORD *)(v26 + 4 * v41));
                  ++v41;
                }
                while ( v40 != v41 );
                v26 += 4 * v40;
                v42 = v20 + 4 * v40;
              }
              else
              {
                v42 = v20;
              }
              *v48 = v26;
              if ( v26 == v54 || v35 >= v42 + 4 )
              {
                if ( v42 == v35 )
                  sub_CF00(
                    (__int64)"nstatus == __GCONV_FULL_OUTPUT",
                    (__int64)"../iconv/skeleton.c",
                    0x2EBu,
                    "__gconv_transform_internal_ucs4",
                    a7,
                    a8,
                    a9,
                    a10,
                    a11,
                    a12,
                    a13,
                    a14);
LABEL_70:
                sub_CF00(
                  (__int64)"outbuf == outerr",
                  (__int64)"../iconv/skeleton.c",
                  0x2EAu,
                  "__gconv_transform_internal_ucs4",
                  a7,
                  a8,
                  a9,
                  a10,
                  a11,
                  a12,
                  a13,
                  a14);
              }
              if ( v42 != v35 )
                goto LABEL_70;
              if ( v42 == v20 )
                --*((_DWORD *)a2 + 5);
            }
          }
          if ( v34 )
          {
            v36 = v48;
            v33 = v34;
LABEL_37:
            if ( v33 == 7 && a16 )
            {
              v43 = *v36;
              v44 = a4 - *v36;
              if ( v44 > 4 )
                sub_CF00(
                  (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
                  (__int64)"../iconv/skeleton.c",
                  0x31Fu,
                  "__gconv_transform_internal_ucs4",
                  a7,
                  a8,
                  a9,
                  a10,
                  a11,
                  a12,
                  a13,
                  a14);
              v45 = (_DWORD *)a2[4];
              v46 = 0LL;
              if ( v44 )
              {
                do
                {
                  *((_BYTE *)v45 + v46 + 4) = *(_BYTE *)(v43 + v46);
                  ++v46;
                }
                while ( v44 != v46 );
              }
              v47 = *v45;
              *v36 = a4;
              v33 = 7;
              *v45 = v47 & 0xFFFFFFF8 | v44;
            }
            return v33;
          }
        }
        v20 = *a2;
      }
    }
    if ( a5 )
      sub_CF00(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x234u,
        "__gconv_transform_internal_ucs4",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    v23 = (int)v23;
    if ( a4 > *a3 )
    {
      if ( (v22 & 4) != 0 )
        goto LABEL_16;
      v24 = *a3 + 1;
      while ( 1 )
      {
        *a3 = v24;
        *((_BYTE *)v21 + ++v23 + 3) = *(_BYTE *)(v24 - 1);
        if ( a4 == v24 )
          break;
        ++v24;
        if ( v23 == 4 )
          goto LABEL_16;
      }
    }
    if ( v23 <= 3 )
    {
      v33 = 7;
      *v21 = v22 & 0xFFFFFFF8 | v23;
      return v33;
    }
LABEL_16:
    v48 = a3;
    v20 += 4LL;
    v25 = a6;
    *(_BYTE *)(v20 - 4) = *((_BYTE *)v21 + 7);
    *(_BYTE *)(v20 - 3) = *((_BYTE *)v21 + 6);
    *(_BYTE *)(v20 - 2) = *((_BYTE *)v21 + 5);
    *(_BYTE *)(v20 - 1) = *((_BYTE *)v21 + 4);
    *v21 &= 0xFFFFFFF8;
    goto LABEL_18;
  }
  if ( a5 )
    sub_CF00(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x1A4u,
      "__gconv_transform_internal_ucs4",
      a7,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14);
  v33 = 0;
  *(_QWORD *)a2[4] = 0LL;
  if ( (a2[2] & 1) != 0 )
    return v33;
  sub_4F2B0((__int64)v51);
  return ((__int64 (__fastcall *)(__int64, __int64 *, _QWORD, _QWORD, _QWORD, __int64 *, __int64))v51)(
           v57,
           v56,
           0LL,
           0LL,
           0LL,
           a6,
           a15);
}
// 5399F: variable 'a11' is possibly undefined
// 5399F: variable 'a12' is possibly undefined

//----- (0000000000053B20) ----------------------------------------------------
__int64 __fastcall sub_53B20(__int64 a1, __int64 a2, unsigned int **a3, unsigned int *a4, int **a5, __int64 *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16)
{
  __int64 (__fastcall *v16)(__int64, __int64, __int64 *, int *, _QWORD, __int64 *, _QWORD, _QWORD); // r15
  int v19; // eax
  int **v20; // rdx
  int *v21; // rbp
  __int64 *v22; // rdx
  unsigned int **v23; // r11
  __int64 *v24; // r13
  unsigned int *v25; // r12
  int *v26; // r14
  unsigned int *v27; // rsi
  signed __int64 v28; // rdx
  __int64 v29; // r8
  __int64 v30; // rdi
  int v31; // eax
  int v32; // edx
  int v33; // er15
  unsigned int v34; // er10
  unsigned int v36; // eax
  unsigned __int64 v37; // rsi
  signed __int64 v38; // r10
  unsigned int **v39; // r13
  unsigned int *v40; // rsi
  unsigned __int64 v41; // rax
  _DWORD *v42; // rcx
  __int64 v43; // rdx
  unsigned int v44; // edx
  unsigned int *v45; // rsi
  unsigned int v46; // edi
  int v47; // er8
  unsigned int *v48; // rdx
  unsigned __int64 v49; // rcx
  __int64 v50; // rdx
  int v51; // er9
  int *v52; // rcx
  __int64 i; // rdi
  int v54; // edx
  __int64 v55; // [rsp+0h] [rbp-B8h]
  __int64 (__fastcall *v58)(__int64, __int64, __int64 *, int *, _QWORD, __int64 *, _QWORD, _QWORD); // [rsp+10h] [rbp-A8h]
  int **v59; // [rsp+18h] [rbp-A0h]
  unsigned __int64 v60; // [rsp+20h] [rbp-98h]
  unsigned int **v61; // [rsp+28h] [rbp-90h]
  __int64 *v62; // [rsp+40h] [rbp-78h]
  __int64 v63; // [rsp+48h] [rbp-70h]
  __int64 v64; // [rsp+50h] [rbp-68h]
  __int64 v65; // [rsp+68h] [rbp-50h] BYREF
  __int64 v66[9]; // [rsp+70h] [rbp-48h] BYREF

  v16 = 0LL;
  v59 = a5;
  v66[1] = __readfsqword(0x28u);
  v64 = a1 + 104;
  v63 = a2 + 48;
  v19 = *(_DWORD *)(a2 + 16);
  if ( (v19 & 1) == 0 )
  {
    v16 = *(__int64 (__fastcall **)(__int64, __int64, __int64 *, int *, _QWORD, __int64 *, _QWORD, _QWORD))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v16 = (__int64 (__fastcall *)(__int64, __int64, __int64 *, int *, _QWORD, __int64 *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v16, 17));
  }
  if ( !(_DWORD)a15 )
  {
    v20 = a5;
    if ( !a5 )
      v20 = (int **)a2;
    v21 = *v20;
    v60 = *(_QWORD *)(a2 + 8);
    v22 = 0LL;
    v65 = 0LL;
    if ( a6 )
      v22 = &v65;
    v62 = v22;
    if ( !a16 || (v45 = *(unsigned int **)(a2 + 32), v46 = *v45, (v47 = *v45 & 7) == 0) )
    {
LABEL_10:
      v55 = 0LL;
      v23 = a3;
      v24 = a6;
      v58 = v16;
      while ( 1 )
      {
        v25 = *v23;
        if ( v24 )
          v55 += *v24;
        v26 = v21;
        v27 = *v23;
        v28 = v60 - (_QWORD)v21;
        if ( (__int64)(v60 - (_QWORD)v21) > (char *)a4 - (char *)v25 )
          v28 = (char *)a4 - (char *)v25;
        v29 = v28 / 4;
        if ( v28 / 4 )
        {
          v30 = 0LL;
          v31 = v19 & 2;
          while ( 1 )
          {
            while ( 1 )
            {
              v32 = _byteswap_ulong(*v27);
              if ( v32 < 0 )
                break;
              ++v30;
              *v26 = v32;
              ++v27;
              ++v26;
              if ( v29 == v30 )
                goto LABEL_22;
            }
            if ( !v62 )
              break;
            if ( !v31 )
            {
              *v23 = v27;
              v33 = 6;
              goto LABEL_27;
            }
            ++v30;
            ++*v62;
            ++v27;
            if ( v29 == v30 )
              goto LABEL_22;
          }
          v26 = v21;
          v33 = 6;
        }
        else
        {
LABEL_22:
          *v23 = v27;
          v33 = 4;
          if ( v27 != a4 )
          {
            v33 = v60 < (unsigned __int64)(v26 + 1) ? 5 : 7;
            if ( v59 )
              goto LABEL_24;
            goto LABEL_28;
          }
        }
LABEL_27:
        if ( v59 )
        {
LABEL_24:
          v34 = v33;
          *v59 = v26;
          return v34;
        }
LABEL_28:
        ++*(_DWORD *)(a2 + 20);
        if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
        {
          *(_QWORD *)a2 = v26;
          v34 = v33;
          *v24 += v65;
          v39 = v23;
          goto LABEL_36;
        }
        if ( v21 >= v26 )
          goto LABEL_35;
        v61 = v23;
        v66[0] = *(_QWORD *)a2;
        sub_4F2B0((__int64)v58);
        v36 = v58(v64, v63, v66, v26, 0LL, v24, 0LL, a16);
        v23 = v61;
        if ( v36 == 4 )
        {
          if ( v33 != 5 )
          {
LABEL_35:
            v34 = v33;
            v39 = v23;
            goto LABEL_36;
          }
        }
        else
        {
          v37 = v66[0];
          v38 = (char *)a4 - (char *)v25;
          if ( (int *)v66[0] != v26 )
          {
            v50 = 0LL;
            if ( v24 )
              v50 = *v24;
            if ( v65 + v50 == v55 )
            {
              *v61 = (unsigned int *)((char *)*v61 - ((unsigned __int64)v26 - v66[0]));
            }
            else
            {
              *v61 = v25;
              v51 = *(_DWORD *)(a2 + 16);
              v52 = v21;
              if ( (__int64)(v37 - (_QWORD)v21) <= (char *)a4 - (char *)v25 )
                v38 = v37 - (_QWORD)v21;
              if ( v38 / 4 )
              {
                for ( i = 0LL; v38 / 4 != i; ++i )
                {
                  v54 = _byteswap_ulong(*v25);
                  if ( v54 >= 0 )
                  {
                    *v52++ = v54;
                  }
                  else
                  {
                    if ( !v62 )
                    {
                      if ( (int *)v37 != v21 )
LABEL_84:
                        sub_CF00(
                          (__int64)"outbuf == outerr",
                          (__int64)"../iconv/skeleton.c",
                          0x2EAu,
                          "__gconv_transform_ucs4_internal",
                          a7,
                          a8,
                          a9,
                          a10,
                          a11,
                          a12,
                          a13,
                          a14);
LABEL_74:
                      sub_CF00(
                        (__int64)"nstatus == __GCONV_FULL_OUTPUT",
                        (__int64)"../iconv/skeleton.c",
                        0x2EBu,
                        "__gconv_transform_ucs4_internal",
                        a7,
                        a8,
                        a9,
                        a10,
                        a11,
                        a12,
                        a13,
                        a14);
                    }
                    if ( (v51 & 2) == 0 )
                    {
                      *v61 = v25;
                      goto LABEL_73;
                    }
                    ++*v62;
                  }
                  ++v25;
                }
              }
              *v61 = v25;
              if ( v25 == a4 || v37 >= (unsigned __int64)(v52 + 1) )
              {
LABEL_73:
                if ( v52 != (int *)v37 )
                  goto LABEL_84;
                goto LABEL_74;
              }
              if ( v52 != (int *)v37 )
                goto LABEL_84;
              if ( v52 == v21 )
                --*(_DWORD *)(a2 + 20);
            }
          }
          if ( v36 )
          {
            v39 = v61;
            v34 = v36;
LABEL_36:
            if ( a16 && v34 == 7 )
            {
              v40 = *v39;
              v41 = (char *)a4 - (char *)*v39;
              if ( v41 > 4 )
                sub_CF00(
                  (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
                  (__int64)"../iconv/skeleton.c",
                  0x31Fu,
                  "__gconv_transform_ucs4_internal",
                  a7,
                  a8,
                  a9,
                  a10,
                  a11,
                  a12,
                  a13,
                  a14);
              v42 = *(_DWORD **)(a2 + 32);
              v43 = 0LL;
              if ( v41 )
              {
                do
                {
                  *((_BYTE *)v42 + v43 + 4) = *((_BYTE *)v40 + v43);
                  ++v43;
                }
                while ( v41 != v43 );
              }
              v44 = *v42 & 0xFFFFFFF8;
              *v39 = a4;
              *v42 = v44 | v41;
            }
            return v34;
          }
        }
        v21 = *(int **)a2;
        v55 = v65;
        v19 = *(_DWORD *)(a2 + 16);
      }
    }
    if ( v59 )
      sub_CF00(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x234u,
        "__gconv_transform_ucs4_internal",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    v48 = *a3;
    v49 = v47;
    if ( a4 > *a3 )
    {
      if ( (v46 & 4) != 0 )
      {
LABEL_50:
        if ( *((_BYTE *)v45 + 4) > 0x80u )
        {
          if ( (v19 & 2) == 0 )
          {
            v34 = 6;
            *a3 = (unsigned int *)((char *)v48 + v47 - v49);
            return v34;
          }
        }
        else
        {
          *((_BYTE *)++v21 - 4) = *((_BYTE *)v45 + 7);
          *((_BYTE *)v21 - 3) = *((_BYTE *)v45 + 6);
          *((_BYTE *)v21 - 2) = *((_BYTE *)v45 + 5);
          *((_BYTE *)v21 - 1) = *((_BYTE *)v45 + 4);
          v46 = *v45;
        }
        v19 = *(_DWORD *)(a2 + 16);
        *v45 = v46 & 0xFFFFFFF8;
        goto LABEL_10;
      }
      while ( 1 )
      {
        v48 = (unsigned int *)((char *)v48 + 1);
        ++v49;
        *a3 = v48;
        *((_BYTE *)v45 + v49 + 3) = *((_BYTE *)v48 - 1);
        if ( a4 == v48 )
          break;
        if ( v49 == 4 )
          goto LABEL_50;
      }
    }
    if ( v49 <= 3 )
    {
      v34 = 7;
      *v45 = v46 & 0xFFFFFFF8 | v49;
      return v34;
    }
    goto LABEL_50;
  }
  if ( a5 )
    sub_CF00(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x1A4u,
      "__gconv_transform_ucs4_internal",
      a7,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14);
  v34 = 0;
  **(_QWORD **)(a2 + 32) = 0LL;
  if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
    return v34;
  sub_4F2B0((__int64)v16);
  return ((__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD, __int64 *, __int64))v16)(
           v64,
           v63,
           0LL,
           0LL,
           0LL,
           a6,
           a15);
}
// 5401C: variable 'a11' is possibly undefined
// 5401C: variable 'a12' is possibly undefined

//----- (0000000000054110) ----------------------------------------------------
__int64 __fastcall sub_54110(__int64 a1, unsigned __int64 *a2, unsigned __int64 *a3, unsigned __int64 a4, unsigned __int64 *a5, __int64 *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16)
{
  unsigned __int64 *v17; // rax
  unsigned __int64 v18; // r14
  unsigned __int64 *v19; // r15
  unsigned __int64 v20; // rbp
  unsigned __int64 v21; // r13
  unsigned int v22; // er12
  __int64 v23; // rax
  __int64 v24; // rdx
  unsigned __int64 v25; // rdx
  unsigned __int64 v26; // rax
  double v27; // xmm4_8
  double v28; // xmm5_8
  unsigned __int64 v29; // r14
  unsigned int v30; // er8
  unsigned __int64 v31; // r12
  unsigned __int64 *v32; // rbp
  int *v34; // rcx
  int v35; // edi
  unsigned __int64 v36; // rdx
  unsigned __int64 v37; // rax
  unsigned __int64 v38; // r14
  __int64 v39; // rax
  __int64 v40; // rax
  __int64 v41; // rdx
  unsigned __int64 v42; // rdx
  __int64 v43; // rax
  unsigned __int64 v44; // rdi
  unsigned __int64 v45; // rdx
  _DWORD *v46; // rsi
  __int64 v47; // rax
  unsigned __int64 v50; // [rsp+10h] [rbp-88h]
  __int64 (__fastcall *v51)(__int64, __int64 *, __int64 *, unsigned __int64, _QWORD, __int64 *, _QWORD, _QWORD); // [rsp+18h] [rbp-80h]
  __int64 v52; // [rsp+20h] [rbp-78h]
  unsigned int v53; // [rsp+20h] [rbp-78h]
  unsigned __int64 *v54; // [rsp+28h] [rbp-70h]
  __int64 *v55; // [rsp+40h] [rbp-58h]
  __int64 v56; // [rsp+48h] [rbp-50h]
  __int64 v57[9]; // [rsp+50h] [rbp-48h] BYREF

  v54 = a5;
  v57[1] = __readfsqword(0x28u);
  v51 = 0LL;
  v56 = a1 + 104;
  v55 = (__int64 *)(a2 + 6);
  if ( (a2[2] & 1) == 0 )
  {
    v51 = *(__int64 (__fastcall **)(__int64, __int64 *, __int64 *, unsigned __int64, _QWORD, __int64 *, _QWORD, _QWORD))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v51 = (__int64 (__fastcall *)(__int64, __int64 *, __int64 *, unsigned __int64, _QWORD, __int64 *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(*(_QWORD *)(a1 + 144), 17));
  }
  if ( !(_DWORD)a15 )
  {
    v17 = a5;
    if ( !a5 )
      v17 = a2;
    v18 = *v17;
    v50 = a2[1];
    if ( !a16 || (v34 = (int *)a2[4], v35 = *v34, LODWORD(v36) = *v34 & 7, !(_DWORD)v36) )
    {
      v19 = a3;
      v20 = *v17;
      goto LABEL_9;
    }
    if ( a5 )
      sub_CF00(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x234u,
        "__gconv_transform_internal_ucs4le",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    v37 = *a3;
    v36 = (int)v36;
    if ( *a3 < a4 )
    {
      if ( (v35 & 4) != 0 )
      {
LABEL_37:
        v38 = v18 + 4;
        v19 = a3;
        *(_BYTE *)(v38 - 4) = *((_BYTE *)v34 + 4);
        *(_BYTE *)(v38 - 3) = *((_BYTE *)v34 + 5);
        *(_BYTE *)(v38 - 2) = *((_BYTE *)v34 + 6);
        *(_BYTE *)(v38 - 1) = *((_BYTE *)v34 + 7);
        v20 = v38;
        *v34 &= 0xFFFFFFF8;
        while ( 1 )
        {
LABEL_9:
          v21 = *v19;
          v52 = 0LL;
          if ( a6 )
            v52 = *a6;
          v22 = 4;
          v23 = v50 - v20;
          if ( (__int64)(v50 - v20) > (__int64)(a4 - v21) )
            v23 = a4 - v21;
          v24 = v23 + 3;
          if ( v23 >= 0 )
            v24 = v23;
          v25 = v24 & 0xFFFFFFFFFFFFFFFCLL;
          *v19 = v21 + v25;
          v26 = sub_91D0(v20, v21, v25);
          v29 = v26;
          if ( a4 != *v19 )
            v22 = v50 < v26 + 4 ? 5 : 7;
          if ( v54 )
          {
            *v54 = v26;
            return v22;
          }
          ++*((_DWORD *)a2 + 5);
          if ( (a2[2] & 1) != 0 )
          {
            *a2 = v26;
            v32 = v19;
            goto LABEL_26;
          }
          if ( v26 <= v20 )
            goto LABEL_25;
          v57[0] = *a2;
          sub_4F2B0((__int64)v51);
          v30 = v51(v56, v55, v57, v29, 0LL, a6, 0LL, a16);
          if ( v30 == 4 )
          {
            if ( v22 != 5 )
            {
LABEL_25:
              v32 = v19;
              goto LABEL_26;
            }
          }
          else
          {
            v31 = v57[0];
            if ( v57[0] != v29 )
            {
              v39 = 0LL;
              if ( a6 )
                v39 = *a6;
              if ( v39 == v52 )
              {
                *v19 -= v29 - v57[0];
              }
              else
              {
                v40 = a4 - v21;
                v53 = v30;
                if ( (__int64)(v57[0] - v20) <= (__int64)(a4 - v21) )
                  v40 = v57[0] - v20;
                v41 = v40 + 3;
                if ( v40 >= 0 )
                  v41 = v40;
                v42 = v41 & 0xFFFFFFFFFFFFFFFCLL;
                *v19 = v21 + v42;
                v43 = sub_91D0(v20, v21, v42);
                v30 = v53;
                if ( a4 == *v19 )
                {
                  if ( v57[0] != v43 )
LABEL_64:
                    sub_CF00(
                      (__int64)"outbuf == outerr",
                      (__int64)"../iconv/skeleton.c",
                      0x2EAu,
                      "__gconv_transform_internal_ucs4le",
                      a7,
                      a8,
                      a9,
                      a10,
                      v27,
                      v28,
                      a13,
                      a14);
LABEL_57:
                  sub_CF00(
                    (__int64)"nstatus == __GCONV_FULL_OUTPUT",
                    (__int64)"../iconv/skeleton.c",
                    0x2EBu,
                    "__gconv_transform_internal_ucs4le",
                    a7,
                    a8,
                    a9,
                    a10,
                    v27,
                    v28,
                    a13,
                    a14);
                }
                if ( v31 >= v43 + 4 )
                {
                  if ( v43 != v57[0] )
                    goto LABEL_64;
                  goto LABEL_57;
                }
                if ( v43 != v57[0] )
                  goto LABEL_64;
                if ( v20 == v43 )
                  --*((_DWORD *)a2 + 5);
              }
            }
            if ( v30 )
            {
              v32 = v19;
              v22 = v30;
LABEL_26:
              if ( v22 == 7 && a16 )
              {
                v44 = *v32;
                v45 = a4 - *v32;
                if ( v45 > 4 )
                  sub_CF00(
                    (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
                    (__int64)"../iconv/skeleton.c",
                    0x31Fu,
                    "__gconv_transform_internal_ucs4le",
                    a7,
                    a8,
                    a9,
                    a10,
                    v27,
                    v28,
                    a13,
                    a14);
                v46 = (_DWORD *)a2[4];
                v47 = 0LL;
                if ( v45 )
                {
                  do
                  {
                    *((_BYTE *)v46 + v47 + 4) = *(_BYTE *)(v44 + v47);
                    ++v47;
                  }
                  while ( v45 != v47 );
                }
                v22 = 7;
                *v32 = a4;
                *v46 = *v46 & 0xFFFFFFF8 | v45;
              }
              return v22;
            }
          }
          v20 = *a2;
        }
      }
      while ( 1 )
      {
        ++v37;
        ++v36;
        *a3 = v37;
        *((_BYTE *)v34 + v36 + 3) = *(_BYTE *)(v37 - 1);
        if ( a4 == v37 )
          break;
        if ( v36 == 4 )
          goto LABEL_37;
      }
    }
    if ( v36 <= 3 )
    {
      v22 = 7;
      *v34 = v35 & 0xFFFFFFF8 | v36;
      return v22;
    }
    goto LABEL_37;
  }
  if ( a5 )
    sub_CF00(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x1A4u,
      "__gconv_transform_internal_ucs4le",
      a7,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14);
  v22 = 0;
  *(_QWORD *)a2[4] = 0LL;
  if ( (a2[2] & 1) != 0 )
    return v22;
  sub_4F2B0((__int64)v51);
  return ((__int64 (__fastcall *)(__int64, __int64 *, _QWORD, _QWORD, _QWORD, __int64 *, __int64))v51)(
           v56,
           v55,
           0LL,
           0LL,
           0LL,
           a6,
           a15);
}
// 54523: variable 'v27' is possibly undefined
// 54523: variable 'v28' is possibly undefined
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);

//----- (0000000000054630) ----------------------------------------------------
__int64 __fastcall sub_54630(__int64 a1, __int64 a2, unsigned __int64 *a3, unsigned __int64 a4, _QWORD *a5, _QWORD *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16)
{
  __int64 (__fastcall *v16)(__int64, __int64, __int64 *, _DWORD *, _QWORD, _QWORD *, _QWORD, _QWORD); // r15
  __int64 v19; // rax
  int v20; // esi
  _QWORD *v21; // rax
  _DWORD *v22; // rbp
  unsigned __int64 v23; // rax
  __int64 *v24; // rax
  __int64 *v25; // r11
  __int64 *v26; // r10
  unsigned __int64 *v27; // r11
  _QWORD *v28; // r13
  _DWORD *v29; // r12
  _DWORD *v30; // r15
  signed __int64 v31; // r14
  __int64 v32; // rax
  __int64 v33; // r8
  int *v34; // rax
  __int64 v35; // r8
  __int64 v36; // rdx
  int v37; // esi
  unsigned int v39; // eax
  unsigned __int64 v40; // rdx
  unsigned __int64 *v41; // r13
  unsigned __int64 v42; // rsi
  unsigned __int64 v43; // rax
  _DWORD *v44; // rcx
  __int64 v45; // rdx
  unsigned int v46; // edx
  unsigned int *v47; // rcx
  unsigned int v48; // er8
  unsigned __int64 v49; // rdx
  _DWORD *v50; // rax
  _QWORD *v51; // r9
  __int64 v52; // rsi
  int v53; // esi
  _DWORD *v54; // rcx
  __int64 i; // rdi
  __int64 v56; // [rsp+0h] [rbp-A8h]
  __int64 (__fastcall *v59)(__int64, __int64, __int64 *, _DWORD *, _QWORD, _QWORD *, _QWORD, _QWORD); // [rsp+10h] [rbp-98h]
  _QWORD *v60; // [rsp+18h] [rbp-90h]
  __int64 *v61; // [rsp+20h] [rbp-88h]
  unsigned __int64 *v62; // [rsp+28h] [rbp-80h]
  unsigned __int64 v63; // [rsp+30h] [rbp-78h]
  unsigned int v64; // [rsp+38h] [rbp-70h]
  __int64 v65; // [rsp+40h] [rbp-68h]
  __int64 v66; // [rsp+48h] [rbp-60h]
  __int64 v67; // [rsp+58h] [rbp-50h] BYREF
  __int64 v68[9]; // [rsp+60h] [rbp-48h] BYREF

  v16 = 0LL;
  v60 = a5;
  v68[1] = __readfsqword(0x28u);
  v66 = a1 + 104;
  v19 = a2 + 48;
  v20 = *(_DWORD *)(a2 + 16);
  v65 = v19;
  if ( (v20 & 1) == 0 )
  {
    v16 = *(__int64 (__fastcall **)(__int64, __int64, __int64 *, _DWORD *, _QWORD, _QWORD *, _QWORD, _QWORD))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v16 = (__int64 (__fastcall *)(__int64, __int64, __int64 *, _DWORD *, _QWORD, _QWORD *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v16, 17));
  }
  if ( !(_DWORD)a15 )
  {
    v21 = a5;
    if ( !a5 )
      v21 = (_QWORD *)a2;
    v22 = (_DWORD *)*v21;
    v23 = *(_QWORD *)(a2 + 8);
    v67 = 0LL;
    v63 = v23;
    v24 = 0LL;
    if ( a6 )
      v24 = &v67;
    v25 = v24;
    if ( !a16 || (v47 = *(unsigned int **)(a2 + 32), v48 = *v47, LODWORD(v49) = *v47 & 7, !(_DWORD)v49) )
    {
LABEL_10:
      v59 = v16;
      v56 = 0LL;
      v26 = v25;
      v27 = a3;
      v28 = a6;
      while ( 1 )
      {
        v29 = (_DWORD *)*v27;
        if ( v28 )
          v56 += *v28;
        v30 = v22;
        v31 = a4 - (_QWORD)v29;
        v32 = v63 - (_QWORD)v22;
        if ( (__int64)(v63 - (_QWORD)v22) > (__int64)(a4 - (_QWORD)v29) )
          v32 = a4 - (_QWORD)v29;
        v33 = v32 + 3;
        if ( v32 >= 0 )
          v33 = v32;
        v34 = (int *)*v27;
        v35 = v33 >> 2;
        if ( v35 )
          break;
LABEL_24:
        *v27 = (unsigned __int64)v34;
        if ( (int *)a4 == v34 )
        {
          v64 = 4;
          goto LABEL_31;
        }
        if ( a4 < (unsigned __int64)(v34 + 1) )
        {
          v64 = 7;
          goto LABEL_31;
        }
        if ( v63 >= (unsigned __int64)(v30 + 1) )
          goto LABEL_96;
        v64 = 5;
        if ( v60 )
        {
LABEL_28:
          *v60 = v30;
          return v64;
        }
LABEL_32:
        ++*(_DWORD *)(a2 + 20);
        if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
        {
          v51 = v28;
          *(_QWORD *)a2 = v30;
          v41 = v27;
          *v51 += v67;
          goto LABEL_40;
        }
        v61 = v26;
        if ( v22 >= v30 )
          goto LABEL_39;
        v62 = v27;
        v68[0] = *(_QWORD *)a2;
        sub_4F2B0((__int64)v59);
        v39 = v59(v66, v65, v68, v30, 0LL, v28, 0LL, a16);
        v27 = v62;
        v26 = v61;
        if ( v39 == 4 )
        {
          if ( v64 != 5 )
          {
LABEL_39:
            v41 = v27;
            goto LABEL_40;
          }
        }
        else
        {
          v40 = v68[0];
          if ( (_DWORD *)v68[0] != v30 )
          {
            v52 = 0LL;
            if ( v28 )
              v52 = *v28;
            if ( v67 + v52 == v56 )
            {
              *v62 -= (unsigned __int64)v30 - v68[0];
            }
            else
            {
              *v62 = (unsigned __int64)v29;
              v53 = *(_DWORD *)(a2 + 16);
              if ( (__int64)(v40 - (_QWORD)v22) <= v31 )
                v31 = v40 - (_QWORD)v22;
              v54 = v22;
              if ( v31 / 4 )
              {
                for ( i = 0LL; v31 / 4 != i; ++i )
                {
                  if ( (int)*v29 >= 0 )
                  {
                    *v54++ = *v29;
                  }
                  else
                  {
                    if ( !v61 )
                    {
                      if ( (_DWORD *)v40 != v22 )
LABEL_91:
                        sub_CF00(
                          (__int64)"outbuf == outerr",
                          (__int64)"../iconv/skeleton.c",
                          0x2EAu,
                          "__gconv_transform_ucs4le_internal",
                          a7,
                          a8,
                          a9,
                          a10,
                          a11,
                          a12,
                          a13,
                          a14);
LABEL_80:
                      sub_CF00(
                        (__int64)"nstatus == __GCONV_FULL_OUTPUT",
                        (__int64)"../iconv/skeleton.c",
                        0x2EBu,
                        "__gconv_transform_ucs4le_internal",
                        a7,
                        a8,
                        a9,
                        a10,
                        a11,
                        a12,
                        a13,
                        a14);
                    }
                    if ( (v53 & 2) == 0 )
                    {
                      *v62 = (unsigned __int64)v29;
                      goto LABEL_79;
                    }
                    ++*v61;
                  }
                  ++v29;
                }
              }
              *v62 = (unsigned __int64)v29;
              if ( v29 == (_DWORD *)a4 || a4 < (unsigned __int64)(v29 + 1) )
              {
LABEL_79:
                if ( v54 != (_DWORD *)v40 )
                  goto LABEL_91;
                goto LABEL_80;
              }
              if ( v40 >= (unsigned __int64)(v54 + 1) )
LABEL_96:
                sub_CF00(
                  (__int64)"*outptrp + 4 > outend",
                  (__int64)"gconv_simple.c",
                  0x29Au,
                  "ucs4le_internal_loop",
                  a7,
                  a8,
                  a9,
                  a10,
                  a11,
                  a12,
                  a13,
                  a14);
              if ( v54 != (_DWORD *)v40 )
                goto LABEL_91;
              if ( v54 == v22 )
                --*(_DWORD *)(a2 + 20);
            }
          }
          if ( v39 )
          {
            v64 = v39;
            v41 = v62;
LABEL_40:
            if ( a16 && v64 == 7 )
            {
              v42 = *v41;
              v43 = a4 - *v41;
              if ( v43 > 4 )
                sub_CF00(
                  (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
                  (__int64)"../iconv/skeleton.c",
                  0x31Fu,
                  "__gconv_transform_ucs4le_internal",
                  a7,
                  a8,
                  a9,
                  a10,
                  a11,
                  a12,
                  a13,
                  a14);
              v44 = *(_DWORD **)(a2 + 32);
              v45 = 0LL;
              if ( v43 )
              {
                do
                {
                  *((_BYTE *)v44 + v45 + 4) = *(_BYTE *)(v42 + v45);
                  ++v45;
                }
                while ( v43 != v45 );
              }
              v46 = *v44 & 0xFFFFFFF8;
              *v41 = a4;
              *v44 = v46 | v43;
            }
            return v64;
          }
        }
        v22 = *(_DWORD **)a2;
        v20 = *(_DWORD *)(a2 + 16);
        v56 = v67;
      }
      v36 = 0LL;
      v37 = v20 & 2;
      while ( 1 )
      {
        while ( *v34 >= 0 )
        {
          ++v36;
          *v30++ = *v34++;
          if ( v35 == v36 )
            goto LABEL_24;
        }
        if ( !v26 )
          break;
        if ( !v37 )
        {
          *v27 = (unsigned __int64)v34;
          v64 = 6;
          goto LABEL_31;
        }
        ++v36;
        ++*v26;
        ++v34;
        if ( v35 == v36 )
          goto LABEL_24;
      }
      v64 = 6;
      v30 = v22;
LABEL_31:
      if ( v60 )
        goto LABEL_28;
      goto LABEL_32;
    }
    if ( v60 )
      sub_CF00(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x234u,
        "__gconv_transform_ucs4le_internal",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    v50 = (_DWORD *)*a3;
    v49 = (int)v49;
    if ( a4 > *a3 )
    {
      if ( (v48 & 4) != 0 )
      {
LABEL_56:
        if ( *((_BYTE *)v47 + 7) > 0x80u )
        {
          if ( (v20 & 2) == 0 )
            return 6;
        }
        else
        {
          *((_BYTE *)++v22 - 4) = *((_BYTE *)v47 + 4);
          *((_BYTE *)v22 - 3) = *((_BYTE *)v47 + 5);
          *((_BYTE *)v22 - 2) = *((_BYTE *)v47 + 6);
          *((_BYTE *)v22 - 1) = *((_BYTE *)v47 + 7);
          v48 = *v47;
        }
        v20 = *(_DWORD *)(a2 + 16);
        *v47 = v48 & 0xFFFFFFF8;
        goto LABEL_10;
      }
      while ( 1 )
      {
        v50 = (_DWORD *)((char *)v50 + 1);
        ++v49;
        *a3 = (unsigned __int64)v50;
        *((_BYTE *)v47 + v49 + 3) = *((_BYTE *)v50 - 1);
        if ( (_DWORD *)a4 == v50 )
          break;
        if ( v49 == 4 )
          goto LABEL_56;
      }
    }
    if ( v49 <= 3 )
    {
      v64 = 7;
      *v47 = v48 & 0xFFFFFFF8 | v49;
      return v64;
    }
    goto LABEL_56;
  }
  if ( a5 )
    sub_CF00(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x1A4u,
      "__gconv_transform_ucs4le_internal",
      a7,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14);
  v64 = 0;
  **(_QWORD **)(a2 + 32) = 0LL;
  if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
    return v64;
  sub_4F2B0((__int64)v16);
  return ((__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD, _QWORD *, __int64))v16)(
           v66,
           v65,
           0LL,
           0LL,
           0LL,
           a6,
           a15);
}
// 54B3E: variable 'a11' is possibly undefined
// 54B3E: variable 'a12' is possibly undefined

//----- (0000000000054C60) ----------------------------------------------------
__int64 __fastcall sub_54C60(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, _QWORD *a5, _QWORD *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16)
{
  int v18; // er8
  _QWORD *v19; // rax
  unsigned __int64 v20; // r13
  _DWORD *v21; // r14
  __int64 *v22; // rax
  __int64 v23; // r11
  __int64 v24; // r15
  _DWORD *v25; // rcx
  __int64 v26; // rax
  _DWORD *v27; // rbx
  unsigned int v28; // er10
  int v29; // er8
  int v30; // edx
  __int64 v31; // rsi
  unsigned int v32; // eax
  double v33; // xmm4_8
  double v34; // xmm5_8
  unsigned __int64 v35; // rdx
  __int64 v37; // rcx
  int v38; // er10
  _DWORD *v39; // r8
  __int64 v40; // rcx
  _DWORD *v41; // rdi
  int v42; // er10
  int v43; // esi
  __int64 v44; // r11
  _QWORD *v46; // [rsp+8h] [rbp-A0h]
  __int64 (__fastcall *v47)(__int64, __int64, _QWORD, _QWORD, _QWORD, _QWORD *, __int64); // [rsp+10h] [rbp-98h]
  _QWORD *v49; // [rsp+20h] [rbp-88h]
  __int64 v50; // [rsp+28h] [rbp-80h]
  __int64 v51; // [rsp+30h] [rbp-78h]
  __int64 v52; // [rsp+38h] [rbp-70h]
  unsigned int v53; // [rsp+40h] [rbp-68h]
  __int64 *v54; // [rsp+48h] [rbp-60h]
  __int64 v55; // [rsp+58h] [rbp-50h] BYREF
  __int64 v56[9]; // [rsp+60h] [rbp-48h] BYREF

  v18 = *(_DWORD *)(a2 + 16);
  v56[1] = __readfsqword(0x28u);
  v47 = 0LL;
  v52 = a1 + 104;
  v51 = a2 + 48;
  if ( (v18 & 1) == 0 )
  {
    v47 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD, _QWORD, _QWORD *, __int64))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v47 = (__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD, _QWORD *, __int64))(__readfsqword(0x30u) ^ __ROR8__(*(_QWORD *)(a1 + 144), 17));
  }
  if ( !(_DWORD)a15 )
  {
    v19 = a5;
    v20 = *(_QWORD *)(a2 + 8);
    if ( !a5 )
      v19 = (_QWORD *)a2;
    v21 = (_DWORD *)*v19;
    v22 = 0LL;
    v55 = 0LL;
    if ( a6 )
      v22 = &v55;
    v23 = 0LL;
    v54 = v22;
    while ( 1 )
    {
      v24 = *a3;
      if ( a6 )
        v23 += *a6;
      if ( a4 == v24 )
        break;
      v25 = v21 + 1;
      if ( v20 < (unsigned __int64)(v21 + 1) )
      {
        v31 = *a3;
        v27 = v21;
        v28 = 5;
        goto LABEL_21;
      }
      v26 = v24 + 1;
      v27 = v21;
      v28 = 4;
      v29 = v18 & 2;
      do
      {
        v30 = *(unsigned __int8 *)(v26 - 1);
        v31 = v26;
        if ( (v30 & 0x80u) == 0 )
        {
          *v27 = v30;
          v27 = v25;
          if ( a4 == v26 )
            goto LABEL_21;
        }
        else
        {
          if ( !v54 || !v29 )
          {
            v31 = v26 - 1;
            v28 = 6;
            goto LABEL_21;
          }
          ++*v54;
          v28 = 6;
          if ( a4 == v26 )
            goto LABEL_21;
        }
        v25 = v27 + 1;
        ++v26;
      }
      while ( v20 >= (unsigned __int64)(v27 + 1) );
      v28 = 5;
      *a3 = v31;
      if ( a5 )
      {
LABEL_29:
        *a5 = v27;
        return v28;
      }
LABEL_22:
      ++*(_DWORD *)(a2 + 20);
      if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
      {
        *(_QWORD *)a2 = v27;
        *a6 += v55;
        return v28;
      }
      v49 = a6;
      v50 = v23;
      if ( v27 <= v21 )
        return v28;
      v53 = v28;
      v56[0] = *(_QWORD *)a2;
      sub_4F2B0((__int64)v47);
      v32 = ((__int64 (__fastcall *)(__int64, __int64, __int64 *, _DWORD *, _QWORD, _QWORD *, _QWORD, _QWORD))v47)(
              v52,
              v51,
              v56,
              v27,
              0LL,
              v49,
              0LL,
              a16);
      a6 = v49;
      v28 = v53;
      if ( v32 == 4 )
      {
        if ( v53 != 5 )
          return v28;
      }
      else
      {
        v35 = v56[0];
        if ( v27 != (_DWORD *)v56[0] )
        {
          v37 = 0LL;
          if ( v49 )
            v37 = *v49;
          if ( v55 + v37 == v50 )
          {
            *a3 -= ((__int64)v27 - v56[0]) / 4;
          }
          else
          {
            v38 = *(_DWORD *)(a2 + 16);
            *a3 = v24;
            if ( a4 == v24 )
            {
              v44 = a4;
              v41 = v21;
LABEL_47:
              *a3 = v44;
              if ( v41 == (_DWORD *)v35 )
                sub_CF00(
                  (__int64)"nstatus == __GCONV_FULL_OUTPUT",
                  (__int64)"../iconv/skeleton.c",
                  0x2EBu,
                  "__gconv_transform_ascii_internal",
                  a7,
                  a8,
                  a9,
                  a10,
                  v33,
                  v34,
                  a13,
                  a14);
LABEL_48:
              sub_CF00(
                (__int64)"outbuf == outerr",
                (__int64)"../iconv/skeleton.c",
                0x2EAu,
                "__gconv_transform_ascii_internal",
                a7,
                a8,
                a9,
                a10,
                v33,
                v34,
                a13,
                a14);
            }
            v39 = v21 + 1;
            if ( v35 >= (unsigned __int64)(v21 + 1) )
            {
              v40 = v24 + 1;
              v41 = v21;
              v42 = v38 & 2;
              while ( 1 )
              {
                v43 = *(unsigned __int8 *)(v40 - 1);
                v44 = v40 - 1;
                v24 = v40;
                if ( (v43 & 0x80u) == 0 )
                {
                  *v41 = v43;
                  v41 = v39;
                }
                else
                {
                  if ( !v54 || !v42 )
                    goto LABEL_47;
                  ++*v54;
                }
                if ( a4 == v40 )
                  break;
                v39 = v41 + 1;
                ++v40;
                if ( v35 < (unsigned __int64)(v41 + 1) )
                  goto LABEL_55;
              }
              v44 = a4;
              goto LABEL_47;
            }
            v41 = v21;
LABEL_55:
            *a3 = v24;
            if ( v41 != (_DWORD *)v35 )
              goto LABEL_48;
            if ( v41 == v21 )
              --*(_DWORD *)(a2 + 20);
          }
        }
        if ( v32 )
          return v32;
      }
      v21 = *(_DWORD **)a2;
      v23 = v55;
      v18 = *(_DWORD *)(a2 + 16);
    }
    v31 = a4;
    v27 = v21;
    v28 = 4;
LABEL_21:
    *a3 = v31;
    if ( a5 )
      goto LABEL_29;
    goto LABEL_22;
  }
  if ( a5 )
    sub_CF00(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x1A4u,
      "__gconv_transform_ascii_internal",
      a7,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14);
  v28 = 0;
  **(_QWORD **)(a2 + 32) = 0LL;
  if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
    return v28;
  v46 = a6;
  sub_4F2B0((__int64)v47);
  return v47(v52, v51, 0LL, 0LL, 0LL, v46, a15);
}
// 54FBD: variable 'v33' is possibly undefined
// 54FBD: variable 'v34' is possibly undefined

//----- (0000000000055100) ----------------------------------------------------
__int64 __fastcall sub_55100(_QWORD *a1, __int64 a2, __int64 *a3, unsigned __int64 a4, _QWORD *a5, __int64 *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16)
{
  __int64 *v16; // r13
  int v19; // er14
  unsigned int *v20; // r12
  _BYTE **v21; // rax
  _BYTE *v22; // r11
  unsigned __int64 v23; // rax
  __int64 *v24; // rax
  unsigned __int64 v25; // r15
  unsigned __int64 v26; // r11
  __int64 v27; // r10
  _BYTE *v28; // rcx
  unsigned int *v29; // rax
  int v30; // er13
  int v31; // er14
  unsigned int *v32; // rdx
  unsigned int v33; // eax
  int v34; // eax
  int v35; // er14
  unsigned __int64 v36; // r13
  unsigned int v37; // er15
  unsigned int v39; // eax
  unsigned __int64 v40; // r10
  unsigned int *v41; // rax
  char v42; // dl
  unsigned __int64 v43; // rdi
  unsigned int *v44; // rcx
  unsigned int *v45; // rax
  signed __int64 v46; // rax
  unsigned int v47; // edx
  signed __int64 v48; // rcx
  __int64 v49; // r11
  unsigned int *v50; // rax
  __int64 v51; // rdi
  unsigned __int64 v52; // rdx
  _DWORD *v53; // rcx
  __int64 v54; // rax
  int v55; // eax
  __int64 v56; // rax
  int v57; // er10
  _BYTE *v58; // rax
  int v59; // er10
  unsigned int v60; // edx
  unsigned int *v61; // rcx
  __int64 v62; // rdx
  unsigned int *v63; // r12
  unsigned __int64 v64; // rax
  unsigned int *v65; // r12
  char v66; // dl
  int v67; // esi
  signed int v68; // eax
  __int64 v69; // rax
  __int64 v70; // rdx
  unsigned __int64 v72; // [rsp+10h] [rbp-D8h]
  __int64 *v73; // [rsp+10h] [rbp-D8h]
  _QWORD *v74; // [rsp+18h] [rbp-D0h]
  _BYTE *v75; // [rsp+20h] [rbp-C8h]
  unsigned int *v76; // [rsp+20h] [rbp-C8h]
  unsigned __int64 v77; // [rsp+20h] [rbp-C8h]
  unsigned __int64 v78; // [rsp+20h] [rbp-C8h]
  unsigned __int64 v79; // [rsp+28h] [rbp-C0h]
  __int64 v80; // [rsp+28h] [rbp-C0h]
  int v81; // [rsp+28h] [rbp-C0h]
  __int64 v82; // [rsp+30h] [rbp-B8h]
  __int64 (__fastcall *v83)(_QWORD *, __int64, _BYTE **, _BYTE *, _QWORD, __int64 *, _QWORD, _QWORD); // [rsp+40h] [rbp-A8h]
  _QWORD *v84; // [rsp+48h] [rbp-A0h]
  __int64 v85; // [rsp+50h] [rbp-98h]
  __int64 *v86; // [rsp+58h] [rbp-90h]
  __int64 *v88; // [rsp+68h] [rbp-80h]
  unsigned __int64 v89; // [rsp+70h] [rbp-78h]
  _BYTE *v90; // [rsp+78h] [rbp-70h]
  __int64 v91; // [rsp+80h] [rbp-68h] BYREF
  _BYTE *v92; // [rsp+88h] [rbp-60h] BYREF
  char *v93; // [rsp+90h] [rbp-58h] BYREF
  _BYTE *v94; // [rsp+98h] [rbp-50h] BYREF
  char v95; // [rsp+A3h] [rbp-45h]
  unsigned int v96; // [rsp+A4h] [rbp-44h] BYREF
  __int64 v97[8]; // [rsp+A8h] [rbp-40h] BYREF

  v16 = a6;
  v19 = *(_DWORD *)(a2 + 16);
  v74 = a5;
  v97[0] = __readfsqword(0x28u);
  v83 = 0LL;
  v84 = a1 + 13;
  v85 = a2 + 48;
  if ( (v19 & 1) == 0 )
  {
    v83 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))a1[18];
    if ( a1[13] )
      v83 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(a1[18], 17));
  }
  if ( !(_DWORD)a15 )
  {
    v20 = (unsigned int *)*a3;
    v21 = (_BYTE **)a5;
    if ( !a5 )
      v21 = (_BYTE **)a2;
    v22 = *v21;
    v23 = *(_QWORD *)(a2 + 8);
    v91 = 0LL;
    v72 = v23;
    v24 = 0LL;
    if ( a6 )
      v24 = &v91;
    v86 = v24;
    if ( !a16 || (v76 = *(unsigned int **)(a2 + 32), (v39 = *v76 & 7) == 0) )
    {
      v25 = (unsigned __int64)v22;
      v26 = v72;
      v73 = a6;
      v27 = 0LL;
      goto LABEL_11;
    }
    if ( a5 )
      sub_CF00(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x234u,
        "__gconv_transform_internal_ascii",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    v93 = (char *)v20;
    v94 = v22;
    if ( v39 > 4 )
      sub_CF00(
        (__int64)"(state->__count & 7) <= sizeof (state->__value)",
        (__int64)"../iconv/loop.c",
        0x18Bu,
        "internal_ascii_loop_single",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    v40 = 0LL;
    do
    {
      *((_BYTE *)&v96 + v40) = *((_BYTE *)v76 + v40 + 4);
      ++v40;
    }
    while ( v40 < (*v76 & 7) );
    if ( a4 < (unsigned __int64)v20 - v40 + 4 )
    {
      *a3 = a4;
      v64 = v40 + a4 - (_QWORD)v20;
      if ( v64 > 4 )
        sub_CF00(
          (__int64)"inlen_after <= sizeof (state->__value.__wchb)",
          (__int64)"../iconv/loop.c",
          0x1A8u,
          "internal_ascii_loop_single",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      v65 = (unsigned int *)((char *)v20 + 1);
      if ( v40 < v64 )
      {
        do
        {
          v93 = (char *)v65;
          v66 = *((_BYTE *)v65 - 1);
          v65 = (unsigned int *)((char *)v65 + 1);
          *((_BYTE *)v76 + v40++ + 4) = v66;
        }
        while ( v64 != v40 );
      }
    }
    else
    {
      v41 = (unsigned int *)((char *)v20 + 1);
      v37 = 5;
      if ( (unsigned __int64)v22 >= v72 )
        return v37;
      do
      {
        v93 = (char *)v41;
        v42 = *((_BYTE *)v41 - 1);
        v43 = v40++;
        v44 = v41;
        v41 = (unsigned int *)((char *)v41 + 1);
        *(&v95 + v40) = v42;
      }
      while ( v40 <= 3 && a4 > (unsigned __int64)v44 );
      v93 = (char *)&v96;
      if ( v96 <= 0x7F )
      {
        v94 = v22 + 1;
        *v22 = v96;
        v45 = (unsigned int *)(v93 + 4);
        v93 = (char *)v45;
        if ( v45 != &v96 )
        {
LABEL_49:
          v46 = (char *)v45 - (char *)&v96;
LABEL_50:
          v47 = *v76;
          v48 = *v76 & 7;
          if ( v48 >= v46 )
            sub_CF00(
              (__int64)"inptr - bytebuf > (state->__count & 7)",
              (__int64)"../iconv/loop.c",
              0x1CBu,
              "internal_ascii_loop_single",
              a7,
              a8,
              a9,
              a10,
              a11,
              a12,
              a13,
              a14);
          v19 = *(_DWORD *)(a2 + 16);
          v49 = (__int64)v94;
          v27 = v91;
          v50 = (unsigned int *)(*a3 + v46 - v48);
          *a3 = (__int64)v50;
          v20 = v50;
          v25 = v49;
          v26 = v72;
          v73 = v16;
          *v76 = v47 & 0xFFFFFFF8;
          goto LABEL_11;
        }
LABEL_97:
        v25 = (unsigned __int64)v22;
        v27 = v91;
        v26 = v72;
        v19 = *(_DWORD *)(a2 + 16);
        v73 = v16;
        v20 = (unsigned int *)*a3;
LABEL_11:
        if ( v73 )
          v27 += *v73;
        v93 = (char *)v20;
        v28 = (_BYTE *)v25;
        v94 = (_BYTE *)v25;
        if ( (unsigned int *)a4 == v20 )
        {
          v29 = (unsigned int *)a4;
          v30 = 4;
          goto LABEL_20;
        }
        v29 = v20;
        v30 = 4;
        v31 = v19 & 2;
        while ( 1 )
        {
          v32 = v29 + 1;
          if ( a4 < (unsigned __int64)(v29 + 1) )
            break;
          if ( v26 <= (unsigned __int64)v28 )
          {
            v29 = (unsigned int *)v93;
            v30 = 5;
            goto LABEL_20;
          }
          v33 = *v29;
          if ( v33 > 0x7F )
          {
            if ( v33 >> 7 == 7168 )
            {
              v93 = (char *)v32;
              v29 = v32;
            }
            else
            {
              if ( !v86 )
              {
                v29 = (unsigned int *)v93;
                v30 = 6;
LABEL_20:
                *a3 = (__int64)v29;
                if ( !v74 )
                {
LABEL_21:
                  ++*(_DWORD *)(a2 + 20);
                  if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
                  {
                    v37 = v30;
                    *(_QWORD *)a2 = v28;
                    *v73 += v91;
                    goto LABEL_53;
                  }
                  v82 = v27;
                  v75 = v28;
                  if ( v25 >= (unsigned __int64)v28 )
                  {
                    v35 = v30;
                    goto LABEL_25;
                  }
                  v79 = v26;
                  v92 = *(_BYTE **)a2;
                  sub_4F2B0((__int64)v83);
                  v34 = ((__int64 (__fastcall *)(_QWORD *, __int64, _BYTE **, _BYTE *, _QWORD, __int64 *, _QWORD, _QWORD))v83)(
                          v84,
                          v85,
                          &v92,
                          v75,
                          0LL,
                          v73,
                          0LL,
                          a16);
                  v26 = v79;
                  v35 = v34;
                  if ( v34 == 4 )
                  {
                    v35 = v30;
                    if ( v30 != 5 )
                      goto LABEL_25;
                    goto LABEL_26;
                  }
                  v36 = (unsigned __int64)v92;
                  if ( v92 == v75 )
                    goto LABEL_25;
                  v56 = 0LL;
                  if ( v73 )
                    v56 = *v73;
                  if ( v91 + v56 == v82 )
                  {
                    *a3 -= 4 * (v75 - v92);
                    goto LABEL_25;
                  }
                  v57 = *(_DWORD *)(a2 + 16);
                  v93 = (char *)v20;
                  v94 = (_BYTE *)v25;
                  *a3 = (__int64)v20;
                  if ( (unsigned int *)a4 == v20 )
                  {
                    if ( v36 != v25 )
                      goto LABEL_87;
                  }
                  else
                  {
                    v58 = (_BYTE *)v25;
                    v59 = v57 & 2;
                    while ( a4 >= (unsigned __int64)(v20 + 1) )
                    {
                      if ( v36 <= (unsigned __int64)v58 )
                      {
                        v61 = (unsigned int *)v93;
                        v62 = (__int64)v58;
                        goto LABEL_86;
                      }
                      v60 = *v20;
                      if ( *v20 > 0x7F )
                      {
                        if ( v60 >> 7 == 7168 )
                        {
                          v93 = (char *)++v20;
                        }
                        else
                        {
                          if ( !v86 )
                            break;
                          if ( (*(_BYTE *)(a2 + 16) & 8) == 0
                            || (v81 = v59,
                                v78 = v26,
                                v67 = sub_59FA0(a1, a2, *a3, (unsigned int **)&v93, a4, (__int64 *)&v94, v86),
                                v26 = v78,
                                v59 = v81,
                                v58 = v94,
                                v67 == 6) )
                          {
                            v63 = (unsigned int *)v93;
                            if ( !v59 )
                              goto LABEL_89;
                            v20 = (unsigned int *)(v93 + 4);
                            v93 += 4;
                            ++*v86;
                          }
                          else
                          {
                            v20 = (unsigned int *)v93;
                            v58 = v94;
                            v61 = (unsigned int *)v93;
                            if ( v67 == 5 )
                            {
                              v62 = (__int64)v94;
LABEL_86:
                              *a3 = (__int64)v61;
                              if ( (_BYTE *)v62 != v92 )
LABEL_87:
                                sub_CF00(
                                  (__int64)"outbuf == outerr",
                                  (__int64)"../iconv/skeleton.c",
                                  0x2EAu,
                                  "__gconv_transform_internal_ascii",
                                  a7,
                                  a8,
                                  a9,
                                  a10,
                                  a11,
                                  a12,
                                  a13,
                                  a14);
                              if ( (_BYTE *)v25 == v92 )
                                --*(_DWORD *)(a2 + 20);
LABEL_25:
                              if ( !v35 )
                              {
LABEL_26:
                                v25 = *(_QWORD *)a2;
                                v27 = v91;
                                v19 = *(_DWORD *)(a2 + 16);
                                v20 = (unsigned int *)*a3;
                                goto LABEL_11;
                              }
                              v37 = v35;
LABEL_53:
                              if ( a16 && v37 == 7 )
                              {
                                v51 = *a3;
                                v52 = a4 - *a3;
                                if ( v52 > 4 )
                                  sub_CF00(
                                    (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
                                    (__int64)"../iconv/skeleton.c",
                                    0x31Fu,
                                    "__gconv_transform_internal_ascii",
                                    a7,
                                    a8,
                                    a9,
                                    a10,
                                    a11,
                                    a12,
                                    a13,
                                    a14);
                                v53 = *(_DWORD **)(a2 + 32);
                                v54 = 0LL;
                                if ( v52 )
                                {
                                  do
                                  {
                                    *((_BYTE *)v53 + v54 + 4) = *(_BYTE *)(v51 + v54);
                                    ++v54;
                                  }
                                  while ( v52 != v54 );
                                }
                                *a3 = a4;
                                *v53 = *v53 & 0xFFFFFFF8 | v52;
                              }
                              return v37;
                            }
                          }
                        }
                      }
                      else
                      {
                        v94 = v58 + 1;
                        *v58 = v60;
                        v20 = (unsigned int *)(v93 + 4);
                        v58 = v94;
                        v93 += 4;
                      }
                      if ( (unsigned int *)a4 == v20 )
                      {
                        *a3 = a4;
                        if ( v92 != v58 )
                          goto LABEL_87;
                        goto LABEL_90;
                      }
                    }
                    v63 = (unsigned int *)v93;
LABEL_89:
                    *a3 = (__int64)v63;
                    if ( v58 != v92 )
                      goto LABEL_87;
                  }
LABEL_90:
                  sub_CF00(
                    (__int64)"nstatus == __GCONV_FULL_OUTPUT",
                    (__int64)"../iconv/skeleton.c",
                    0x2EBu,
                    "__gconv_transform_internal_ascii",
                    a7,
                    a8,
                    a9,
                    a10,
                    a11,
                    a12,
                    a13,
                    a14);
                }
LABEL_28:
                v37 = v30;
                *v74 = v28;
                return v37;
              }
              if ( (*(_BYTE *)(a2 + 16) & 8) == 0
                || (v80 = v27,
                    v77 = v26,
                    v55 = sub_59FA0(a1, a2, *a3, (unsigned int **)&v93, a4, (__int64 *)&v94, v86),
                    v26 = v77,
                    v27 = v80,
                    v30 = v55,
                    v28 = v94,
                    v55 == 6) )
              {
                v29 = (unsigned int *)v93;
                if ( !v31 )
                {
                  v30 = 6;
                  goto LABEL_20;
                }
                v29 = (unsigned int *)(v93 + 4);
                v30 = 6;
                v93 += 4;
                ++*v86;
              }
              else
              {
                v29 = (unsigned int *)v93;
                v28 = v94;
                if ( v30 == 5 )
                  goto LABEL_20;
              }
            }
          }
          else
          {
            v94 = v28 + 1;
            *v28 = v33;
            v28 = v94;
            v29 = (unsigned int *)(v93 + 4);
            v93 += 4;
          }
          if ( (unsigned int *)a4 == v29 )
            goto LABEL_20;
        }
        v30 = 7;
        *a3 = (__int64)v93;
        if ( !v74 )
          goto LABEL_21;
        goto LABEL_28;
      }
      if ( v96 >> 7 == 7168 )
      {
        v93 = (char *)v97;
        v46 = 4LL;
        goto LABEL_50;
      }
      if ( !v86 )
        return 6;
      if ( (v19 & 8) == 0 )
      {
        v45 = &v96;
        v37 = 6;
        if ( (v19 & 2) == 0 )
          return v37;
        goto LABEL_107;
      }
      v90 = v22;
      v89 = v40;
      v88 = (__int64 *)((char *)&v96 + v40);
      v37 = sub_59FA0(a1, a2, (__int64)v20, (unsigned int **)&v93, (unsigned __int64)&v96 + v40, (__int64 *)&v94, v86);
      if ( v37 == 6 )
      {
        v45 = (unsigned int *)v93;
        if ( (v19 & 2) == 0 )
        {
LABEL_108:
          if ( v45 != &v96 )
            goto LABEL_49;
          return 6;
        }
LABEL_107:
        v93 = (char *)++v45;
        ++*v86;
        goto LABEL_108;
      }
      v22 = v90;
      v46 = v93 - (char *)&v96;
      if ( v93 != (char *)&v96 )
        goto LABEL_50;
      if ( v37 != 7 )
      {
        if ( v37 )
          return v37;
        goto LABEL_97;
      }
      if ( v88 == v97 )
        sub_CF00(
          (__int64)"inend != &bytebuf[MAX_NEEDED_INPUT]",
          (__int64)"../iconv/loop.c",
          0x1DDu,
          "internal_ascii_loop_single",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      v68 = *v76 & 0xFFFFFFF8;
      *a3 += v89 - (*v76 & 7);
      if ( (__int64)v89 <= v68 )
        sub_CF00(
          (__int64)"inend - inptr > (state->__count & ~7)",
          (__int64)"../iconv/loop.c",
          0x1E7u,
          "internal_ascii_loop_single",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      if ( v89 > 4 )
        sub_CF00(
          (__int64)"inend - inptr <= sizeof (state->__value.__wchb)",
          (__int64)"../iconv/loop.c",
          0x1E8u,
          "internal_ascii_loop_single",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      *v76 = v89 | v68;
      if ( v89 )
      {
        v69 = 0LL;
        do
        {
          *((_BYTE *)v76 + v69 + 4) = *((_BYTE *)&v96 + v69);
          v70 = v69++;
        }
        while ( v43 != v70 );
      }
    }
    return 7;
  }
  if ( a5 )
    sub_CF00(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x1A4u,
      "__gconv_transform_internal_ascii",
      a7,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14);
  v37 = 0;
  **(_QWORD **)(a2 + 32) = 0LL;
  if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
    return v37;
  sub_4F2B0((__int64)v83);
  return v83(v84, v85, 0LL, 0LL, 0LL, v16, a15);
}
// 557AD: conditional instruction was optimized away because of 'esi.4!=5'
// 55100: too many cbuild loops
// 558B5: variable 'a11' is possibly undefined
// 558B5: variable 'a12' is possibly undefined

//----- (0000000000055D30) ----------------------------------------------------
__int64 __fastcall sub_55D30(_QWORD *a1, __int64 a2, __int64 *a3, unsigned __int64 a4, _QWORD *a5, _QWORD *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16)
{
  int v18; // er15
  unsigned __int64 v19; // r13
  unsigned int *v20; // r12
  _BYTE **v21; // rax
  _BYTE *v22; // r14
  __int64 *v23; // rax
  unsigned __int64 v24; // r11
  unsigned __int64 v25; // r14
  unsigned int *v26; // r13
  _BYTE *v27; // r12
  unsigned int *v28; // rax
  unsigned int v29; // er10
  int v30; // er15
  int v31; // eax
  unsigned int v32; // er15
  unsigned __int64 v33; // r10
  __int64 v34; // r11
  __int64 v36; // rcx
  char v37; // dl
  unsigned int v38; // eax
  unsigned __int64 v39; // r11
  unsigned int *v40; // rax
  char v41; // dl
  unsigned __int64 v42; // rdi
  unsigned int *v43; // rcx
  unsigned int v44; // eax
  unsigned int *v45; // rax
  signed __int64 v46; // rax
  unsigned int v47; // edx
  signed __int64 v48; // rcx
  __int64 v49; // r14
  unsigned int *v50; // rax
  __int64 v51; // rax
  __int64 v52; // rdi
  unsigned __int64 v53; // rdx
  _DWORD *v54; // rcx
  __int64 v55; // rax
  int v56; // er12
  _BYTE *v57; // rax
  int v58; // er12
  int v59; // edx
  unsigned int *v60; // r12
  unsigned int *v61; // rdx
  __int64 v62; // rcx
  __int64 v63; // rcx
  char v64; // di
  unsigned int v65; // eax
  unsigned __int64 v66; // rax
  unsigned int *v67; // r12
  char v68; // dl
  __int64 v69; // rcx
  char v70; // dl
  int v71; // esi
  signed int v72; // eax
  __int64 v73; // rax
  __int64 v74; // rdx
  _QWORD *v76; // [rsp+8h] [rbp-D0h]
  unsigned int v77; // [rsp+10h] [rbp-C8h]
  unsigned int *v78; // [rsp+10h] [rbp-C8h]
  unsigned __int64 v79; // [rsp+10h] [rbp-C8h]
  unsigned __int64 v80; // [rsp+10h] [rbp-C8h]
  __int64 v81; // [rsp+18h] [rbp-C0h]
  __int64 v82; // [rsp+18h] [rbp-C0h]
  __int64 (__fastcall *v84)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // [rsp+30h] [rbp-A8h]
  _QWORD *v85; // [rsp+38h] [rbp-A0h]
  __int64 v86; // [rsp+40h] [rbp-98h]
  __int64 *v87; // [rsp+48h] [rbp-90h]
  __int64 *v89; // [rsp+60h] [rbp-78h]
  unsigned __int64 v90; // [rsp+68h] [rbp-70h]
  __int64 v91; // [rsp+70h] [rbp-68h] BYREF
  _BYTE *v92; // [rsp+78h] [rbp-60h] BYREF
  unsigned int *v93; // [rsp+80h] [rbp-58h] BYREF
  _BYTE *v94; // [rsp+88h] [rbp-50h] BYREF
  char v95; // [rsp+93h] [rbp-45h]
  unsigned int v96; // [rsp+94h] [rbp-44h] BYREF
  unsigned __int64 v97; // [rsp+98h] [rbp-40h] BYREF

  v18 = *(_DWORD *)(a2 + 16);
  v76 = a5;
  v97 = __readfsqword(0x28u);
  v84 = 0LL;
  v85 = a1 + 13;
  v86 = a2 + 48;
  if ( (v18 & 1) == 0 )
  {
    v84 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))a1[18];
    if ( a1[13] )
      v84 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(a1[18], 17));
  }
  if ( !(_DWORD)a15 )
  {
    v19 = *(_QWORD *)(a2 + 8);
    v20 = (unsigned int *)*a3;
    v21 = (_BYTE **)a5;
    if ( !a5 )
      v21 = (_BYTE **)a2;
    v22 = *v21;
    v23 = 0LL;
    v91 = 0LL;
    if ( a6 )
      v23 = &v91;
    v87 = v23;
    if ( !a16 || (v78 = *(unsigned int **)(a2 + 32), (v38 = *v78 & 7) == 0) )
    {
      v24 = (unsigned __int64)v22;
      v25 = v19;
      v26 = v20;
      goto LABEL_11;
    }
    if ( a5 )
      sub_CF00(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x234u,
        "__gconv_transform_internal_utf8",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    v93 = v20;
    v94 = v22;
    if ( v38 > 4 )
      sub_CF00(
        (__int64)"(state->__count & 7) <= sizeof (state->__value)",
        (__int64)"../iconv/loop.c",
        0x18Bu,
        "internal_utf8_loop_single",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    v39 = 0LL;
    do
    {
      *((_BYTE *)&v96 + v39) = *((_BYTE *)v78 + v39 + 4);
      ++v39;
    }
    while ( v39 < (*v78 & 7) );
    if ( a4 < (unsigned __int64)v20 - v39 + 4 )
    {
      *a3 = a4;
      v66 = v39 + a4 - (_QWORD)v20;
      if ( v66 > 4 )
        sub_CF00(
          (__int64)"inlen_after <= sizeof (state->__value.__wchb)",
          (__int64)"../iconv/loop.c",
          0x1A8u,
          "internal_utf8_loop_single",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      v67 = (unsigned int *)((char *)v20 + 1);
      if ( v39 < v66 )
      {
        do
        {
          v93 = v67;
          v68 = *((_BYTE *)v67 - 1);
          v67 = (unsigned int *)((char *)v67 + 1);
          *((_BYTE *)v78 + v39++ + 4) = v68;
        }
        while ( v66 != v39 );
      }
    }
    else
    {
      v40 = (unsigned int *)((char *)v20 + 1);
      if ( (unsigned __int64)v22 >= v19 )
        return 5;
      do
      {
        v93 = v40;
        v41 = *((_BYTE *)v40 - 1);
        v42 = v39++;
        v43 = v40;
        v40 = (unsigned int *)((char *)v40 + 1);
        *(&v95 + v39) = v41;
      }
      while ( v39 <= 3 && a4 > (unsigned __int64)v43 );
      v93 = &v96;
      v44 = v96;
      if ( v96 <= 0x7F )
      {
        v94 = v22 + 1;
        *v22 = v96;
        goto LABEL_53;
      }
      if ( v96 - 55296 > 0x7FF && (v96 & 0x80000000) == 0 )
      {
        if ( (v96 & 0xFFFFF800) != 0 )
        {
          if ( (v96 & 0xFFFF0000) != 0 )
          {
            if ( (v96 & 0xFFE00000) != 0 )
              v69 = ((v96 & 0xFC000000) != 0) + 5LL;
            else
              v69 = 4LL;
          }
          else
          {
            v69 = 3LL;
          }
        }
        else
        {
          v69 = 2LL;
        }
        if ( v19 >= (unsigned __int64)&v22[v69] )
        {
          *v22 = -256 >> v69;
          v94 += v69;
          do
          {
            v70 = v44;
            --v69;
            v44 >>= 6;
            v22[v69] = v70 & 0x3F | 0x80;
          }
          while ( v69 != 1 );
          *v22 |= v44;
LABEL_53:
          v45 = v93 + 1;
          v93 = v45;
          if ( v45 != &v96 )
          {
LABEL_54:
            v46 = (char *)v45 - (char *)&v96;
            v47 = *v78;
            v48 = *v78 & 7;
            if ( v46 <= v48 )
              sub_CF00(
                (__int64)"inptr - bytebuf > (state->__count & 7)",
                (__int64)"../iconv/loop.c",
                0x1CBu,
                "internal_utf8_loop_single",
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14);
            v18 = *(_DWORD *)(a2 + 16);
            v49 = (__int64)v94;
            v50 = (unsigned int *)(*a3 + v46 - v48);
            *a3 = (__int64)v50;
            v24 = v49;
            v25 = v19;
            v26 = v50;
            *v78 = v47 & 0xFFFFFFF8;
            goto LABEL_11;
          }
LABEL_109:
          v24 = (unsigned __int64)v22;
          v18 = *(_DWORD *)(a2 + 16);
          v25 = v19;
          v26 = (unsigned int *)*a3;
LABEL_11:
          v93 = v26;
          v27 = (_BYTE *)v24;
          v94 = (_BYTE *)v24;
          if ( (unsigned int *)a4 == v26 )
          {
            v28 = (unsigned int *)a4;
            v29 = 4;
            goto LABEL_19;
          }
          v28 = v26;
          v29 = 4;
          v30 = v18 & 2;
          while ( 1 )
          {
            if ( a4 < (unsigned __int64)(v28 + 1) )
            {
              v29 = 7;
              *a3 = (__int64)v93;
              if ( !v76 )
                goto LABEL_20;
              goto LABEL_27;
            }
            if ( v25 <= (unsigned __int64)v27 )
              goto LABEL_29;
            v31 = *v28;
            if ( (unsigned int)v31 <= 0x7F )
              break;
            if ( (unsigned int)(v31 - 55296) > 0x7FF && v31 >= 0 )
            {
              if ( (v31 & 0xFFFFF800) != 0 )
              {
                if ( (v31 & 0xFFFF0000) != 0 )
                {
                  if ( (v31 & 0xFFE00000) != 0 )
                    v36 = ((v31 & 0xFC000000) != 0) + 5LL;
                  else
                    v36 = 4LL;
                }
                else
                {
                  v36 = 3LL;
                }
              }
              else
              {
                v36 = 2LL;
              }
              if ( v25 < (unsigned __int64)&v27[v36] )
              {
LABEL_29:
                v28 = v93;
                v29 = 5;
                goto LABEL_19;
              }
              *v27 = -256 >> v36;
              v94 += v36;
              do
              {
                v37 = v31;
                --v36;
                v31 = (unsigned int)v31 >> 6;
                v27[v36] = v37 & 0x3F | 0x80;
              }
              while ( v36 != 1 );
              *v27 |= v31;
              goto LABEL_17;
            }
            if ( !v87 )
            {
              v28 = v93;
              v29 = 6;
LABEL_19:
              *a3 = (__int64)v28;
              if ( !v76 )
              {
LABEL_20:
                ++*(_DWORD *)(a2 + 20);
                if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
                {
                  v51 = v91;
                  *(_QWORD *)a2 = v27;
                  *a6 += v51;
                  goto LABEL_57;
                }
                v81 = v24;
                if ( v24 >= (unsigned __int64)v27 )
                {
                  v32 = v29;
                  goto LABEL_24;
                }
                v77 = v29;
                v92 = *(_BYTE **)a2;
                sub_4F2B0((__int64)v84);
                v32 = ((__int64 (__fastcall *)(_QWORD *, __int64, _BYTE **, _BYTE *, _QWORD, _QWORD *, _QWORD, _QWORD))v84)(
                        v85,
                        v86,
                        &v92,
                        v27,
                        0LL,
                        a6,
                        0LL,
                        a16);
                if ( v32 == 4 )
                {
                  v32 = v77;
                  if ( v77 != 5 )
                    goto LABEL_24;
                  goto LABEL_25;
                }
                v33 = (unsigned __int64)v92;
                v34 = v81;
                if ( v92 == v27 )
                  goto LABEL_24;
                v56 = *(_DWORD *)(a2 + 16);
                v93 = v26;
                v94 = (_BYTE *)v81;
                *a3 = (__int64)v26;
                if ( (unsigned int *)a4 == v26 )
                {
                  if ( v33 != v81 )
                    goto LABEL_83;
                  goto LABEL_73;
                }
                v57 = (_BYTE *)v81;
                v58 = v56 & 2;
                while ( 2 )
                {
                  if ( a4 < (unsigned __int64)(v26 + 1) )
                  {
LABEL_81:
                    v60 = v93;
LABEL_82:
                    *a3 = (__int64)v60;
                    if ( v57 != v92 )
                      goto LABEL_83;
LABEL_73:
                    sub_CF00(
                      (__int64)"nstatus == __GCONV_FULL_OUTPUT",
                      (__int64)"../iconv/skeleton.c",
                      0x2EBu,
                      "__gconv_transform_internal_utf8",
                      a7,
                      a8,
                      a9,
                      a10,
                      a11,
                      a12,
                      a13,
                      a14);
                  }
                  if ( v33 <= (unsigned __int64)v57 )
                    goto LABEL_84;
                  v59 = *v26;
                  if ( *v26 <= 0x7F )
                  {
                    v94 = v57 + 1;
                    *v57 = v59;
                    goto LABEL_70;
                  }
                  if ( (unsigned int)(v59 - 55296) <= 0x7FF || v59 < 0 )
                  {
                    if ( !v87 )
                      goto LABEL_81;
                    if ( (*(_BYTE *)(a2 + 16) & 8) == 0
                      || (v82 = v34,
                          v80 = v33,
                          v71 = sub_59FA0(a1, a2, *a3, &v93, a4, (__int64 *)&v94, v87),
                          v33 = v80,
                          v34 = v82,
                          v57 = v94,
                          v71 == 6) )
                    {
                      if ( !v58 )
                      {
                        v60 = v93;
                        goto LABEL_82;
                      }
                      v26 = ++v93;
                      ++*v87;
                    }
                    else
                    {
                      v61 = v93;
                      v57 = v94;
                      v26 = v93;
                      if ( v71 == 5 )
                      {
                        v62 = (__int64)v94;
LABEL_85:
                        *a3 = (__int64)v61;
                        if ( (_BYTE *)v62 == v92 )
                        {
                          if ( (_BYTE *)v34 == v92 )
                            --*(_DWORD *)(a2 + 20);
LABEL_24:
                          if ( !v32 )
                          {
LABEL_25:
                            v24 = *(_QWORD *)a2;
                            v18 = *(_DWORD *)(a2 + 16);
                            v26 = (unsigned int *)*a3;
                            goto LABEL_11;
                          }
                          v29 = v32;
LABEL_57:
                          if ( a16 && v29 == 7 )
                          {
                            v52 = *a3;
                            v53 = a4 - *a3;
                            if ( v53 > 4 )
                              sub_CF00(
                                (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
                                (__int64)"../iconv/skeleton.c",
                                0x31Fu,
                                "__gconv_transform_internal_utf8",
                                a7,
                                a8,
                                a9,
                                a10,
                                a11,
                                a12,
                                a13,
                                a14);
                            v54 = *(_DWORD **)(a2 + 32);
                            v55 = 0LL;
                            if ( v53 )
                            {
                              do
                              {
                                *((_BYTE *)v54 + v55 + 4) = *(_BYTE *)(v52 + v55);
                                ++v55;
                              }
                              while ( v53 != v55 );
                            }
                            *a3 = a4;
                            *v54 = *v54 & 0xFFFFFFF8 | v53;
                          }
                          return v29;
                        }
LABEL_83:
                        sub_CF00(
                          (__int64)"outbuf == outerr",
                          (__int64)"../iconv/skeleton.c",
                          0x2EAu,
                          "__gconv_transform_internal_utf8",
                          a7,
                          a8,
                          a9,
                          a10,
                          a11,
                          a12,
                          a13,
                          a14);
                      }
                    }
                  }
                  else
                  {
                    if ( (v59 & 0xFFFFF800) != 0 )
                    {
                      if ( (v59 & 0xFFFF0000) != 0 )
                      {
                        if ( (v59 & 0xFFE00000) != 0 )
                          v63 = ((v59 & 0xFC000000) != 0) + 5LL;
                        else
                          v63 = 4LL;
                      }
                      else
                      {
                        v63 = 3LL;
                      }
                    }
                    else
                    {
                      v63 = 2LL;
                    }
                    if ( v33 < (unsigned __int64)&v57[v63] )
                    {
LABEL_84:
                      v61 = v93;
                      v62 = (__int64)v57;
                      goto LABEL_85;
                    }
                    *v57 = -256 >> v63;
                    v94 += v63;
                    do
                    {
                      v64 = v59;
                      --v63;
                      v59 = (unsigned int)v59 >> 6;
                      v57[v63] = v64 & 0x3F | 0x80;
                    }
                    while ( v63 != 1 );
                    *v57 |= v59;
LABEL_70:
                    v26 = v93 + 1;
                    v57 = v94;
                    ++v93;
                  }
                  if ( (unsigned int *)a4 == v26 )
                  {
                    *a3 = a4;
                    if ( v92 != v57 )
                      goto LABEL_83;
                    goto LABEL_73;
                  }
                  continue;
                }
              }
LABEL_27:
              *v76 = v27;
              return v29;
            }
            if ( (*(_BYTE *)(a2 + 16) & 8) == 0
              || (v79 = v24,
                  v65 = sub_59FA0(a1, a2, *a3, &v93, a4, (__int64 *)&v94, v87),
                  v27 = v94,
                  v24 = v79,
                  v29 = v65,
                  v65 == 6) )
            {
              v28 = v93;
              if ( !v30 )
              {
                v29 = 6;
                goto LABEL_19;
              }
              v28 = v93 + 1;
              v29 = 6;
              ++v93;
              ++*v87;
            }
            else
            {
              v28 = v93;
              v27 = v94;
              if ( v29 == 5 )
                goto LABEL_19;
            }
LABEL_18:
            if ( (unsigned int *)a4 == v28 )
              goto LABEL_19;
          }
          v94 = v27 + 1;
          *v27 = v31;
LABEL_17:
          v27 = v94;
          v28 = ++v93;
          goto LABEL_18;
        }
        return 5;
      }
      if ( !v87 )
        return 6;
      if ( (v18 & 8) == 0 )
      {
        v29 = 6;
        if ( (v18 & 2) == 0 )
          return v29;
        goto LABEL_141;
      }
      v90 = v39;
      v89 = (__int64 *)((char *)&v96 + v39);
      v29 = sub_59FA0(a1, a2, (__int64)v20, &v93, (unsigned __int64)&v96 + v39, (__int64 *)&v94, v87);
      if ( v29 == 6 )
      {
        if ( (v18 & 2) == 0 )
        {
LABEL_142:
          v45 = v93;
          if ( v93 != &v96 )
            goto LABEL_54;
          return 6;
        }
LABEL_141:
        ++v93;
        ++*v87;
        goto LABEL_142;
      }
      v45 = v93;
      if ( v93 != &v96 )
        goto LABEL_54;
      if ( v29 != 7 )
      {
        if ( v29 )
          return v29;
        goto LABEL_109;
      }
      if ( v89 == (__int64 *)&v97 )
        sub_CF00(
          (__int64)"inend != &bytebuf[MAX_NEEDED_INPUT]",
          (__int64)"../iconv/loop.c",
          0x1DDu,
          "internal_utf8_loop_single",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      v72 = *v78 & 0xFFFFFFF8;
      *a3 += v90 - (*v78 & 7);
      if ( v72 >= (__int64)v90 )
        sub_CF00(
          (__int64)"inend - inptr > (state->__count & ~7)",
          (__int64)"../iconv/loop.c",
          0x1E7u,
          "internal_utf8_loop_single",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      if ( v90 > 4 )
        sub_CF00(
          (__int64)"inend - inptr <= sizeof (state->__value.__wchb)",
          (__int64)"../iconv/loop.c",
          0x1E8u,
          "internal_utf8_loop_single",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      *v78 = v90 | v72;
      if ( v90 )
      {
        v73 = 0LL;
        do
        {
          *((_BYTE *)v78 + v73 + 4) = *((_BYTE *)&v96 + v73);
          v74 = v73++;
        }
        while ( v42 != v74 );
      }
    }
    return 7;
  }
  if ( a5 )
    sub_CF00(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x1A4u,
      "__gconv_transform_internal_utf8",
      a7,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14);
  v29 = 0;
  **(_QWORD **)(a2 + 32) = 0LL;
  if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
    return v29;
  sub_4F2B0((__int64)v84);
  return v84(v85, v86, 0LL, 0LL, 0LL, a6, a15);
}
// 562E7: conditional instruction was optimized away because of 'esi.4!=5'
// 56307: variable 'a11' is possibly undefined
// 56307: variable 'a12' is possibly undefined

//----- (0000000000056A10) ----------------------------------------------------
__int64 __fastcall sub_56A10(__int64 a1, __int64 a2, unsigned __int8 **a3, unsigned __int64 a4, unsigned int **a5, _QWORD *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, int a16)
{
  int v18; // er9
  unsigned __int64 v19; // r13
  unsigned __int8 *v20; // r14
  unsigned int **v21; // rax
  unsigned int *v22; // r10
  __int64 *v23; // rax
  unsigned int *v24; // r15
  unsigned int *v25; // rdi
  unsigned __int8 *v26; // rdx
  unsigned int *v27; // rbx
  int v28; // er9
  unsigned int v29; // eax
  unsigned __int8 *v30; // r11
  unsigned __int8 v31; // cl
  __int64 v32; // r10
  unsigned __int8 *v33; // r8
  __int64 v34; // rsi
  unsigned __int8 v35; // cl
  unsigned int v36; // eax
  unsigned __int64 v37; // rsi
  unsigned int v38; // er15
  _DWORD *v40; // r8
  unsigned __int8 *v41; // r9
  int v42; // edx
  unsigned __int64 v43; // r10
  int v44; // eax
  char v45; // si
  int v46; // edi
  unsigned __int8 *v47; // rdx
  char v48; // cl
  _DWORD *v49; // rdx
  unsigned __int64 v50; // rax
  int v51; // er8
  unsigned int v52; // esi
  unsigned __int64 v53; // rcx
  char *v54; // rcx
  char v55; // di
  int v56; // er15
  unsigned __int8 v57; // cl
  __int64 v58; // rsi
  __int64 v59; // rax
  int v60; // edx
  unsigned int *v61; // r8
  unsigned int *v62; // r9
  unsigned int v63; // edx
  unsigned __int8 *v64; // rbx
  unsigned __int8 v65; // cl
  __int64 v66; // r11
  __int64 v67; // rdi
  unsigned __int8 v68; // cl
  unsigned int v69; // edi
  __int64 i; // r11
  char v71; // al
  char *v72; // rsi
  __int64 v73; // r11
  int v74; // er9
  __int64 v75; // rdi
  int v76; // esi
  char *v77; // r10
  char v78; // cl
  int v79; // [rsp+8h] [rbp-B0h]
  int v80; // [rsp+8h] [rbp-B0h]
  unsigned __int64 v81; // [rsp+8h] [rbp-B0h]
  __int64 (__fastcall *v83)(__int64, __int64, unsigned int **, unsigned int *, _QWORD, _QWORD *, __int64); // [rsp+18h] [rbp-A0h]
  unsigned int **v84; // [rsp+20h] [rbp-98h]
  __int64 v86; // [rsp+30h] [rbp-88h]
  __int64 v87; // [rsp+38h] [rbp-80h]
  __int64 *v88; // [rsp+40h] [rbp-78h]
  __int64 v89; // [rsp+48h] [rbp-70h]
  unsigned int v90; // [rsp+5Ch] [rbp-5Ch]
  __int64 v91; // [rsp+60h] [rbp-58h] BYREF
  unsigned int *v92; // [rsp+68h] [rbp-50h] BYREF
  char v93; // [rsp+71h] [rbp-47h]
  unsigned __int8 v94; // [rsp+72h] [rbp-46h] BYREF
  char v95[5]; // [rsp+73h] [rbp-45h] BYREF
  unsigned __int64 v96; // [rsp+78h] [rbp-40h] BYREF

  v18 = *(_DWORD *)(a2 + 16);
  v84 = a5;
  v96 = __readfsqword(0x28u);
  v83 = 0LL;
  v86 = a1 + 104;
  v87 = a2 + 48;
  if ( (v18 & 1) == 0 )
  {
    v83 = *(__int64 (__fastcall **)(__int64, __int64, unsigned int **, unsigned int *, _QWORD, _QWORD *, __int64))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v83 = (__int64 (__fastcall *)(__int64, __int64, unsigned int **, unsigned int *, _QWORD, _QWORD *, __int64))(__readfsqword(0x30u) ^ __ROR8__(*(_QWORD *)(a1 + 144), 17));
  }
  if ( !(_DWORD)a15 )
  {
    v19 = *(_QWORD *)(a2 + 8);
    v20 = *a3;
    v21 = a5;
    if ( !a5 )
      v21 = (unsigned int **)a2;
    v22 = *v21;
    v23 = 0LL;
    v91 = 0LL;
    if ( a6 )
      v23 = &v91;
    v88 = v23;
    if ( !a16 || (v49 = *(_DWORD **)(a2 + 32), LODWORD(v50) = *v49, (v51 = *v49 & 7) == 0) )
    {
      v24 = v22;
      goto LABEL_11;
    }
    if ( v84 )
      sub_CF00(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x234u,
        "__gconv_transform_utf8_internal",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    v52 = v49[1];
    v50 = (unsigned __int8)v50;
    v53 = (int)*v49 >> 8;
    v94 = byte_94B41[(int)v53 - 2];
    do
    {
      if ( v50 > --v53 )
        *(&v94 + v53) = v52 & 0x3F | 0x80;
      v52 >>= 6;
    }
    while ( v53 > 1 );
    v94 |= v52;
    if ( v19 < (unsigned __int64)(v22 + 1) )
      return 5;
    v54 = (char *)v20;
    do
    {
      v55 = *v54;
      ++v50;
      ++v54;
      *(&v93 + v50) = v55;
    }
    while ( v50 <= 5 && a4 > (unsigned __int64)v54 );
    v56 = v94;
    v57 = v94;
    if ( (v94 & 0x80u) == 0 )
    {
      *v22++ = v94;
      v58 = 1LL;
      v51 = *v49 & 7;
      goto LABEL_76;
    }
    v81 = (unsigned __int64)(&v94 + v50);
    v90 = v94 - 194;
    if ( v90 > 0x1D )
    {
      if ( (v94 & 0xF0) == 0xE0 )
      {
        v58 = 3LL;
        v69 = v94 & 0xF;
      }
      else if ( (v94 & 0xF8) == 0xF0 )
      {
        v58 = 4LL;
        v69 = v94 & 7;
      }
      else if ( (v94 & 0xFC) == 0xF8 )
      {
        v58 = 5LL;
        v69 = v94 & 3;
      }
      else
      {
        if ( (v94 & 0xFE) != 0xFC )
        {
          i = 0LL;
          do
            ++i;
          while ( v81 > (unsigned __int64)(&v94 + i) && (*(&v94 + i) & 0xC0) == 0x80 && i != 5 );
LABEL_134:
          v89 = i;
          goto LABEL_135;
        }
        v58 = 6LL;
        v69 = v94 & 1;
      }
    }
    else
    {
      v58 = 2LL;
      v69 = v94 & 0x1F;
    }
    v89 = 1LL;
    if ( v81 >= (unsigned __int64)(&v94 + v58) )
    {
      for ( i = 1LL; i != v58; ++i )
      {
        v71 = *(&v94 + i);
        if ( (v71 & 0xC0) != 0x80 )
          goto LABEL_134;
        v69 = v71 & 0x3F | (v69 << 6);
      }
      v89 = i;
      if ( v58 == 2 )
      {
        if ( v69 - 55296 > 0x7FF )
        {
          *v22 = v69;
          v58 = 2LL;
          ++v22;
          v51 = *v49 & 7;
          goto LABEL_76;
        }
      }
      else if ( v69 >> (5 * v58 - 4) && v69 - 55296 > 0x7FF )
      {
        *v22++ = v69;
        v51 = *v49 & 7;
        goto LABEL_76;
      }
      goto LABEL_135;
    }
    if ( v81 <= (unsigned __int64)v95 )
    {
      if ( (char *)v81 == v95 )
      {
LABEL_154:
        *a3 = &v20[v50 - v51];
        *v49 = v50;
        if ( (unsigned int)(v56 - 192) <= 1 )
          sub_CF00(
            (__int64)"ch != 0xc0 && ch != 0xc1",
            (__int64)"../iconv/loop.c",
            0x1E3u,
            "utf8_internal_loop_single",
            a7,
            a8,
            a9,
            a10,
            a11,
            a12,
            a13,
            a14);
        if ( v90 > 0x1D )
        {
          if ( (v57 & 0xF0) == 0xE0 )
          {
            v74 = 768;
            v75 = 2LL;
            v76 = v57 & 0xF;
          }
          else if ( (v57 & 0xF8) == 0xF0 )
          {
            v74 = 1024;
            v75 = 3LL;
            v76 = v57 & 7;
          }
          else if ( (v57 & 0xFC) == 0xF8 )
          {
            v76 = v57 & 3;
            v74 = 1280;
            v75 = 4LL;
          }
          else
          {
            v76 = v57 & 1;
            v74 = 1536;
            v75 = 5LL;
          }
        }
        else
        {
          v74 = 512;
          v75 = 1LL;
          v76 = v57 & 0x1F;
        }
        if ( v81 > (unsigned __int64)v95 )
        {
          v77 = v95;
          do
          {
            v78 = *v77++;
            v76 = v78 & 0x3F | (v76 << 6);
          }
          while ( (char *)v81 != v77 );
          v75 += (__int64)&v95[-v81];
        }
        v38 = 7;
        *v49 = v74 | v50;
        v49[1] = v76 << (6 * v75);
        return v38;
      }
    }
    else
    {
      v72 = v95;
      v73 = 1LL;
      do
      {
        if ( (*v72 & 0xC0) != 0x80 )
          break;
        ++v73;
        ++v72;
      }
      while ( v81 > (unsigned __int64)v72 );
      v89 = v73;
      if ( (char *)v81 == v72 )
      {
        if ( (unsigned __int64 *)v81 == &v96 )
          sub_CF00(
            (__int64)"inend != &bytebuf[MAX_NEEDED_INPUT]",
            (__int64)"../iconv/loop.c",
            0x1DDu,
            "utf8_internal_loop_single",
            a7,
            a8,
            a9,
            a10,
            a11,
            a12,
            a13,
            a14);
        goto LABEL_154;
      }
    }
LABEL_135:
    v38 = 6;
    if ( !v88 || (v18 & 2) == 0 )
      return v38;
    v58 = v89;
    ++*v88;
LABEL_76:
    if ( v51 >= v58 )
      sub_CF00(
        (__int64)"inptr - bytebuf > (state->__count & 7)",
        (__int64)"../iconv/loop.c",
        0x1CBu,
        "utf8_internal_loop_single",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    v18 = *(_DWORD *)(a2 + 16);
    v24 = v22;
    v20 += v58 - v51;
    *a3 = v20;
    *v49 = 0;
LABEL_11:
    if ( (unsigned __int8 *)a4 != v20 )
    {
      v25 = v24 + 1;
      v26 = v20;
      v27 = v24;
      if ( v19 < (unsigned __int64)(v24 + 1) )
      {
LABEL_27:
        v79 = 5;
        goto LABEL_28;
      }
      v79 = 4;
      v28 = v18 & 2;
      while ( 1 )
      {
        v29 = *v26;
        v30 = v26 + 1;
        v31 = *v26;
        if ( (v29 & 0x80u) == 0 )
          goto LABEL_14;
        if ( v29 - 194 <= 0x1D )
        {
          v32 = 2LL;
          v29 = v31 & 0x1F;
          goto LABEL_20;
        }
        if ( (v31 & 0xF0) == 0xE0 )
        {
          v32 = 3LL;
          v34 = 1LL;
          v33 = v26 + 3;
          v29 = v31 & 0xF;
          if ( a4 < (unsigned __int64)(v26 + 3) )
            goto LABEL_44;
          do
          {
LABEL_21:
            v35 = v26[v34];
            if ( (v35 & 0xC0) != 0x80 )
              goto LABEL_39;
            ++v34;
            v29 = v35 & 0x3F | (v29 << 6);
          }
          while ( v32 != v34 );
          if ( (v34 == 2 || v29 >> (5 * v34 - 4)) && v29 - 55296 > 0x7FF )
          {
            v30 = v33;
LABEL_14:
            *v27 = v29;
            v26 = v30;
            v27 = v25;
            goto LABEL_15;
          }
        }
        else
        {
          if ( (v31 & 0xF8) == 0xF0 )
          {
            v32 = 4LL;
            v29 = v31 & 7;
            goto LABEL_20;
          }
          if ( (v31 & 0xFC) == 0xF8 )
          {
            v32 = 5LL;
            v29 = v31 & 3;
            goto LABEL_20;
          }
          if ( (v31 & 0xFE) == 0xFC )
          {
            v32 = 6LL;
            v29 = v31 & 1;
LABEL_20:
            v33 = &v26[v32];
            v34 = 1LL;
            if ( a4 >= (unsigned __int64)&v26[v32] )
              goto LABEL_21;
LABEL_44:
            if ( a4 > (unsigned __int64)v30 )
            {
              do
              {
                if ( (*v30 & 0xC0) != 0x80 )
                  break;
                ++v34;
                ++v30;
              }
              while ( a4 - (_QWORD)v26 != v34 );
            }
            if ( (unsigned __int8 *)a4 == v30 )
            {
              v79 = 7;
              *a3 = v26;
              if ( v84 )
                goto LABEL_50;
              goto LABEL_29;
            }
            goto LABEL_39;
          }
          v34 = 0LL;
          do
            ++v34;
          while ( a4 > (unsigned __int64)&v26[v34] && (v26[v34] & 0xC0) == 0x80 && v34 != 5 );
        }
LABEL_39:
        if ( !v88 || !v28 )
        {
          v79 = 6;
          goto LABEL_28;
        }
        ++*v88;
        v26 += v34;
        v79 = 6;
LABEL_15:
        if ( (unsigned __int8 *)a4 == v26 )
          goto LABEL_28;
        v25 = v27 + 1;
        if ( v19 < (unsigned __int64)(v27 + 1) )
          goto LABEL_27;
      }
    }
    v79 = 4;
    v26 = (unsigned __int8 *)a4;
    v27 = v24;
LABEL_28:
    *a3 = v26;
    if ( v84 )
    {
LABEL_50:
      v38 = v79;
      *v84 = v27;
      return v38;
    }
LABEL_29:
    ++*(_DWORD *)(a2 + 20);
    if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
    {
      v59 = v91;
      *(_QWORD *)a2 = v27;
      v38 = v79;
      *a6 += v59;
      goto LABEL_54;
    }
    if ( v27 > v24 )
    {
      v92 = *(unsigned int **)a2;
      sub_4F2B0((__int64)v83);
      v36 = v83(v86, v87, &v92, v27, 0LL, a6, 0LL);
      if ( v36 != 4 )
      {
        v37 = (unsigned __int64)v92;
        if ( v27 == v92 )
          goto LABEL_33;
        v60 = *(_DWORD *)(a2 + 16);
        *a3 = v20;
        if ( (unsigned __int8 *)a4 == v20 )
          goto LABEL_103;
        v61 = v24 + 1;
        if ( v37 < (unsigned __int64)(v24 + 1) )
        {
          if ( (unsigned int *)v37 == v24 )
            goto LABEL_119;
          goto LABEL_104;
        }
        v62 = v24;
        v80 = v60 & 2;
        while ( 1 )
        {
          v63 = *v20;
          v64 = v20 + 1;
          v65 = *v20;
          if ( (v63 & 0x80u) != 0 )
          {
            if ( v63 - 194 > 0x1D )
            {
              if ( (v65 & 0xF0) == 0xE0 )
              {
                v66 = 3LL;
                v63 = v65 & 0xF;
              }
              else if ( (v65 & 0xF8) == 0xF0 )
              {
                v66 = 4LL;
                v63 = v65 & 7;
              }
              else if ( (v65 & 0xFC) == 0xF8 )
              {
                v66 = 5LL;
                v63 = v65 & 3;
              }
              else
              {
                if ( (v65 & 0xFE) != 0xFC )
                {
                  v67 = 0LL;
                  do
                    ++v67;
                  while ( a4 > (unsigned __int64)&v20[v67] && (v20[v67] & 0xC0) == 0x80 && v67 != 5 );
LABEL_100:
                  if ( !v88 || !v80 )
                    goto LABEL_102;
                  ++*v88;
                  v20 += v67;
                  goto LABEL_83;
                }
                v66 = 6LL;
                v63 = v65 & 1;
              }
            }
            else
            {
              v66 = 2LL;
              v63 = v65 & 0x1F;
            }
            v67 = 1LL;
            if ( a4 < (unsigned __int64)&v20[v66] )
            {
              if ( a4 > (unsigned __int64)v64 )
              {
                do
                {
                  if ( (*v64 & 0xC0) != 0x80 )
                    break;
                  ++v67;
                  ++v64;
                }
                while ( a4 - (_QWORD)v20 != v67 );
              }
              if ( v64 == (unsigned __int8 *)a4 )
              {
LABEL_102:
                v24 = v62;
LABEL_103:
                *a3 = v20;
                if ( (unsigned int *)v37 == v24 )
                  sub_CF00(
                    (__int64)"nstatus == __GCONV_FULL_OUTPUT",
                    (__int64)"../iconv/skeleton.c",
                    0x2EBu,
                    "__gconv_transform_utf8_internal",
                    a7,
                    a8,
                    a9,
                    a10,
                    a11,
                    a12,
                    a13,
                    a14);
                goto LABEL_104;
              }
              goto LABEL_100;
            }
            do
            {
              v68 = v20[v67];
              if ( (v68 & 0xC0) != 0x80 )
                goto LABEL_100;
              ++v67;
              v63 = v68 & 0x3F | (v63 << 6);
            }
            while ( v66 != v67 );
            if ( v67 != 2 && !(v63 >> (5 * v67 - 4)) || v63 - 55296 <= 0x7FF )
              goto LABEL_100;
            v64 = &v20[v66];
          }
          *v62 = v63;
          v20 = v64;
          v62 = v61;
LABEL_83:
          if ( (unsigned __int8 *)a4 == v20 )
            goto LABEL_102;
          v61 = v62 + 1;
          if ( v37 < (unsigned __int64)(v62 + 1) )
          {
            *a3 = v20;
            if ( (unsigned int *)v37 == v62 )
            {
              if ( v24 == (unsigned int *)v37 )
LABEL_119:
                --*(_DWORD *)(a2 + 20);
LABEL_33:
              if ( !v36 )
              {
LABEL_34:
                v24 = *(unsigned int **)a2;
                v18 = *(_DWORD *)(a2 + 16);
                v20 = *a3;
                goto LABEL_11;
              }
              v38 = v36;
LABEL_54:
              if ( a16 && v38 == 7 )
              {
                v40 = *(_DWORD **)(a2 + 32);
                v41 = *a3;
                v42 = **a3;
                v43 = a4 - (_QWORD)*a3;
                *v40 = v43;
                if ( (unsigned int)(v42 - 192) <= 1 )
                  sub_CF00(
                    (__int64)"ch != 0xc0 && ch != 0xc1",
                    (__int64)"../iconv/skeleton.c",
                    0x31Au,
                    "__gconv_transform_utf8_internal",
                    a7,
                    a8,
                    a9,
                    a10,
                    a11,
                    a12,
                    a13,
                    a14);
                if ( (unsigned int)(v42 - 194) > 0x1D )
                {
                  if ( (v42 & 0xF0) == 0xE0 )
                  {
                    v44 = v42 & 0xF;
                    v45 = 2;
                    v46 = 768;
                  }
                  else if ( (v42 & 0xF8) == 0xF0 )
                  {
                    v44 = v42 & 7;
                    v45 = 3;
                    v46 = 1024;
                  }
                  else if ( (v42 & 0xFC) == 0xF8 )
                  {
                    v44 = v42 & 3;
                    v45 = 4;
                    v46 = 1280;
                  }
                  else
                  {
                    v44 = v42 & 1;
                    v45 = 5;
                    v46 = 1536;
                  }
                }
                else
                {
                  v44 = v42 & 0x1F;
                  v45 = 1;
                  v46 = 512;
                }
                v47 = v41 + 1;
                *a3 = v41 + 1;
                if ( a4 > (unsigned __int64)(v41 + 1) )
                {
                  do
                  {
                    v48 = *v47++;
                    *a3 = v47;
                    v44 = v48 & 0x3F | (v44 << 6);
                  }
                  while ( v47 != (unsigned __int8 *)a4 );
                  v45 += (_BYTE)v41 - (_BYTE)v47 + 1;
                }
                *v40 = v43 | v46;
                v40[1] = v44 << (6 * v45);
              }
              return v38;
            }
LABEL_104:
            sub_CF00(
              (__int64)"outbuf == outerr",
              (__int64)"../iconv/skeleton.c",
              0x2EAu,
              "__gconv_transform_utf8_internal",
              a7,
              a8,
              a9,
              a10,
              a11,
              a12,
              a13,
              a14);
          }
        }
      }
      if ( v79 == 5 )
        goto LABEL_34;
    }
    v38 = v79;
    goto LABEL_54;
  }
  if ( a5 )
    sub_CF00(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x1A4u,
      "__gconv_transform_utf8_internal",
      a7,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14);
  v38 = 0;
  **(_QWORD **)(a2 + 32) = 0LL;
  if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
    return v38;
  sub_4F2B0((__int64)v83);
  return v83(v86, v87, 0LL, 0LL, 0LL, a6, a15);
}
// 570BE: variable 'a11' is possibly undefined
// 570BE: variable 'a12' is possibly undefined

//----- (0000000000057700) ----------------------------------------------------
__int64 __fastcall sub_57700(__int64 a1, __int64 a2, unsigned __int64 *a3, unsigned __int64 a4, _QWORD *a5, _QWORD *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16)
{
  int v18; // er8
  unsigned __int64 v19; // r14
  _BYTE *v20; // r15
  _DWORD **v21; // rax
  _DWORD *v22; // r13
  __int64 *v23; // rax
  __int64 v24; // r10
  _BYTE *v25; // rax
  _DWORD *v26; // rcx
  _DWORD *v27; // rbx
  unsigned int v28; // er11
  int v29; // er8
  int v30; // edx
  unsigned int v31; // eax
  unsigned __int64 v32; // rdx
  _BYTE *v34; // rdi
  unsigned __int64 v35; // rdx
  _DWORD *v36; // rcx
  __int64 v37; // rax
  unsigned int *v38; // rdx
  unsigned int v39; // eax
  int v40; // er10
  _BYTE *v41; // rsi
  unsigned __int64 v42; // rcx
  _BYTE *v43; // r15
  __int64 v44; // rcx
  _BYTE *v45; // rcx
  _DWORD *v46; // rdi
  _DWORD *v47; // r11
  int v48; // er10
  int v49; // esi
  unsigned __int64 v50; // rax
  _BYTE *v51; // r15
  _QWORD *v53; // [rsp+8h] [rbp-A0h]
  __int64 (__fastcall *v54)(__int64, __int64, _QWORD, _QWORD, _QWORD, _QWORD *, __int64); // [rsp+10h] [rbp-98h]
  _QWORD *v56; // [rsp+20h] [rbp-88h]
  __int64 v57; // [rsp+28h] [rbp-80h]
  unsigned int v58; // [rsp+30h] [rbp-78h]
  __int64 v59; // [rsp+38h] [rbp-70h]
  __int64 v60; // [rsp+40h] [rbp-68h]
  __int64 *v61; // [rsp+48h] [rbp-60h]
  __int64 v62; // [rsp+50h] [rbp-58h] BYREF
  unsigned __int64 v63; // [rsp+58h] [rbp-50h] BYREF
  unsigned __int16 v64; // [rsp+66h] [rbp-42h]
  unsigned __int64 v65; // [rsp+68h] [rbp-40h]

  v18 = *(_DWORD *)(a2 + 16);
  v65 = __readfsqword(0x28u);
  v54 = 0LL;
  v59 = a1 + 104;
  v60 = a2 + 48;
  if ( (v18 & 1) == 0 )
  {
    v54 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD, _QWORD, _QWORD *, __int64))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v54 = (__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD, _QWORD *, __int64))(__readfsqword(0x30u) ^ __ROR8__(*(_QWORD *)(a1 + 144), 17));
  }
  if ( !(_DWORD)a15 )
  {
    v19 = *(_QWORD *)(a2 + 8);
    v20 = (_BYTE *)*a3;
    v21 = (_DWORD **)a5;
    if ( !a5 )
      v21 = (_DWORD **)a2;
    v22 = *v21;
    v23 = 0LL;
    v62 = 0LL;
    if ( a6 )
      v23 = &v62;
    v61 = v23;
    if ( !a16 || (v38 = *(unsigned int **)(a2 + 32), v39 = *v38, (v40 = *v38 & 7) == 0) )
    {
      v24 = 0LL;
      goto LABEL_11;
    }
    if ( a5 )
      sub_CF00(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x234u,
        "__gconv_transform_ucs2_internal",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    if ( (unsigned int)v40 > 4 )
      sub_CF00(
        (__int64)"(state->__count & 7) <= sizeof (state->__value)",
        (__int64)"../iconv/loop.c",
        0x18Bu,
        "ucs2_internal_loop_single",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    LOBYTE(v64) = *((_BYTE *)v38 + 4);
    if ( v40 == 1 )
    {
      v41 = v20 + 1;
      v42 = 1LL;
    }
    else
    {
      v41 = v20;
      HIBYTE(v64) = *((_BYTE *)v38 + 5);
      v42 = 2LL;
    }
    if ( a4 < (unsigned __int64)v41 )
    {
      *a3 = a4;
      v50 = v42 + a4 - (_QWORD)v20;
      if ( v50 > 4 )
        sub_CF00(
          (__int64)"inlen_after <= sizeof (state->__value.__wchb)",
          (__int64)"../iconv/loop.c",
          0x1A8u,
          "ucs2_internal_loop_single",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      v51 = &v20[-v42];
      if ( v42 < v50 )
      {
        do
        {
          *((_BYTE *)v38 + v42 + 4) = v51[v42];
          ++v42;
        }
        while ( v50 != v42 );
      }
      return 7;
    }
    if ( v19 < (unsigned __int64)(v22 + 1) )
      return 5;
    *((_BYTE *)&v64 + v42) = *v20;
    if ( (unsigned __int16)(v64 + 10240) <= 0x7FFu )
    {
      if ( !v61 || (v18 & 2) == 0 )
        return 6;
      ++*v61;
    }
    else
    {
      *v22 = v64;
      v39 = *v38;
      ++v22;
      v40 = *v38 & 7;
    }
    if ( v40 > 1 )
      sub_CF00(
        (__int64)"inptr - bytebuf > (state->__count & 7)",
        (__int64)"../iconv/loop.c",
        0x1CBu,
        "ucs2_internal_loop_single",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    v43 = &v20[-v40];
    v24 = v62;
    v20 = v43 + 2;
    v18 = *(_DWORD *)(a2 + 16);
    *a3 = (unsigned __int64)v20;
    *v38 = v39 & 0xFFFFFFF8;
    while ( 1 )
    {
LABEL_11:
      if ( a6 )
        v24 += *a6;
      if ( (_BYTE *)a4 == v20 )
      {
        v27 = v22;
        v25 = (_BYTE *)a4;
        v28 = 4;
      }
      else
      {
        v25 = v20 + 2;
        if ( (unsigned __int64)(v20 + 2) > a4 )
        {
          v27 = v22;
          v25 = v20;
          v28 = 7;
        }
        else
        {
          v26 = v22 + 1;
          v27 = v22;
          if ( v19 >= (unsigned __int64)(v22 + 1) )
          {
            v28 = 4;
            v29 = v18 & 2;
            while ( 1 )
            {
              v30 = *((unsigned __int16 *)v25 - 1);
              if ( (unsigned __int16)(v30 + 10240) <= 0x7FFu )
              {
                if ( !v61 || !v29 )
                {
                  v25 -= 2;
                  v28 = 6;
                  goto LABEL_24;
                }
                ++*v61;
                v28 = 6;
              }
              else
              {
                *v27 = v30;
                v27 = v26;
              }
              if ( (_BYTE *)a4 == v25 )
                goto LABEL_24;
              if ( a4 < (unsigned __int64)(v25 + 2) )
              {
                v28 = 7;
                goto LABEL_24;
              }
              v26 = v27 + 1;
              if ( v19 < (unsigned __int64)(v27 + 1) )
                break;
              v25 += 2;
            }
            v28 = 5;
            *a3 = (unsigned __int64)v25;
            if ( !a5 )
              goto LABEL_25;
LABEL_35:
            *a5 = v27;
            return v28;
          }
          v25 = v20;
          v28 = 5;
        }
      }
LABEL_24:
      *a3 = (unsigned __int64)v25;
      if ( a5 )
        goto LABEL_35;
LABEL_25:
      ++*(_DWORD *)(a2 + 20);
      if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
      {
        *(_QWORD *)a2 = v27;
        *a6 += v62;
        goto LABEL_38;
      }
      v56 = a6;
      v57 = v24;
      if ( v27 <= v22 )
        goto LABEL_38;
      v58 = v28;
      v63 = *(_QWORD *)a2;
      sub_4F2B0((__int64)v54);
      v31 = ((__int64 (__fastcall *)(__int64, __int64, unsigned __int64 *, _DWORD *, _QWORD, _QWORD *, _QWORD, _QWORD))v54)(
              v59,
              v60,
              &v63,
              v27,
              0LL,
              v56,
              0LL,
              a16);
      a6 = v56;
      v28 = v58;
      if ( v31 == 4 )
      {
        if ( v58 != 5 )
          goto LABEL_38;
      }
      else
      {
        v32 = v63;
        if ( (_DWORD *)v63 != v27 )
        {
          v44 = 0LL;
          if ( v56 )
            v44 = *v56;
          if ( v62 + v44 == v57 )
          {
            *a3 -= (__int64)((__int64)v27 - v63) / 2;
          }
          else
          {
            if ( (_BYTE *)a4 == v20 )
            {
              v47 = v22;
              v45 = (_BYTE *)a4;
              goto LABEL_79;
            }
            v45 = v20 + 2;
            if ( a4 < (unsigned __int64)(v20 + 2) )
            {
              v47 = v22;
              v45 = v20;
              goto LABEL_79;
            }
            v46 = v22 + 1;
            v47 = v22;
            if ( v63 >= (unsigned __int64)(v22 + 1) )
            {
              v48 = *(_DWORD *)(a2 + 16) & 2;
              while ( 1 )
              {
                v49 = *((unsigned __int16 *)v45 - 1);
                if ( (unsigned __int16)(v49 + 10240) <= 0x7FFu )
                {
                  if ( !v61 || !v48 )
                  {
                    v45 -= 2;
LABEL_79:
                    *a3 = (unsigned __int64)v45;
                    if ( v47 == (_DWORD *)v32 )
                      sub_CF00(
                        (__int64)"nstatus == __GCONV_FULL_OUTPUT",
                        (__int64)"../iconv/skeleton.c",
                        0x2EBu,
                        "__gconv_transform_ucs2_internal",
                        a7,
                        a8,
                        a9,
                        a10,
                        a11,
                        a12,
                        a13,
                        a14);
LABEL_80:
                    sub_CF00(
                      (__int64)"outbuf == outerr",
                      (__int64)"../iconv/skeleton.c",
                      0x2EAu,
                      "__gconv_transform_ucs2_internal",
                      a7,
                      a8,
                      a9,
                      a10,
                      a11,
                      a12,
                      a13,
                      a14);
                  }
                  ++*v61;
                }
                else
                {
                  *v47 = v49;
                  v47 = v46;
                }
                if ( (_BYTE *)a4 == v45 || a4 < (unsigned __int64)(v45 + 2) )
                  goto LABEL_79;
                v46 = v47 + 1;
                if ( v32 < (unsigned __int64)(v47 + 1) )
                  goto LABEL_83;
                v45 += 2;
              }
            }
            v45 = v20;
LABEL_83:
            *a3 = (unsigned __int64)v45;
            if ( v47 != (_DWORD *)v32 )
              goto LABEL_80;
            if ( v47 == v22 )
              --*(_DWORD *)(a2 + 20);
          }
        }
        if ( v31 )
        {
          v28 = v31;
LABEL_38:
          if ( a16 && v28 == 7 )
          {
            v34 = (_BYTE *)*a3;
            v35 = a4 - *a3;
            if ( v35 > 4 )
              sub_CF00(
                (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
                (__int64)"../iconv/skeleton.c",
                0x31Fu,
                "__gconv_transform_ucs2_internal",
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14);
            v36 = *(_DWORD **)(a2 + 32);
            v37 = 0LL;
            if ( v35 )
            {
              do
              {
                *((_BYTE *)v36 + v37 + 4) = v34[v37];
                ++v37;
              }
              while ( v35 != v37 );
            }
            *a3 = a4;
            *v36 = *v36 & 0xFFFFFFF8 | v35;
          }
          return v28;
        }
      }
      v22 = *(_DWORD **)a2;
      v24 = v62;
      v18 = *(_DWORD *)(a2 + 16);
      v20 = (_BYTE *)*a3;
    }
  }
  if ( a5 )
    sub_CF00(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x1A4u,
      "__gconv_transform_ucs2_internal",
      a7,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14);
  v28 = 0;
  **(_QWORD **)(a2 + 32) = 0LL;
  if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
    return v28;
  v53 = a6;
  sub_4F2B0((__int64)v54);
  return v54(v59, v60, 0LL, 0LL, 0LL, v53, a15);
}
// 57CAD: variable 'a11' is possibly undefined
// 57CAD: variable 'a12' is possibly undefined

//----- (0000000000057E60) ----------------------------------------------------
__int64 __fastcall sub_57E60(_QWORD *a1, __int64 a2, __int64 *a3, unsigned __int64 a4, char **a5, __int64 *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16)
{
  __int64 *v16; // r14
  int v19; // er13
  unsigned int *v20; // r12
  char **v21; // rax
  char *v22; // r11
  unsigned __int64 v23; // rax
  __int64 *v24; // rax
  unsigned __int64 v25; // r15
  unsigned __int64 v26; // r11
  __int64 v27; // r10
  char *v28; // rcx
  unsigned int *v29; // rax
  int v30; // er14
  int v31; // er13
  unsigned int *v32; // rdx
  __int64 v33; // rsi
  unsigned int v34; // eax
  int v35; // eax
  int v36; // er13
  unsigned __int64 v37; // r14
  unsigned int v38; // er15
  unsigned int v40; // eax
  unsigned __int64 v41; // r10
  unsigned int *v42; // rax
  unsigned __int64 v43; // rdi
  signed __int64 v44; // r12
  unsigned int v45; // eax
  signed __int64 v46; // rdx
  __int64 v47; // r11
  __int64 v48; // rdi
  unsigned __int64 v49; // rdx
  _DWORD *v50; // rsi
  __int64 v51; // rax
  int v52; // eax
  __int64 v53; // rax
  int v54; // er10
  char *v55; // rdx
  int v56; // er8
  int v57; // er10
  unsigned int *v58; // rax
  __int64 v59; // rsi
  unsigned int v60; // ecx
  unsigned int *v61; // r12
  unsigned int *v62; // rcx
  __int64 v63; // rax
  unsigned __int64 v64; // rax
  unsigned int *v65; // r12
  char v66; // dl
  unsigned int *v67; // r12
  int v68; // eax
  unsigned int v69; // eax
  signed int v70; // eax
  __int64 v71; // rax
  __int64 v72; // rdx
  unsigned __int64 v74; // [rsp+10h] [rbp-D8h]
  __int64 *v75; // [rsp+10h] [rbp-D8h]
  char **v76; // [rsp+18h] [rbp-D0h]
  char *v77; // [rsp+20h] [rbp-C8h]
  unsigned int *v78; // [rsp+20h] [rbp-C8h]
  __int64 v79; // [rsp+20h] [rbp-C8h]
  unsigned __int64 v80; // [rsp+20h] [rbp-C8h]
  unsigned __int64 v81; // [rsp+28h] [rbp-C0h]
  unsigned __int64 v82; // [rsp+28h] [rbp-C0h]
  int v83; // [rsp+28h] [rbp-C0h]
  __int64 v84; // [rsp+30h] [rbp-B8h]
  __int64 (__fastcall *v85)(_QWORD *, __int64, char **, char *, _QWORD, __int64 *, _QWORD, _QWORD); // [rsp+40h] [rbp-A8h]
  __int64 *v86; // [rsp+48h] [rbp-A0h]
  _QWORD *v87; // [rsp+50h] [rbp-98h]
  __int64 v88; // [rsp+58h] [rbp-90h]
  __int64 *v90; // [rsp+68h] [rbp-80h]
  unsigned __int64 v91; // [rsp+70h] [rbp-78h]
  char *v92; // [rsp+78h] [rbp-70h]
  __int64 v93; // [rsp+80h] [rbp-68h] BYREF
  char *v94; // [rsp+88h] [rbp-60h] BYREF
  char *v95; // [rsp+90h] [rbp-58h] BYREF
  char *v96; // [rsp+98h] [rbp-50h] BYREF
  char v97; // [rsp+A3h] [rbp-45h]
  unsigned int v98; // [rsp+A4h] [rbp-44h] BYREF
  __int64 v99[8]; // [rsp+A8h] [rbp-40h] BYREF

  v16 = a6;
  v19 = *(_DWORD *)(a2 + 16);
  v76 = a5;
  v99[0] = __readfsqword(0x28u);
  v85 = 0LL;
  v87 = a1 + 13;
  v88 = a2 + 48;
  if ( (v19 & 1) == 0 )
  {
    v85 = (__int64 (__fastcall *)(_QWORD *, __int64, char **, char *, _QWORD, __int64 *, _QWORD, _QWORD))a1[18];
    if ( a1[13] )
      v85 = (__int64 (__fastcall *)(_QWORD *, __int64, char **, char *, _QWORD, __int64 *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(a1[18], 17));
  }
  if ( !(_DWORD)a15 )
  {
    v20 = (unsigned int *)*a3;
    v21 = a5;
    if ( !a5 )
      v21 = (char **)a2;
    v22 = *v21;
    v23 = *(_QWORD *)(a2 + 8);
    v93 = 0LL;
    v74 = v23;
    v24 = 0LL;
    if ( a6 )
      v24 = &v93;
    v86 = v24;
    if ( !a16 || (v78 = *(unsigned int **)(a2 + 32), (v40 = *v78 & 7) == 0) )
    {
      v25 = (unsigned __int64)v22;
      v26 = v74;
      v75 = a6;
      v27 = 0LL;
      goto LABEL_11;
    }
    if ( a5 )
      sub_CF00(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x234u,
        "__gconv_transform_internal_ucs2",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    v95 = (char *)v20;
    v96 = v22;
    if ( v40 > 4 )
      sub_CF00(
        (__int64)"(state->__count & 7) <= sizeof (state->__value)",
        (__int64)"../iconv/loop.c",
        0x18Bu,
        "internal_ucs2_loop_single",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    v41 = 0LL;
    do
    {
      *((_BYTE *)&v98 + v41) = *((_BYTE *)v78 + v41 + 4);
      ++v41;
    }
    while ( v41 < (*v78 & 7) );
    if ( a4 < (unsigned __int64)v20 - v41 + 4 )
    {
      *a3 = a4;
      v64 = v41 + a4 - (_QWORD)v20;
      if ( v64 > 4 )
        sub_CF00(
          (__int64)"inlen_after <= sizeof (state->__value.__wchb)",
          (__int64)"../iconv/loop.c",
          0x1A8u,
          "internal_ucs2_loop_single",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      v65 = (unsigned int *)((char *)v20 + 1);
      if ( v41 < v64 )
      {
        do
        {
          v95 = (char *)v65;
          v66 = *((_BYTE *)v65 - 1);
          v65 = (unsigned int *)((char *)v65 + 1);
          *((_BYTE *)v78 + v41++ + 4) = v66;
        }
        while ( v64 != v41 );
      }
    }
    else
    {
      v42 = v20;
      v38 = 5;
      if ( v74 < (unsigned __int64)(v22 + 2) )
        return v38;
      do
      {
        v42 = (unsigned int *)((char *)v42 + 1);
        v43 = v41++;
        v95 = (char *)v42;
        *(&v97 + v41) = *((_BYTE *)v42 - 1);
      }
      while ( v41 <= 3 && a4 > (unsigned __int64)v42 );
      v95 = (char *)&v98;
      if ( v98 <= 0xFFFF )
      {
        if ( v98 - 55296 <= 0x7FF )
        {
          v38 = 6;
          if ( !v86 || (v19 & 2) == 0 )
            return v38;
          v44 = 4LL;
          v95 = (char *)v99;
          ++*v86;
          goto LABEL_56;
        }
        *(_WORD *)v22 = v98;
        v96 = v22 + 2;
        goto LABEL_55;
      }
      if ( v98 >> 7 == 7168 )
      {
LABEL_55:
        v44 = 4LL;
        v95 = (char *)v99;
LABEL_56:
        v45 = *v78;
        v46 = *v78 & 7;
        if ( v44 <= v46 )
          sub_CF00(
            (__int64)"inptr - bytebuf > (state->__count & 7)",
            (__int64)"../iconv/loop.c",
            0x1CBu,
            "internal_ucs2_loop_single",
            a7,
            a8,
            a9,
            a10,
            a11,
            a12,
            a13,
            a14);
        v19 = *(_DWORD *)(a2 + 16);
        v47 = (__int64)v96;
        v27 = v93;
        v20 = (unsigned int *)(*a3 + v44 - v46);
        *a3 = (__int64)v20;
        v25 = v47;
        v26 = v74;
        v75 = v16;
        *v78 = v45 & 0xFFFFFFF8;
        goto LABEL_11;
      }
      if ( !v86 )
        return 6;
      if ( (v19 & 8) == 0 )
      {
        v67 = &v98;
        v38 = 6;
        if ( (v19 & 2) == 0 )
          return v38;
        goto LABEL_113;
      }
      v92 = v22;
      v91 = v41;
      v90 = (__int64 *)((char *)&v98 + v41);
      v69 = sub_59FA0(a1, a2, (__int64)v20, (unsigned int **)&v95, (unsigned __int64)&v98 + v41, (__int64 *)&v96, v86);
      v38 = v69;
      if ( v69 == 6 )
      {
        v67 = (unsigned int *)v95;
        if ( (v19 & 2) == 0 )
        {
LABEL_114:
          if ( v67 != &v98 )
          {
            v44 = (char *)v67 - (char *)&v98;
            goto LABEL_56;
          }
          return 6;
        }
LABEL_113:
        v95 = (char *)++v67;
        ++*v86;
        goto LABEL_114;
      }
      v44 = v95 - (char *)&v98;
      if ( v95 != (char *)&v98 )
        goto LABEL_56;
      if ( v69 != 7 )
      {
        if ( v69 )
          return v38;
        v25 = (unsigned __int64)v92;
        v27 = v93;
        v26 = v74;
        v19 = *(_DWORD *)(a2 + 16);
        v75 = v16;
        v20 = (unsigned int *)*a3;
LABEL_11:
        if ( v75 )
          v27 += *v75;
        v95 = (char *)v20;
        v28 = (char *)v25;
        v29 = v20;
        v30 = 4;
        v96 = (char *)v25;
        if ( v20 == (unsigned int *)a4 )
        {
LABEL_21:
          *a3 = (__int64)v29;
          if ( v76 )
            goto LABEL_29;
        }
        else
        {
          v31 = v19 & 2;
          while ( 1 )
          {
            v32 = v29 + 1;
            if ( a4 < (unsigned __int64)(v29 + 1) )
              break;
            v33 = (__int64)(v28 + 2);
            if ( v26 < (unsigned __int64)(v28 + 2) )
            {
              v29 = (unsigned int *)v95;
              v30 = 5;
              goto LABEL_21;
            }
            v34 = *v29;
            if ( v34 > 0xFFFF )
            {
              if ( v34 >> 7 == 7168 )
              {
                v95 = (char *)v32;
                v29 = v32;
              }
              else
              {
                if ( !v86 )
                  goto LABEL_42;
                if ( (*(_BYTE *)(a2 + 16) & 8) == 0
                  || (v82 = v26,
                      v79 = v27,
                      v52 = sub_59FA0(a1, a2, *a3, (unsigned int **)&v95, a4, (__int64 *)&v96, v86),
                      v27 = v79,
                      v26 = v82,
                      v30 = v52,
                      v28 = v96,
                      v52 == 6) )
                {
                  v29 = (unsigned int *)v95;
                  if ( !v31 )
                  {
                    v30 = 6;
                    goto LABEL_21;
                  }
                  v29 = (unsigned int *)(v95 + 4);
                  v30 = 6;
                  v95 += 4;
                  ++*v86;
                }
                else
                {
                  v29 = (unsigned int *)v95;
                  v28 = v96;
                  if ( v30 == 5 )
                    goto LABEL_21;
                }
              }
            }
            else if ( v34 - 55296 <= 0x7FF )
            {
              if ( !v86 || !v31 )
              {
LABEL_42:
                v29 = (unsigned int *)v95;
                v30 = 6;
                goto LABEL_21;
              }
              v95 = (char *)v32;
              v30 = 6;
              ++*v86;
              v29 = v32;
            }
            else
            {
              *(_WORD *)v28 = v34;
              v28 += 2;
              v29 = v32;
              v96 = (char *)v33;
              v95 = (char *)v32;
            }
            if ( (unsigned int *)a4 == v29 )
              goto LABEL_21;
          }
          v30 = 7;
          *a3 = (__int64)v95;
          if ( v76 )
          {
LABEL_29:
            v38 = v30;
            *v76 = v28;
            return v38;
          }
        }
        ++*(_DWORD *)(a2 + 20);
        if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
        {
          v38 = v30;
          *(_QWORD *)a2 = v28;
          *v75 += v93;
          goto LABEL_60;
        }
        v84 = v27;
        v77 = v28;
        if ( (unsigned __int64)v28 <= v25 )
        {
          v36 = v30;
          goto LABEL_26;
        }
        v81 = v26;
        v94 = *(char **)a2;
        sub_4F2B0((__int64)v85);
        v35 = v85(v87, v88, &v94, v77, 0LL, v75, 0LL, a16);
        v26 = v81;
        v36 = v35;
        if ( v35 == 4 )
        {
          v36 = v30;
          if ( v30 != 5 )
            goto LABEL_26;
          goto LABEL_27;
        }
        v37 = (unsigned __int64)v94;
        if ( v94 == v77 )
          goto LABEL_26;
        v53 = 0LL;
        if ( v75 )
          v53 = *v75;
        if ( v84 == v93 + v53 )
        {
          *a3 -= 2 * (v77 - v94);
          goto LABEL_26;
        }
        v54 = *(_DWORD *)(a2 + 16);
        v95 = (char *)v20;
        v96 = (char *)v25;
        *a3 = (__int64)v20;
        if ( v20 == (unsigned int *)a4 )
        {
          if ( v37 != v25 )
            goto LABEL_93;
          goto LABEL_137;
        }
        v55 = (char *)v25;
        v56 = 4;
        v57 = v54 & 2;
        while ( 1 )
        {
          v58 = v20 + 1;
          if ( a4 < (unsigned __int64)(v20 + 1) )
            break;
          v59 = (__int64)(v55 + 2);
          if ( v37 < (unsigned __int64)(v55 + 2) )
          {
            v62 = (unsigned int *)v95;
            v63 = (__int64)v55;
            goto LABEL_95;
          }
          v60 = *v20;
          if ( *v20 > 0xFFFF )
          {
            if ( v60 >> 7 == 7168 )
            {
              v95 = (char *)++v20;
            }
            else
            {
              if ( !v86 )
                break;
              if ( (*(_BYTE *)(a2 + 16) & 8) == 0
                || (v83 = v57,
                    v80 = v26,
                    v68 = sub_59FA0(a1, a2, *a3, (unsigned int **)&v95, a4, (__int64 *)&v96, v86),
                    v26 = v80,
                    v57 = v83,
                    v56 = v68,
                    v55 = v96,
                    v68 == 6) )
              {
                v61 = (unsigned int *)v95;
                if ( !v57 )
                  goto LABEL_92;
                v20 = (unsigned int *)(v95 + 4);
                v56 = 6;
                v95 += 4;
                ++*v86;
              }
              else
              {
                v20 = (unsigned int *)v95;
                v55 = v96;
                v62 = (unsigned int *)v95;
                if ( v68 == 5 )
                {
                  v63 = (__int64)v96;
LABEL_95:
                  v55 = v94;
                  *a3 = (__int64)v62;
                  if ( (char *)v63 != v55 )
LABEL_93:
                    sub_CF00(
                      (__int64)"outbuf == outerr",
                      (__int64)"../iconv/skeleton.c",
                      0x2EAu,
                      "__gconv_transform_internal_ucs2",
                      a7,
                      a8,
                      a9,
                      a10,
                      a11,
                      a12,
                      a13,
                      a14);
LABEL_84:
                  if ( (char *)v25 == v55 )
                    --*(_DWORD *)(a2 + 20);
LABEL_26:
                  if ( !v36 )
                  {
LABEL_27:
                    v25 = *(_QWORD *)a2;
                    v27 = v93;
                    v19 = *(_DWORD *)(a2 + 16);
                    v20 = (unsigned int *)*a3;
                    goto LABEL_11;
                  }
                  v38 = v36;
LABEL_60:
                  if ( a16 && v38 == 7 )
                  {
                    v48 = *a3;
                    v49 = a4 - *a3;
                    if ( v49 > 4 )
                      sub_CF00(
                        (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
                        (__int64)"../iconv/skeleton.c",
                        0x31Fu,
                        "__gconv_transform_internal_ucs2",
                        a7,
                        a8,
                        a9,
                        a10,
                        a11,
                        a12,
                        a13,
                        a14);
                    v50 = *(_DWORD **)(a2 + 32);
                    v51 = 0LL;
                    if ( v49 )
                    {
                      do
                      {
                        *((_BYTE *)v50 + v51 + 4) = *(_BYTE *)(v48 + v51);
                        ++v51;
                      }
                      while ( v49 != v51 );
                    }
                    *a3 = a4;
                    *v50 = *v50 & 0xFFFFFFF8 | v49;
                  }
                  return v38;
                }
              }
            }
          }
          else if ( v60 - 55296 <= 0x7FF )
          {
            if ( !v86 || !v57 )
              break;
            ++v20;
            v95 = (char *)v58;
            v56 = 6;
            ++*v86;
          }
          else
          {
            *(_WORD *)v55 = v60;
            ++v20;
            v55 += 2;
            v96 = (char *)v59;
            v95 = (char *)v58;
          }
          if ( (unsigned int *)a4 == v20 )
          {
            *a3 = a4;
            if ( v94 != v55 )
              goto LABEL_93;
            if ( v56 == 5 )
              goto LABEL_84;
LABEL_137:
            sub_CF00(
              (__int64)"nstatus == __GCONV_FULL_OUTPUT",
              (__int64)"../iconv/skeleton.c",
              0x2EBu,
              "__gconv_transform_internal_ucs2",
              a7,
              a8,
              a9,
              a10,
              a11,
              a12,
              a13,
              a14);
          }
        }
        v61 = (unsigned int *)v95;
LABEL_92:
        *a3 = (__int64)v61;
        if ( v55 != v94 )
          goto LABEL_93;
        goto LABEL_137;
      }
      if ( v90 == v99 )
        sub_CF00(
          (__int64)"inend != &bytebuf[MAX_NEEDED_INPUT]",
          (__int64)"../iconv/loop.c",
          0x1DDu,
          "internal_ucs2_loop_single",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      v70 = *v78 & 0xFFFFFFF8;
      *a3 += v91 - (*v78 & 7);
      if ( v70 >= (__int64)v91 )
        sub_CF00(
          (__int64)"inend - inptr > (state->__count & ~7)",
          (__int64)"../iconv/loop.c",
          0x1E7u,
          "internal_ucs2_loop_single",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      if ( v91 > 4 )
        sub_CF00(
          (__int64)"inend - inptr <= sizeof (state->__value.__wchb)",
          (__int64)"../iconv/loop.c",
          0x1E8u,
          "internal_ucs2_loop_single",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      *v78 = v91 | v70;
      if ( v91 )
      {
        v71 = 0LL;
        do
        {
          *((_BYTE *)v78 + v71 + 4) = *((_BYTE *)&v98 + v71);
          v72 = v71++;
        }
        while ( v43 != v72 );
      }
    }
    return 7;
  }
  if ( a5 )
    sub_CF00(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x1A4u,
      "__gconv_transform_internal_ucs2",
      a7,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14);
  v38 = 0;
  **(_QWORD **)(a2 + 32) = 0LL;
  if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
    return v38;
  sub_4F2B0((__int64)v85);
  return ((__int64 (__fastcall *)(_QWORD *, __int64, _QWORD, _QWORD, _QWORD, __int64 *, __int64))v85)(
           v87,
           v88,
           0LL,
           0LL,
           0LL,
           v16,
           a15);
}
// 58657: variable 'a11' is possibly undefined
// 58657: variable 'a12' is possibly undefined

//----- (0000000000058B30) ----------------------------------------------------
__int64 __fastcall sub_58B30(__int64 a1, __int64 a2, unsigned __int64 *a3, unsigned __int64 a4, _QWORD *a5, __int64 *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16)
{
  int v18; // er11
  unsigned __int64 v19; // r13
  _BYTE *v20; // r14
  _DWORD **v21; // rax
  _DWORD *v22; // r12
  __int64 *v23; // rax
  __int64 v24; // r10
  __int64 *v25; // r15
  _BYTE *v26; // rdx
  _DWORD *v27; // rsi
  _DWORD *v28; // rcx
  int v29; // er11
  unsigned __int16 v30; // ax
  unsigned int v31; // er11
  unsigned int v32; // eax
  unsigned __int64 v33; // rdx
  _BYTE *v35; // rdi
  unsigned __int64 v36; // rdx
  _DWORD *v37; // rcx
  __int64 v38; // rax
  unsigned int *v39; // rcx
  unsigned int v40; // eax
  int v41; // er8
  _BYTE *v42; // rsi
  unsigned __int64 v43; // rdx
  unsigned __int16 v44; // dx
  __int64 v45; // rsi
  _BYTE *v46; // rsi
  _DWORD *v47; // rdi
  _DWORD *v48; // r11
  int v49; // er10
  unsigned __int16 v50; // cx
  unsigned __int64 v51; // rax
  _BYTE *v52; // r14
  __int64 (__fastcall *v55)(__int64, __int64, _QWORD, _QWORD, _QWORD, __int64 *, __int64); // [rsp+10h] [rbp-98h]
  _QWORD *v56; // [rsp+18h] [rbp-90h]
  _DWORD *v57; // [rsp+20h] [rbp-88h]
  __int64 v58; // [rsp+28h] [rbp-80h]
  unsigned int v59; // [rsp+30h] [rbp-78h]
  __int64 v60; // [rsp+38h] [rbp-70h]
  __int64 v61; // [rsp+40h] [rbp-68h]
  __int64 *v62; // [rsp+48h] [rbp-60h]
  __int64 v63; // [rsp+50h] [rbp-58h] BYREF
  unsigned __int64 v64; // [rsp+58h] [rbp-50h] BYREF
  __int16 v65; // [rsp+66h] [rbp-42h]
  unsigned __int64 v66; // [rsp+68h] [rbp-40h]

  v18 = *(_DWORD *)(a2 + 16);
  v56 = a5;
  v66 = __readfsqword(0x28u);
  v55 = 0LL;
  v60 = a1 + 104;
  v61 = a2 + 48;
  if ( (v18 & 1) == 0 )
  {
    v55 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD, _QWORD, __int64 *, __int64))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v55 = (__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD, __int64 *, __int64))(__readfsqword(0x30u) ^ __ROR8__(*(_QWORD *)(a1 + 144), 17));
  }
  if ( !(_DWORD)a15 )
  {
    v19 = *(_QWORD *)(a2 + 8);
    v20 = (_BYTE *)*a3;
    v21 = (_DWORD **)a5;
    if ( !a5 )
      v21 = (_DWORD **)a2;
    v22 = *v21;
    v23 = 0LL;
    v63 = 0LL;
    if ( a6 )
      v23 = &v63;
    v62 = v23;
    if ( !a16 || (v39 = *(unsigned int **)(a2 + 32), v40 = *v39, (v41 = *v39 & 7) == 0) )
    {
      v24 = 0LL;
      v25 = a6;
      goto LABEL_11;
    }
    if ( v56 )
      sub_CF00(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x234u,
        "__gconv_transform_ucs2reverse_internal",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    if ( (unsigned int)v41 > 4 )
      sub_CF00(
        (__int64)"(state->__count & 7) <= sizeof (state->__value)",
        (__int64)"../iconv/loop.c",
        0x18Bu,
        "ucs2reverse_internal_loop_single",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    LOBYTE(v65) = *((_BYTE *)v39 + 4);
    if ( v41 == 1 )
    {
      v42 = v20 + 1;
      v43 = 1LL;
    }
    else
    {
      v42 = v20;
      HIBYTE(v65) = *((_BYTE *)v39 + 5);
      v43 = 2LL;
    }
    if ( a4 < (unsigned __int64)v42 )
    {
      *a3 = a4;
      v51 = v43 + a4 - (_QWORD)v20;
      if ( v51 > 4 )
        sub_CF00(
          (__int64)"inlen_after <= sizeof (state->__value.__wchb)",
          (__int64)"../iconv/loop.c",
          0x1A8u,
          "ucs2reverse_internal_loop_single",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      v52 = &v20[-v43];
      if ( v43 < v51 )
      {
        do
        {
          *((_BYTE *)v39 + v43 + 4) = v52[v43];
          ++v43;
        }
        while ( v51 != v43 );
      }
      return 7;
    }
    if ( v19 < (unsigned __int64)(v22 + 1) )
      return 5;
    *((_BYTE *)&v65 + v43) = *v20;
    v44 = __ROL2__(v65, 8);
    if ( (unsigned __int16)(v44 + 10240) <= 0x7FFu )
    {
      if ( !v62 || (v18 & 2) == 0 )
        return 6;
      ++*v62;
    }
    else
    {
      *v22 = v44;
      v40 = *v39;
      ++v22;
      v41 = *v39 & 7;
    }
    if ( v41 > 1 )
      sub_CF00(
        (__int64)"inptr - bytebuf > (state->__count & 7)",
        (__int64)"../iconv/loop.c",
        0x1CBu,
        "ucs2reverse_internal_loop_single",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    v24 = v63;
    v20 = &v20[-v41 + 2];
    v18 = *(_DWORD *)(a2 + 16);
    v25 = a6;
    *a3 = (unsigned __int64)v20;
    *v39 = v40 & 0xFFFFFFF8;
LABEL_11:
    if ( v25 )
      v24 += *v25;
    if ( (_BYTE *)a4 == v20 )
    {
      v28 = v22;
      v26 = (_BYTE *)a4;
LABEL_56:
      v31 = 4;
    }
    else
    {
      v26 = v20 + 2;
      if ( a4 < (unsigned __int64)(v20 + 2) )
      {
        v28 = v22;
        v26 = v20;
        v31 = 7;
      }
      else
      {
        v27 = v22 + 1;
        v28 = v22;
        if ( (unsigned __int64)(v22 + 1) <= v19 )
        {
          v29 = v18 & 2;
          while ( 1 )
          {
            v30 = __ROL2__(*((_WORD *)v26 - 1), 8);
            if ( (unsigned __int16)(v30 + 10240) <= 0x7FFu )
            {
              if ( !v62 || !v29 )
              {
                v26 -= 2;
                v31 = 6;
                goto LABEL_25;
              }
              ++*v62;
              if ( v26 == (_BYTE *)a4 )
                goto LABEL_56;
            }
            else
            {
              *v28 = v30;
              v28 = v27;
              if ( v26 == (_BYTE *)a4 )
                goto LABEL_56;
            }
            if ( a4 < (unsigned __int64)(v26 + 2) )
              break;
            v27 = v28 + 1;
            if ( v19 < (unsigned __int64)(v28 + 1) )
            {
              v31 = 5;
              goto LABEL_25;
            }
            v26 += 2;
          }
          v31 = 7;
          *a3 = (unsigned __int64)v26;
          if ( v56 )
          {
LABEL_33:
            *v56 = v28;
            return v31;
          }
LABEL_26:
          ++*(_DWORD *)(a2 + 20);
          if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
          {
            *(_QWORD *)a2 = v28;
            *v25 += v63;
            goto LABEL_37;
          }
          v58 = v24;
          v57 = v28;
          if ( v28 <= v22 )
            goto LABEL_37;
          v59 = v31;
          v64 = *(_QWORD *)a2;
          sub_4F2B0((__int64)v55);
          v32 = ((__int64 (__fastcall *)(__int64, __int64, unsigned __int64 *, _DWORD *, _QWORD, __int64 *, _QWORD, _QWORD))v55)(
                  v60,
                  v61,
                  &v64,
                  v57,
                  0LL,
                  v25,
                  0LL,
                  a16);
          v31 = v59;
          if ( v32 == 4 )
          {
            if ( v59 == 5 )
              goto LABEL_31;
            goto LABEL_37;
          }
          v33 = v64;
          if ( (_DWORD *)v64 == v57 )
            goto LABEL_30;
          v45 = 0LL;
          if ( v25 )
            v45 = *v25;
          if ( v63 + v45 == v58 )
          {
            *a3 -= (__int64)((__int64)v57 - v64) / 2;
            goto LABEL_30;
          }
          if ( (_BYTE *)a4 == v20 )
          {
            v48 = v22;
            v46 = (_BYTE *)a4;
          }
          else
          {
            v46 = v20 + 2;
            if ( a4 >= (unsigned __int64)(v20 + 2) )
            {
              v47 = v22 + 1;
              if ( v64 < (unsigned __int64)(v22 + 1) )
              {
                *a3 = (unsigned __int64)v20;
                if ( (_DWORD *)v33 == v22 )
                {
LABEL_86:
                  --*(_DWORD *)(a2 + 20);
                  goto LABEL_30;
                }
                goto LABEL_82;
              }
              v48 = v22;
              v49 = *(_DWORD *)(a2 + 16) & 2;
              while ( 1 )
              {
                v50 = __ROL2__(*((_WORD *)v46 - 1), 8);
                if ( (unsigned __int16)(v50 + 10240) <= 0x7FFu )
                {
                  if ( !v62 || !v49 )
                  {
                    v46 -= 2;
                    goto LABEL_81;
                  }
                  ++*v62;
                }
                else
                {
                  *v48 = v50;
                  v48 = v47;
                }
                if ( (_BYTE *)a4 == v46 || a4 < (unsigned __int64)(v46 + 2) )
                  goto LABEL_81;
                v47 = v48 + 1;
                if ( v33 < (unsigned __int64)(v48 + 1) )
                {
                  *a3 = (unsigned __int64)v46;
                  if ( (_DWORD *)v33 == v48 )
                  {
                    if ( v22 == (_DWORD *)v33 )
                      goto LABEL_86;
LABEL_30:
                    if ( !v32 )
                    {
LABEL_31:
                      v22 = *(_DWORD **)a2;
                      v24 = v63;
                      v18 = *(_DWORD *)(a2 + 16);
                      v20 = (_BYTE *)*a3;
                      goto LABEL_11;
                    }
                    v31 = v32;
LABEL_37:
                    if ( a16 && v31 == 7 )
                    {
                      v35 = (_BYTE *)*a3;
                      v36 = a4 - *a3;
                      if ( v36 > 4 )
                        sub_CF00(
                          (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
                          (__int64)"../iconv/skeleton.c",
                          0x31Fu,
                          "__gconv_transform_ucs2reverse_internal",
                          a7,
                          a8,
                          a9,
                          a10,
                          a11,
                          a12,
                          a13,
                          a14);
                      v37 = *(_DWORD **)(a2 + 32);
                      v38 = 0LL;
                      if ( v36 )
                      {
                        do
                        {
                          *((_BYTE *)v37 + v38 + 4) = v35[v38];
                          ++v38;
                        }
                        while ( v36 != v38 );
                      }
                      *a3 = a4;
                      *v37 = *v37 & 0xFFFFFFF8 | v36;
                    }
                    return v31;
                  }
LABEL_82:
                  sub_CF00(
                    (__int64)"outbuf == outerr",
                    (__int64)"../iconv/skeleton.c",
                    0x2EAu,
                    "__gconv_transform_ucs2reverse_internal",
                    a7,
                    a8,
                    a9,
                    a10,
                    a11,
                    a12,
                    a13,
                    a14);
                }
                v46 += 2;
              }
            }
            v48 = v22;
            v46 = v20;
          }
LABEL_81:
          *a3 = (unsigned __int64)v46;
          if ( (_DWORD *)v33 == v48 )
            sub_CF00(
              (__int64)"nstatus == __GCONV_FULL_OUTPUT",
              (__int64)"../iconv/skeleton.c",
              0x2EBu,
              "__gconv_transform_ucs2reverse_internal",
              a7,
              a8,
              a9,
              a10,
              a11,
              a12,
              a13,
              a14);
          goto LABEL_82;
        }
        v26 = v20;
        v31 = 5;
      }
    }
LABEL_25:
    *a3 = (unsigned __int64)v26;
    if ( v56 )
      goto LABEL_33;
    goto LABEL_26;
  }
  if ( a5 )
    sub_CF00(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x1A4u,
      "__gconv_transform_ucs2reverse_internal",
      a7,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14);
  v31 = 0;
  **(_QWORD **)(a2 + 32) = 0LL;
  if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
    return v31;
  sub_4F2B0((__int64)v55);
  return v55(v60, v61, 0LL, 0LL, 0LL, a6, a15);
}
// 5910D: variable 'a11' is possibly undefined
// 5910D: variable 'a12' is possibly undefined

//----- (00000000000592D0) ----------------------------------------------------
__int64 __fastcall sub_592D0(_QWORD *a1, __int64 a2, __int64 *a3, unsigned __int64 a4, char **a5, __int64 *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, unsigned int a16)
{
  __int64 *v16; // r14
  int v19; // er13
  unsigned int *v20; // r12
  char **v21; // rax
  char *v22; // r11
  unsigned __int64 v23; // rax
  __int64 *v24; // rax
  unsigned __int64 v25; // r15
  unsigned __int64 v26; // r11
  __int64 v27; // r10
  char *v28; // rcx
  unsigned int *v29; // rax
  int v30; // er14
  int v31; // er13
  unsigned int *v32; // rdx
  __int64 v33; // rsi
  unsigned int v34; // eax
  int v35; // eax
  int v36; // er13
  unsigned __int64 v37; // r14
  unsigned int v38; // er15
  unsigned int v40; // eax
  unsigned __int64 v41; // r10
  unsigned int *v42; // rax
  char v43; // dl
  unsigned __int64 v44; // r8
  unsigned int *v45; // rcx
  signed __int64 v46; // r12
  unsigned int v47; // eax
  signed __int64 v48; // rdx
  __int64 v49; // r11
  __int64 v50; // rdi
  unsigned __int64 v51; // rdx
  _DWORD *v52; // rsi
  __int64 v53; // rax
  int v54; // eax
  __int64 v55; // rax
  int v56; // er10
  char *v57; // rcx
  int v58; // edi
  int v59; // er10
  unsigned int *v60; // rdx
  __int64 v61; // rsi
  unsigned int v62; // eax
  unsigned int *v63; // r12
  unsigned int *v64; // rdx
  __int64 v65; // rax
  unsigned __int64 v66; // rax
  unsigned int *v67; // r12
  char v68; // dl
  unsigned int *v69; // r12
  int v70; // eax
  unsigned int v71; // eax
  signed int v72; // eax
  __int64 v73; // rax
  __int64 v74; // rdx
  unsigned __int64 v76; // [rsp+10h] [rbp-D8h]
  __int64 *v77; // [rsp+10h] [rbp-D8h]
  char **v78; // [rsp+18h] [rbp-D0h]
  char *v79; // [rsp+20h] [rbp-C8h]
  unsigned int *v80; // [rsp+20h] [rbp-C8h]
  unsigned __int64 v81; // [rsp+20h] [rbp-C8h]
  unsigned __int64 v82; // [rsp+20h] [rbp-C8h]
  unsigned __int64 v83; // [rsp+28h] [rbp-C0h]
  __int64 v84; // [rsp+28h] [rbp-C0h]
  int v85; // [rsp+28h] [rbp-C0h]
  __int64 v86; // [rsp+30h] [rbp-B8h]
  unsigned __int64 v87; // [rsp+30h] [rbp-B8h]
  __int64 (__fastcall *v88)(_QWORD *, __int64, char **, char *, _QWORD, __int64 *, _QWORD, _QWORD); // [rsp+40h] [rbp-A8h]
  __int64 *v89; // [rsp+48h] [rbp-A0h]
  _QWORD *v90; // [rsp+50h] [rbp-98h]
  __int64 v91; // [rsp+58h] [rbp-90h]
  __int64 *v93; // [rsp+68h] [rbp-80h]
  unsigned __int64 v94; // [rsp+70h] [rbp-78h]
  char *v95; // [rsp+78h] [rbp-70h]
  __int64 v96; // [rsp+80h] [rbp-68h] BYREF
  char *v97; // [rsp+88h] [rbp-60h] BYREF
  char *v98; // [rsp+90h] [rbp-58h] BYREF
  char *v99; // [rsp+98h] [rbp-50h] BYREF
  char v100; // [rsp+A3h] [rbp-45h]
  unsigned int v101; // [rsp+A4h] [rbp-44h] BYREF
  __int64 v102[8]; // [rsp+A8h] [rbp-40h] BYREF

  v16 = a6;
  v19 = *(_DWORD *)(a2 + 16);
  v78 = a5;
  v102[0] = __readfsqword(0x28u);
  v88 = 0LL;
  v90 = a1 + 13;
  v91 = a2 + 48;
  if ( (v19 & 1) == 0 )
  {
    v88 = (__int64 (__fastcall *)(_QWORD *, __int64, char **, char *, _QWORD, __int64 *, _QWORD, _QWORD))a1[18];
    if ( a1[13] )
      v88 = (__int64 (__fastcall *)(_QWORD *, __int64, char **, char *, _QWORD, __int64 *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(a1[18], 17));
  }
  if ( !(_DWORD)a15 )
  {
    v20 = (unsigned int *)*a3;
    v21 = a5;
    if ( !a5 )
      v21 = (char **)a2;
    v22 = *v21;
    v23 = *(_QWORD *)(a2 + 8);
    v96 = 0LL;
    v76 = v23;
    v24 = 0LL;
    if ( a6 )
      v24 = &v96;
    v89 = v24;
    if ( !a16 || (v80 = *(unsigned int **)(a2 + 32), (v40 = *v80 & 7) == 0) )
    {
      v25 = (unsigned __int64)v22;
      v26 = v76;
      v77 = a6;
      v27 = 0LL;
      goto LABEL_11;
    }
    if ( a5 )
      sub_CF00(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x234u,
        "__gconv_transform_internal_ucs2reverse",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    v98 = (char *)v20;
    v99 = v22;
    if ( v40 > 4 )
      sub_CF00(
        (__int64)"(state->__count & 7) <= sizeof (state->__value)",
        (__int64)"../iconv/loop.c",
        0x18Bu,
        "internal_ucs2reverse_loop_single",
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14);
    v41 = 0LL;
    do
    {
      *((_BYTE *)&v101 + v41) = *((_BYTE *)v80 + v41 + 4);
      ++v41;
    }
    while ( v41 < (*v80 & 7) );
    if ( a4 < (unsigned __int64)v20 - v41 + 4 )
    {
      *a3 = a4;
      v66 = v41 + a4 - (_QWORD)v20;
      if ( v66 > 4 )
        sub_CF00(
          (__int64)"inlen_after <= sizeof (state->__value.__wchb)",
          (__int64)"../iconv/loop.c",
          0x1A8u,
          "internal_ucs2reverse_loop_single",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      v67 = (unsigned int *)((char *)v20 + 1);
      if ( v41 < v66 )
      {
        do
        {
          v98 = (char *)v67;
          v68 = *((_BYTE *)v67 - 1);
          v67 = (unsigned int *)((char *)v67 + 1);
          *((_BYTE *)v80 + v41++ + 4) = v68;
        }
        while ( v66 != v41 );
      }
    }
    else
    {
      v42 = (unsigned int *)((char *)v20 + 1);
      v38 = 5;
      if ( v76 < (unsigned __int64)(v22 + 2) )
        return v38;
      do
      {
        v98 = (char *)v42;
        v43 = *((_BYTE *)v42 - 1);
        v44 = v41++;
        v45 = v42;
        v42 = (unsigned int *)((char *)v42 + 1);
        *(&v100 + v41) = v43;
      }
      while ( v41 <= 3 && a4 > (unsigned __int64)v45 );
      v87 = v44;
      v98 = (char *)&v101;
      if ( v101 <= 0xFFFF )
      {
        if ( v101 - 55296 <= 0x7FF )
        {
          v38 = 6;
          if ( !v89 || (v19 & 2) == 0 )
            return v38;
          v46 = 4LL;
          v98 = (char *)v102;
          ++*v89;
          goto LABEL_56;
        }
        *(_WORD *)v22 = __ROL2__(v101, 8);
        v99 = v22 + 2;
        goto LABEL_55;
      }
      if ( v101 >> 7 == 7168 )
      {
LABEL_55:
        v46 = 4LL;
        v98 = (char *)v102;
LABEL_56:
        v47 = *v80;
        v48 = *v80 & 7;
        if ( v48 >= v46 )
          sub_CF00(
            (__int64)"inptr - bytebuf > (state->__count & 7)",
            (__int64)"../iconv/loop.c",
            0x1CBu,
            "internal_ucs2reverse_loop_single",
            a7,
            a8,
            a9,
            a10,
            a11,
            a12,
            a13,
            a14);
        v19 = *(_DWORD *)(a2 + 16);
        v49 = (__int64)v99;
        v27 = v96;
        v20 = (unsigned int *)(*a3 + v46 - v48);
        *a3 = (__int64)v20;
        v25 = v49;
        v26 = v76;
        v77 = v16;
        *v80 = v47 & 0xFFFFFFF8;
        goto LABEL_11;
      }
      if ( !v89 )
        return 6;
      if ( (v19 & 8) == 0 )
      {
        v69 = &v101;
        v38 = 6;
        if ( (v19 & 2) == 0 )
          return v38;
        goto LABEL_113;
      }
      v95 = v22;
      v94 = v41;
      v93 = (__int64 *)((char *)&v101 + v41);
      v71 = sub_59FA0(a1, a2, (__int64)v20, (unsigned int **)&v98, (unsigned __int64)&v101 + v41, (__int64 *)&v99, v89);
      v38 = v71;
      if ( v71 == 6 )
      {
        v69 = (unsigned int *)v98;
        if ( (v19 & 2) == 0 )
        {
LABEL_114:
          if ( v69 != &v101 )
          {
            v46 = (char *)v69 - (char *)&v101;
            goto LABEL_56;
          }
          return 6;
        }
LABEL_113:
        v98 = (char *)++v69;
        ++*v89;
        goto LABEL_114;
      }
      v46 = v98 - (char *)&v101;
      if ( v98 != (char *)&v101 )
        goto LABEL_56;
      if ( v71 != 7 )
      {
        if ( v71 )
          return v38;
        v25 = (unsigned __int64)v95;
        v27 = v96;
        v26 = v76;
        v19 = *(_DWORD *)(a2 + 16);
        v77 = v16;
        v20 = (unsigned int *)*a3;
LABEL_11:
        if ( v77 )
          v27 += *v77;
        v98 = (char *)v20;
        v28 = (char *)v25;
        v29 = v20;
        v30 = 4;
        v99 = (char *)v25;
        if ( v20 == (unsigned int *)a4 )
        {
LABEL_21:
          *a3 = (__int64)v29;
          if ( v78 )
            goto LABEL_29;
        }
        else
        {
          v31 = v19 & 2;
          while ( 1 )
          {
            v32 = v29 + 1;
            if ( a4 < (unsigned __int64)(v29 + 1) )
              break;
            v33 = (__int64)(v28 + 2);
            if ( v26 < (unsigned __int64)(v28 + 2) )
            {
              v29 = (unsigned int *)v98;
              v30 = 5;
              goto LABEL_21;
            }
            v34 = *v29;
            if ( v34 > 0xFFFF )
            {
              if ( v34 >> 7 == 7168 )
              {
                v98 = (char *)v32;
                v29 = v32;
              }
              else
              {
                if ( !v89 )
                  goto LABEL_42;
                if ( (*(_BYTE *)(a2 + 16) & 8) == 0
                  || (v84 = v27,
                      v81 = v26,
                      v54 = sub_59FA0(a1, a2, *a3, (unsigned int **)&v98, a4, (__int64 *)&v99, v89),
                      v26 = v81,
                      v27 = v84,
                      v30 = v54,
                      v28 = v99,
                      v54 == 6) )
                {
                  v29 = (unsigned int *)v98;
                  if ( !v31 )
                  {
                    v30 = 6;
                    goto LABEL_21;
                  }
                  v29 = (unsigned int *)(v98 + 4);
                  v30 = 6;
                  v98 += 4;
                  ++*v89;
                }
                else
                {
                  v29 = (unsigned int *)v98;
                  v28 = v99;
                  if ( v30 == 5 )
                    goto LABEL_21;
                }
              }
            }
            else if ( v34 - 55296 <= 0x7FF )
            {
              if ( !v89 || !v31 )
              {
LABEL_42:
                v29 = (unsigned int *)v98;
                v30 = 6;
                goto LABEL_21;
              }
              v98 = (char *)v32;
              ++*v89;
              v29 = v32;
            }
            else
            {
              *(_WORD *)v28 = __ROL2__(v34, 8);
              v28 += 2;
              v29 = v32;
              v99 = (char *)v33;
              v98 = (char *)v32;
            }
            if ( (unsigned int *)a4 == v29 )
              goto LABEL_21;
          }
          v30 = 7;
          *a3 = (__int64)v98;
          if ( v78 )
          {
LABEL_29:
            v38 = v30;
            *v78 = v28;
            return v38;
          }
        }
        ++*(_DWORD *)(a2 + 20);
        if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
        {
          v38 = v30;
          *(_QWORD *)a2 = v28;
          *v77 += v96;
          goto LABEL_60;
        }
        v86 = v27;
        v79 = v28;
        if ( (unsigned __int64)v28 <= v25 )
        {
          v36 = v30;
          goto LABEL_26;
        }
        v83 = v26;
        v97 = *(char **)a2;
        sub_4F2B0((__int64)v88);
        v35 = v88(v90, v91, &v97, v79, 0LL, v77, 0LL, a16);
        v26 = v83;
        v36 = v35;
        if ( v35 == 4 )
        {
          v36 = v30;
          if ( v30 != 5 )
            goto LABEL_26;
          goto LABEL_27;
        }
        v37 = (unsigned __int64)v97;
        if ( v97 == v79 )
          goto LABEL_26;
        v55 = 0LL;
        if ( v77 )
          v55 = *v77;
        if ( v96 + v55 == v86 )
        {
          *a3 -= 2 * (v79 - v97);
          goto LABEL_26;
        }
        v56 = *(_DWORD *)(a2 + 16);
        v98 = (char *)v20;
        v99 = (char *)v25;
        *a3 = (__int64)v20;
        if ( v20 == (unsigned int *)a4 )
        {
          if ( v37 != v25 )
            goto LABEL_93;
          goto LABEL_137;
        }
        v57 = (char *)v25;
        v58 = 4;
        v59 = v56 & 2;
        while ( 1 )
        {
          v60 = v20 + 1;
          if ( a4 < (unsigned __int64)(v20 + 1) )
            break;
          v61 = (__int64)(v57 + 2);
          if ( v37 < (unsigned __int64)(v57 + 2) )
          {
            v64 = (unsigned int *)v98;
            v65 = (__int64)v57;
            goto LABEL_95;
          }
          v62 = *v20;
          if ( *v20 > 0xFFFF )
          {
            if ( v62 >> 7 == 7168 )
            {
              v98 = (char *)++v20;
            }
            else
            {
              if ( !v89 )
                break;
              if ( (*(_BYTE *)(a2 + 16) & 8) == 0
                || (v85 = v59,
                    v82 = v26,
                    v70 = sub_59FA0(a1, a2, *a3, (unsigned int **)&v98, a4, (__int64 *)&v99, v89),
                    v26 = v82,
                    v59 = v85,
                    v58 = v70,
                    v57 = v99,
                    v70 == 6) )
              {
                v63 = (unsigned int *)v98;
                if ( !v59 )
                  goto LABEL_92;
                v20 = (unsigned int *)(v98 + 4);
                v58 = 6;
                v98 += 4;
                ++*v89;
              }
              else
              {
                v20 = (unsigned int *)v98;
                v57 = v99;
                v64 = (unsigned int *)v98;
                if ( v70 == 5 )
                {
                  v65 = (__int64)v99;
LABEL_95:
                  v57 = v97;
                  *a3 = (__int64)v64;
                  if ( (char *)v65 != v57 )
LABEL_93:
                    sub_CF00(
                      (__int64)"outbuf == outerr",
                      (__int64)"../iconv/skeleton.c",
                      0x2EAu,
                      "__gconv_transform_internal_ucs2reverse",
                      a7,
                      a8,
                      a9,
                      a10,
                      a11,
                      a12,
                      a13,
                      a14);
LABEL_84:
                  if ( (char *)v25 == v57 )
                    --*(_DWORD *)(a2 + 20);
LABEL_26:
                  if ( !v36 )
                  {
LABEL_27:
                    v25 = *(_QWORD *)a2;
                    v27 = v96;
                    v19 = *(_DWORD *)(a2 + 16);
                    v20 = (unsigned int *)*a3;
                    goto LABEL_11;
                  }
                  v38 = v36;
LABEL_60:
                  if ( a16 && v38 == 7 )
                  {
                    v50 = *a3;
                    v51 = a4 - *a3;
                    if ( v51 > 4 )
                      sub_CF00(
                        (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
                        (__int64)"../iconv/skeleton.c",
                        0x31Fu,
                        "__gconv_transform_internal_ucs2reverse",
                        a7,
                        a8,
                        a9,
                        a10,
                        a11,
                        a12,
                        a13,
                        a14);
                    v52 = *(_DWORD **)(a2 + 32);
                    v53 = 0LL;
                    if ( v51 )
                    {
                      do
                      {
                        *((_BYTE *)v52 + v53 + 4) = *(_BYTE *)(v50 + v53);
                        ++v53;
                      }
                      while ( v51 != v53 );
                    }
                    *a3 = a4;
                    *v52 = *v52 & 0xFFFFFFF8 | v51;
                  }
                  return v38;
                }
              }
            }
          }
          else if ( v62 - 55296 <= 0x7FF )
          {
            if ( !v89 || !v59 )
              break;
            v98 = (char *)++v20;
            ++*v89;
          }
          else
          {
            ++v20;
            *(_WORD *)v57 = __ROL2__(v62, 8);
            v57 += 2;
            v99 = (char *)v61;
            v98 = (char *)v60;
          }
          if ( (unsigned int *)a4 == v20 )
          {
            *a3 = a4;
            if ( v97 != v57 )
              goto LABEL_93;
            if ( v58 == 5 )
              goto LABEL_84;
LABEL_137:
            sub_CF00(
              (__int64)"nstatus == __GCONV_FULL_OUTPUT",
              (__int64)"../iconv/skeleton.c",
              0x2EBu,
              "__gconv_transform_internal_ucs2reverse",
              a7,
              a8,
              a9,
              a10,
              a11,
              a12,
              a13,
              a14);
          }
        }
        v63 = (unsigned int *)v98;
LABEL_92:
        *a3 = (__int64)v63;
        if ( v57 != v97 )
          goto LABEL_93;
        goto LABEL_137;
      }
      if ( v93 == v102 )
        sub_CF00(
          (__int64)"inend != &bytebuf[MAX_NEEDED_INPUT]",
          (__int64)"../iconv/loop.c",
          0x1DDu,
          "internal_ucs2reverse_loop_single",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      v72 = *v80 & 0xFFFFFFF8;
      *a3 += v94 - (*v80 & 7);
      if ( v72 >= (__int64)v94 )
        sub_CF00(
          (__int64)"inend - inptr > (state->__count & ~7)",
          (__int64)"../iconv/loop.c",
          0x1E7u,
          "internal_ucs2reverse_loop_single",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      if ( v94 > 4 )
        sub_CF00(
          (__int64)"inend - inptr <= sizeof (state->__value.__wchb)",
          (__int64)"../iconv/loop.c",
          0x1E8u,
          "internal_ucs2reverse_loop_single",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      *v80 = v94 | v72;
      if ( v94 )
      {
        v73 = 0LL;
        do
        {
          *((_BYTE *)v80 + v73 + 4) = *((_BYTE *)&v101 + v73);
          v74 = v73++;
        }
        while ( v74 != v87 );
      }
    }
    return 7;
  }
  if ( a5 )
    sub_CF00(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x1A4u,
      "__gconv_transform_internal_ucs2reverse",
      a7,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14);
  v38 = 0;
  **(_QWORD **)(a2 + 32) = 0LL;
  if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
    return v38;
  sub_4F2B0((__int64)v88);
  return ((__int64 (__fastcall *)(_QWORD *, __int64, _QWORD, _QWORD, _QWORD, __int64 *, __int64))v88)(
           v90,
           v91,
           0LL,
           0LL,
           0LL,
           v16,
           a15);
}
// 59ACA: variable 'a11' is possibly undefined
// 59ACA: variable 'a12' is possibly undefined

//----- (0000000000059FA0) ----------------------------------------------------
__int64 __fastcall sub_59FA0(_QWORD *a1, __int64 a2, __int64 a3, unsigned int **a4, unsigned __int64 a5, __int64 *a6, _QWORD *a7)
{
  __int64 (__fastcall *v8)(_QWORD *, __int64, __int64 *, int *, __int64 *, _QWORD, _QWORD, _QWORD); // r15
  unsigned __int64 v9; // rax
  __int64 v10; // rsi
  __int64 v11; // r14
  __int64 v12; // r11
  int v13; // ebx
  int v14; // edx
  int v15; // er12
  unsigned int *v16; // rax
  unsigned int *v17; // rax
  unsigned __int64 v18; // rax
  __int64 v19; // rax
  unsigned int *v20; // rcx
  unsigned int v21; // edi
  __int64 result; // rax
  __int64 v23; // rax
  __int64 v24; // r14
  int v25; // edx
  int v26; // ebp
  __int64 v27; // rsi
  int *v28; // rax
  int v29; // ebx
  int *v30; // rcx
  int v31; // er8
  __int64 v32; // rax
  unsigned int *v33; // r8
  __int64 v34; // rbx
  __int64 v35; // rbp
  unsigned __int64 v36; // [rsp+0h] [rbp-D8h]
  int *v37; // [rsp+8h] [rbp-D0h]
  unsigned __int64 v38; // [rsp+10h] [rbp-C8h]
  unsigned int *v39; // [rsp+18h] [rbp-C0h]
  unsigned __int64 v40; // [rsp+20h] [rbp-B8h]
  __int64 v43; // [rsp+40h] [rbp-98h]
  __int64 v46; // [rsp+60h] [rbp-78h]
  __int64 v47; // [rsp+68h] [rbp-70h]
  int v48; // [rsp+70h] [rbp-68h]
  __int64 v49; // [rsp+88h] [rbp-50h] BYREF
  __int64 v50[9]; // [rsp+90h] [rbp-48h] BYREF

  v8 = (__int64 (__fastcall *)(_QWORD *, __int64, __int64 *, int *, __int64 *, _QWORD, _QWORD, _QWORD))a1[5];
  v50[1] = __readfsqword(0x28u);
  v39 = *a4;
  if ( *a1 )
    v8 = (__int64 (__fastcall *)(_QWORD *, __int64, __int64 *, int *, __int64 *, _QWORD, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v8, 17));
  v9 = __readfsqword(0xFFFFFFA0);
  v10 = *(_QWORD *)v9;
  v38 = *(unsigned int *)(*(_QWORD *)v9 + 552LL);
  if ( *(_DWORD *)(*(_QWORD *)v9 + 552LL) )
  {
    if ( a5 >= (unsigned __int64)(v39 + 1) )
    {
      v36 = 0LL;
      v11 = *(_QWORD *)(v10 + 568);
      v12 = *(_QWORD *)(v10 + 584);
      v43 = *(_QWORD *)(v10 + 560);
      v46 = *(_QWORD *)(v10 + 576);
      while ( 2 )
      {
        v13 = 0;
        v40 = (v38 + v36) >> 1;
        v14 = *(_DWORD *)(v11 + 4LL * *(unsigned int *)(v43 + 4 * v40));
        v15 = *(_DWORD *)(v43 + 4 * v40);
        v16 = v39;
        while ( *v16 == v14 )
        {
          v14 = *(_DWORD *)(v11 + 4LL * (unsigned int)(++v13 + v15));
          if ( !v14 )
            goto LABEL_23;
          if ( a5 <= (unsigned __int64)++v16 )
            return 7LL;
        }
        if ( v13 )
        {
          if ( v14 )
            return 7LL;
LABEL_23:
          v48 = v13;
          v23 = *(unsigned int *)(v46 + 4 * v40);
          v47 = v11;
          v24 = v12;
          v25 = *(_DWORD *)(v12 + 4 * v23);
          v26 = *(_DWORD *)(v46 + 4 * v40);
          while ( 1 )
          {
            v27 = v24 + 4 * v23;
            if ( v25 )
            {
              v28 = (int *)(v24 + 4 * v23 + 4);
              v29 = 0;
              do
              {
                v30 = v28;
                v31 = *v28++;
                ++v29;
              }
              while ( v31 );
            }
            else
            {
              v30 = (int *)(v24 + 4 * v23);
              v29 = 0;
            }
            v32 = *a6;
            v37 = v30;
            v49 = v27;
            v50[0] = v32;
            sub_4F2B0((__int64)v8);
            result = v8(a1, a2, &v49, v37, v50, 0LL, 0LL, 0LL);
            if ( (_DWORD)result != 6 )
              break;
            v23 = (unsigned int)(v26 + v29 + 1);
            v25 = *(_DWORD *)(v24 + 4 * v23);
            v26 += v29 + 1;
            if ( !v25 )
            {
              v12 = v24;
              v11 = v47;
              v13 = v48;
              v17 = &v39[v48];
              goto LABEL_12;
            }
          }
          if ( (_DWORD)result == 4 )
          {
            *a4 += v48;
            ++*a7;
            result = 0LL;
          }
          else if ( (_DWORD)result == 5 )
          {
            return result;
          }
          goto LABEL_41;
        }
        v17 = v39;
LABEL_12:
        if ( a5 <= (unsigned __int64)v17 || *(_DWORD *)(v11 + 4LL * (unsigned int)(v13 + v15)) < *v17 )
          v36 = v40 + 1;
        else
          v38 = (v38 + v36) >> 1;
        if ( v38 > v36 )
          continue;
        break;
      }
      v18 = __readfsqword(0xFFFFFFA0);
      v10 = *(_QWORD *)v18;
      v19 = *(int *)(*(_QWORD *)v18 + 608LL);
      if ( !(_DWORD)v19 )
        goto LABEL_37;
      v20 = *(unsigned int **)(v10 + 616);
      v39 = *a4;
      v21 = **a4;
      goto LABEL_34;
    }
LABEL_18:
    result = 4LL;
    if ( v39 != (unsigned int *)a5 )
      return 7LL;
    return result;
  }
  v19 = *(int *)(v10 + 608);
  if ( !(_DWORD)v19 )
  {
    v34 = *(unsigned int *)(v10 + 592);
    if ( !(_DWORD)v34 )
      return 6LL;
    v35 = *(_QWORD *)(v10 + 600);
    v49 = v35;
    if ( a5 < (unsigned __int64)(v39 + 1) )
      return 3 * (unsigned int)(v39 != (unsigned int *)a5) + 4;
    goto LABEL_48;
  }
  if ( a5 < (unsigned __int64)(v39 + 1) )
    goto LABEL_18;
  v20 = *(unsigned int **)(v10 + 616);
  v21 = *v39;
LABEL_34:
  if ( (int)v19 > 0 )
  {
    v33 = &v20[3 * v19];
    while ( *v20 <= v21 )
    {
      if ( v20[1] >= v21 && !((v21 - *v20) % v20[2]) )
      {
        *a4 = v39 + 1;
        ++*a7;
        return 0LL;
      }
      v20 += 3;
      if ( v20 == v33 )
        break;
    }
  }
LABEL_37:
  v34 = *(unsigned int *)(v10 + 592);
  if ( !(_DWORD)v34 )
    return 6LL;
  v35 = *(_QWORD *)(v10 + 600);
  v49 = v35;
LABEL_48:
  v50[0] = *a6;
  sub_4F2B0((__int64)v8);
  result = v8(a1, a2, &v49, (int *)(v35 + 4 * v34), v50, 0LL, 0LL, 0LL);
  if ( (_DWORD)result != 6 )
  {
    if ( (_DWORD)result == 4 )
    {
      ++*a7;
      ++*a4;
      result = 0LL;
    }
LABEL_41:
    *a6 = v50[0];
  }
  return result;
}

//----- (000000000005A460) ----------------------------------------------------
__int64 __fastcall sub_5A460(unsigned __int8 *a1, _QWORD *a2)
{
  __int64 v2; // r14
  __int64 v3; // r12
  unsigned int v4; // eax
  unsigned int v5; // er13
  unsigned int v6; // ebx
  unsigned int v7; // ebp
  __int64 result; // rax
  unsigned int v9; // eax
  unsigned __int16 *v10; // r15
  __int64 v11; // rsi
  unsigned int v12; // [rsp+4h] [rbp-54h]
  __int64 v13; // [rsp+8h] [rbp-50h]

  v2 = qword_C1538;
  v3 = *(unsigned __int16 *)(qword_C1538 + 6);
  v13 = *(unsigned __int16 *)(qword_C1538 + 4);
  v4 = sub_11AA0(a1);
  v5 = *(unsigned __int16 *)(v2 + 8);
  v6 = v4 % v5;
  v12 = qword_C1530 - *(unsigned __int16 *)(v2 + 4);
  v7 = v4 % (v5 - 2) + 1;
  while ( 1 )
  {
    v10 = (unsigned __int16 *)(v2 + v3 + 4LL * v6);
    v11 = *v10;
    if ( !(_WORD)v11 )
      return 0xFFFFFFFFLL;
    if ( (unsigned __int16)v11 < v12 )
    {
      result = sub_91B0(a1, v2 + v13 + v11);
      if ( !(_DWORD)result )
        break;
    }
    v9 = v7 + v6;
    if ( v5 <= v7 + v6 )
      v9 = v7 + v6 - v5;
    v6 = v9;
  }
  *a2 = v10[1];
  return result;
}
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// C1530: using guessed type __int64 qword_C1530;
// C1538: using guessed type __int64 qword_C1538;

//----- (000000000005A540) ----------------------------------------------------
__int64 __fastcall sub_5A540(__int64 a1, const void *a2, _QWORD *a3)
{
  __int64 v4; // r14
  __int64 v5; // rax
  size_t v6; // r15
  void *v7; // rsp
  void *v8; // rax
  _QWORD *v9; // rax
  unsigned int v10; // er8
  __int64 v11; // rdx
  __int64 v12; // r12
  __int64 v13; // rax
  __int64 (__fastcall *v14)(_QWORD *); // r12
  _QWORD v16[8]; // [rsp+0h] [rbp-40h] BYREF

  v16[1] = __readfsqword(0x28u);
  v4 = strlen(a1);
  v5 = strlen((__int64)a2);
  v6 = v5 + 1;
  v7 = alloca(v4 + v5 + 1);
  v8 = (void *)sub_91D0(v16, a1, v4);
  memcpy(v8, a2, v6);
  v9 = (_QWORD *)sub_5AEB0(v16);
  v10 = 1;
  *a3 = v9;
  if ( v9 )
  {
    v11 = v9[3];
    v12 = v9[4];
    a3[1] = 0LL;
    v10 = 0;
    v13 = v9[5];
    a3[6] = 0LL;
    a3[7] = v12;
    a3[5] = v11;
    a3[8] = v13;
    a3[12] = 0LL;
    v14 = (__int64 (__fastcall *)(_QWORD *))(__readfsqword(0x30u) ^ __ROR8__(v12, 17));
    if ( v14 )
    {
      sub_4F2B0((__int64)v14);
      v10 = v14(a3);
      a3[6] = __ROL8__(__readfsqword(0x30u) ^ a3[6], 17);
    }
  }
  return v10;
}
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);

//----- (000000000005A660) ----------------------------------------------------
__int64 __fastcall sub_5A660(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  unsigned int v8; // eax
  unsigned int v9; // ebp
  unsigned __int64 v10; // rcx
  __int64 v11; // rdx
  unsigned int v12; // er8
  __int64 v14; // rax
  double v15; // xmm4_8
  double v16; // xmm5_8
  __int64 v17; // rdx
  unsigned __int64 v18; // r12
  __int64 v19; // rax
  __int64 v20; // [rsp+8h] [rbp-C0h]
  struct stat v21; // [rsp+10h] [rbp-B8h] BYREF
  unsigned __int64 v22; // [rsp+A8h] [rbp-20h]

  v22 = __readfsqword(0x28u);
  qword_C1508 = (__int64)sub_12350("GCONV_PATH");
  if ( qword_C1508 )
    return (unsigned int)-1;
  v8 = sub_4B910("/usr/lib/gconv/gconv-modules.cache", 0, 0);
  v9 = v8;
  if ( v8 == -1 )
    return (unsigned int)-1;
  if ( (sub_4AA80(1u, v8, &v21) & 0x80000000) != 0LL || v21.st_size <= 0xFuLL )
    goto LABEL_25;
  qword_C1530 = v21.st_size;
  qword_C1538 = (__int64)mmap(0LL, v21.st_size, 1uLL, 1u, v9, 0LL);
  if ( qword_C1538 != -1 )
    goto LABEL_6;
  v20 = qword_C1530;
  v14 = sub_21500(qword_C1530);
  qword_C1538 = v14;
  if ( !v14 )
  {
LABEL_25:
    sub_4B7A0(v9);
    return (unsigned int)-1;
  }
  v17 = v20;
  v18 = 0LL;
  while ( 1 )
  {
    LODWORD(v19) = sub_4AC10(v9, (char *)(v14 + v18), v17 - v18, a1, a2, a3, a4, v15, v16, a7, a8);
    if ( v19 == -1 )
    {
      sub_21B70(qword_C1538);
      qword_C1538 = 0LL;
      goto LABEL_25;
    }
    v17 = qword_C1530;
    v18 += v19;
    if ( qword_C1530 <= v18 )
      break;
    v14 = qword_C1538;
  }
  dword_C1528 = 1;
LABEL_6:
  sub_4B7A0(v9);
  if ( *(_DWORD *)qword_C1538 != 536937252
    || *(unsigned __int16 *)(qword_C1538 + 4) >= (unsigned __int64)qword_C1530
    || (v10 = *(unsigned __int16 *)(qword_C1538 + 6), qword_C1530 <= v10)
    || (v11 = *(unsigned __int16 *)(qword_C1538 + 8), !(_WORD)v11)
    || qword_C1530 < v10 + 4 * v11
    || qword_C1530 <= (unsigned __int64)*(unsigned __int16 *)(qword_C1538 + 10)
    || (v12 = 0, qword_C1530 < (unsigned __int64)*(unsigned __int16 *)(qword_C1538 + 12)) )
  {
    if ( dword_C1528 )
    {
      sub_21B70(qword_C1538);
      dword_C1528 = 0;
    }
    else
    {
      munmap((void *)qword_C1538, qword_C1530);
    }
    qword_C1538 = 0LL;
    return (unsigned int)-1;
  }
  return v12;
}
// 5A80F: variable 'v19' is possibly undefined
// 5A827: variable 'v15' is possibly undefined
// 5A827: variable 'v16' is possibly undefined
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// C1508: using guessed type __int64 qword_C1508;
// C1528: using guessed type int dword_C1528;
// C1530: using guessed type __int64 qword_C1530;
// C1538: using guessed type __int64 qword_C1538;

//----- (000000000005A880) ----------------------------------------------------
__int64 __fastcall sub_5A880(unsigned __int8 *a1, unsigned __int8 *a2, _DWORD *a3)
{
  __int64 result; // rax
  __int64 v5; // [rsp+8h] [rbp-30h] BYREF
  _QWORD v6[5]; // [rsp+10h] [rbp-28h] BYREF

  v6[1] = __readfsqword(0x28u);
  if ( !qword_C1538 )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)sub_5A460(a1, &v5) || (result = sub_5A460(a2, v6), (_DWORD)result) )
  {
    *a3 = sub_91B0(a1, a2);
    result = 0LL;
  }
  else
  {
    *a3 = v5 - LODWORD(v6[0]);
  }
  return result;
}
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// C1538: using guessed type __int64 qword_C1538;

//----- (000000000005A920) ----------------------------------------------------
__int64 __fastcall sub_5A920(unsigned __int8 *a1, unsigned __int8 *a2, __int64 *a3, __int64 *a4, char a5)
{
  __int64 v5; // r12
  __int64 v7; // r14
  __int64 v8; // r15
  unsigned int v10; // er13
  __int64 v12; // rcx
  __int64 v13; // r15
  __int64 v14; // rsi
  __int64 v15; // rcx
  __int64 v16; // r14
  unsigned __int16 *v17; // rbp
  __int64 v18; // rax
  unsigned __int16 *v19; // rcx
  __int64 v20; // r15
  int v21; // ebp
  __int64 v22; // rdx
  __int64 v23; // rax
  __int64 v24; // rdi
  _BYTE *v25; // rdi
  const void *v26; // r14
  unsigned int v27; // eax
  __int64 v28; // rsi
  __int64 v29; // rax
  __int64 v30; // rdi
  __int64 v31; // rax
  _BYTE *v32; // rdi
  __int64 v33; // rax
  __int64 v34; // rax
  bool v35; // zf
  unsigned __int16 *v36; // r8
  int v37; // edx
  __int64 v38; // rax
  __int64 v39; // r9
  int v40; // ebp
  __int64 v41; // r9
  __int64 v42; // r12
  __int64 v43; // r13
  unsigned __int16 *v44; // r14
  __int64 v45; // rbx
  __int64 v46; // rax
  __int64 v47; // rdi
  _BYTE *v48; // rdi
  __int64 v49; // r9
  __int64 v50; // rax
  unsigned int v52; // [rsp+8h] [rbp-90h]
  unsigned int v53; // [rsp+8h] [rbp-90h]
  __int64 v54; // [rsp+10h] [rbp-88h]
  unsigned __int16 *v55; // [rsp+10h] [rbp-88h]
  unsigned __int16 *v56; // [rsp+10h] [rbp-88h]
  unsigned __int16 *v57; // [rsp+10h] [rbp-88h]
  __int64 v58; // [rsp+18h] [rbp-80h]
  __int64 v59; // [rsp+20h] [rbp-78h]
  unsigned __int16 *v60; // [rsp+28h] [rbp-70h]
  __int64 *v61; // [rsp+38h] [rbp-60h]
  __int64 v62; // [rsp+48h] [rbp-50h] BYREF
  __int64 v63[9]; // [rsp+50h] [rbp-48h] BYREF

  v5 = qword_C1538;
  v63[1] = __readfsqword(0x28u);
  if ( !qword_C1538 )
    return 2;
  v7 = *(unsigned __int16 *)(qword_C1538 + 4);
  v8 = *(unsigned __int16 *)(qword_C1538 + 10);
  if ( (unsigned int)sub_5A460(a2, &v62) )
    return 1;
  v54 = 4 * (3 * v62 + 3);
  if ( v54 + (unsigned __int64)*(unsigned __int16 *)(v5 + 10) > qword_C1530 )
    return 1;
  v10 = sub_5A460(a1, v63);
  if ( v10 )
    return 1;
  v12 = 4 * (3 * v63[0] + 3);
  if ( v12 + (unsigned __int64)*(unsigned __int16 *)(v5 + 10) > qword_C1530 )
    return 1;
  v13 = v5 + v8;
  v14 = v62;
  v15 = v13 + v12 - 12;
  if ( (a5 & 1) != 0 && v63[0] == v62 )
    return (unsigned int)-1;
  v16 = v5 + v7;
  v17 = (unsigned __int16 *)(v13 + v54 - 12);
  if ( !v63[0] )
  {
LABEL_28:
    if ( !v14 )
      goto LABEL_11;
    if ( !v17[2] )
      return 1;
    if ( !v63[0] )
    {
LABEL_22:
      v56 = (unsigned __int16 *)v15;
      v29 = sub_21500(208LL);
      v20 = v29;
      if ( v29 )
      {
        v30 = v17[3];
        *a3 = v29;
        v31 = *v17;
        v32 = (_BYTE *)(v16 + v30);
        *a4 = 0LL;
        *(_QWORD *)(v20 + 32) = "INTERNAL";
        *(_QWORD *)(v20 + 24) = v16 + v31;
        v33 = v17[4];
        *(_DWORD *)(v20 + 16) = 1;
        *(_QWORD *)(v20 + 96) = 0LL;
        if ( *v32 )
        {
          v27 = sub_5A540((__int64)v32, (const void *)(v16 + v33), (_QWORD *)v20);
          v19 = v56;
          if ( v27 )
            goto LABEL_39;
        }
        else
        {
          sub_534E0(v16 + v33, v20);
          v19 = v56;
        }
        v34 = *a4 + 1;
        v35 = v63[0] == 0;
        *a4 = v34;
        if ( v35 )
          return v10;
        v21 = v34;
        v22 = v20 + 104LL * (int)v34;
LABEL_15:
        v23 = *v19;
        v24 = v19[1];
        *(_QWORD *)(v22 + 24) = "INTERNAL";
        *(_DWORD *)(v22 + 16) = 1;
        v25 = (_BYTE *)(v16 + v24);
        *(_QWORD *)(v22 + 96) = 0LL;
        *(_QWORD *)(v22 + 32) = v16 + v23;
        v26 = (const void *)(v19[2] + v16);
        if ( !*v25 )
        {
          sub_534E0((__int64)v26, v22);
          goto LABEL_17;
        }
        v27 = sub_5A540((__int64)v25, v26, (_QWORD *)v22);
        if ( !v27 )
        {
LABEL_17:
          ++*a4;
          return v10;
        }
        if ( v21 )
        {
          v52 = v27;
          sub_51660(v20);
          v27 = v52;
        }
LABEL_39:
        v53 = v27;
        sub_21B70(v20);
        return v53;
      }
      return 3;
    }
LABEL_21:
    if ( *(_WORD *)(v15 + 8) )
      goto LABEL_22;
    return 1;
  }
  if ( !v62 )
  {
LABEL_11:
    if ( v63[0] && *(_WORD *)(v15 + 8) )
    {
      v55 = (unsigned __int16 *)v15;
      v18 = sub_21500(208LL);
      v19 = v55;
      v20 = v18;
      if ( v18 )
      {
        v21 = 0;
        v22 = v18;
        *a3 = v18;
        *a4 = 0LL;
        goto LABEL_15;
      }
      return 3;
    }
    return 1;
  }
  v28 = v17[5];
  if ( !(_WORD)v28
    || (v36 = (unsigned __int16 *)(qword_C1538 + *(unsigned __int16 *)(v5 + 12) + v28 - 1), v37 = *v36, !(_WORD)v37) )
  {
LABEL_20:
    if ( !v17[2] )
      return 1;
    goto LABEL_21;
  }
  while ( v63[0] != v36[3 * v37 - 2] )
  {
    v36 += 3 * (unsigned __int16)v37 + 1;
    v37 = *v36;
    if ( !(_WORD)v37 )
      goto LABEL_20;
  }
  *a4 = (unsigned __int16)v37;
  v59 = v15;
  v57 = v36;
  v38 = sub_21500(104LL * (unsigned __int16)v37);
  v58 = v38;
  *a3 = v38;
  if ( !v38 )
    return 3;
  v39 = *v17;
  v60 = v17;
  v40 = 0;
  v41 = v16 + v39;
  v42 = v38;
  v43 = v16;
  v61 = a4;
  v44 = v57 + 1;
  v45 = v41;
  do
  {
    v46 = *v44;
    v47 = v44[1];
    *(_QWORD *)(v42 + 24) = v45;
    v48 = (_BYTE *)(v43 + v47);
    v49 = *(unsigned __int16 *)(v13 + 12 * v46);
    v50 = v44[2];
    *(_DWORD *)(v42 + 16) = 1;
    *(_QWORD *)(v42 + 96) = 0LL;
    v45 = v43 + v49;
    *(_QWORD *)(v42 + 32) = v43 + v49;
    if ( *v48 )
    {
      if ( (unsigned int)sub_5A540((__int64)v48, (const void *)(v43 + v50), (_QWORD *)v42) )
      {
        v16 = v43;
        v17 = v60;
        v10 = 0;
        a4 = v61;
        sub_21B70(v58);
        v14 = v62;
        v15 = v59;
        goto LABEL_28;
      }
    }
    else
    {
      sub_534E0(v43 + v50, v42);
    }
    ++v40;
    v42 += 104LL;
    v44 += 3;
  }
  while ( *v57 > v40 );
  return 0;
}
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// C1530: using guessed type __int64 qword_C1530;
// C1538: using guessed type __int64 qword_C1538;

//----- (000000000005AE00) ----------------------------------------------------
__int64 __fastcall sub_5AE00(__int64 a1)
{
  __int64 result; // rax

  if ( qword_C1538 )
    result = sub_21B70(a1);
  return result;
}
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// C1538: using guessed type __int64 qword_C1538;

//----- (000000000005AE20) ----------------------------------------------------
__int64 __fastcall sub_5AE20(_QWORD *a1, _QWORD *a2)
{
  return sub_91B0(*a1, *a2);
}
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);

//----- (000000000005AE30) ----------------------------------------------------
void __fastcall sub_5AE30(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v14; // rbx
  int v15; // eax
  __int64 v16; // rdx
  int v17; // eax
  __int64 v18; // rdi

  if ( !(_DWORD)a2 || (_DWORD)a2 == 3 )
  {
    v14 = *a1;
    v15 = *(_DWORD *)(*a1 + 8);
    if ( a3 == *a1 )
    {
      if ( v15 <= 0 )
        sub_CF00(
          (__int64)"obj->counter > 0",
          (__int64)"gconv_dl.c",
          0xA5u,
          "do_release_shlib",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14);
      *(_DWORD *)(a3 + 8) = v15 - 1;
    }
    else
    {
      v16 = (unsigned int)(v15 + 2);
      if ( (unsigned int)v15 >= 0xFFFFFFFE || (_DWORD)v16 == 2 )
      {
        v17 = v15 - 1;
        *(_DWORD *)(v14 + 8) = v17;
        if ( v17 == -3 )
        {
          v18 = *(_QWORD *)(v14 + 16);
          if ( v18 )
          {
            sub_79F90(v18, a2, v16, a4, a5, a6);
            *(_QWORD *)(v14 + 16) = 0LL;
          }
        }
      }
    }
  }
}

//----- (000000000005AEB0) ----------------------------------------------------
__int64 __fastcall sub_5AEB0(void *a1)
{
  __int64 *v1; // rax
  __int64 v2; // rcx
  __int64 v3; // r8
  __int64 v4; // r9
  __int64 v5; // r12
  int v6; // eax
  __int64 v7; // rdx
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rax
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rax
  __int64 v19; // rdi
  __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // r9
  __int64 v24; // rax
  __int64 v25; // rdx
  __int64 v26; // rax
  __int64 v27; // rdx
  __int64 result; // rax
  void *v29; // rbp
  __int64 v30; // rax
  size_t v31; // r13
  void **v32; // rax
  __int64 v33; // rdx
  void *v34; // [rsp+8h] [rbp-20h] BYREF

  v34 = a1;
  v1 = sub_4C220((__int64)&v34, &qword_C1540, (__int64 (__fastcall *)(__int64, _QWORD))sub_5AE20);
  if ( v1 )
  {
    v5 = *v1;
    if ( !*v1 )
      return 0LL;
  }
  else
  {
    v29 = v34;
    v30 = strlen((__int64)v34);
    v31 = v30 + 1;
    v32 = (void **)sub_21500(v30 + 49);
    v5 = (__int64)v32;
    if ( !v32 )
      return 0LL;
    *v32 = memcpy(v32 + 6, v29, v31);
    *(_DWORD *)(v5 + 8) = -3;
    *(_QWORD *)(v5 + 16) = 0LL;
    if ( !sub_4C080(v5, &qword_C1540, (__int64 (__fastcall *)(__int64, _QWORD))sub_5AE20) )
    {
      sub_21B70(v5);
      return 0LL;
    }
  }
  v6 = *(_DWORD *)(v5 + 8);
  v7 = *(_QWORD *)(v5 + 16);
  if ( v6 >= -2 )
  {
    if ( v7 )
    {
      if ( v6 < 0 )
        v6 = 0;
      *(_DWORD *)(v5 + 8) = v6 + 1;
    }
    return v5;
  }
  if ( v7 )
    sub_CF00("found->handle == NULL", "gconv_dl.c", 114LL, "__gconv_find_shlib");
  v8 = sub_7A0B0(*(_QWORD *)v5, -2147483646, 0LL, v2, v3, v4);
  *(_QWORD *)(v5 + 16) = v8;
  if ( v8 )
  {
    v13 = sub_79C80(v8, (__int64)"gconv", v9, v10, v11, v12);
    *(_QWORD *)(v5 + 24) = v13;
    if ( v13 )
    {
      v18 = sub_79C80(*(_QWORD *)(v5 + 16), (__int64)"gconv_init", v14, v15, v16, v17);
      v19 = *(_QWORD *)(v5 + 16);
      *(_QWORD *)(v5 + 32) = v18;
      v24 = sub_79C80(v19, (__int64)"gconv_end", v20, v21, v22, v23);
      v25 = *(_QWORD *)(v5 + 24);
      *(_DWORD *)(v5 + 8) = 1;
      v26 = __ROL8__(__readfsqword(0x30u) ^ v24, 17);
      *(_QWORD *)(v5 + 24) = __ROL8__(__readfsqword(0x30u) ^ v25, 17);
      v27 = *(_QWORD *)(v5 + 32);
      *(_QWORD *)(v5 + 40) = v26;
      result = v5;
      *(_QWORD *)(v5 + 32) = __ROL8__(__readfsqword(0x30u) ^ v27, 17);
      return result;
    }
    v33 = v5;
    v5 = 0LL;
    sub_4C850(qword_C1540, (void (__fastcall *)(__int64, __int64, __int64))sub_5AE30, v33);
    return v5;
  }
  return 0LL;
}
// 5AF14: variable 'v2' is possibly undefined
// 5AF14: variable 'v3' is possibly undefined
// 5AF14: variable 'v4' is possibly undefined
// 5AF31: variable 'v9' is possibly undefined
// 5AF31: variable 'v10' is possibly undefined
// 5AF31: variable 'v11' is possibly undefined
// 5AF31: variable 'v12' is possibly undefined
// 5AF50: variable 'v14' is possibly undefined
// 5AF50: variable 'v15' is possibly undefined
// 5AF50: variable 'v16' is possibly undefined
// 5AF50: variable 'v17' is possibly undefined
// 5AF66: variable 'v20' is possibly undefined
// 5AF66: variable 'v21' is possibly undefined
// 5AF66: variable 'v22' is possibly undefined
// 5AF66: variable 'v23' is possibly undefined
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// C1540: using guessed type __int64 qword_C1540;

//----- (000000000005B0B0) ----------------------------------------------------
__int64 __fastcall sub_5B0B0(__int64 a1)
{
  return sub_4C850(qword_C1540, (void (__fastcall *)(__int64, __int64, __int64))sub_5AE30, a1);
}
// C1540: using guessed type __int64 qword_C1540;

//----- (000000000005B0D0) ----------------------------------------------------
char *__fastcall sub_5B0D0(int a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  __int64 v10; // r14
  _BOOL4 v11; // er12
  u32 *v12; // rbp
  __int64 v13; // r13
  __int64 v14; // rdx
  __int64 v15; // rcx
  u32 *v16; // r8
  u32 v17; // er9
  __int64 v18; // r15
  double v19; // xmm4_8
  double v20; // xmm5_8
  const void *v21; // rbp
  __int64 v22; // rdx
  u32 *v23; // r8
  u32 v24; // er9
  double v25; // xmm4_8
  double v26; // xmm5_8
  char *v28; // rdi
  __int64 i; // r15
  _BYTE *v30; // rax
  _BYTE *v31; // rax
  void *v32; // rdi
  __int64 *v33; // [rsp+0h] [rbp-48h]
  char *v34; // [rsp+8h] [rbp-40h]

  v10 = 0LL;
  v11 = 1;
  v12 = 0LL;
  v33 = (__int64 *)a2;
  while ( 1 )
  {
    if ( v10 != 6 )
    {
      if ( a1 == 6 )
      {
        v13 = v33[v10];
      }
      else if ( a1 == (_DWORD)v10 )
      {
        v13 = *v33;
      }
      else
      {
        v13 = (__int64)*(&off_BF960 + v10);
      }
      v18 = strlen(v13);
      v12 = (u32 *)((char *)v12 + v18 + byte_950F0[v10] + 2);
      if ( v11 )
      {
        a2 = *v33;
        if ( *v33 != v13 )
          v11 = sub_91B0(v13, a2) == 0;
      }
      if ( v10 == 12 )
        break;
    }
    ++v10;
  }
  if ( !v11 )
  {
    v34 = (char *)sub_21500(v12, a2, v14, v15, v16, v17, a3, a4, a5, a6, v19, v20, a9, a10);
    v28 = v34;
    if ( v34 )
    {
      for ( i = 0LL; ; ++i )
      {
        if ( i != 6 )
        {
          v30 = (_BYTE *)sub_90F0(v28);
          *v30 = 61;
          v31 = (_BYTE *)sub_90F0(v30 + 1);
          *v31 = 59;
          v28 = v31 + 1;
          if ( i == 12 )
            break;
        }
      }
      *v31 = 0;
      return v34;
    }
    return 0LL;
  }
  v21 = (const void *)*v33;
  if ( !(unsigned int)sub_91B0(*v33, "C") )
    return "C";
  v34 = "C";
  if ( !(unsigned int)sub_91B0(v21, "POSIX") )
    return v34;
  v32 = (void *)sub_21500(
                  (u32 *)(v18 + 1),
                  (__int64)"POSIX",
                  v22,
                  (__int64)"C",
                  v23,
                  v24,
                  a3,
                  a4,
                  a5,
                  a6,
                  v25,
                  v26,
                  a9,
                  a10);
  if ( !v32 )
    return 0LL;
  return (char *)memcpy(v32, v21, v18 + 1);
}
// 5B1F3: variable 'v14' is possibly undefined
// 5B1F3: variable 'v15' is possibly undefined
// 5B1F3: variable 'v16' is possibly undefined
// 5B1F3: variable 'v17' is possibly undefined
// 5B1F3: variable 'v19' is possibly undefined
// 5B1F3: variable 'v20' is possibly undefined
// 5B297: variable 'v22' is possibly undefined
// 5B297: variable 'v23' is possibly undefined
// 5B297: variable 'v24' is possibly undefined
// 5B297: variable 'v25' is possibly undefined
// 5B297: variable 'v26' is possibly undefined
// 90F0: using guessed type __int64 __fastcall sub_90F0(_QWORD);
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// BF960: using guessed type void *off_BF960;

//----- (000000000005B980) ----------------------------------------------------
void **__fastcall sub_5B980(char *a1, size_t a2, int a3, __int64 **a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  __int64 v14; // rbx
  __int64 *v15; // r12
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // r14
  __int64 v18; // rdx
  __int64 v19; // rcx
  u32 *v20; // r8
  u32 v21; // er9
  double v22; // xmm4_8
  double v23; // xmm5_8
  __int64 *v24; // rdi
  __int64 v25; // rdx
  __int64 v26; // rcx
  u32 *v27; // r8
  u32 v28; // er9
  size_t v29; // r13
  double v30; // xmm4_8
  double v31; // xmm5_8
  __int64 *v33; // rax
  __int64 *v34; // rax
  __int64 *v35; // rax
  __int64 *v36; // r12
  __int64 v37; // rax
  void *v38; // rsp
  unsigned __int8 *v39; // rax
  int v40; // eax
  __int64 v41; // r15
  __int64 v42; // rsi
  __int64 v43; // r10
  _QWORD *v44; // rax
  __int64 v45; // rdx
  u32 *v46; // r8
  __int64 v47; // r9
  double v48; // xmm4_8
  double v49; // xmm5_8
  _QWORD *v50; // rdi
  char v51; // cl
  __int64 v52; // r12
  unsigned __int64 v53; // rcx
  size_t v54; // rdx
  char *v55; // rbx
  __int64 v56; // rax
  char *v57; // r15
  __int64 v58; // rax
  char v59; // dl
  void *v60; // rsp
  char **v61; // rdi
  int v62; // er8
  int v63; // eax
  int v64; // ecx
  int v65; // eax
  __int64 v66; // rbx
  char **v67; // rdi
  double v68; // xmm4_8
  double v69; // xmm5_8
  char **v70; // rax
  __int64 v71; // rdx
  char **v72; // rax
  __int64 v73; // rdx
  int v74; // eax
  unsigned int v75; // eax
  int v76; // edx
  double v77; // xmm4_8
  double v78; // xmm5_8
  __int64 v79; // r15
  __int64 v80; // rax
  char v81; // dl
  void *v82; // rsp
  int v83; // er8
  int v84; // eax
  int v85; // ecx
  int v86; // eax
  __int64 v87; // rax
  __int64 v88; // rdx
  __int64 v89; // rcx
  __int64 v90; // r8
  __int64 v91; // r9
  double v92; // xmm4_8
  double v93; // xmm5_8
  char *v94; // rdi
  __int64 v95; // rsi
  _QWORD *v96; // rax
  __int64 v97; // rdi
  __int64 *v98; // r14
  __int64 v99; // rax
  char *v100; // [rsp+0h] [rbp-90h] BYREF
  int v101; // [rsp+Ch] [rbp-84h]
  _QWORD *v102; // [rsp+10h] [rbp-80h]
  size_t v103; // [rsp+18h] [rbp-78h]
  __int64 *v104; // [rsp+28h] [rbp-68h] BYREF
  unsigned __int8 *v105; // [rsp+30h] [rbp-60h] BYREF
  __int64 v106; // [rsp+38h] [rbp-58h] BYREF
  unsigned __int8 *v107; // [rsp+40h] [rbp-50h] BYREF
  char *v108; // [rsp+48h] [rbp-48h] BYREF
  __int64 v109[8]; // [rsp+50h] [rbp-40h] BYREF

  v14 = a3;
  v103 = a2;
  v15 = *a4;
  v109[1] = __readfsqword(0x28u);
  v104 = v15;
  if ( !*(_BYTE *)v15 )
  {
    v33 = (__int64 *)sub_12350("LC_ALL");
    v104 = v33;
    if ( v33 && *(_BYTE *)v33
      || (v35 = (__int64 *)sub_12350(&aLcCollate[byte_95100[(int)v14]]), (v104 = v35) != 0LL) && *(_BYTE *)v35 )
    {
      v34 = v104;
    }
    else
    {
      v34 = (__int64 *)sub_12350("LANG");
      v104 = v34;
      if ( !v34 )
        goto LABEL_26;
    }
    if ( *(_BYTE *)v34 )
    {
      v15 = v104;
      goto LABEL_2;
    }
LABEL_26:
    v15 = (__int64 *)"C";
    v104 = (__int64 *)"C";
  }
LABEL_2:
  if ( !(unsigned int)sub_91B0(v15, "C") || !(unsigned int)sub_91B0(v15, "POSIX") )
  {
    *a4 = (__int64 *)"C";
    return off_BDA80[v14];
  }
  v16 = strlen((__int64)v15);
  v17 = v16;
  if ( v16 > 0xFF || sub_6C060((unsigned __int8 *)v15, v16, "/../", 4uLL) )
    goto LABEL_17;
  if ( v17 == 2 )
  {
    if ( *(_BYTE *)v15 == 46 )
    {
      if ( *((_BYTE *)v15 + 1) == 46 || sub_9110(v15, 47LL, 2LL) )
        goto LABEL_17;
      goto LABEL_11;
    }
  }
  else if ( v17 > 2
         && (*(_BYTE *)v15 == 46 && *((_BYTE *)v15 + 1) == 46 && *((_BYTE *)v15 + 2) == 47
          || *((_BYTE *)v15 + v17 - 3) == 47 && *((_BYTE *)v15 + v17 - 2) == 46 && *((_BYTE *)v15 + v17 - 1) == 46) )
  {
    goto LABEL_17;
  }
  if ( sub_9110(v15, 47LL, v17) && *(_BYTE *)v15 != 47 )
  {
LABEL_17:
    v29 = 0LL;
    __writefsdword(0xFFFFFFC0, 0x16u);
    return (void **)v29;
  }
LABEL_11:
  v24 = v104;
  *a4 = v104;
  if ( a1 )
  {
    v104 = (__int64 *)sub_10460((__int64)v24, 47LL, a5, a6, a7, a8, v22, v23, a11, a12, v18, v19, v20, v21);
    v36 = v104;
  }
  else
  {
    v29 = sub_5C800(v14, a4, v18, a5, a6, a7, a8, v22, v23, a11, a12);
    if ( v29 )
      return (void **)v29;
    v104 = (__int64 *)sub_10460((__int64)*a4, (__int64)a4, a5, a6, a7, a8, v30, v31, a11, a12, v25, v26, v27, v28);
    if ( !v104 )
    {
      v103 = 16LL;
      a1 = "/usr/lib/locale";
      goto LABEL_86;
    }
    v29 = sub_5C800(v14, &v104, v76, a5, a6, a7, a8, v77, v78, a11, a12);
    if ( v29 )
      return (void **)v29;
    v103 = 16LL;
    v36 = v104;
    a1 = "/usr/lib/locale";
  }
  if ( !v36 )
  {
LABEL_86:
    v36 = *a4;
    v104 = *a4;
  }
  v37 = strlen((__int64)v36);
  v38 = alloca(v37 + 9);
  v39 = (unsigned __int8 *)memcpy(&v100, v36, v37 + 1);
  v40 = sub_10C80(v39, &v105, &v106, &v107, &v108, v109);
  if ( v40 == -1 )
    return 0LL;
  v41 = (int)v14;
  v42 = (__int64)a1;
  v43 = byte_95100[(int)v14];
  v101 = v40;
  v100 = &aLcCollate[v43];
  v102 = (_QWORD *)((char *)&unk_C15A0 + 8 * (int)v14);
  v44 = sub_10650(v102, a1, v103, v40, (__int64)v105, (__int64)v107, (__int64)v108, v109[0], v106, &aLcCollate[v43], 0);
  v50 = v102;
  v51 = v101;
  v52 = (__int64)v44;
  if ( !v44 )
  {
    v42 = (__int64)a1;
    LODWORD(v102) = v101;
    v96 = sub_10650(v50, a1, v103, v101, (__int64)v105, (__int64)v107, (__int64)v108, v109[0], v106, v100, 1);
    v51 = (char)v102;
    v52 = (__int64)v96;
    if ( !v96 )
      return 0LL;
  }
  v53 = v51 & 1;
  if ( (_DWORD)v53 )
    sub_21B70(v109[0], a5, a6, a7, a8, v48, v49, a11, a12, v42, v45, v53, v46, v47);
  LODWORD(v54) = *(_DWORD *)(v52 + 8);
  if ( !(_DWORD)v54 )
    sub_5C440(v52, v14, 0, a5, a6, a7, a8, v48, v49, a11, a12);
  v29 = *(_QWORD *)(v52 + 16);
  if ( !v29 )
  {
    v97 = *(_QWORD *)(v52 + 32);
    if ( !v97 )
    {
LABEL_109:
      *(_QWORD *)(v52 + 32) = 0LL;
      return (void **)v29;
    }
    v98 = (__int64 *)(v52 + 32);
    while ( 1 )
    {
      if ( !*(_DWORD *)(v97 + 8) )
        sub_5C440(v97, v14, v54, a5, a6, a7, a8, v48, v49, a11, a12);
      v99 = *v98;
      v54 = *(_QWORD *)(*v98 + 16);
      if ( v54 )
        break;
      v97 = v98[1];
      ++v98;
      if ( !v97 )
        goto LABEL_109;
    }
    *(_QWORD *)(v52 + 32) = v99;
    v29 = v54;
    v52 = v99;
  }
  v55 = v108;
  if ( !v108 )
    goto LABEL_59;
  v56 = dword_95200[v41];
  v57 = *(char **)(v29 + 8 * v56 + 64);
  if ( !v57 )
    sub_CF00(
      (__int64)"locale_codeset != NULL",
      (__int64)"findlocale.c",
      0x11Bu,
      "_nl_find_locale",
      a5,
      a6,
      a7,
      a8,
      v48,
      v49,
      a11,
      a12);
  v58 = strlen(*(_QWORD *)(v29 + 8 * v56 + 64));
  v59 = *v57;
  v60 = alloca(v58 + 11);
  if ( !*v57 )
  {
    v61 = &v100;
    v64 = 1;
LABEL_71:
    v79 = (unsigned int)(2 - v64) + 1LL;
    if ( v64 > 2 )
      v79 = 1LL;
    v61 = (char **)(v79 + sub_9190((__int64)v61, 47LL, v79));
    goto LABEL_74;
  }
  v61 = &v100;
  v62 = 0;
  do
  {
    v63 = (*(_WORD *)&byte_971A0[2 * v59] >> 3) & 1;
    if ( (unsigned __int8)(v59 - 44) <= 0x33u )
      v63 |= (0x8000000004007uLL >> (v59 - 44)) & 1;
    v64 = v62 + 1;
    if ( (_BYTE)v63 )
    {
      v61 = (char **)((char *)v61 + 1);
      *((_BYTE *)v61 - 1) = dword_968A0[v59];
    }
    else if ( v59 == 47 )
    {
      if ( v62 == 2 )
        goto LABEL_74;
      v65 = v62 + 2;
      *(_BYTE *)v61 = 47;
      ++v62;
      v61 = (char **)((char *)v61 + 1);
      v64 = v65;
    }
    v59 = *++v57;
  }
  while ( v59 );
  if ( v62 <= 1 )
    goto LABEL_71;
LABEL_74:
  *(_BYTE *)v61 = 0;
  v80 = strlen((__int64)v55);
  v81 = *v55;
  v82 = alloca(v80 + 11);
  if ( *v55 )
  {
    v67 = &v100;
    v83 = 0;
    do
    {
      v84 = (*(_WORD *)&byte_971A0[2 * v81] >> 3) & 1;
      if ( (unsigned __int8)(v81 - 44) <= 0x33u )
        v84 |= (0x8000000004007uLL >> (v81 - 44)) & 1;
      v85 = v83 + 1;
      if ( (_BYTE)v84 )
      {
        v67 = (char **)((char *)v67 + 1);
        *((_BYTE *)v67 - 1) = dword_968A0[v81];
      }
      else if ( v81 == 47 )
      {
        if ( v83 == 2 )
          goto LABEL_53;
        v86 = v83 + 2;
        *(_BYTE *)v67 = 47;
        ++v83;
        v67 = (char **)((char *)v67 + 1);
        v85 = v86;
      }
      v81 = *++v55;
    }
    while ( v81 );
    if ( v83 > 1 )
      goto LABEL_53;
  }
  else
  {
    v67 = &v100;
    v85 = 1;
  }
  v66 = (unsigned int)(2 - v85) + 1LL;
  if ( v85 > 2 )
    v66 = 1LL;
  v67 = (char **)(v66 + sub_9190((__int64)v67, 47LL, v66));
LABEL_53:
  *(_BYTE *)v67 = 0;
  v70 = &v100;
  do
  {
    v71 = *(char *)v70;
    v70 = (char **)((char *)v70 + 1);
    LODWORD(v71) = dword_968A0[v71];
    *((_BYTE *)v70 - 1) = v71;
  }
  while ( (_BYTE)v71 );
  v72 = &v100;
  do
  {
    v73 = *(char *)v72;
    v72 = (char **)((char *)v72 + 1);
    LODWORD(v73) = dword_968A0[v73];
    *((_BYTE *)v72 - 1) = v73;
  }
  while ( (_BYTE)v73 );
  if ( (unsigned int)sub_521F0((unsigned __int8 *)&v100, (unsigned __int8 *)&v100, a5, a6, a7, a8, v68, v69, a11, a12) )
    return 0LL;
  v29 = *(_QWORD *)(v52 + 16);
LABEL_59:
  if ( !*(_QWORD *)v29 )
  {
    v87 = sub_90E0(*(_QWORD *)v52, 47LL);
    v94 = (char *)(v87 - 1);
    if ( *(_BYTE *)(v87 - 2) == 47 )
    {
      v95 = 1LL;
    }
    else
    {
      do
        --v94;
      while ( *(v94 - 1) != 47 );
      v95 = v87 - (_QWORD)v94;
    }
    *(_QWORD *)v29 = sub_6BB80(v94, v95, v88, v89, v90, v91, a5, a6, a7, a8, v92, v93, a11, a12);
  }
  if ( v106 )
  {
    v74 = sub_9150(v106, "TRANSLIT", off_BDB00);
    v29 = *(_QWORD *)(v52 + 16);
    if ( !v74 )
      *(_DWORD *)(v29 + 52) = 1;
  }
  else
  {
    v29 = *(_QWORD *)(v52 + 16);
  }
  v75 = *(_DWORD *)(v29 + 48);
  if ( v75 <= 0xFFFFFFFD )
    *(_DWORD *)(v29 + 48) = v75 + 1;
  return (void **)v29;
}
// 5BA79: variable 'v18' is possibly undefined
// 5BA79: variable 'v22' is possibly undefined
// 5BA79: variable 'v23' is possibly undefined
// 5BBA0: variable 'v19' is possibly undefined
// 5BBA0: variable 'v20' is possibly undefined
// 5BBA0: variable 'v21' is possibly undefined
// 5C0A4: variable 'v48' is possibly undefined
// 5C0A4: variable 'v49' is possibly undefined
// 5C0A4: variable 'v45' is possibly undefined
// 5C0A4: variable 'v46' is possibly undefined
// 5C0A4: variable 'v47' is possibly undefined
// 5BDF9: variable 'v68' is possibly undefined
// 5BDF9: variable 'v69' is possibly undefined
// 5BE73: variable 'v30' is possibly undefined
// 5BE73: variable 'v31' is possibly undefined
// 5BE73: variable 'v25' is possibly undefined
// 5BE73: variable 'v26' is possibly undefined
// 5BE73: variable 'v27' is possibly undefined
// 5BE73: variable 'v28' is possibly undefined
// 5BE8B: variable 'v76' is possibly undefined
// 5BE8B: variable 'v77' is possibly undefined
// 5BE8B: variable 'v78' is possibly undefined
// 5C000: variable 'v88' is possibly undefined
// 5C000: variable 'v89' is possibly undefined
// 5C000: variable 'v90' is possibly undefined
// 5C000: variable 'v91' is possibly undefined
// 5C000: variable 'v92' is possibly undefined
// 5C000: variable 'v93' is possibly undefined
// 5C0FA: variable 'v54' is possibly undefined
// 90E0: using guessed type __int64 __fastcall sub_90E0(_QWORD, _QWORD);
// 9110: using guessed type __int64 __fastcall sub_9110(_QWORD, _QWORD, _QWORD);
// 9150: using guessed type __int64 __fastcall sub_9150(_QWORD, _QWORD, _QWORD);
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// BDA80: using guessed type void **off_BDA80[6];
// BDB00: using guessed type void **off_BDB00[6];

//----- (000000000005C1E0) ----------------------------------------------------
__int64 __fastcall sub_5C1E0(unsigned int a1, unsigned int *a2, unsigned __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v15; // rdx
  int v16; // eax
  unsigned __int64 v17; // r13
  __int64 v18; // rax
  unsigned __int64 v19; // rcx
  double v20; // xmm4_8
  double v21; // xmm5_8
  __int64 v22; // r8
  unsigned __int64 v23; // rdx

  if ( a3 <= 7 )
    goto LABEL_14;
  v15 = *a2;
  v16 = 537202711;
  if ( a1 != 3 )
  {
    a4 = 537462560LL;
    v16 = a1 ^ 0x20031115;
    if ( !a1 )
      v16 = 537462560;
  }
  if ( (_DWORD)v15 != v16 )
    goto LABEL_14;
  v17 = a2[1];
  if ( v17 < qword_958A0[a1] || 4 * v17 + 8 >= a3 )
    goto LABEL_14;
  v18 = sub_21500((u32 *)(8 * v17 + 64), (__int64)a2, v15, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
  v22 = v18;
  if ( v18 )
  {
    *(_QWORD *)(v18 + 8) = a2;
    *(_QWORD *)(v18 + 16) = a3;
    *(_QWORD *)(v18 + 32) = 0LL;
    *(_QWORD *)(v18 + 40) = 0LL;
    *(_QWORD *)(v18 + 48) = 0LL;
    *(_DWORD *)(v18 + 56) = v17;
    if ( v17 )
    {
      v23 = a2[2];
      if ( a3 >= v23 )
      {
        if ( a1 <= 0xC )
          __asm { jmp     rcx }
        sub_CF00(
          (__int64)"category == LC_CTYPE",
          (__int64)"loadlocale.c",
          0x90u,
          "_nl_intern_locale_data",
          a7,
          a8,
          a9,
          a10,
          v20,
          v21,
          a13,
          a14);
      }
      sub_21B70(v18, a7, a8, a9, a10, v20, v21, a13, a14, v23, v23, v19, (u32 *)v18, a1);
LABEL_14:
      v22 = 0LL;
      __writefsdword(0xFFFFFFC0, 0x16u);
      return v22;
    }
  }
  return v22;
}
// 5C402: conditional instruction was optimized away because of 'ebp.4>=Du'
// 5C2E3: variable 'v20' is possibly undefined
// 5C2E3: variable 'v21' is possibly undefined
// 5C2E3: variable 'v19' is possibly undefined

//----- (000000000005C440) ----------------------------------------------------
unsigned __int64 __fastcall sub_5C440(__int64 a1, unsigned int a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  signed int v13; // eax
  unsigned int v14; // er14
  __int64 v15; // rsi
  __int64 v16; // rdx
  __int64 v17; // rcx
  u32 *v18; // r8
  u32 v19; // er9
  unsigned int *v20; // r15
  double v21; // xmm4_8
  double v22; // xmm5_8
  __int64 v23; // rcx
  u32 *v24; // r8
  u32 v25; // er9
  double v26; // xmm4_8
  double v27; // xmm5_8
  __int64 v28; // rax
  int v29; // edx
  signed __int64 v31; // r15
  unsigned int *v32; // rax
  char *v33; // r13
  signed __int64 v34; // rax
  __int64 v35; // rdx
  unsigned __int64 v36; // rcx
  u32 *v37; // r8
  __int64 v38; // r9
  double v39; // xmm4_8
  double v40; // xmm5_8
  __int64 v41; // r9
  __int64 v42; // r14
  void *v43; // rsp
  __int64 v44; // rax
  char *v45; // r8
  __int64 v46; // rdi
  __int64 v47; // rcx
  __int64 v48; // rax
  int v49; // edx
  signed int v50; // eax
  __int64 v51; // rdi
  __int64 v52; // rcx
  u32 *v53; // r8
  u32 v54; // er9
  double v55; // xmm4_8
  double v56; // xmm5_8
  char *v57; // [rsp+0h] [rbp-E0h] BYREF
  char *v58; // [rsp+8h] [rbp-D8h]
  struct stat v59; // [rsp+10h] [rbp-D0h] BYREF
  unsigned __int64 v60; // [rsp+A8h] [rbp-38h]

  v60 = __readfsqword(0x28u);
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 16) = 0LL;
  v13 = sub_4B910(*(const char **)a1, (int)sub_80000, a3);
  if ( v13 < 0 )
    return v60 - __readfsqword(0x28u);
  v14 = v13;
  if ( (sub_4AA80(1u, v13, &v59) & 0x80000000) != 0LL )
    goto LABEL_18;
  if ( (v59.st_mode & 0xF000) == 0x4000 )
  {
    sub_4B7A0(v14);
    v57 = *(char **)a1;
    v41 = strlen((__int64)v57);
    v42 = byte_950F0[a2];
    v43 = alloca(v41 + v42 + 14);
    v58 = &aLcCollate[byte_95100[a2]];
    v44 = sub_91D0(&v57, v57, v41);
    v45 = v58;
    *(_DWORD *)v44 = 1398362927;
    v46 = v44;
    v47 = v44 + 5;
    *(_BYTE *)(v44 + 4) = 95;
    v48 = (unsigned int)(v42 + 1);
    if ( (unsigned int)v48 >= 8 )
    {
      v51 = v46 + 13;
      *(_QWORD *)(v51 - 8) = *(_QWORD *)v45;
      v49 = v42 + 1;
      *(_QWORD *)(v47 + (unsigned int)v48 - 8) = *(_QWORD *)&v45[(unsigned int)v48 - 8];
      qmemcpy(
        (void *)(v51 & 0xFFFFFFFFFFFFFFF8LL),
        &v45[-(v47 - (v51 & 0xFFFFFFFFFFFFFFF8LL))],
        8 * ((unsigned __int64)((unsigned int)v48 + (_DWORD)v47 - (v51 & 0xFFFFFFF8)) >> 3));
    }
    else if ( (((_BYTE)v42 + 1) & 4) != 0 )
    {
      *(_DWORD *)(v46 + 5) = *(_DWORD *)v45;
      v49 = *(_DWORD *)&v45[v48 - 4];
      *(_DWORD *)(v47 + v48 - 4) = v49;
    }
    else
    {
      v49 = (unsigned __int8)*v45;
      *(_BYTE *)(v46 + 5) = v49;
      if ( (((_BYTE)v42 + 1) & 2) != 0 )
      {
        v49 = *(unsigned __int16 *)&v45[v48 - 2];
        *(_WORD *)(v47 + v48 - 2) = v49;
      }
    }
    v50 = sub_4B910((const char *)&v57, (int)sub_80000, v49);
    v14 = v50;
    if ( v50 < 0 )
      return v60 - __readfsqword(0x28u);
    if ( (sub_4AA80(1u, v50, &v59) & 0x80000000) != 0LL )
    {
LABEL_18:
      sub_4B7A0(v14);
      return v60 - __readfsqword(0x28u);
    }
  }
  v15 = v59.st_size;
  LODWORD(v58) = __readfsdword(0xFFFFFFC0);
  v20 = (unsigned int *)mmap(0LL, v59.st_size, 1uLL, 2u, v14, 0LL);
  if ( v20 == (unsigned int *)-1LL )
  {
    if ( __readfsdword(0xFFFFFFC0) == 38 )
    {
      v31 = v59.st_size;
      v32 = (unsigned int *)sub_21500((u32 *)v59.st_size, v15, v16, v17, v18, v19, a4, a5, a6, a7, v21, v22, a10, a11);
      v57 = (char *)v32;
      if ( v32 )
      {
        v33 = (char *)v32;
        if ( v31 <= 0 )
        {
LABEL_27:
          __writefsdword(0xFFFFFFC0, (unsigned int)v58);
          sub_4B7A0(v14);
          v28 = sub_5C1E0(a2, (unsigned int *)v57, v59.st_size, v52, v53, v54, a4, a5, a6, a7, v55, v56, a10, a11);
          if ( !v28 )
            return v60 - __readfsqword(0x28u);
          v29 = 0;
          goto LABEL_8;
        }
        while ( 1 )
        {
          v34 = sub_4BA60(v14, v33, v31);
          if ( v34 <= 0 )
            break;
          v31 -= v34;
          v33 += v34;
          if ( v31 <= 0 )
            goto LABEL_27;
        }
        v58 = (char *)v34;
        sub_21B70((__int64)v57, a4, a5, a6, a7, v39, v40, a10, a11, (__int64)v33, v35, v36, v37, v38);
        if ( !v58 )
          __writefsdword(0xFFFFFFC0, 0x16u);
      }
    }
    goto LABEL_18;
  }
  sub_4B7A0(v14);
  if ( v20 )
  {
    v28 = sub_5C1E0(a2, v20, v59.st_size, v23, v24, v25, a4, a5, a6, a7, v26, v27, a10, a11);
    if ( !v28 )
    {
      munmap(v20, v59.st_size);
      return v60 - __readfsqword(0x28u);
    }
    v29 = 1;
LABEL_8:
    *(_QWORD *)v28 = 0LL;
    *(_DWORD *)(v28 + 24) = v29;
    *(_QWORD *)(a1 + 16) = v28;
  }
  return v60 - __readfsqword(0x28u);
}
// 5C69D: conditional instruction was optimized away because of 'er14.4<100u'
// 5C519: variable 'v23' is possibly undefined
// 5C519: variable 'v24' is possibly undefined
// 5C519: variable 'v25' is possibly undefined
// 5C519: variable 'v26' is possibly undefined
// 5C519: variable 'v27' is possibly undefined
// 5C57B: variable 'v16' is possibly undefined
// 5C57B: variable 'v17' is possibly undefined
// 5C57B: variable 'v18' is possibly undefined
// 5C57B: variable 'v19' is possibly undefined
// 5C57B: variable 'v21' is possibly undefined
// 5C57B: variable 'v22' is possibly undefined
// 5C5D0: variable 'v39' is possibly undefined
// 5C5D0: variable 'v40' is possibly undefined
// 5C5D0: variable 'v35' is possibly undefined
// 5C5D0: variable 'v36' is possibly undefined
// 5C5D0: variable 'v37' is possibly undefined
// 5C5D0: variable 'v38' is possibly undefined
// 5C749: variable 'v52' is possibly undefined
// 5C749: variable 'v53' is possibly undefined
// 5C749: variable 'v54' is possibly undefined
// 5C749: variable 'v55' is possibly undefined
// 5C749: variable 'v56' is possibly undefined
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);

//----- (000000000005C7A0) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_5C7A0(__int64 a1, size_t a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14))(_QWORD, _QWORD)
{
  void (*v14)(void); // rax
  int v15; // eax

  v14 = *(void (**)(void))(a1 + 32);
  if ( v14 )
    v14();
  v15 = *(_DWORD *)(a1 + 24);
  if ( v15 )
  {
    if ( v15 == 1 )
    {
      a2 = *(_QWORD *)(a1 + 16);
      munmap(*(void **)(a1 + 8), a2);
      v15 = *(_DWORD *)(a1 + 24);
    }
  }
  else
  {
    sub_21B70(*(_QWORD *)(a1 + 8), a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);
    v15 = *(_DWORD *)(a1 + 24);
  }
  if ( v15 != 2 )
    sub_21B70(*(_QWORD *)a1, a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);
  return sub_21B70(a1, a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);
}
// 5C7D8: variable 'a11' is possibly undefined
// 5C7D8: variable 'a12' is possibly undefined
// 5C7D8: variable 'a3' is possibly undefined
// 5C7D8: variable 'a4' is possibly undefined
// 5C7D8: variable 'a5' is possibly undefined
// 5C7D8: variable 'a6' is possibly undefined

//----- (000000000005C800) ----------------------------------------------------
size_t __fastcall sub_5C800(int a1, __int64 **a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  __int64 *v11; // r13
  _QWORD *v12; // rbx
  __int64 *v13; // r12
  __int64 v14; // r14
  size_t v15; // r10
  __int64 v17; // rax
  int v18; // edx
  unsigned int *v19; // r12
  __int64 v20; // rcx
  unsigned int v21; // er9
  __int64 *v22; // rax
  unsigned __int8 *v23; // rcx
  int v24; // edx
  unsigned __int64 v25; // rcx
  unsigned int v26; // esi
  unsigned __int64 v27; // r10
  unsigned __int64 v28; // r8
  unsigned __int64 v29; // r15
  _DWORD *v30; // rbx
  __int64 v31; // rsi
  int v32; // eax
  double v33; // xmm4_8
  double v34; // xmm5_8
  __int64 v35; // rax
  char *v36; // r9
  unsigned int v37; // er10
  __int64 v38; // rsi
  __int64 v39; // rdx
  char *i; // rcx
  __int64 v41; // rax
  unsigned int v42; // edi
  u32 *v43; // r8
  _QWORD *v44; // r13
  double v45; // xmm4_8
  double v46; // xmm5_8
  void *v47; // rax
  __int64 v48; // rdx
  unsigned __int64 v49; // rcx
  u32 *v50; // r8
  __int64 v51; // r9
  double v52; // xmm4_8
  double v53; // xmm5_8
  __int64 v54; // rax
  __int64 v55; // r12
  __int64 v56; // rax
  __int64 v57; // rdx
  __int64 v58; // r14
  signed int v59; // eax
  unsigned int v60; // er15
  unsigned __int8 *v61; // r15
  _BYTE *v62; // r12
  signed __int64 v63; // rbx
  _DWORD *v64; // rax
  __int64 v65; // r14
  __int64 v66; // rsi
  __int64 v67; // rdx
  unsigned __int64 v68; // rcx
  u32 *v69; // r8
  __int64 v70; // r9
  double v71; // xmm4_8
  double v72; // xmm5_8
  __int64 v73; // rbx
  __int64 v74; // rax
  void *v75; // rsp
  __int64 v76; // rax
  void *v77; // rax
  int v78; // eax
  size_t v79; // r10
  size_t v80; // r14
  unsigned int *v81; // rax
  __int64 v82; // rax
  __int64 v83; // [rsp+0h] [rbp-140h] BYREF
  int v84; // [rsp+Ch] [rbp-134h]
  void **v85; // [rsp+10h] [rbp-130h]
  unsigned __int64 v86; // [rsp+18h] [rbp-128h]
  unsigned __int64 v87; // [rsp+20h] [rbp-120h]
  size_t v88; // [rsp+28h] [rbp-118h]
  char v89[216]; // [rsp+30h] [rbp-110h] BYREF
  unsigned __int64 v90; // [rsp+108h] [rbp-38h]

  v84 = a1;
  v11 = *a2;
  v85 = (void **)a2;
  v90 = __readfsqword(0x28u);
  sub_49C90(30, (__int64)a2, a3);
  v12 = (_QWORD *)qword_C1620;
  if ( !qword_C1620 )
  {
LABEL_8:
    v17 = sub_9210(v11, 46LL);
    if ( v17 && (*(_BYTE *)(v17 + 1) & 0xBF) != 0 )
    {
      v61 = (unsigned __int8 *)(v17 + 1);
      v62 = (_BYTE *)sub_9100(v17 + 1, 64LL);
      v63 = v62 - v61;
      v64 = sub_10B60(v61, v62 - v61);
      v65 = (__int64)v64;
      if ( !v64 )
        return 0LL;
      v66 = (__int64)v61;
      if ( (unsigned int)sub_9130(v64, v61, v63) || *(_BYTE *)(v65 + v63) )
      {
        v73 = strlen(v65);
        v74 = strlen((__int64)v62);
        v88 = v74 + 1;
        v75 = alloca(v61 - (unsigned __int8 *)v11 + v73 + v74 + 9);
        v76 = sub_91D0(&v83, v11, v61 - (unsigned __int8 *)v11);
        v11 = &v83;
        v77 = (void *)sub_91D0(v76, v65, v73);
        v66 = (__int64)v62;
        memcpy(v77, v62, v88);
      }
      sub_21B70(v65, a4, a5, a6, a7, v71, v72, a10, a11, v66, v67, v68, v69, v70);
    }
    if ( qword_C16E8 )
    {
      v19 = (unsigned int *)qword_C16D0;
      if ( qword_C16D0 )
      {
LABEL_12:
        v20 = strlen((__int64)v11);
        v21 = v20;
        if ( !v20 )
          goto LABEL_41;
        v22 = v11;
        v23 = (unsigned __int8 *)v11 + v20;
        do
        {
          v24 = *(unsigned __int8 *)v22;
          v22 = (__int64 *)((char *)v22 + 1);
          v21 = v24 + __ROL4__(v21, 9);
        }
        while ( v22 != (__int64 *)v23 );
        v25 = v21;
        if ( !v21 )
        {
LABEL_41:
          v25 = 0xFFFFFFFFLL;
          v21 = -1;
        }
        v26 = v19[4];
        v83 = v19[2];
        if ( v26 > 2 )
        {
          v27 = v26;
          v28 = v25 % v26;
          v29 = v25 % (v26 - 2) + 1;
LABEL_18:
          v30 = (unsigned int *)((char *)&v19[3 * v28] + v83);
          while ( 1 )
          {
            v31 = (unsigned int)v30[1];
            if ( !(_DWORD)v31 )
              break;
            if ( *v30 == v21 )
            {
              v86 = v28;
              v87 = v27;
              LODWORD(v88) = v21;
              v32 = sub_91B0(v11, (char *)v19 + v31);
              v21 = v88;
              v27 = v87;
              v28 = v86;
              if ( !v32 )
              {
                v35 = (unsigned int)v30[2];
                if ( (_DWORD)v35 )
                {
                  v36 = (char *)v19 + v35;
                  v37 = dword_C16DC;
                  if ( dword_C16DC != qword_C1670 )
                    sub_CF00(
                      (__int64)"headmap.len == archive_stat.st_size",
                      (__int64)"loadarchive.c",
                      0x136u,
                      "_nl_load_locale_from_archive",
                      a4,
                      a5,
                      a6,
                      a7,
                      v33,
                      v34,
                      a10,
                      a11);
                  v38 = 1LL;
                  v39 = 0LL;
                  for ( i = v89; ; i += 16 )
                  {
                    if ( v39 != 6 )
                    {
                      v41 = *(unsigned int *)&v36[8 * v39 + 4];
                      v42 = *(_DWORD *)&v36[8 * v39 + 8];
                      v43 = (u32 *)((unsigned int)v41 + v42);
                      if ( v37 < (unsigned int)v43 )
                        return 0LL;
                      *(_QWORD *)i = (char *)v19 + v41;
                      *((_QWORD *)i + 1) = v42;
                      if ( (_DWORD)v38 == 13 )
                        break;
                    }
                    ++v39;
                    v38 = (unsigned int)(v38 + 1);
                  }
                  v44 = (_QWORD *)sub_21500(
                                    (u32 *)&dword_78,
                                    v38,
                                    v39,
                                    (__int64)i,
                                    v43,
                                    (u32)v36,
                                    a4,
                                    a5,
                                    a6,
                                    a7,
                                    v33,
                                    v34,
                                    a10,
                                    a11);
                  if ( v44 )
                  {
                    v47 = sub_23100(*v85, v38, a4, a5, a6, a7, v45, v46, a10, a11);
                    v44[1] = v47;
                    if ( v47 )
                    {
                      v54 = qword_C1620;
                      v55 = 0LL;
                      qword_C1620 = (__int64)v44;
                      *v44 = v54;
                      while ( 1 )
                      {
                        if ( v55 != 6 )
                        {
                          v56 = sub_5C1E0(
                                  v55,
                                  *(unsigned int **)&v89[16 * v55],
                                  *(_QWORD *)&v89[16 * v55 + 8],
                                  v49,
                                  v50,
                                  v51,
                                  a4,
                                  a5,
                                  a6,
                                  a7,
                                  v52,
                                  v53,
                                  a10,
                                  a11);
                          v44[v55 + 2] = v56;
                          if ( v56 )
                          {
                            v57 = v44[1];
                            *(_DWORD *)(v56 + 24) = 2;
                            *(_DWORD *)(v56 + 48) = -1;
                            *(_QWORD *)v56 = v57;
                          }
                          if ( v55 == 12 )
                            break;
                        }
                        ++v55;
                      }
                      v58 = v84;
                      *v85 = (void *)v44[1];
                      v15 = v44[v58 + 2];
                    }
                    else
                    {
                      v88 = 0LL;
                      sub_21B70((__int64)v44, a4, a5, a6, a7, v52, v53, a10, a11, v38, v48, v49, v50, v51);
                      v15 = v88;
                    }
                    return v15;
                  }
                }
                return 0LL;
              }
            }
            v28 += v29;
            v30 += 3 * v29;
            if ( v27 <= v28 )
            {
              v28 -= v27;
              goto LABEL_18;
            }
          }
        }
        return 0LL;
      }
    }
    else
    {
      v88 = qword_C16E8;
      qword_C16E8 = (__int64)&qword_C16D0;
      v59 = sub_4B910("/usr/lib/locale/locale-archive", (int)sub_80000, v18);
      v60 = v59;
      if ( v59 >= 0 )
      {
        v78 = sub_4AA80(1u, v59, (struct stat *)&unk_C1640);
        v79 = v88;
        if ( v78 != -1 )
        {
          v80 = qword_C1670;
          v81 = (unsigned int *)mmap(0LL, qword_C1670, 1uLL, 2u, v60, 0LL);
          v79 = v88;
          v19 = v81;
          if ( v81 != (unsigned int *)-1LL )
          {
            v82 = v81[2] + 12LL * v81[4];
            if ( v82 < v19[8] + 108LL * v19[9] )
              v82 = v19[8] + 108LL * v19[9];
            if ( v82 < v19[5] + v19[6] )
              v82 = v19[5] + v19[6];
            if ( v80 >= v82 )
            {
              sub_4B7A0(v60);
              qword_C16D0 = (__int64)v19;
              dword_C16DC = v80;
              goto LABEL_12;
            }
            munmap(v19, v80);
            v79 = v88;
          }
        }
        v88 = v79;
        sub_4B7A0(v60);
        return v88;
      }
    }
    return 0LL;
  }
  while ( 1 )
  {
    v13 = (__int64 *)v12[1];
    if ( v13 == v11 || !(unsigned int)sub_91B0(v11, v12[1]) )
      break;
    v12 = (_QWORD *)*v12;
    if ( !v12 )
      goto LABEL_8;
  }
  v14 = v84;
  *v85 = v13;
  return v12[v14 + 2];
}
// 5CA5E: variable 'v33' is possibly undefined
// 5CA5E: variable 'v34' is possibly undefined
// 5CA79: variable 'v45' is possibly undefined
// 5CA79: variable 'v46' is possibly undefined
// 5CACC: variable 'v49' is possibly undefined
// 5CACC: variable 'v50' is possibly undefined
// 5CACC: variable 'v51' is possibly undefined
// 5CACC: variable 'v52' is possibly undefined
// 5CACC: variable 'v53' is possibly undefined
// 5CB38: variable 'v18' is possibly undefined
// 5CC2A: variable 'v71' is possibly undefined
// 5CC2A: variable 'v72' is possibly undefined
// 5CC2A: variable 'v67' is possibly undefined
// 5CC2A: variable 'v68' is possibly undefined
// 5CC2A: variable 'v69' is possibly undefined
// 5CC2A: variable 'v70' is possibly undefined
// 5CD30: variable 'v48' is possibly undefined
// 78: using guessed type int;
// 9100: using guessed type __int64 __fastcall sub_9100(_QWORD, _QWORD);
// 9130: using guessed type __int64 __fastcall sub_9130(_QWORD, _QWORD, _QWORD);
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// 9210: using guessed type __int64 __fastcall sub_9210(_QWORD, _QWORD);
// C1620: using guessed type __int64 qword_C1620;
// C16D0: using guessed type __int64 qword_C16D0;
// C16DC: using guessed type int dword_C16DC;
// C16E8: using guessed type __int64 qword_C16E8;

//----- (000000000005CD70) ----------------------------------------------------
void *sub_5CD70()
{
  char *v0; // rcx
  char *v1; // rax
  char *v2; // rdx
  void *result; // rax
  void *v4; // rdx

  v0 = (char *)off_BF8E0[0][8] + 256;
  v1 = (char *)off_BF8E0[0][11];
  v2 = (char *)off_BF8E0[0][9];
  off_BF948 = v0;
  result = v1 + 512;
  v4 = v2 + 512;
  off_BF950 = result;
  off_BF958 = v4;
  if ( (void ***)__readfsqword(0xFFFFFFA8) == off_BF8E0 )
  {
    __writefsqword(0xFFFFFFF8, (unsigned __int64)v0);
    __writefsqword(0xFFFFFFF0, (unsigned __int64)v4);
    __writefsqword(0xFFFFFFE8, (unsigned __int64)result);
  }
  return result;
}
// BF8E0: using guessed type void **off_BF8E0[6];
// BF948: using guessed type void *off_BF948;
// BF950: using guessed type void *off_BF950;
// BF958: using guessed type void *off_BF958;

//----- (000000000005CDF0) ----------------------------------------------------
__int64 __fastcall sub_5CDF0(int a1)
{
  return *(_QWORD *)(__readfsqword(0xFFFFFFA8) + 8LL * a1 + 128);
}

//----- (000000000005CE70) ----------------------------------------------------
unsigned __int64 sub_5CE70()
{
  _QWORD *v0; // rax
  unsigned __int64 result; // rax

  v0 = *(_QWORD **)__readfsqword(0xFFFFFFA0);
  __writefsqword(0xFFFFFFF8, v0[8] + 256LL);
  __writefsqword(0xFFFFFFF0, v0[9] + 512LL);
  result = v0[11] + 512LL;
  __writefsqword(0xFFFFFFE8, result);
  return result;
}

//----- (000000000005CED0) ----------------------------------------------------
__int64 sub_5CED0()
{
  return 0LL;
}
// 5CED0: using guessed type __int64 __fastcall sub_5CED0();

//----- (000000000005CF30) ----------------------------------------------------
__int64 __fastcall sub_5CF30(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7)
{
  __int64 v7; // rbx
  __int64 v8; // rbp
  __int64 v9; // r12
  __int64 v10; // r13
  __int64 v11; // r14
  __int64 v12; // r15
  __int64 result; // rax
  _BOOL4 v15; // esi
  unsigned __int64 retaddr; // [rsp+0h] [rbp+0h]

  *(_QWORD *)a1 = v7;
  *(_QWORD *)(a1 + 8) = __ROL8__(__readfsqword(0x30u) ^ v8, 17);
  *(_QWORD *)(a1 + 16) = v9;
  *(_QWORD *)(a1 + 24) = v10;
  *(_QWORD *)(a1 + 32) = v11;
  *(_QWORD *)(a1 + 40) = v12;
  *(_QWORD *)(a1 + 48) = __ROL8__(__readfsqword(0x30u) ^ (unsigned __int64)&a7, 17);
  *(_QWORD *)(a1 + 56) = __ROL8__(__readfsqword(0x30u) ^ retaddr, 17);
  __asm { rdsspq  rax }
  *(_QWORD *)(a1 + 88) = _RAX;
  if ( a2 )
  {
    v15 = sub_5D2B0(0, 0LL, (sigset_t *)(a1 + 72)) == 0;
    result = 0LL;
    *(_DWORD *)(a1 + 64) = v15;
  }
  else
  {
    *(_DWORD *)(a1 + 64) = 0;
    result = 0LL;
  }
  return result;
}
// 5CF34: variable 'v7' is possibly undefined
// 5CF3A: variable 'v8' is possibly undefined
// 5CF4B: variable 'v9' is possibly undefined
// 5CF4F: variable 'v10' is possibly undefined
// 5CF53: variable 'v11' is possibly undefined
// 5CF57: variable 'v12' is possibly undefined

//----- (000000000005CFE0) ----------------------------------------------------
__int64 __fastcall sub_5CFE0(__int64 a1)
{
  __int64 (*v1)(void); // rdx
  __int64 v3; // rax
  unsigned __int64 v4; // rax
  bool v6; // cc

  v1 = (__int64 (*)(void))(__readfsqword(0x30u) ^ __ROR8__(*(_QWORD *)(a1 + 56), 17));
  __asm { rdsspq  rax }
  v3 = _RAX - *(_QWORD *)(a1 + 88);
  if ( v3 )
  {
    v4 = ((unsigned __int64)-v3 >> 3) + 1;
    _RBX = 255LL;
    do
    {
      if ( v4 < _RBX )
        _RBX = v4;
      __asm { incsspq rbx }
      v6 = v4 <= _RBX;
      v4 -= _RBX;
    }
    while ( !v6 );
  }
  return v1();
}

//----- (000000000005D080) ----------------------------------------------------
__int64 __fastcall sub_5D080(unsigned __int64 a1, __int64 a2)
{
  signed __int64 v2; // rax
  __int64 v3; // rdx

  v2 = sys_rt_sigreturn(a1);
  return sub_5D090(a1, a2, v3);
}
// 5D08A: variable 'v3' is possibly undefined

//----- (000000000005D090) ----------------------------------------------------
__int64 __fastcall sub_5D090(int a1, __int64 a2, __int64 a3)
{
  __m128i v4; // xmm0
  struct sigaction *v5; // rdx
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  __m128i v8; // xmm3
  __m128i v9; // xmm4
  int v10; // eax
  __m128i v11; // xmm5
  __m128i v12; // xmm6
  __m128i v13; // xmm7
  const struct sigaction *v14; // rsi
  unsigned __int64 v15; // rax
  __int64 v16; // r8
  unsigned int v17; // er9
  __m128i v18; // xmm0
  __m128i v19; // xmm1
  __m128i v20; // xmm2
  __m128i v21; // xmm3
  int v22; // eax
  __m128i v23; // xmm4
  __m128i v24; // xmm5
  __m128i v25; // xmm6
  __m128i v26; // xmm7
  __int64 v27; // rax
  __int64 v29[3]; // [rsp+0h] [rbp-148h] BYREF
  __m128i v30; // [rsp+18h] [rbp-130h]
  __m128i v31; // [rsp+28h] [rbp-120h]
  __m128i v32; // [rsp+38h] [rbp-110h]
  __m128i v33; // [rsp+48h] [rbp-100h]
  __m128i v34; // [rsp+58h] [rbp-F0h]
  __m128i v35; // [rsp+68h] [rbp-E0h]
  __m128i v36; // [rsp+78h] [rbp-D0h]
  __m128i v37; // [rsp+88h] [rbp-C0h]
  __int64 v38; // [rsp+A0h] [rbp-A8h] BYREF
  __int64 v39; // [rsp+A8h] [rbp-A0h]
  __int64 v40; // [rsp+B0h] [rbp-98h]
  __m128i v41; // [rsp+B8h] [rbp-90h] BYREF
  __m128i v42; // [rsp+C8h] [rbp-80h] BYREF
  __m128i v43; // [rsp+D8h] [rbp-70h] BYREF
  __m128i v44; // [rsp+E8h] [rbp-60h] BYREF
  __m128i v45; // [rsp+F8h] [rbp-50h] BYREF
  __m128i v46; // [rsp+108h] [rbp-40h] BYREF
  __m128i v47; // [rsp+118h] [rbp-30h] BYREF
  __m128i v48; // [rsp+128h] [rbp-20h] BYREF
  unsigned __int64 v49; // [rsp+138h] [rbp-10h]

  v49 = __readfsqword(0x28u);
  if ( a2 )
  {
    v4 = _mm_loadu_si128((const __m128i *)(a2 + 8));
    v5 = (struct sigaction *)&v38;
    v6 = _mm_loadu_si128((const __m128i *)(a2 + 24));
    v7 = _mm_loadu_si128((const __m128i *)(a2 + 40));
    v8 = _mm_loadu_si128((const __m128i *)(a2 + 56));
    v9 = _mm_loadu_si128((const __m128i *)(a2 + 72));
    v29[0] = *(_QWORD *)a2;
    v10 = *(_DWORD *)(a2 + 136);
    v11 = _mm_loadu_si128((const __m128i *)(a2 + 88));
    v30 = v4;
    v12 = _mm_loadu_si128((const __m128i *)(a2 + 104));
    v13 = _mm_loadu_si128((const __m128i *)(a2 + 120));
    v31 = v6;
    v14 = (const struct sigaction *)v29;
    v32 = v7;
    v33 = v8;
    v29[1] = v10 | 0x4000000;
    v29[2] = (__int64)sub_5D080;
    if ( !a3 )
      v5 = 0LL;
    v34 = v9;
    v35 = v11;
    v36 = v12;
    v37 = v13;
  }
  else
  {
    v14 = 0LL;
    v5 = (struct sigaction *)&v38;
    if ( !a3 )
      v5 = 0LL;
  }
  v15 = sys_rt_sigaction(a1, v14, v5, 8uLL);
  if ( v15 > 0xFFFFFFFFFFFFF000LL )
  {
    v17 = -1;
    __writefsdword(0xFFFFFFC0, -(int)v15);
  }
  else
  {
    v17 = v15;
    if ( v16 && (v15 & 0x80000000) == 0LL )
    {
      v18 = _mm_loadu_si128(&v41);
      v19 = _mm_loadu_si128(&v42);
      v20 = _mm_loadu_si128(&v43);
      v21 = _mm_loadu_si128(&v44);
      *(_QWORD *)v16 = v38;
      v22 = v39;
      *(__m128i *)(v16 + 8) = v18;
      v23 = _mm_loadu_si128(&v45);
      v24 = _mm_loadu_si128(&v46);
      *(__m128i *)(v16 + 24) = v19;
      v25 = _mm_loadu_si128(&v47);
      v26 = _mm_loadu_si128(&v48);
      *(_DWORD *)(v16 + 136) = v22;
      v27 = v40;
      *(__m128i *)(v16 + 40) = v20;
      *(__m128i *)(v16 + 56) = v21;
      *(_QWORD *)(v16 + 144) = v27;
      *(__m128i *)(v16 + 72) = v23;
      *(__m128i *)(v16 + 88) = v24;
      *(__m128i *)(v16 + 104) = v25;
      *(__m128i *)(v16 + 120) = v26;
    }
  }
  return v17;
}
// 5D168: variable 'v16' is possibly undefined

//----- (000000000005D270) ----------------------------------------------------
__int64 __fastcall sub_5D270(int a1, __int64 a2, __int64 a3)
{
  if ( (unsigned int)(a1 - 1) <= 0x3F && (unsigned int)(a1 - 32) > 1 )
    return sub_5D090(a1, a2, a3);
  __writefsdword(0xFFFFFFC0, 0x16u);
  return 0xFFFFFFFFLL;
}

//----- (000000000005D2B0) ----------------------------------------------------
__int64 __fastcall sub_5D2B0(int a1, const __m128i *a2, sigset_t *a3)
{
  __int64 result; // rax

  result = sub_6B920(a1, a2, a3);
  if ( (_DWORD)result )
  {
    __writefsdword(0xFFFFFFC0, result);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000005D2F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_5D2F0(char *a1, unsigned __int64 a2, unsigned __int64 a3, int (__fastcall *a4)(_QWORD, _QWORD, _QWORD), __int64 a5)
{
  unsigned __int64 v5; // r14
  __int64 v8; // r13
  char *v9; // r12
  char *v10; // r15
  char *v11; // r14
  char *v12; // rax
  char *v13; // rcx
  char *v14; // r15
  char *v15; // r13
  char *v16; // r12
  char *v17; // rax
  char *v18; // rcx
  char v19; // dl
  char v20; // si
  char *v21; // r13
  char *i; // r12
  char *v23; // rcx
  char *v25; // rdi
  char v26; // r8
  char *v27; // r11
  char *v28; // r9
  char *v29; // rax
  char *v30; // rdx
  char *v31; // rsi
  char *v32; // rsi
  char *v33; // rdx
  char *v34; // rax
  char v35; // cl
  char v36; // si
  _QWORD *v37; // rax
  char *v38; // rdx
  char *v39; // r15
  char *v40; // rax
  char v41; // cl
  char v42; // si
  char *v43; // rdx
  char *v44; // rax
  char v45; // cl
  char v46; // si
  char *v47; // rdx
  char *v48; // rax
  char v49; // cl
  char v50; // si
  char *v51; // rax
  char *v52; // rcx
  char *v54; // [rsp+0h] [rbp-488h]
  char *v55; // [rsp+8h] [rbp-480h]
  char *v56; // [rsp+8h] [rbp-480h]
  char *v57; // [rsp+10h] [rbp-478h]
  char *v58; // [rsp+18h] [rbp-470h]
  char *v59; // [rsp+20h] [rbp-468h]
  unsigned __int64 v60; // [rsp+28h] [rbp-460h]
  __int64 v61[2]; // [rsp+40h] [rbp-448h] BYREF
  char v62; // [rsp+50h] [rbp-438h] BYREF
  unsigned __int64 v63; // [rsp+448h] [rbp-40h]

  v63 = __readfsqword(0x28u);
  if ( a2 )
  {
    v5 = a3;
    v60 = 4 * a3;
    v58 = &a1[a3 * (a2 - 1)];
    if ( a2 <= 4 )
      goto LABEL_19;
    v55 = &a1[a3 * (a2 - 1)];
    v59 = &v62;
    v8 = -(__int64)a3;
    v61[0] = 0LL;
    v61[1] = 0LL;
    v57 = a1;
    do
    {
      v9 = &v57[a3 * (((v55 - v57) / a3) >> 1)];
      if ( a4(v9, v57, a5) < 0 )
      {
        v47 = v57;
        v48 = &v57[a3 * (((v55 - v57) / a3) >> 1)];
        do
        {
          v49 = *v48;
          v50 = *v47;
          ++v48;
          ++v47;
          *(v48 - 1) = v50;
          *(v47 - 1) = v49;
        }
        while ( &v9[a3] != v48 );
      }
      if ( a4(v55, v9, a5) < 0 )
      {
        v38 = v55;
        v39 = &v9[a3];
        v40 = &v57[a3 * (((v55 - v57) / a3) >> 1)];
        do
        {
          v41 = *v40;
          v42 = *v38;
          ++v40;
          ++v38;
          *(v40 - 1) = v42;
          *(v38 - 1) = v41;
        }
        while ( v39 != v40 );
        if ( a4(v9, v57, a5) < 0 )
        {
          v43 = v57;
          v44 = &v57[a3 * (((v55 - v57) / a3) >> 1)];
          do
          {
            v45 = *v44;
            v46 = *v43;
            ++v44;
            ++v43;
            *(v44 - 1) = v46;
            *(v43 - 1) = v45;
          }
          while ( v39 != v44 );
        }
      }
      v10 = &v57[a3];
      v11 = &v55[v8];
      while ( 1 )
      {
        while ( a4(v10, v9, a5) < 0 )
          v10 += a3;
        while ( a4(v9, v11, a5) < 0 )
          v11 += v8;
        if ( v10 < v11 )
        {
          v33 = v11;
          v34 = v10;
          do
          {
            v35 = *v34;
            v36 = *v33;
            ++v34;
            ++v33;
            *(v34 - 1) = v36;
            *(v33 - 1) = v35;
          }
          while ( &v10[a3] != v34 );
          if ( v10 == v9 )
          {
            v9 = v11;
          }
          else if ( v11 == v9 )
          {
            v9 = v10;
          }
          v11 += v8;
          v10 += a3;
          goto LABEL_13;
        }
        if ( v10 == v11 )
          break;
LABEL_13:
        if ( v10 > v11 )
          goto LABEL_14;
      }
      v10 += a3;
      v11 += v8;
LABEL_14:
      v12 = (char *)(v55 - v10);
      if ( v11 - v57 > v60 )
      {
        if ( v60 >= (unsigned __int64)v12 )
        {
          v55 = v11;
        }
        else if ( v11 - v57 <= (__int64)v12 )
        {
          v51 = v59;
          v52 = v55;
          v59 += 16;
          v55 = v11;
          *(_QWORD *)v51 = v10;
          *((_QWORD *)v51 + 1) = v52;
        }
        else
        {
          v37 = v59;
          v59 += 16;
          v37[1] = v11;
          *v37 = v57;
          v57 = v10;
        }
      }
      else
      {
        v57 = v10;
        if ( v60 >= (unsigned __int64)v12 )
        {
          v57 = (char *)*((_QWORD *)v59 - 2);
          v13 = (char *)*((_QWORD *)v59 - 1);
          v59 -= 16;
          v55 = v13;
        }
      }
    }
    while ( v59 > (char *)v61 );
    v5 = a3;
LABEL_19:
    v14 = a1;
    v15 = &a1[v60];
    if ( v58 < &a1[v60] )
      v15 = v58;
    v54 = &a1[v5];
    v16 = &a1[v5];
    if ( v15 >= &a1[v5] )
    {
      do
      {
        if ( a4(v16, v14, a5) < 0 )
          v14 = v16;
        v16 += v5;
      }
      while ( v15 >= v16 );
      v17 = a1;
      if ( v14 != a1 )
      {
        v18 = &v14[v5];
        do
        {
          v19 = *v14;
          v20 = *v17;
          ++v14;
          ++v17;
          *(v14 - 1) = v20;
          *(v17 - 1) = v19;
        }
        while ( v18 != v14 );
      }
    }
    if ( &v54[v5] <= v58 )
    {
      v21 = &v54[v5];
      v56 = &v54[v5 - 1 + v5];
      while ( 1 )
      {
        for ( i = v54; a4(v21, i, a5) < 0; i -= v5 )
          ;
        v23 = &i[v5];
        if ( &i[v5] == v21 )
          goto LABEL_34;
        v25 = v56;
        if ( v56 < v21 )
          goto LABEL_34;
        v26 = *v56;
        v27 = v21 - 1;
        v28 = &v56[-v5];
        v29 = &v56[-v5];
        if ( &v56[-v5] >= v23 )
          break;
        while ( 1 )
        {
          v32 = v25--;
          --v28;
          *v32 = v26;
          if ( v25 == v27 )
            break;
LABEL_41:
          v26 = *v25;
          v29 = v28;
          if ( v28 >= v23 )
            goto LABEL_38;
        }
LABEL_34:
        v56 += v5;
        v21 += v5;
        v54 += v5;
        if ( v58 < v21 )
          return v63 - __readfsqword(0x28u);
      }
LABEL_38:
      v30 = v25;
      do
      {
        *v30 = *v29;
        v31 = v29;
        v29 -= v5;
        v30 -= v5;
      }
      while ( v23 <= v29 );
      --v25;
      *v31 = v26;
      --v28;
      if ( v25 == v27 )
        goto LABEL_34;
      goto LABEL_41;
    }
  }
  return v63 - __readfsqword(0x28u);
}

//----- (000000000005D780) ----------------------------------------------------
__int64 __fastcall sub_5D780(__int64 a1, void *a2, void *a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  __int64 v13; // rcx
  u32 *v14; // r8
  __int64 v15; // r9
  __int64 v16; // r14
  double v17; // xmm4_8
  double v18; // xmm5_8
  void **v20; // r13
  _BYTE *v21; // r15
  __int64 i; // rbx
  void *v23; // rsi
  __int64 v24; // rdx
  __int64 v25; // rsi
  void *v26; // rbx
  _QWORD *v27; // rax
  u32 *v28; // r8
  _QWORD *v29; // rcx
  __int64 v30; // r15
  unsigned int v31; // er8
  u32 *v33; // r15
  __int64 v34; // rdx
  __int64 v35; // rcx
  u32 *v36; // r8
  u32 v37; // er9
  double v38; // xmm4_8
  double v39; // xmm5_8
  void *v40; // rsp
  _BYTE *v41; // rax
  size_t v42; // rdx
  void *v43; // rsi
  void **v44; // rax
  __int64 v45; // rdx
  __int64 v46; // rcx
  u32 *v47; // r8
  double v48; // xmm4_8
  double v49; // xmm5_8
  unsigned __int64 v50; // rcx
  u32 *v51; // r8
  __int64 v52; // r9
  double v53; // xmm4_8
  double v54; // xmm5_8
  signed __int64 v55; // rax
  void *v56; // rbx
  _BYTE *v57; // rax
  size_t v58; // rdx
  void *v59; // rsi
  void **v60; // rax
  __int64 v61; // rdx
  void *v62; // rbx
  signed __int64 v63; // rax
  size_t v64; // [rsp+0h] [rbp-60h] BYREF
  void *v65; // [rsp+8h] [rbp-58h]
  __int64 v66; // [rsp+10h] [rbp-50h]
  void *v67; // [rsp+18h] [rbp-48h]
  unsigned __int64 v68; // [rsp+28h] [rbp-38h]

  v65 = a2;
  v67 = a3;
  LODWORD(v66) = a4;
  v68 = __readfsqword(0x28u);
  v16 = strlen(a1);
  if ( !a3 )
    v64 = strlen((__int64)v65) + 1;
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C1700, 1, 0) )
      sub_1C7D0((volatile __int32 *)&dword_C1700, (__int64)a2, 1LL, v13, v14, v15);
  }
  else
  {
    _EDX = 1;
    __asm { cmpxchg cs:dword_C1700, edx }
  }
  v20 = (void **)qword_C1270;
  if ( qword_C1270 && (v21 = *(_BYTE **)qword_C1270) != 0LL )
  {
    for ( i = 0LL; ; ++i )
    {
      v23 = (void *)a1;
      if ( !(unsigned int)sub_9130(v21, a1, v16) && v21[v16] == 61 )
        break;
      v21 = v20[1];
      ++v20;
      v24 = i + 1;
      if ( !v21 )
      {
        v25 = 8 * i + 24;
        goto LABEL_13;
      }
    }
    if ( *v20 )
    {
      if ( !(_DWORD)v66 )
      {
LABEL_19:
        v31 = __readfsdword(0x18u);
        if ( v31 )
        {
          v31 = 0;
          if ( _InterlockedExchange((volatile __int32 *)&dword_C1700, 0) > 1 )
            v55 = sys_futex(&dword_C1700, 129, 1u, 0LL, 0LL, v15);
        }
        else
        {
          --dword_C1700;
        }
        return v31;
      }
      goto LABEL_17;
    }
    v25 = 8 * i + 16;
    v24 = i;
  }
  else
  {
    v25 = 16LL;
    v24 = 0LL;
  }
LABEL_13:
  v26 = (void *)qword_C16F0;
  v66 = v24;
  v27 = sub_21DF0((const char *)qword_C16F0, v25, v24, v13, v14, v15, a5, a6, a7, a8, v17, v18, a11, a12);
  v29 = v27;
  if ( !v27 )
    goto LABEL_42;
  v23 = qword_C1270;
  v30 = v66;
  if ( v26 != qword_C1270 )
    v29 = memcpy(v27, qword_C1270, 8 * v66);
  v20 = (void **)&v29[v30];
  qword_C16F0 = (__int64)v29;
  v29[v66] = 0LL;
  v29[v30 + 1] = 0LL;
  qword_C1270 = v29;
LABEL_17:
  if ( v67 )
  {
LABEL_18:
    *v20 = v67;
    goto LABEL_19;
  }
  v33 = (u32 *)(v64 + v16 + 1);
  if ( sub_1C780((unsigned __int64)v33) || (unsigned __int64)v33 <= 0x1000 )
  {
    v40 = alloca(v64 + v16 + 9);
    v41 = (_BYTE *)sub_91D0(&v64, a1, v16);
    v42 = v64;
    v43 = v65;
    *v41 = 61;
    memcpy(v41 + 1, v43, v42);
    v44 = (void **)sub_4C220((__int64)&v64, &qword_C16F8, sub_91B0);
    if ( v44 )
    {
      v67 = *v44;
      if ( v67 )
        goto LABEL_18;
    }
    v67 = (void *)sub_21500(v33, (__int64)&qword_C16F8, v45, v46, v47, v15, a5, a6, a7, a8, v48, v49, a11, a12);
    if ( v67 )
    {
      memcpy(v67, &v64, (size_t)v33);
LABEL_33:
      sub_4C080((__int64)v67, &qword_C16F8, sub_91B0, v50, a5, a6, a7, a8, v53, v54, a11, a12, (__int64)v51, v52);
      goto LABEL_18;
    }
  }
  else
  {
    v67 = (void *)sub_21500(v33, (__int64)v23, v34, v35, v36, v37, a5, a6, a7, a8, v38, v39, a11, a12);
    if ( v67 )
    {
      v56 = v67;
      v57 = (_BYTE *)sub_91D0(v67, a1, v16);
      v58 = v64;
      v59 = v65;
      *v57 = 61;
      memcpy(v57 + 1, v59, v58);
      v60 = (void **)sub_4C220((__int64)v56, &qword_C16F8, sub_91B0);
      if ( v60 )
      {
        v62 = *v60;
        if ( *v60 )
        {
          sub_21B70((__int64)v67, a5, a6, a7, a8, v53, v54, a11, a12, (__int64)&qword_C16F8, v61, v50, v51, v52);
          v67 = v62;
          goto LABEL_18;
        }
      }
      goto LABEL_33;
    }
  }
LABEL_42:
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedExchange((volatile __int32 *)&dword_C1700, 0) > 1 )
      v63 = sys_futex(&dword_C1700, 129, 1u, 0LL, v28, v15);
    v31 = -1;
  }
  else
  {
    --dword_C1700;
    v31 = -1;
  }
  return v31;
}
// 5D84F: variable 'v13' is possibly undefined
// 5D84F: variable 'v14' is possibly undefined
// 5D84F: variable 'v15' is possibly undefined
// 5D84F: variable 'v17' is possibly undefined
// 5D84F: variable 'v18' is possibly undefined
// 5D8EC: variable 'v31' is possibly undefined
// 5D9D6: variable 'v45' is possibly undefined
// 5D9D6: variable 'v46' is possibly undefined
// 5D9D6: variable 'v47' is possibly undefined
// 5D9D6: variable 'v48' is possibly undefined
// 5D9D6: variable 'v49' is possibly undefined
// 5DA09: variable 'v50' is possibly undefined
// 5DA09: variable 'v53' is possibly undefined
// 5DA09: variable 'v54' is possibly undefined
// 5DA09: variable 'v51' is possibly undefined
// 5DA09: variable 'v52' is possibly undefined
// 5DA77: variable 'v34' is possibly undefined
// 5DA77: variable 'v35' is possibly undefined
// 5DA77: variable 'v36' is possibly undefined
// 5DA77: variable 'v37' is possibly undefined
// 5DA77: variable 'v38' is possibly undefined
// 5DA77: variable 'v39' is possibly undefined
// 5DADA: variable 'v61' is possibly undefined
// 5DB3C: variable 'v28' is possibly undefined
// 9130: using guessed type __int64 __fastcall sub_9130(_QWORD, _QWORD, _QWORD);
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// C16F0: using guessed type __int64 qword_C16F0;
// C16F8: using guessed type __int64 qword_C16F8;

//----- (000000000005DBA0) ----------------------------------------------------
__int64 __fastcall sub_5DBA0(_BYTE *a1)
{
  __int64 v1; // rcx
  u32 *v2; // r8
  u32 v3; // er9
  __int64 v4; // r13
  _QWORD *v6; // rbp
  __int64 v7; // rbx
  unsigned int v8; // er8
  _QWORD *v10; // rax
  __int64 v11; // rdx
  signed __int64 v12; // rax

  if ( a1 && *a1 && !sub_9210(a1, 61LL) )
  {
    v4 = strlen((__int64)a1);
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C1700, 1, 0) )
        sub_1C7D0((volatile __int32 *)&dword_C1700, 61LL, 1LL, v1, v2, v3);
    }
    else
    {
      _EDX = 1;
      __asm { cmpxchg cs:dword_C1700, edx }
    }
    v6 = qword_C1270;
    if ( qword_C1270 )
    {
      while ( 1 )
      {
        v7 = *v6;
        if ( !*v6 )
          break;
        if ( !(unsigned int)sub_9130(*v6, a1, v4) && *(_BYTE *)(v7 + v4) == 61 )
        {
          v10 = v6;
          do
          {
            v11 = v10[1];
            *v10++ = v11;
          }
          while ( v11 );
        }
        else
        {
          ++v6;
        }
      }
    }
    v8 = __readfsdword(0x18u);
    if ( v8 )
    {
      v8 = 0;
      if ( _InterlockedExchange((volatile __int32 *)&dword_C1700, 0) > 1 )
        v12 = sys_futex(&dword_C1700, 129, 1u, 0LL, 0LL, v3);
    }
    else
    {
      --dword_C1700;
    }
  }
  else
  {
    v8 = -1;
    __writefsdword(0xFFFFFFC0, 0x16u);
  }
  return v8;
}
// 5DC4F: variable 'v8' is possibly undefined
// 5DC9C: variable 'v1' is possibly undefined
// 5DC9C: variable 'v2' is possibly undefined
// 5DC9C: variable 'v3' is possibly undefined
// 9130: using guessed type __int64 __fastcall sub_9130(_QWORD, _QWORD, _QWORD);
// 9210: using guessed type __int64 __fastcall sub_9210(_QWORD, _QWORD);

//----- (000000000005DD00) ----------------------------------------------------
__int64 __fastcall sub_5DD00(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14)
{
  signed __int64 v16; // rax

  if ( __readfsdword(0x18u) )
  {
    _RDX = 1LL;
    if ( _InterlockedCompareExchange((volatile signed __int32 *)&dword_C1700, 1, 0) )
      sub_1C7D0((volatile __int32 *)&dword_C1700, a10, 1LL, a12, a13, a14);
  }
  else
  {
    _RDX = 1LL;
    __asm { cmpxchg cs:dword_C1700, edx }
  }
  if ( (void *)qword_C16F0 == qword_C1270 && qword_C1270 )
  {
    sub_21B70((__int64)qword_C1270, a1, a2, a3, a4, a5, a6, a7, a8, a10, _RDX, a12, a13, a14);
    qword_C16F0 = 0LL;
  }
  qword_C1270 = 0LL;
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedExchange((volatile __int32 *)&dword_C1700, 0) > 1 )
      v16 = sys_futex(&dword_C1700, 129, 1u, 0LL, a13, a14);
  }
  else
  {
    --dword_C1700;
  }
  return 0LL;
}
// 5DD60: variable 'a5' is possibly undefined
// 5DD60: variable 'a6' is possibly undefined
// 5DD60: variable '_RDX' is possibly undefined
// 5DD60: variable 'a12' is possibly undefined
// 5DD60: variable 'a13' is possibly undefined
// 5DD60: variable 'a14' is possibly undefined
// C16F0: using guessed type __int64 qword_C16F0;

//----- (000000000005DDD0) ----------------------------------------------------
__int64 __fastcall sub_5DDD0(_BYTE *a1)
{
  return 0LL;
}
// BD7E0: using guessed type int dword_BD7E0;

//----- (000000000005DE10) ----------------------------------------------------
unsigned __int64 __fastcall sub_5DE10(unsigned __int8 *a1, unsigned __int8 **a2, unsigned int a3)
{
  unsigned __int64 v3; // r8
  int v5; // edi
  __int64 v6; // rcx
  unsigned __int8 *v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rdx
  unsigned __int8 *v10; // rbx
  __int64 v11; // rdx
  unsigned __int64 v12; // r8
  unsigned __int8 *v13; // rcx
  unsigned __int64 v14; // rsi
  int v15; // er9
  unsigned __int8 v16; // al
  unsigned __int64 result; // rax
  __int64 v18; // rax
  __int64 v19; // rax
  unsigned __int8 v21; // [rsp+Ah] [rbp-46h]
  int v22; // [rsp+Ch] [rbp-44h]

  v3 = __readfsqword(0xFFFFFFA8);
  v5 = a3;
  if ( a3 == 1 || a3 > 0x24 )
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    return 0LL;
  }
  v6 = *(_QWORD *)(v3 + 104);
  v7 = a1;
  v8 = (char)*a1;
  if ( (*(_BYTE *)(v6 + 2 * v8 + 1) & 0x20) != 0 )
  {
    do
    {
      v9 = (char)*++v7;
      LOBYTE(v8) = v9;
    }
    while ( (*(_BYTE *)(v6 + 2 * v9 + 1) & 0x20) != 0 );
  }
  if ( !(_BYTE)v8 )
  {
    if ( !a2 )
      return 0LL;
    goto LABEL_45;
  }
  if ( (_BYTE)v8 == 45 )
  {
    v22 = 1;
    v10 = v7 + 1;
  }
  else
  {
    v22 = 0;
    v10 = &v7[(_BYTE)v8 == 43];
  }
  v11 = *v10;
  if ( (_BYTE)v11 == 48 )
  {
    if ( (v5 & 0xFFFFFFEF) == 0 )
    {
      if ( dword_968A0[(char)v10[1]] == 88 )
      {
        v11 = v10[2];
        v21 = 15;
        v10 += 2;
        v12 = 0xFFFFFFFFFFFFFFFLL;
        v5 = 16;
        goto LABEL_11;
      }
      if ( !v5 )
      {
        v21 = 7;
        v5 = 8;
        v12 = 0x1FFFFFFFFFFFFFFFLL;
        v11 = 48LL;
        goto LABEL_13;
      }
    }
    if ( v5 == 10 )
    {
      v21 = 5;
      v11 = 48LL;
      v12 = 0x1999999999999999LL;
    }
    else
    {
      v19 = v5 - 2;
      v12 = qword_A3820[v19];
      v11 = 48LL;
      v21 = *((_BYTE *)&off_A37E0 + v19);
    }
    goto LABEL_13;
  }
  if ( !v5 || v5 == 10 )
  {
    v21 = 5;
    v5 = 10;
    v12 = 0x1999999999999999LL;
  }
  else
  {
    v18 = v5 - 2;
    v12 = qword_A3820[v18];
    v21 = *((_BYTE *)&off_A37E0 + v18);
  }
LABEL_11:
  if ( !(_BYTE)v11 || !v10 )
  {
LABEL_42:
    if ( !a2 )
      return 0LL;
    if ( v10 - a1 > 1 && dword_968A0[(char)*(v10 - 1)] == 88 && *(v10 - 2) == 48 )
    {
      *a2 = v10 - 1;
      return 0LL;
    }
LABEL_45:
    *a2 = a1;
    return 0LL;
  }
LABEL_13:
  v13 = v10;
  v14 = 0LL;
  v15 = 0;
  do
  {
    v16 = v11 - 48;
    if ( (unsigned __int8)(v11 - 48) > 9u )
    {
      if ( (byte_971A0[2 * v11 + 1] & 4) == 0 )
        break;
      v16 = dword_968A0[v11] - 55;
    }
    if ( v16 >= v5 )
      break;
    if ( v12 < v14 || v12 == v14 && v16 > v21 )
    {
      v15 = 1;
      v11 = *++v13;
      if ( !(_BYTE)v11 )
        break;
    }
    else
    {
      v14 = v16 + v5 * v14;
      v11 = *++v13;
      if ( !(_BYTE)v11 )
        break;
    }
  }
  while ( v13 );
  if ( v13 == v10 )
    goto LABEL_42;
  if ( a2 )
    *a2 = v13;
  if ( v15 || v22 + 0x7FFFFFFFFFFFFFFFLL < v14 )
  {
    __writefsdword(0xFFFFFFC0, 0x22u);
    result = 0x8000000000000000LL;
    if ( !v22 )
      result = 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    result = -(__int64)v14;
    if ( !v22 )
      result = v14;
  }
  return result;
}
// 5DED5: conditional instruction was optimized away because of 'r14.8==0'
// 5DF60: conditional instruction was optimized away because of 'rbp.8==0'
// 5E217: conditional instruction was optimized away because of 'r14.8==0'
// A37E0: using guessed type void *off_A37E0;

//----- (000000000005E360) ----------------------------------------------------
__int64 sub_5E360(__int64 a1, unsigned __int64 a2, ...)
{
  __m128 v2; // xmm0
  __m128i v3; // xmm2
  __m128 v4; // xmm3
  __va_list_tag va[1]; // [rsp+0h] [rbp-D8h] BYREF
  unsigned __int64 v7; // [rsp+18h] [rbp-C0h]
  __int128 v8; // [rsp+50h] [rbp-88h]
  __int128 v9; // [rsp+60h] [rbp-78h]
  __int128 v10; // [rsp+70h] [rbp-68h]
  __int128 v11; // [rsp+80h] [rbp-58h]
  __int128 v12; // [rsp+90h] [rbp-48h]
  __int128 v13; // [rsp+A0h] [rbp-38h]
  __int128 v14; // [rsp+B0h] [rbp-28h]
  __int128 v15; // [rsp+C0h] [rbp-18h]

  va_start(va, a2);
  *(double *)&v8 = va_arg(va, double);
  v2.m128_u64[0] = v8;
  *(double *)&v9 = va_arg(va, double);
  *(double *)&v10 = va_arg(va, double);
  v3.m128i_i64[0] = v10;
  *(double *)&v11 = va_arg(va, double);
  v4.m128_u64[0] = v11;
  *(double *)&v12 = va_arg(va, double);
  *(double *)&v13 = va_arg(va, double);
  *(double *)&v14 = va_arg(va, double);
  *(double *)&v15 = va_arg(va, double);
  va_end(va);
  va_start(va, a2);
  v7 = __readfsqword(0x28u);
  return sub_61370(
           a1,
           a2,
           (__m128i *)va,
           0,
           v2,
           *(double *)&v9,
           v3,
           v4,
           *(double *)&v12,
           *(double *)&v13,
           *(double *)&v14,
           *(double *)&v15);
}
// 5E3F5: variable 'v2' is possibly undefined
// 5E3F5: variable 'v3' is possibly undefined
// 5E3F5: variable 'v4' is possibly undefined

//----- (000000000005E420) ----------------------------------------------------
__int64 sub_5E420(char *a1, __int64 a2, __int64 a3, ...)
{
  __va_list_tag va[1]; // [rsp+0h] [rbp-D8h] BYREF
  unsigned __int64 v5; // [rsp+18h] [rbp-C0h]

  va_start(va, a3);
  v5 = __readfsqword(0x28u);
  return sub_6B6D0(a1, a2, a3, (__int64)va, 0);
}

//----- (000000000005E560) ----------------------------------------------------
__int64 __fastcall sub_5E560(unsigned __int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5)
{
  __int64 v5; // r12
  int v6; // ebx
  int v11; // eax
  _BYTE *v12; // rcx
  __int64 v13; // r13
  unsigned __int64 v14; // rsi
  _BYTE *v15; // rcx
  char v16; // dl
  __int64 v17; // rax
  char v18; // dl
  int v19; // [rsp+0h] [rbp-48h]
  _BYTE *v20; // [rsp+8h] [rbp-40h]

  v5 = a2;
  v6 = (char)*a4;
  if ( (unsigned __int8)(*a4 - 1) <= 0x7Du )
  {
    v11 = strlen(a5);
    v12 = a4 + 1;
    v13 = a3 - a2;
    v19 = v11;
    v20 = v12;
    sub_9050(a1, a2, a3 - a2);
    v14 = a1 + a3 - a2;
    if ( a1 >= a1 + v13 )
      return a3;
    v15 = v20;
    while ( 1 )
    {
      v16 = *(_BYTE *)--v14;
      v5 = a3 - 1;
      *(_BYTE *)(a3 - 1) = v16;
      if ( --v6 )
      {
        if ( a1 >= v14 )
          return v5;
      }
      else
      {
        if ( a1 >= v14 )
          return v5;
        if ( v19 >= (__int64)(v5 - v14) )
          goto LABEL_17;
        v17 = v19;
        do
        {
          v18 = *(_BYTE *)(a5 + v17-- - 1);
          *(_BYTE *)--v5 = v18;
        }
        while ( (int)v17 > 0 );
        v6 = (char)*v15;
        if ( *v15 > 0x7Eu )
        {
LABEL_17:
          sub_9050(v5, v14, a1 - v14);
          return v5;
        }
        if ( (_BYTE)v6 )
          ++v15;
        else
          v6 = (char)*(v15 - 1);
      }
      a3 = v5;
    }
  }
  return v5;
}
// 9050: using guessed type __int64 __fastcall sub_9050(_QWORD, _QWORD, _QWORD);

//----- (000000000005E680) ----------------------------------------------------
__int64 __fastcall sub_5E680(_QWORD *a1, unsigned __int8 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  unsigned __int8 *v12; // rax
  __int64 v13; // rsi
  int v14; // er12
  __int64 v15; // rdi
  __int64 v16; // r13
  __int64 v17; // r13
  unsigned int v18; // er8

  v12 = (unsigned __int8 *)a1[5];
  v13 = a1[4];
  v14 = (_DWORD)v12 - v13;
  if ( (_DWORD)v12 != (_DWORD)v13 )
  {
    v15 = a1[28];
    v16 = *(_QWORD *)(v15 + 216);
    if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v16 - (_QWORD)&unk_BFAE0) )
    {
      sub_17140(a3, a4, a5, a6, a7, a8, a9, a10);
      v13 = a1[4];
    }
    v17 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v16 + 56))(v15, v13, v14);
    if ( (unsigned __int64)(v17 - 1) > 0xFFFFFFFFFFFFFFFDLL )
      return (unsigned int)-1;
    sub_9050(a1[4], a1[4] + v17, v14 - v17);
    v12 = (unsigned __int8 *)(a1[5] - v17);
    a1[5] = v12;
  }
  v18 = a2;
  if ( a1[6] > (unsigned __int64)v12 )
  {
    a1[5] = v12 + 1;
    *v12 = a2;
    return v18;
  }
  return sub_1A150((__int64)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}
// 5E758: variable 'a7' is possibly undefined
// 5E758: variable 'a8' is possibly undefined
// 9050: using guessed type __int64 __fastcall sub_9050(_QWORD, _QWORD, _QWORD);
// C0308: using guessed type void *off_C0308;

//----- (000000000005E770) ----------------------------------------------------
_QWORD *__fastcall sub_5E770(__int64 a1, __int64 a2, _QWORD *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  _DWORD *v12; // rbx
  unsigned int v13; // ebp
  unsigned int v14; // eax
  __int64 v15; // rcx
  u32 v16; // er9
  double v17; // xmm4_8
  double v18; // xmm5_8
  char *v19; // r15
  char *v20; // r13
  char v21; // al
  __int64 v22; // r14
  __int64 v23; // rdx
  __int64 v24; // rax
  __int16 *v27; // rdi
  __int64 v28; // rax
  unsigned int v29; // er15
  __int64 v30; // rax
  __int64 v31; // rcx
  u32 v32; // er9
  double v33; // xmm4_8
  double v34; // xmm5_8
  __int64 v35; // rax
  unsigned __int64 v36; // r8
  unsigned int v37; // eax
  unsigned int v38; // eax
  unsigned int v39; // edx
  __int64 v40; // rcx
  unsigned __int64 v41; // [rsp+8h] [rbp-4A0h]
  __int64 v42[2]; // [rsp+20h] [rbp-488h] BYREF
  char v43[1024]; // [rsp+30h] [rbp-478h] BYREF
  __int16 v44[16]; // [rsp+430h] [rbp-78h] BYREF
  __int16 v45[12]; // [rsp+450h] [rbp-58h] BYREF
  unsigned __int64 v46; // [rsp+468h] [rbp-40h]

  v46 = __readfsqword(0x28u);
  v12 = (_DWORD *)sub_6ED60((__int64)"to_outpunct");
  v13 = sub_6EDF0(0x2Eu, v12);
  v14 = sub_6EDF0(0x2Cu, v12);
  if ( v12 )
  {
    v29 = v14;
    v42[0] = 0LL;
    v30 = sub_6D090((char *)v44, v13, v42, v15, (u32 *)v42, v16, a4, a5, a6, a7, v17, v18, a10, a11);
    if ( v30 == -1 )
      v44[0] = 46;
    else
      *((_BYTE *)v44 + v30) = 0;
    v42[0] = 0LL;
    v35 = sub_6D090((char *)v45, v29, v42, v31, (u32 *)v42, v32, a4, a5, a6, a7, v33, v34, a10, a11);
    if ( v35 == -1 )
      v45[0] = 44;
    else
      *((_BYTE *)v45 + v35) = 0;
  }
  v42[0] = (__int64)v43;
  v42[1] = 1024LL;
  if ( !(unsigned __int8)sub_6BAD0(v42, a2 - a1, 1LL) )
    return (_QWORD *)a1;
  v41 = v42[0];
  v19 = (char *)(sub_91D0(v42[0], a1, a2 - a1) - 1);
  if ( v41 <= (unsigned __int64)v19 )
  {
    v20 = (char *)(v41 - 1);
    while ( 1 )
    {
      v21 = *v19;
      if ( (unsigned __int8)(*v19 - 48) > 9u )
        break;
      v22 = *(_QWORD *)(*(_QWORD *)__readfsqword(0xFFFFFFA0) + 8LL * (char)(v21 - 7) + 64);
      v23 = strlen(v22);
      a3 = (_QWORD *)((char *)a3 - v23);
      v24 = v23 - 1;
      if ( v23 )
      {
        do
          *((_BYTE *)a3 + v24) = *(_BYTE *)(v22 + v24);
        while ( v24-- != 0 );
        if ( --v19 == v20 )
          goto LABEL_12;
      }
      else
      {
LABEL_7:
        if ( --v19 == v20 )
          goto LABEL_12;
      }
    }
    if ( v12 && (v21 & 0xFD) == 44 )
    {
      v27 = v45;
      if ( v21 == 46 )
        v27 = v44;
      v28 = strlen((__int64)v27);
      a3 = (_QWORD *)((char *)a3 - v28);
      if ( v28 )
      {
        if ( (unsigned int)v28 >= 8 )
        {
          v36 = (unsigned __int64)(a3 + 1) & 0xFFFFFFFFFFFFFFF8LL;
          *a3 = *(_QWORD *)v27;
          *(_QWORD *)((char *)a3 + (unsigned int)v28 - 8) = *(_QWORD *)((char *)v27 + (unsigned int)v28 - 8);
          v37 = ((_DWORD)a3 - v36 + v28) & 0xFFFFFFF8;
          if ( v37 >= 8 )
          {
            v38 = v37 & 0xFFFFFFF8;
            v39 = 0;
            do
            {
              v40 = v39;
              v39 += 8;
              *(_QWORD *)(v36 + v40) = *(_QWORD *)((char *)v27 - ((char *)a3 - v36) + v40);
            }
            while ( v39 < v38 );
          }
        }
        else if ( (v28 & 4) != 0 )
        {
          *(_DWORD *)a3 = *(_DWORD *)v27;
          *(_DWORD *)((char *)a3 + (unsigned int)v28 - 4) = *(_DWORD *)((char *)v27 + (unsigned int)v28 - 4);
        }
        else if ( (_DWORD)v28 )
        {
          *(_BYTE *)a3 = *(_BYTE *)v27;
          if ( (v28 & 2) != 0 )
            *(_WORD *)((char *)a3 + (unsigned int)v28 - 2) = *(__int16 *)((char *)v27 + (unsigned int)v28 - 2);
        }
      }
    }
    else
    {
      *((_BYTE *)a3 - 1) = v21;
      a3 = (_QWORD *)((char *)a3 - 1);
    }
    goto LABEL_7;
  }
LABEL_12:
  if ( (char *)v42[0] != v43 )
    sub_21B70(v42[0]);
  return a3;
}
// 5E99E: variable 'v15' is possibly undefined
// 5E99E: variable 'v16' is possibly undefined
// 5E99E: variable 'v17' is possibly undefined
// 5E99E: variable 'v18' is possibly undefined
// 5E9D6: variable 'v31' is possibly undefined
// 5E9D6: variable 'v32' is possibly undefined
// 5E9D6: variable 'v33' is possibly undefined
// 5E9D6: variable 'v34' is possibly undefined
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (000000000005EA90) ----------------------------------------------------
void __noreturn sub_5EA90()
{
  sub_CF00("(size_t) done <= (size_t) INT_MAX", "vfprintf-internal.c", 238LL, "outstring_func");
}
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// 5EA90: using guessed type void __fastcall __noreturn sub_5EA90();

//----- (000000000005EE80) ----------------------------------------------------
__int64 __fastcall sub_5EE80(__int64 a1, __int64 a2, int a3, __m128 a4, __m128 a5, __m128 a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, __int64 a13, int a14, int a15, _BYTE *a16, char *a17, unsigned int a18, char *a19, __int64 a20, char a21)
{
  _BYTE *v21; // rbx
  unsigned __int64 v22; // r14
  unsigned __int64 v23; // r15
  u32 *v24; // r8
  __int64 v25; // rsi
  __int64 v26; // r12
  __int64 v27; // rax
  __int64 v28; // rdx
  __int64 v29; // rcx
  u32 v30; // er9
  double v31; // xmm4_8
  double v32; // xmm5_8
  u32 *v33; // r12
  unsigned __int64 v34; // r13
  u32 *v35; // rbx
  __int64 v36; // rcx
  double v37; // xmm4_8
  double v38; // xmm5_8
  u32 *v39; // rdi
  unsigned __int64 v40; // r12
  __int64 v41; // r15
  u32 *v42; // r13
  u32 *v43; // r14
  u32 *v44; // rbx
  __int64 v45; // rax
  __int64 v46; // rax
  __int64 v47; // rsi
  __int64 v48; // rdx
  __int64 v49; // rax
  u32 *v50; // rdi
  __m128 *v51; // rax
  __int64 v52; // rsi
  unsigned __int64 v53; // r14
  unsigned int v54; // ecx
  __int64 *v55; // rdi
  int *v56; // r15
  _QWORD *v57; // r14
  unsigned __int8 v58; // al
  int v59; // er13
  int v60; // er11
  char v61; // dl
  __int64 v62; // r8
  char v63; // bl
  bool v64; // r12
  int v65; // esi
  __int64 v66; // rdx
  bool v67; // bl
  unsigned __int8 v68; // r9
  int v69; // edi
  __int64 v70; // rax
  __int64 (__fastcall *v71)(_QWORD *, int *, __int64 *); // rax
  unsigned __int64 v72; // rsi
  void *v73; // rsp
  int v74; // er8
  __int64 v75; // r9
  unsigned int v76; // edx
  __int64 v77; // rcx
  _BYTE *v78; // rax
  char v79; // al
  _BYTE *v80; // rax
  int v81; // ebx
  _BYTE *v82; // rax
  _BYTE *v83; // rax
  _BYTE *v84; // rax
  int v85; // eax
  _BYTE *v86; // rax
  char *v87; // r13
  unsigned __int8 *v88; // rax
  unsigned __int8 v89; // dl
  unsigned int v91; // ecx
  unsigned int *v92; // rdi
  unsigned int v93; // edi
  __int64 v94; // rax
  __int64 v95; // rbx
  char v96; // al
  int v97; // eax
  __int64 v98; // r9
  __int64 v99; // rax
  double v100; // xmm4_8
  double v101; // xmm5_8
  unsigned __int64 v102; // r12
  int v103; // eax
  __int64 v104; // rax
  signed __int64 v105; // r8
  __int64 v106; // rax
  unsigned __int64 v107; // r8
  int v108; // edx
  __int64 v109; // rax
  __int64 v110; // r12
  bool v111; // of
  char *v112; // rax
  int v113; // ebx
  __int32 v114; // edx
  _BYTE *v115; // rax
  int v116; // eax
  __int64 v117; // rax
  const char *v118; // r12
  __int64 v119; // rax
  char *v120; // r13
  __int64 v121; // rax
  signed __int64 v122; // r8
  __int64 v123; // rax
  int v124; // edx
  __int64 v125; // rax
  int v126; // eax
  __int64 v127; // r13
  char v128; // bl
  int v129; // eax
  int v130; // ebx
  __int64 v131; // rsi
  unsigned __int64 v132; // r12
  __int64 v133; // r13
  int v134; // edx
  __int64 v135; // rax
  char v136; // al
  __int64 v137; // rbx
  unsigned int v138; // er13
  __int64 v139; // rax
  char v140; // r9
  bool v141; // r12
  char *v142; // r10
  __int64 v143; // rax
  char *v144; // rax
  __int64 v145; // rbx
  int v146; // er12
  char v147; // al
  int v148; // ebx
  _BYTE *v149; // rax
  _BYTE *v150; // rax
  unsigned __int8 *v151; // rax
  unsigned __int8 v152; // si
  int v153; // er12
  __int64 v154; // r12
  signed __int64 v155; // r8
  _BOOL4 v156; // edx
  _QWORD *v157; // rax
  char v158; // bl
  int v159; // eax
  int v160; // esi
  __m128 *v161; // rax
  unsigned __int64 v162; // rax
  _BYTE *v163; // rax
  _BYTE *v164; // rax
  unsigned __int8 *v165; // rax
  unsigned __int8 v166; // di
  int v167; // er12
  int v168; // ebx
  int v169; // ebx
  __int64 v170; // rax
  _BYTE *v171; // rax
  unsigned __int64 v172; // rsi
  void *v173; // rsp
  int v174; // edi
  unsigned int v175; // edx
  __int64 v176; // rcx
  __int64 v177; // r8
  int v178; // edi
  char *v179; // r13
  unsigned __int64 v180; // rax
  _BYTE *v181; // rax
  __int64 v182; // rcx
  signed __int64 v183; // r8
  int v184; // edx
  __int64 v185; // rax
  int v186; // er13
  int v187; // eax
  _BYTE *v188; // rax
  _BYTE *v189; // rax
  int v190; // eax
  _BYTE *v191; // rdx
  int v192; // ebx
  _BYTE *v193; // rax
  __int64 v194; // rdx
  __int64 v195; // rcx
  signed __int64 v196; // r8
  __int64 v197; // rbx
  int v198; // eax
  int v199; // ebx
  int v200; // eax
  int v201; // eax
  unsigned __int64 v202; // r13
  __int64 v203; // rax
  double v204; // xmm4_8
  double v205; // xmm5_8
  _BYTE *v206; // rax
  unsigned int v207; // ecx
  __int64 v208; // rdi
  unsigned __int64 *v209; // rdi
  _BYTE *v210; // rax
  char *v211; // r13
  unsigned __int8 *v212; // rax
  unsigned __int8 v213; // dl
  _BYTE *v214; // rax
  _QWORD *v215; // rbx
  __int64 v216; // rax
  char *v217; // rbx
  bool v218; // cc
  void *v219; // rsp
  unsigned int v220; // esi
  int v221; // eax
  unsigned int v222; // esi
  int v223; // eax
  int v224; // eax
  int v225; // eax
  int v226; // eax
  int v227; // eax
  int v228; // eax
  __int64 v229; // [rsp+0h] [rbp-940h] BYREF
  char *v230; // [rsp+8h] [rbp-938h]
  char *v231; // [rsp+10h] [rbp-930h]
  __int64 v232; // [rsp+18h] [rbp-928h]
  int v233; // [rsp+20h] [rbp-920h]
  int v234; // [rsp+24h] [rbp-91Ch]
  _QWORD *v235; // [rsp+28h] [rbp-918h]
  __int64 v236; // [rsp+30h] [rbp-910h]
  char *v237; // [rsp+38h] [rbp-908h]
  char *v238; // [rsp+40h] [rbp-900h]
  char *v239; // [rsp+48h] [rbp-8F8h]
  unsigned __int64 v240; // [rsp+50h] [rbp-8F0h]
  int v241; // [rsp+58h] [rbp-8E8h]
  int v242; // [rsp+5Ch] [rbp-8E4h]
  __int64 v243; // [rsp+60h] [rbp-8E0h]
  char *v244; // [rsp+68h] [rbp-8D8h]
  unsigned int v245; // [rsp+70h] [rbp-8D0h]
  bool v246; // [rsp+74h] [rbp-8CCh]
  bool v247; // [rsp+75h] [rbp-8CBh]
  unsigned __int8 v248; // [rsp+76h] [rbp-8CAh]
  char v249; // [rsp+77h] [rbp-8C9h]
  signed __int64 v250; // [rsp+78h] [rbp-8C8h]
  __int64 v251; // [rsp+80h] [rbp-8C0h]
  char *v252; // [rsp+88h] [rbp-8B8h]
  __m128 *v253; // [rsp+90h] [rbp-8B0h]
  __m128 *v254; // [rsp+98h] [rbp-8A8h]
  unsigned __int64 v255; // [rsp+A0h] [rbp-8A0h]
  u32 *v256; // [rsp+A8h] [rbp-898h]
  unsigned __int64 v257; // [rsp+B8h] [rbp-888h] BYREF
  __m128 *v258; // [rsp+C0h] [rbp-880h] BYREF
  __int64 v259; // [rsp+C8h] [rbp-878h] BYREF
  char *v260; // [rsp+D0h] [rbp-870h] BYREF
  unsigned __int64 v261; // [rsp+D8h] [rbp-868h]
  char v262[1024]; // [rsp+E0h] [rbp-860h] BYREF
  __int64 v263[2]; // [rsp+4E0h] [rbp-460h] BYREF
  char v264[1024]; // [rsp+4F0h] [rbp-450h] BYREF
  char v265[12]; // [rsp+8F0h] [rbp-50h] BYREF
  char v266[12]; // [rsp+8FCh] [rbp-44h] BYREF
  unsigned __int64 v267; // [rsp+908h] [rbp-38h]

  v251 = a1;
  v232 = a2;
  v237 = a17;
  v253 = (__m128 *)a13;
  v234 = a3;
  LODWORD(v252) = a14;
  v239 = a19;
  v236 = a20;
  v267 = __readfsqword(0x28u);
  v244 = v262;
  v260 = v262;
  v261 = 1024LL;
  v238 = v264;
  v263[0] = (__int64)v264;
  v263[1] = 1024LL;
  v257 = 0LL;
  if ( a19 == (char *)-1LL )
  {
    v94 = *(_QWORD *)__readfsqword(0xFFFFFFB0);
    v95 = *(_QWORD *)(v94 + 72);
    v239 = *(char **)(v94 + 80);
    v96 = *v239;
    v236 = v95;
    if ( !v96 || v96 == 127 )
      v239 = 0LL;
  }
  if ( *a16 )
  {
    v21 = a16;
    v22 = 0LL;
    v23 = 0LL;
    v255 = 14LL;
    v24 = (u32 *)v244;
    while ( 1 )
    {
      v25 = v22;
      v26 = (__int64)&v24[18 * v23];
      v256 = v24;
      ++v23;
      v27 = sub_68FF0((__int64)v21, v22, v26, (__int64 *)&v257);
      v21 = *(_BYTE **)(v26 + 32);
      v24 = v256;
      v22 += v27;
      if ( !*v21 )
        break;
      if ( v255 == v23 )
      {
        if ( !(unsigned __int8)sub_6BA10(
                                 (__int64)&v260,
                                 *(double *)a4.m128_u64,
                                 *(double *)a5.m128_u64,
                                 *(double *)a6.m128_u64,
                                 a7,
                                 v31,
                                 v32,
                                 a10,
                                 a11,
                                 v25,
                                 v28,
                                 v29,
                                 v256,
                                 v30) )
          goto LABEL_80;
        v24 = (u32 *)v260;
        v255 = v261 / 0x48;
      }
    }
    if ( v257 >= v22 )
      v22 = v257;
    v33 = v256;
    v34 = v22;
  }
  else
  {
    v33 = (u32 *)v244;
    v34 = 0LL;
    v23 = 0LL;
  }
  if ( !(unsigned __int8)sub_6BAD0(v263, v34, 24LL) )
  {
LABEL_80:
    LODWORD(v256) = -1;
    goto LABEL_81;
  }
  v254 = (__m128 *)v263[0];
  v256 = (u32 *)(v263[0] + 16 * v34);
  v35 = &v256[v34];
  v233 = a21 & 2;
  sub_9190((__int64)v35, (unsigned int)-(v233 != 0), 4 * v34);
  if ( !v23 )
  {
    if ( !v34 )
      goto LABEL_358;
LABEL_24:
    v51 = v254;
    v52 = (__int64)v253;
    v53 = 0LL;
    while ( 1 )
    {
      v36 = v35[v53];
      if ( (int)v36 > 7 )
      {
        if ( (_DWORD)v36 == 263 )
        {
          if ( (a21 & 1) != 0 )
          {
            v207 = *(_DWORD *)(v52 + 4);
            if ( v207 > 0xAF )
            {
              v209 = *(unsigned __int64 **)(v52 + 8);
              v36 = (__int64)(v209 + 1);
              *(_QWORD *)(v52 + 8) = v209 + 1;
            }
            else
            {
              v208 = v207;
              v36 = v207 + 16;
              v209 = (unsigned __int64 *)(*(_QWORD *)(v52 + 16) + v208);
              *(_DWORD *)(v52 + 4) = v36;
            }
            a4 = (__m128)*v209;
            v51->m128_u64[0] = a4.m128_u64[0];
            v35[v53] &= 0xFFFFFEFF;
          }
          else if ( (a21 & 8) != 0 )
          {
            v93 = *(_DWORD *)(v52 + 4);
            if ( v93 > 0xAF )
            {
              v36 = (*(_QWORD *)(v52 + 8) + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
              *(_QWORD *)(v52 + 8) = v36 + 16;
            }
            else
            {
              v36 = *(_QWORD *)(v52 + 16) + v93;
              *(_DWORD *)(v52 + 4) = v93 + 16;
            }
            a5 = (__m128)_mm_load_si128((const __m128i *)v36);
            *v51 = a5;
          }
          else
          {
            v36 = (*(_QWORD *)(v52 + 8) + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
            *(_QWORD *)(v52 + 8) = v36 + 16;
            *v51 = *(__m128 *)v36;
          }
          goto LABEL_33;
        }
        if ( (int)v36 <= 263 )
        {
          if ( (_DWORD)v36 == 256 )
            goto LABEL_30;
          goto LABEL_106;
        }
        if ( (_DWORD)v36 == 512 )
          goto LABEL_30;
        if ( (_DWORD)v36 == 1024 )
        {
          v91 = *(_DWORD *)v52;
          if ( *(_DWORD *)v52 > 0x2Fu )
          {
            v92 = *(unsigned int **)(v52 + 8);
            *(_QWORD *)(v52 + 8) = v92 + 2;
          }
          else
          {
            v92 = (unsigned int *)(*(_QWORD *)(v52 + 16) + v91);
            *(_DWORD *)v52 = v91 + 8;
          }
          v36 = *v92;
          v51->m128_i32[0] = v36;
          goto LABEL_33;
        }
      }
      else if ( (int)v36 >= -1 )
      {
        if ( (unsigned int)v36 <= 7 )
          __asm { jmp     rcx }
        if ( v233 )
          sub_17110(
            (__int64)"*** invalid %N$ use detected ***\n",
            *(double *)a4.m128_u64,
            *(double *)a5.m128_u64,
            *(double *)a6.m128_u64,
            a7,
            v37,
            v38,
            a10,
            a11);
        sub_CF00("(mode_flags & PRINTF_FORTIFY) != 0", "vfprintf-internal.c", 1888LL, "printf_positional");
      }
      if ( (v36 & 0x800) != 0 )
      {
LABEL_30:
        v54 = *(_DWORD *)v52;
        if ( *(_DWORD *)v52 > 0x2Fu )
        {
          v55 = *(__int64 **)(v52 + 8);
          *(_QWORD *)(v52 + 8) = v55 + 1;
        }
        else
        {
          v55 = (__int64 *)(*(_QWORD *)(v52 + 16) + v54);
          *(_DWORD *)v52 = v54 + 8;
        }
        v36 = *v55;
        v51->m128_u64[0] = *v55;
        goto LABEL_33;
      }
LABEL_106:
      if ( qword_C1B18 && (v36 = (int)v36, *(_QWORD *)(qword_C1B18 + 8LL * (int)v36 - 64)) )
      {
        v253 = v51;
        v255 = v52;
        v219 = alloca((int)v256[v53] + 8LL);
        v51->m128_u64[0] = (unsigned __int64)&v229;
        (*(void (__fastcall **)(__int64 *, __int64, void *))(qword_C1B18 + 8LL * (int)v35[v53] - 64))(
          &v229,
          v52,
          &unk_A3A20);
        v52 = v255;
        v51 = v253;
      }
      else
      {
        a4 = 0LL;
        *v51 = 0LL;
      }
LABEL_33:
      ++v53;
      ++v51;
      if ( v53 >= v34 )
        goto LABEL_34;
    }
  }
  v39 = v33;
  v255 = (unsigned __int64)v33;
  v40 = v23;
  v250 = v34;
  v41 = 0LL;
  v42 = &v256[v34];
  v43 = v39;
  v44 = v256;
  do
  {
    while ( 1 )
    {
      v45 = (int)v43[11];
      if ( (_DWORD)v45 != -1 )
        v42[v45] = 0;
      v46 = (int)v43[10];
      if ( (_DWORD)v46 != -1 )
        v42[v46] = 0;
      v47 = *((_QWORD *)v43 + 7);
      if ( !v47 )
        goto LABEL_15;
      if ( v47 != 1 )
        break;
      v42[v43[12]] = v43[13];
      v44[v43[12]] = v43[16];
LABEL_15:
      ++v41;
      v43 += 18;
      if ( v41 == v40 )
        goto LABEL_23;
    }
    v48 = (int)v43[12];
    v49 = (int)v43[2];
    ++v41;
    v50 = v43;
    v43 += 18;
    (*(void (__fastcall **)(u32 *, __int64, u32 *, u32 *))(qword_C1B10 + 8 * v49))(v50, v47, &v42[v48], &v44[v48]);
  }
  while ( v41 != v40 );
LABEL_23:
  v35 = v42;
  v34 = v250;
  v23 = v40;
  v33 = (u32 *)v255;
  if ( v250 )
    goto LABEL_24;
LABEL_34:
  v255 = a15;
  if ( v23 > a15 )
  {
    v240 = v23;
    v235 = v237 + 1000;
    v56 = (int *)&v33[18 * v255];
    v57 = (_QWORD *)v251;
    LODWORD(v256) = (_DWORD)v252;
    v231 = v237 + 999;
    v230 = (_BYTE *)(&dword_0 + 1);
    while ( 2 )
    {
      v58 = *((_BYTE *)v56 + 12);
      v59 = v56[2];
      v60 = *v56;
      v61 = *((_BYTE *)v56 + 13);
      v247 = (v58 & 8) != 0;
      LODWORD(v252) = (v58 & 0x20) != 0;
      v62 = (v58 & 0x10) != 0;
      LOBYTE(v245) = v58 & 1;
      v63 = v61;
      v64 = (v58 & 2) != 0;
      LOBYTE(v251) = (v58 & 0x40) != 0;
      v65 = v56[4];
      v246 = (v61 & 8) != 0;
      v66 = v56[11];
      v67 = (v63 & 2) != 0;
      v68 = (v58 & 4) != 0;
      v249 = v58 >> 7;
      LODWORD(v250) = v65;
      v248 = v59;
      if ( (_DWORD)v66 == -1 )
      {
        LODWORD(v253) = v56[1];
      }
      else
      {
        v66 *= 16LL;
        v69 = *(__int32 *)((char *)v254->m128_i32 + v66);
        LODWORD(v253) = v69;
        if ( v69 < 0 )
        {
          LODWORD(v253) = -(int)v253;
          v178 = (int)v253;
          *((_BYTE *)v56 + 12) = v58 | 0x20;
          v56[1] = v178;
          LODWORD(v252) = 1;
        }
        else
        {
          v56[1] = v69;
        }
      }
      v70 = v56[10];
      if ( (_DWORD)v70 != -1 )
      {
        v60 = v254[v70].m128_i32[0];
        if ( v60 < 0 )
        {
          *v56 = -1;
          v60 = -1;
        }
        else
        {
          *v56 = v60;
        }
      }
      if ( qword_C1788 )
      {
        v71 = *(__int64 (__fastcall **)(_QWORD *, int *, __int64 *))(qword_C1788 + 8LL * (char)v59);
        v243 = (char)v59;
        if ( v71 )
        {
          v172 = *((_QWORD *)v56 + 7);
          v173 = alloca(8 * v172 + 8);
          if ( v172 )
          {
            LOBYTE(v242) = v62;
            v174 = v56[12];
            v175 = 0;
            v176 = 0LL;
            v177 = (__int64)v254;
            do
            {
              *(&v229 + v176) = v177 + 16LL * (v174 + v175++);
              v176 = v175;
            }
            while ( v172 > v175 );
            LOBYTE(v62) = v242;
            v71 = *(__int64 (__fastcall **)(_QWORD *, int *, __int64 *))(qword_C1788 + 8 * v243);
          }
          v241 = v60;
          LOBYTE(v242) = v68;
          LOBYTE(v243) = v62;
          v129 = v71(v57, v56, &v229);
          v62 = (unsigned __int8)v243;
          v60 = v241;
          v68 = v242;
          if ( v129 != -2 )
          {
LABEL_169:
            if ( v129 < 0 )
              goto LABEL_80;
            v130 = (int)v256;
            if ( (int)v256 < 0 )
              goto LABEL_81;
            LODWORD(v256) = (_DWORD)v256 + v129;
            if ( __OFADD__(v130, v129) )
              goto LABEL_128;
LABEL_172:
            if ( (int)v256 < 0 )
              goto LABEL_81;
LABEL_173:
            v107 = (char *)&off_C0308 - (char *)&unk_BFAE0;
            goto LABEL_174;
          }
        }
      }
      if ( (unsigned __int8)(v59 - 32) > 0x5Au )
      {
LABEL_45:
        v72 = *((_QWORD *)v56 + 7);
        v73 = alloca(8 * v72 + 8);
        if ( v72 )
        {
          v74 = v56[12];
          v75 = (__int64)v254;
          v76 = 0;
          v77 = 0LL;
          do
          {
            *(&v229 + v77) = v75 + 16LL * (v74 + v76++);
            v77 = v76;
          }
          while ( v72 > v76 );
        }
        v78 = (_BYTE *)v57[5];
        if ( (unsigned __int64)v78 >= v57[6] )
        {
          if ( (unsigned int)sub_1A150(
                               (__int64)v57,
                               0x25u,
                               *(double *)a4.m128_u64,
                               *(double *)a5.m128_u64,
                               *(double *)a6.m128_u64,
                               a7,
                               v37,
                               v38,
                               a10,
                               a11) == -1 )
            goto LABEL_80;
        }
        else
        {
          v57[5] = v78 + 1;
          *v78 = 37;
        }
        v79 = *((_BYTE *)v56 + 12);
        if ( (v79 & 8) != 0 )
        {
          v80 = (_BYTE *)v57[5];
          if ( (unsigned __int64)v80 >= v57[6] )
          {
            if ( (unsigned int)sub_1A150(
                                 (__int64)v57,
                                 0x23u,
                                 *(double *)a4.m128_u64,
                                 *(double *)a5.m128_u64,
                                 *(double *)a6.m128_u64,
                                 a7,
                                 v37,
                                 v38,
                                 a10,
                                 a11) == -1 )
              goto LABEL_80;
          }
          else
          {
            v57[5] = v80 + 1;
            *v80 = 35;
          }
          v79 = *((_BYTE *)v56 + 12);
          v81 = 2;
        }
        else
        {
          v81 = 1;
        }
        if ( v79 < 0 )
        {
          v206 = (_BYTE *)v57[5];
          if ( (unsigned __int64)v206 >= v57[6] )
          {
            if ( (unsigned int)sub_1A150(
                                 (__int64)v57,
                                 0x27u,
                                 *(double *)a4.m128_u64,
                                 *(double *)a5.m128_u64,
                                 *(double *)a6.m128_u64,
                                 a7,
                                 v37,
                                 v38,
                                 a10,
                                 a11) == -1 )
              goto LABEL_80;
          }
          else
          {
            v57[5] = v206 + 1;
            *v206 = 39;
          }
          v79 = *((_BYTE *)v56 + 12);
          ++v81;
        }
        if ( (v79 & 0x40) != 0 )
        {
          v82 = (_BYTE *)v57[5];
          if ( (unsigned __int64)v82 >= v57[6] )
          {
            if ( (unsigned int)sub_1A150(
                                 (__int64)v57,
                                 0x2Bu,
                                 *(double *)a4.m128_u64,
                                 *(double *)a5.m128_u64,
                                 *(double *)a6.m128_u64,
                                 a7,
                                 v37,
                                 v38,
                                 a10,
                                 a11) == -1 )
              goto LABEL_80;
          }
          else
          {
            v57[5] = v82 + 1;
            *v82 = 43;
          }
        }
        else
        {
          if ( (v79 & 0x10) == 0 )
            goto LABEL_59;
          v193 = (_BYTE *)v57[5];
          if ( (unsigned __int64)v193 >= v57[6] )
          {
            if ( (unsigned int)sub_1A150(
                                 (__int64)v57,
                                 0x20u,
                                 *(double *)a4.m128_u64,
                                 *(double *)a5.m128_u64,
                                 *(double *)a6.m128_u64,
                                 a7,
                                 v37,
                                 v38,
                                 a10,
                                 a11) == -1 )
              goto LABEL_80;
          }
          else
          {
            v57[5] = v193 + 1;
            *v193 = 32;
          }
        }
        v79 = *((_BYTE *)v56 + 12);
        ++v81;
LABEL_59:
        if ( (v79 & 0x20) != 0 )
        {
          v83 = (_BYTE *)v57[5];
          if ( (unsigned __int64)v83 >= v57[6] )
          {
            if ( (unsigned int)sub_1A150(
                                 (__int64)v57,
                                 0x2Du,
                                 *(double *)a4.m128_u64,
                                 *(double *)a5.m128_u64,
                                 *(double *)a6.m128_u64,
                                 a7,
                                 v37,
                                 v38,
                                 a10,
                                 a11) == -1 )
              goto LABEL_80;
          }
          else
          {
            v57[5] = v83 + 1;
            *v83 = 45;
          }
          ++v81;
        }
        if ( v56[4] == 48 )
        {
          v210 = (_BYTE *)v57[5];
          if ( (unsigned __int64)v210 >= v57[6] )
          {
            if ( (unsigned int)sub_1A150(
                                 (__int64)v57,
                                 0x30u,
                                 *(double *)a4.m128_u64,
                                 *(double *)a5.m128_u64,
                                 *(double *)a6.m128_u64,
                                 a7,
                                 v37,
                                 v38,
                                 a10,
                                 a11) == -1 )
              goto LABEL_80;
          }
          else
          {
            v57[5] = v210 + 1;
            *v210 = 48;
          }
          ++v81;
        }
        if ( (*((_BYTE *)v56 + 13) & 8) != 0 )
        {
          v84 = (_BYTE *)v57[5];
          if ( (unsigned __int64)v84 >= v57[6] )
          {
            if ( (unsigned int)sub_1A150(
                                 (__int64)v57,
                                 0x49u,
                                 *(double *)a4.m128_u64,
                                 *(double *)a5.m128_u64,
                                 *(double *)a6.m128_u64,
                                 a7,
                                 v37,
                                 v38,
                                 a10,
                                 a11) == -1 )
              goto LABEL_80;
          }
          else
          {
            v57[5] = v84 + 1;
            *v84 = 73;
          }
          ++v81;
        }
        v85 = v56[1];
        if ( v85 )
        {
          v211 = (char *)sub_7A1B0(v85, (__int64)v266, 0xAu, 0);
          if ( v211 < v266 )
          {
            do
            {
              ++v211;
              v212 = (unsigned __int8 *)v57[5];
              v213 = *(v211 - 1);
              if ( (unsigned __int64)v212 < v57[6] )
              {
                v57[5] = v212 + 1;
                *v212 = v213;
              }
              else if ( (unsigned int)sub_1A150(
                                        (__int64)v57,
                                        v213,
                                        *(double *)a4.m128_u64,
                                        *(double *)a5.m128_u64,
                                        *(double *)a6.m128_u64,
                                        a7,
                                        v37,
                                        v38,
                                        a10,
                                        a11) == -1 )
              {
                goto LABEL_80;
              }
              if ( v81 == 0x7FFFFFFF )
                goto LABEL_80;
              ++v81;
            }
            while ( v211 != v266 );
          }
        }
        if ( *v56 != -1 )
        {
          v86 = (_BYTE *)v57[5];
          if ( (unsigned __int64)v86 >= v57[6] )
          {
            if ( (unsigned int)sub_1A150(
                                 (__int64)v57,
                                 0x2Eu,
                                 *(double *)a4.m128_u64,
                                 *(double *)a5.m128_u64,
                                 *(double *)a6.m128_u64,
                                 a7,
                                 v37,
                                 v38,
                                 a10,
                                 a11) == -1 )
              goto LABEL_80;
          }
          else
          {
            v57[5] = v86 + 1;
            *v86 = 46;
          }
          if ( v81 == 0x7FFFFFFF )
            goto LABEL_80;
          ++v81;
          v87 = (char *)sub_7A1B0(*v56, (__int64)v266, 0xAu, 0);
          if ( v87 < v266 )
          {
            do
            {
              ++v87;
              v88 = (unsigned __int8 *)v57[5];
              v89 = *(v87 - 1);
              if ( (unsigned __int64)v88 < v57[6] )
              {
                v57[5] = v88 + 1;
                *v88 = v89;
              }
              else if ( (unsigned int)sub_1A150(
                                        (__int64)v57,
                                        v89,
                                        *(double *)a4.m128_u64,
                                        *(double *)a5.m128_u64,
                                        *(double *)a6.m128_u64,
                                        a7,
                                        v37,
                                        v38,
                                        a10,
                                        a11) == -1 )
              {
                goto LABEL_80;
              }
              if ( v81 == 0x7FFFFFFF )
                goto LABEL_80;
              ++v81;
            }
            while ( v87 != v266 );
          }
        }
        v190 = v56[2];
        if ( v190 )
        {
          v191 = (_BYTE *)v57[5];
          if ( (unsigned __int64)v191 >= v57[6] )
          {
            if ( (unsigned int)sub_1A150(
                                 (__int64)v57,
                                 (unsigned __int8)v190,
                                 *(double *)a4.m128_u64,
                                 *(double *)a5.m128_u64,
                                 *(double *)a6.m128_u64,
                                 a7,
                                 v37,
                                 v38,
                                 a10,
                                 a11) == -1 )
              goto LABEL_80;
          }
          else
          {
            v57[5] = v191 + 1;
            *v191 = v190;
          }
          if ( v81 == 0x7FFFFFFF )
            goto LABEL_80;
          ++v81;
        }
        if ( (int)v256 < 0 )
          goto LABEL_81;
        v111 = __OFADD__((_DWORD)v256, v81);
        v192 = (_DWORD)v256 + v81;
        LODWORD(v256) = v192;
        if ( v111 )
        {
LABEL_128:
          __writefsdword(0xFFFFFFC0, 0x4Bu);
          LODWORD(v256) = -1;
          goto LABEL_81;
        }
        if ( v192 < 0 )
          goto LABEL_81;
        goto LABEL_173;
      }
      v242 = (unsigned __int8)v62;
      LODWORD(v243) = (unsigned __int8)v251;
      v97 = v68;
      v98 = (unsigned __int8)v250;
      LODWORD(v251) = v97;
      switch ( (char)v59 )
      {
        case ' ':
        case '!':
        case '"':
        case '#':
        case '$':
        case '&':
        case '\'':
        case '(':
        case ')':
        case '*':
        case '+':
        case ',':
        case '-':
        case '.':
        case '/':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case ':':
        case ';':
        case '<':
        case '=':
        case '>':
        case '?':
        case '@':
        case 'B':
        case 'D':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'Y':
        case 'Z':
        case '[':
        case '\\':
        case ']':
        case '^':
        case '_':
        case '`':
        case 'b':
        case 'h':
        case 'j':
        case 'k':
        case 'l':
        case 'q':
        case 'r':
        case 't':
        case 'v':
        case 'w':
        case 'y':
        case 'z':
        case '{':
        case '|':
        case '}':
        case '~':
        case '\x7F':
          goto LABEL_45;
        case '%':
          v171 = (_BYTE *)v57[5];
          if ( (unsigned __int64)v171 >= v57[6] )
          {
            if ( (unsigned int)sub_1A150(
                                 (__int64)v57,
                                 0x25u,
                                 *(double *)a4.m128_u64,
                                 *(double *)a5.m128_u64,
                                 *(double *)a6.m128_u64,
                                 a7,
                                 v37,
                                 v38,
                                 a10,
                                 a11) == -1 )
              goto LABEL_80;
          }
          else
          {
            v57[5] = v171 + 1;
            *v171 = 37;
          }
          if ( (_DWORD)v256 == 0x7FFFFFFF )
            goto LABEL_80;
          LODWORD(v256) = (_DWORD)v256 + 1;
          goto LABEL_290;
        case 'A':
        case 'a':
          v258 = &v254[v56[12]];
          if ( (a21 & 1) != 0 )
            *((_BYTE *)v56 + 12) &= 0xFEu;
          v158 = v245;
          if ( (a21 & 8) == 0 )
            v158 = 0;
          *((_BYTE *)v56 + 13) = *((_BYTE *)v56 + 13) & 0xEF | (16 * (v158 & 1));
          v159 = sub_7D370(
                   v57,
                   (unsigned __int64)v56,
                   (const __m128i **)&v258,
                   a4,
                   a5,
                   a6,
                   a7,
                   v37,
                   v38,
                   a10,
                   a11,
                   v36,
                   (u32 *)v62);
          if ( v159 < 0 )
            goto LABEL_80;
          v160 = (int)v256;
          if ( (int)v256 < 0 )
            goto LABEL_81;
          LODWORD(v256) = (_DWORD)v256 + v159;
          if ( __OFADD__(v160, v159) )
            goto LABEL_128;
          goto LABEL_172;
        case 'C':
          goto LABEL_111;
        case 'E':
        case 'F':
        case 'G':
        case 'e':
        case 'f':
        case 'g':
          v258 = &v254[v56[12]];
          if ( (a21 & 1) != 0 )
          {
            *((_BYTE *)v56 + 12) &= 0xFEu;
            v56[13] = 7;
          }
          v128 = v245;
          if ( (a21 & 8) == 0 )
            v128 = 0;
          *((_BYTE *)v56 + 13) = (16 * (v128 & 1)) | *((_BYTE *)v56 + 13) & 0xEF;
          v129 = sub_7D1B0(
                   v57,
                   (__int64)v56,
                   (const __m128i **)&v258,
                   (__m128i)a4,
                   a5,
                   (__m128i)a6,
                   a7,
                   v37,
                   v38,
                   a10,
                   a11,
                   v36,
                   v62,
                   v98);
          goto LABEL_169;
        case 'S':
        case 's':
          v118 = (const char *)v254[v56[12]].m128_u64[0];
          goto LABEL_141;
        case 'X':
        case 'x':
          v245 = 16;
          goto LABEL_247;
        case 'c':
          LODWORD(v98) = v251;
          if ( !(_DWORD)v251 )
          {
            v113 = (_DWORD)v253 - 1;
            if ( !(_DWORD)v252 )
            {
              if ( v113 > 0 )
              {
                if ( v113 != sub_6A2A0(
                               (__int64)v57,
                               32,
                               v113,
                               *(double *)a4.m128_u64,
                               *(double *)a5.m128_u64,
                               *(double *)a6.m128_u64,
                               a7,
                               v37,
                               v38,
                               a10,
                               a11) )
                  goto LABEL_80;
                v224 = (int)v256;
                if ( (int)v256 < 0 )
                  goto LABEL_81;
                LODWORD(v256) = (_DWORD)v256 + v113;
                if ( __OFADD__(v224, v113) )
                  goto LABEL_128;
              }
              if ( (int)v256 < 0 )
                goto LABEL_81;
            }
            v114 = v254[v56[12]].m128_i32[0];
            v115 = (_BYTE *)v57[5];
            if ( (unsigned __int64)v115 >= v57[6] )
            {
              if ( (unsigned int)sub_1A150(
                                   (__int64)v57,
                                   (unsigned __int8)v114,
                                   *(double *)a4.m128_u64,
                                   *(double *)a5.m128_u64,
                                   *(double *)a6.m128_u64,
                                   a7,
                                   v37,
                                   v38,
                                   a10,
                                   a11) == -1 )
                goto LABEL_80;
            }
            else
            {
              v57[5] = v115 + 1;
              *v115 = v114;
            }
            if ( (_DWORD)v256 == 0x7FFFFFFF )
              goto LABEL_80;
            LODWORD(v256) = (_DWORD)v256 + 1;
            if ( !(_DWORD)v252 )
            {
LABEL_290:
              v131 = *((_QWORD *)v56 + 3);
              v132 = *((_QWORD *)v56 + 4) - v131;
              if ( (int)v256 < 0 )
                goto LABEL_351;
              v107 = (char *)&off_C0308 - (char *)&unk_BFAE0;
              goto LABEL_175;
            }
            if ( v113 > 0 )
            {
              if ( v113 != sub_6A2A0(
                             (__int64)v57,
                             32,
                             v113,
                             *(double *)a4.m128_u64,
                             *(double *)a5.m128_u64,
                             *(double *)a6.m128_u64,
                             a7,
                             v37,
                             v38,
                             a10,
                             a11) )
                goto LABEL_80;
              v116 = (int)v256;
              if ( (int)v256 < 0 )
                goto LABEL_81;
              LODWORD(v256) = (_DWORD)v256 + v113;
              if ( __OFADD__(v116, v113) )
                goto LABEL_128;
            }
            goto LABEL_172;
          }
LABEL_111:
          v259 = 0LL;
          v99 = sub_6D090(
                  v265,
                  v254[v56[12]].m128_u32[0],
                  &v259,
                  v36,
                  (u32 *)v62,
                  v98,
                  *(double *)a4.m128_u64,
                  *(double *)a5.m128_u64,
                  *(double *)a6.m128_u64,
                  a7,
                  v37,
                  v38,
                  a10,
                  a11);
          v102 = v99;
          if ( v99 == -1 )
            goto LABEL_80;
          v103 = (_DWORD)v253 - v99;
          LODWORD(v251) = (_DWORD)v253 - v102;
          if ( (_DWORD)v252 )
          {
            if ( (int)v256 < 0 )
              goto LABEL_351;
          }
          else
          {
            if ( v103 > 0 )
            {
              v199 = v103;
              if ( v103 != sub_6A2A0(
                             (__int64)v57,
                             32,
                             v103,
                             *(double *)a4.m128_u64,
                             *(double *)a5.m128_u64,
                             *(double *)a6.m128_u64,
                             a7,
                             v100,
                             v101,
                             a10,
                             a11) )
                goto LABEL_80;
              v200 = (int)v256;
              if ( (int)v256 < 0 )
                goto LABEL_81;
              LODWORD(v256) = (_DWORD)v256 + v199;
              if ( __OFADD__(v200, v199) )
                goto LABEL_128;
            }
            if ( (int)v256 < 0 )
              goto LABEL_81;
          }
          v104 = v57[27];
          v105 = (char *)&off_C0308 - (char *)&unk_BFAE0;
          if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v104 - (_QWORD)&unk_BFAE0) )
          {
            v250 = (char *)&off_C0308 - (char *)&unk_BFAE0;
            v253 = (__m128 *)v104;
            sub_17140(*(double *)a4.m128_u64, *(double *)a5.m128_u64, *(double *)a6.m128_u64, a7, v100, v101, a10, a11);
            v104 = (__int64)v253;
            v105 = v250;
          }
          v253 = (__m128 *)v105;
          v106 = (*(__int64 (__fastcall **)(_QWORD *, char *, unsigned __int64))(v104 + 56))(v57, v265, v102);
          v107 = (unsigned __int64)v253;
          if ( v102 != v106 )
            goto LABEL_80;
          v108 = 0;
          v109 = v102 + (int)v256;
          if ( v109 < 0 || v109 < v102 )
            v108 = 1;
          LODWORD(v256) = v102 + (_DWORD)v256;
          if ( v109 != (int)v109 )
            v108 = 1;
          if ( v108 )
            goto LABEL_128;
          if ( (int)v109 < 0 )
            goto LABEL_81;
          if ( (_DWORD)v252 && (int)v251 > 0 )
          {
            v110 = (int)v251;
            if ( v110 != sub_6A2A0(
                           (__int64)v57,
                           32,
                           v251,
                           *(double *)a4.m128_u64,
                           *(double *)a5.m128_u64,
                           *(double *)a6.m128_u64,
                           a7,
                           v37,
                           v38,
                           a10,
                           a11) )
              goto LABEL_80;
            v111 = __OFADD__((_DWORD)v110, (_DWORD)v256);
            LODWORD(v112) = v110 + (_DWORD)v256;
            LODWORD(v256) = v110 + (_DWORD)v256;
            if ( v111 )
              goto LABEL_128;
            goto LABEL_230;
          }
          goto LABEL_174;
        case 'd':
        case 'i':
          if ( (_DWORD)v251 )
          {
            v170 = v254[v56[12]].m128_i64[0];
          }
          else
          {
            LODWORD(v194) = v254[v56[12]].m128_i32[0];
            v170 = (char)v194;
            if ( !v67 )
            {
              v170 = (int)v194;
              v194 = (__int16)v194;
              if ( v64 )
                v170 = v194;
            }
          }
          if ( v170 < 0 )
          {
            v245 = 10;
            v250 = -v170;
            LODWORD(v251) = 1;
          }
          else
          {
            v250 = v170;
            v245 = 10;
            LODWORD(v251) = 0;
          }
          goto LABEL_249;
        case 'm':
          LODWORD(v250) = v60;
          v117 = sub_23140(
                   a18,
                   v237,
                   1000LL,
                   *(double *)a4.m128_u64,
                   *(double *)a5.m128_u64,
                   *(double *)a6.m128_u64,
                   a7,
                   v37,
                   v38,
                   a10,
                   a11);
          v60 = v250;
          LODWORD(v251) = 0;
          v118 = (const char *)v117;
LABEL_141:
          if ( !v118 )
          {
            if ( v60 == -1 || v60 > 5 )
            {
              LODWORD(v119) = 6;
              v120 = &byte_6;
              v118 = "(null)";
            }
            else
            {
              LODWORD(v119) = 0;
              v120 = 0LL;
              v118 = (const char *)&unk_A6E65;
            }
            goto LABEL_146;
          }
          if ( (v251 & 1) != 0 || (_BYTE)v59 == 83 )
            goto LABEL_377;
          if ( v60 == -1 )
          {
            v119 = strlen((__int64)v118);
            v120 = (char *)v119;
            goto LABEL_146;
          }
          goto LABEL_145;
        case 'n':
          if ( v233 )
          {
            if ( !v234 )
            {
              v202 = v232;
              v203 = strlen(v232);
              v234 = sub_6EE40(
                       v202,
                       v203 + 1,
                       *(double *)a4.m128_u64,
                       *(double *)a5.m128_u64,
                       *(double *)a6.m128_u64,
                       a7,
                       v204,
                       v205,
                       a10,
                       a11);
            }
            if ( v234 < 0 )
              sub_17110(
                (__int64)"*** %n in writable segment detected ***\n",
                *(double *)a4.m128_u64,
                *(double *)a5.m128_u64,
                *(double *)a6.m128_u64,
                a7,
                v37,
                v38,
                a10,
                a11);
          }
          v157 = (_QWORD *)v254[v56[12]].m128_u64[0];
          if ( (_DWORD)v251 )
          {
            *v157 = (int)v256;
          }
          else if ( v67 )
          {
            *(_BYTE *)v157 = (_BYTE)v256;
          }
          else if ( v64 )
          {
            *(_WORD *)v157 = (_WORD)v256;
          }
          else
          {
            *(_DWORD *)v157 = (_DWORD)v256;
          }
          goto LABEL_290;
        case 'o':
          v245 = 8;
          goto LABEL_247;
        case 'p':
          if ( !v254[v56[12]].m128_u64[0] )
          {
            v118 = "(nil)";
            if ( v60 < 5 )
              v60 = 5;
            if ( (_BYTE)v59 == 83 )
LABEL_377:
              ((void (__fastcall *)(_QWORD *, const char *, _QWORD, _QWORD, _QWORD, _QWORD))loc_5EAC0)(
                v57,
                v118,
                (unsigned int)v60,
                (unsigned int)v253,
                (unsigned int)v252,
                (unsigned int)v256);
LABEL_145:
            v119 = sub_9040(v118, v60, v66, v36, v62, v98);
            v120 = (char *)v119;
LABEL_146:
            LODWORD(v253) = (_DWORD)v253 - v119;
            if ( (int)v253 < 0 )
            {
              if ( (int)v256 < 0 )
LABEL_351:
                sub_5EA90();
              v195 = v57[27];
              v196 = (char *)&off_C0308 - (char *)&unk_BFAE0;
              if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v195 - (_QWORD)&unk_BFAE0) )
              {
                v252 = (char *)((char *)&off_C0308 - (char *)&unk_BFAE0);
                v253 = (__m128 *)v195;
                sub_17140(
                  *(double *)a4.m128_u64,
                  *(double *)a5.m128_u64,
                  *(double *)a6.m128_u64,
                  a7,
                  v37,
                  v38,
                  a10,
                  a11);
                v196 = (signed __int64)v252;
                v195 = (__int64)v253;
              }
              v253 = (__m128 *)v196;
              if ( v120 != (char *)(*(__int64 (__fastcall **)(_QWORD *, const char *, char *))(v195 + 56))(
                                     v57,
                                     v118,
                                     v120) )
                goto LABEL_80;
              goto LABEL_227;
            }
            if ( (_DWORD)v252 )
            {
              if ( (int)v256 < 0 )
                goto LABEL_351;
            }
            else
            {
              if ( (_DWORD)v253 )
              {
                v197 = (int)v253;
                if ( v197 != sub_6A2A0(
                               (__int64)v57,
                               32,
                               (int)v253,
                               *(double *)a4.m128_u64,
                               *(double *)a5.m128_u64,
                               *(double *)a6.m128_u64,
                               a7,
                               v37,
                               v38,
                               a10,
                               a11) )
                  goto LABEL_80;
                v198 = (int)v256;
                if ( (int)v256 < 0 )
                  goto LABEL_81;
                LODWORD(v256) = (_DWORD)v256 + v197;
                if ( __OFADD__(v198, (_DWORD)v197) )
                  goto LABEL_128;
              }
              if ( (int)v256 < 0 )
                goto LABEL_81;
            }
            v121 = v57[27];
            v122 = (char *)&off_C0308 - (char *)&unk_BFAE0;
            if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v121 - (_QWORD)&unk_BFAE0) )
            {
              v250 = (char *)&off_C0308 - (char *)&unk_BFAE0;
              v251 = v121;
              sub_17140(*(double *)a4.m128_u64, *(double *)a5.m128_u64, *(double *)a6.m128_u64, a7, v37, v38, a10, a11);
              v121 = v251;
              v122 = v250;
            }
            v251 = v122;
            v123 = (*(__int64 (__fastcall **)(_QWORD *, const char *, char *))(v121 + 56))(v57, v118, v120);
            v107 = v251;
            if ( v120 != (char *)v123 )
              goto LABEL_80;
            v124 = 0;
            v125 = (__int64)&v120[(int)v256];
            if ( v125 < 0 || v125 < (unsigned __int64)v120 )
              v124 = 1;
            LODWORD(v256) = (_DWORD)v120 + (_DWORD)v256;
            if ( v125 != (int)v125 )
              v124 = 1;
            if ( v124 )
              goto LABEL_128;
            if ( (int)v125 < 0 )
              goto LABEL_81;
            if ( (_DWORD)v252 )
            {
              v126 = (int)v253;
              if ( (_DWORD)v253 )
              {
                v127 = (int)v253;
                v253 = (__m128 *)v251;
                if ( v127 != sub_6A2A0(
                               (__int64)v57,
                               32,
                               v126,
                               *(double *)a4.m128_u64,
                               *(double *)a5.m128_u64,
                               *(double *)a6.m128_u64,
                               a7,
                               v37,
                               v38,
                               a10,
                               a11) )
                  goto LABEL_80;
                v111 = __OFADD__((_DWORD)v256, (_DWORD)v127);
                LODWORD(v256) = (_DWORD)v256 + v127;
                LODWORD(v112) = (_DWORD)v256;
                if ( v111 )
                  goto LABEL_128;
                goto LABEL_230;
              }
            }
            goto LABEL_174;
          }
          v250 = v254[v56[12]].m128_i64[0];
          if ( v60 >= 0 )
          {
            if ( v60 )
            {
              v245 = 16;
              v136 = 0;
              v241 = 1;
              v248 = 120;
              LODWORD(v251) = 0;
              goto LABEL_190;
            }
            LODWORD(v251) = 0;
            v136 = 0;
            v245 = 16;
            v241 = 1;
            v248 = 120;
            goto LABEL_342;
          }
          v215 = v235;
          LOBYTE(v251) = v98;
          v216 = sub_7A1B0(v250, (__int64)v235, 0x10u, 0);
          v140 = v251;
          v245 = 16;
          v217 = (char *)v215 - v216;
          v248 = 120;
          v142 = (char *)v216;
          v241 = 1;
          v218 = (__int64)v217 <= 0;
          v120 = v217;
          v137 = 1LL;
          LODWORD(v251) = 0;
          if ( v218 )
            goto LABEL_197;
          goto LABEL_303;
        case 'u':
          v245 = 10;
LABEL_247:
          v161 = &v254[v56[12]];
          if ( (_DWORD)v251 )
          {
            LODWORD(v243) = 0;
            v162 = v161->m128_u64[0];
            v242 = 0;
            v250 = v162;
            LODWORD(v251) = 0;
          }
          else
          {
            v180 = v161->m128_u32[0];
            if ( v67 )
            {
              LODWORD(v243) = 0;
              v250 = (unsigned __int8)v180;
              v242 = 0;
            }
            else
            {
              if ( v64 )
                v180 = (unsigned __int16)v180;
              v250 = v180;
              LODWORD(v243) = 0;
              v242 = 0;
            }
          }
LABEL_249:
          v241 = v247;
          v136 = v249;
          if ( v60 < 0 )
          {
            v137 = 1LL;
          }
          else if ( v60 )
          {
LABEL_190:
            v137 = v60;
            LOBYTE(v98) = 32;
            v249 = v136 & 1;
          }
          else
          {
            if ( !v250 )
            {
              if ( v245 == 8 && v247 )
              {
                v142 = v231;
                v237[999] = 48;
                v120 = v230;
                if ( (__int64)v230 < 0 )
                {
                  LODWORD(v145) = (_DWORD)v231 - (_DWORD)v235;
                  if ( v231 - (char *)v235 < 0 )
                    LODWORD(v145) = v250;
                  v60 = v145;
                  if ( !(_DWORD)v252 )
                  {
                    v146 = (_DWORD)v253 - ((_DWORD)v230 + v145);
                    v148 = v243 | v251 | v242;
                    if ( v148 )
                    {
                      v148 = v243;
                      --v146;
                    }
                    v245 = 8;
                    goto LABEL_316;
                  }
                  v245 = 8;
                  goto LABEL_259;
                }
                v245 = 8;
                LODWORD(v145) = 0;
                v140 = 32;
              }
              else
              {
                v142 = (char *)v235;
                LODWORD(v145) = 0;
                v120 = 0LL;
                v140 = 32;
              }
              goto LABEL_371;
            }
LABEL_342:
            v137 = 0LL;
            LOBYTE(v98) = 32;
            v249 = v136 & 1;
          }
          v138 = v245;
          v247 = v98;
          v139 = sub_7A1B0(v250, (__int64)v235, v245, v248 == 88);
          v140 = v247;
          v141 = v246 && v138 == 10;
          v142 = (char *)v139;
          if ( v239 && v249 )
          {
            v249 = v247;
            v143 = sub_5E560((unsigned __int64)v237, v139, (__int64)v235, v239, v236);
            v140 = v249;
            v142 = (char *)v143;
          }
          if ( v141 )
          {
            v249 = v140;
            v144 = (char *)sub_5E770(
                             (__int64)v142,
                             (__int64)v235,
                             v235,
                             *(double *)a4.m128_u64,
                             *(double *)a5.m128_u64,
                             *(double *)a6.m128_u64,
                             a7,
                             v37,
                             v38,
                             a10,
                             a11);
            v140 = v249;
            v142 = v144;
          }
          v120 = (char *)((char *)v235 - v142);
          if ( (char *)v235 - v142 < v137 )
          {
LABEL_197:
            v145 = v137 - (_QWORD)v120;
            if ( v145 < 0 )
              LODWORD(v145) = 0;
            v60 = v145;
            if ( !(_DWORD)v252 )
            {
              v146 = (_DWORD)v253 - (_DWORD)v120 - v145;
              if ( v250 )
              {
                v147 = v241 & 1;
                goto LABEL_202;
              }
              goto LABEL_205;
            }
            goto LABEL_259;
          }
          if ( v250 )
          {
LABEL_303:
            v147 = v241 & 1;
            if ( v245 == 8 && v147 )
            {
              v179 = (char *)v235;
              *--v142 = 48;
              v120 = (char *)(v179 - v142);
            }
            v145 = v137 - (_QWORD)v120;
            if ( v145 < 0 )
              LODWORD(v145) = 0;
            v60 = v145;
            if ( !(_DWORD)v252 )
            {
              v146 = (_DWORD)v253 - (_DWORD)v120 - v145;
LABEL_202:
              if ( v245 == 16 && v147 )
                v146 -= 2;
LABEL_205:
              v148 = v243 | v242 | v251;
              if ( v148 )
              {
                --v146;
                if ( v140 != 32 )
                  goto LABEL_207;
                v148 = v243;
LABEL_316:
                if ( v146 > 0 )
                {
                  LODWORD(v252) = v60;
                  v253 = (__m128 *)v142;
                  if ( v146 != sub_6A2A0(
                                 (__int64)v57,
                                 32,
                                 v146,
                                 *(double *)a4.m128_u64,
                                 *(double *)a5.m128_u64,
                                 *(double *)a6.m128_u64,
                                 a7,
                                 v37,
                                 v38,
                                 a10,
                                 a11) )
                    goto LABEL_80;
                  v201 = (int)v256;
                  if ( (int)v256 < 0 )
                    goto LABEL_81;
                  v142 = (char *)v253;
                  v60 = (int)v252;
                  LODWORD(v256) = (_DWORD)v256 + v146;
                  if ( __OFADD__(v201, v146) )
                    goto LABEL_128;
                }
                if ( (int)v256 < 0 )
                  goto LABEL_81;
                LODWORD(v243) = v148;
                v146 = 0;
LABEL_207:
                if ( (_DWORD)v251 )
                {
                  v149 = (_BYTE *)v57[5];
                  if ( (unsigned __int64)v149 < v57[6] )
                  {
                    v57[5] = v149 + 1;
                    *v149 = 45;
                    goto LABEL_210;
                  }
                  LODWORD(v252) = v60;
                  v220 = 45;
                  v253 = (__m128 *)v142;
LABEL_442:
                  v221 = sub_1A150(
                           (__int64)v57,
                           v220,
                           *(double *)a4.m128_u64,
                           *(double *)a5.m128_u64,
                           *(double *)a6.m128_u64,
                           a7,
                           v37,
                           v38,
                           a10,
                           a11);
                  v142 = (char *)v253;
                  v60 = (int)v252;
                  if ( v221 == -1 )
                    goto LABEL_80;
                  goto LABEL_210;
                }
                if ( (_DWORD)v243 )
                {
                  v188 = (_BYTE *)v57[5];
                  if ( (unsigned __int64)v188 >= v57[6] )
                  {
                    LODWORD(v252) = v60;
                    v220 = 43;
                    v253 = (__m128 *)v142;
                    goto LABEL_442;
                  }
                  v57[5] = v188 + 1;
                  *v188 = 43;
LABEL_210:
                  if ( (_DWORD)v256 == 0x7FFFFFFF )
                    goto LABEL_80;
                  LODWORD(v256) = (_DWORD)v256 + 1;
                }
                else if ( v242 )
                {
                  v214 = (_BYTE *)v57[5];
                  if ( (unsigned __int64)v214 >= v57[6] )
                  {
                    LODWORD(v252) = v60;
                    v220 = 32;
                    v253 = (__m128 *)v142;
                    goto LABEL_442;
                  }
                  v57[5] = v214 + 1;
                  *v214 = 32;
                  goto LABEL_210;
                }
              }
              else if ( v140 == 32 )
              {
                goto LABEL_316;
              }
              if ( v250 && v245 == 16 && (v241 & 1) != 0 )
              {
                v150 = (_BYTE *)v57[5];
                if ( (unsigned __int64)v150 >= v57[6] )
                {
                  LODWORD(v252) = v60;
                  v253 = (__m128 *)v142;
                  v225 = sub_1A150(
                           (__int64)v57,
                           0x30u,
                           *(double *)a4.m128_u64,
                           *(double *)a5.m128_u64,
                           *(double *)a6.m128_u64,
                           a7,
                           v37,
                           v38,
                           a10,
                           a11);
                  v142 = (char *)v253;
                  v60 = (int)v252;
                  if ( v225 == -1 )
                    goto LABEL_80;
                }
                else
                {
                  v57[5] = v150 + 1;
                  *v150 = 48;
                }
                if ( (_DWORD)v256 == 0x7FFFFFFF )
                  goto LABEL_80;
                v151 = (unsigned __int8 *)v57[5];
                if ( (unsigned __int64)v151 >= v57[6] )
                {
                  LODWORD(v252) = v60;
                  v253 = (__m128 *)v142;
                  v226 = sub_1A150(
                           (__int64)v57,
                           v248,
                           *(double *)a4.m128_u64,
                           *(double *)a5.m128_u64,
                           *(double *)a6.m128_u64,
                           a7,
                           v37,
                           v38,
                           a10,
                           a11);
                  v142 = (char *)v253;
                  v60 = (int)v252;
                  if ( v226 == -1 )
                    goto LABEL_80;
                }
                else
                {
                  v152 = v248;
                  v57[5] = v151 + 1;
                  *v151 = v152;
                }
                if ( (_DWORD)v256 == 2147483646 )
                  goto LABEL_80;
                LODWORD(v256) = (_DWORD)v256 + 2;
              }
              v153 = v60 + v146;
              if ( v153 > 0 )
              {
                v253 = (__m128 *)v142;
                if ( v153 != sub_6A2A0(
                               (__int64)v57,
                               48,
                               v153,
                               *(double *)a4.m128_u64,
                               *(double *)a5.m128_u64,
                               *(double *)a6.m128_u64,
                               a7,
                               v37,
                               v38,
                               a10,
                               a11) )
                  goto LABEL_80;
                v187 = (int)v256;
                if ( (int)v256 < 0 )
                  goto LABEL_81;
                v142 = (char *)v253;
                LODWORD(v256) = (_DWORD)v256 + v153;
                if ( __OFADD__(v187, v153) )
                  goto LABEL_128;
              }
              if ( (int)v256 < 0 )
                goto LABEL_81;
              v154 = v57[27];
              v155 = (char *)&off_C0308 - (char *)&unk_BFAE0;
              if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v154 - (_QWORD)&unk_BFAE0) )
              {
                v252 = (char *)((char *)&off_C0308 - (char *)&unk_BFAE0);
                v253 = (__m128 *)v142;
                sub_17140(
                  *(double *)a4.m128_u64,
                  *(double *)a5.m128_u64,
                  *(double *)a6.m128_u64,
                  a7,
                  v37,
                  v38,
                  a10,
                  a11);
                v155 = (signed __int64)v252;
                v142 = (char *)v253;
              }
              v253 = (__m128 *)v155;
              if ( v120 != (char *)(*(__int64 (__fastcall **)(_QWORD *, char *, char *))(v154 + 56))(v57, v142, v120) )
                goto LABEL_80;
LABEL_227:
              v112 = &v120[(int)v256];
              LODWORD(v256) = (_DWORD)v120 + (_DWORD)v256;
              v156 = v112 + 0x8000000000000000LL < v120;
              if ( v112 != (char *)(int)v112 )
                v156 = 1;
              if ( v156 )
                goto LABEL_128;
              goto LABEL_230;
            }
LABEL_259:
            if ( (_DWORD)v251 )
            {
              v163 = (_BYTE *)v57[5];
              if ( (unsigned __int64)v163 < v57[6] )
              {
                v57[5] = v163 + 1;
                *v163 = 45;
LABEL_262:
                if ( (_DWORD)v256 == 0x7FFFFFFF )
                  goto LABEL_80;
                LODWORD(v253) = (_DWORD)v253 - 1;
                LODWORD(v256) = (_DWORD)v256 + 1;
                goto LABEL_264;
              }
              LODWORD(v251) = v60;
              v222 = 45;
              v252 = v142;
            }
            else if ( (_DWORD)v243 )
            {
              v181 = (_BYTE *)v57[5];
              if ( (unsigned __int64)v181 < v57[6] )
              {
                v57[5] = v181 + 1;
                *v181 = 43;
                goto LABEL_262;
              }
              LODWORD(v251) = v60;
              v222 = 43;
              v252 = v142;
            }
            else
            {
              if ( !v242 )
              {
LABEL_264:
                if ( v250 && v245 == 16 && (v241 & 1) != 0 )
                {
                  v164 = (_BYTE *)v57[5];
                  if ( (unsigned __int64)v164 >= v57[6] )
                  {
                    LODWORD(v251) = v60;
                    v252 = v142;
                    v228 = sub_1A150(
                             (__int64)v57,
                             0x30u,
                             *(double *)a4.m128_u64,
                             *(double *)a5.m128_u64,
                             *(double *)a6.m128_u64,
                             a7,
                             v37,
                             v38,
                             a10,
                             a11);
                    v142 = v252;
                    v60 = v251;
                    if ( v228 == -1 )
                      goto LABEL_80;
                  }
                  else
                  {
                    v57[5] = v164 + 1;
                    *v164 = 48;
                  }
                  if ( (_DWORD)v256 == 0x7FFFFFFF )
                    goto LABEL_80;
                  v165 = (unsigned __int8 *)v57[5];
                  if ( (unsigned __int64)v165 >= v57[6] )
                  {
                    LODWORD(v251) = v60;
                    v252 = v142;
                    v227 = sub_1A150(
                             (__int64)v57,
                             v248,
                             *(double *)a4.m128_u64,
                             *(double *)a5.m128_u64,
                             *(double *)a6.m128_u64,
                             a7,
                             v37,
                             v38,
                             a10,
                             a11);
                    v142 = v252;
                    v60 = v251;
                    if ( v227 == -1 )
                      goto LABEL_80;
                  }
                  else
                  {
                    v166 = v248;
                    v57[5] = v165 + 1;
                    *v165 = v166;
                  }
                  if ( (_DWORD)v256 == 2147483646 )
                    goto LABEL_80;
                  LODWORD(v253) = (_DWORD)v253 - 2;
                  LODWORD(v256) = (_DWORD)v256 + 2;
                }
                v167 = (_DWORD)v253 - ((_DWORD)v120 + v145);
                if ( v60 <= 0 )
                {
                  if ( (int)v256 < 0 )
                    goto LABEL_351;
                }
                else
                {
                  v168 = v60;
                  v253 = (__m128 *)v142;
                  if ( v60 != sub_6A2A0(
                                (__int64)v57,
                                48,
                                v60,
                                *(double *)a4.m128_u64,
                                *(double *)a5.m128_u64,
                                *(double *)a6.m128_u64,
                                a7,
                                v37,
                                v38,
                                a10,
                                a11) )
                    goto LABEL_80;
                  if ( (int)v256 < 0 )
                    goto LABEL_81;
                  v111 = __OFADD__((_DWORD)v256, v168);
                  v169 = (_DWORD)v256 + v168;
                  LODWORD(v256) = v169;
                  if ( v111 )
                    goto LABEL_128;
                  v142 = (char *)v253;
                  if ( v169 < 0 )
                    goto LABEL_81;
                }
                v182 = v57[27];
                v183 = (char *)&off_C0308 - (char *)&unk_BFAE0;
                if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v182 - (_QWORD)&unk_BFAE0) )
                {
                  v251 = (char *)&off_C0308 - (char *)&unk_BFAE0;
                  v252 = (char *)v182;
                  v253 = (__m128 *)v142;
                  sub_17140(
                    *(double *)a4.m128_u64,
                    *(double *)a5.m128_u64,
                    *(double *)a6.m128_u64,
                    a7,
                    v37,
                    v38,
                    a10,
                    a11);
                  v183 = v251;
                  v182 = (__int64)v252;
                  v142 = (char *)v253;
                }
                v253 = (__m128 *)v183;
                if ( (char *)(*(__int64 (__fastcall **)(_QWORD *, char *, char *))(v182 + 56))(v57, v142, v120) != v120 )
                  goto LABEL_80;
                v184 = 0;
                v107 = (unsigned __int64)v253;
                v185 = (__int64)&v120[(int)v256];
                if ( v185 < 0 || v185 < (unsigned __int64)v120 )
                  v184 = 1;
                LODWORD(v256) = (_DWORD)v120 + (_DWORD)v256;
                v186 = v185;
                if ( v185 != (int)v185 )
                  v184 = 1;
                if ( v184 )
                  goto LABEL_128;
                if ( (int)v185 < 0 )
                  goto LABEL_81;
                if ( v167 <= 0 )
                  goto LABEL_174;
                if ( v167 != sub_6A2A0(
                               (__int64)v57,
                               32,
                               v167,
                               *(double *)a4.m128_u64,
                               *(double *)a5.m128_u64,
                               *(double *)a6.m128_u64,
                               a7,
                               v37,
                               v38,
                               a10,
                               a11) )
                  goto LABEL_80;
                LODWORD(v256) = v186 + v167;
                LODWORD(v112) = v186 + v167;
                if ( __OFADD__(v186, v167) )
                  goto LABEL_128;
LABEL_230:
                v107 = (unsigned __int64)v253;
                if ( (int)v112 < 0 )
                  goto LABEL_81;
LABEL_174:
                v131 = *((_QWORD *)v56 + 3);
                v132 = *((_QWORD *)v56 + 4) - v131;
LABEL_175:
                v133 = v57[27];
                if ( v133 - (__int64)&unk_BFAE0 >= v107 )
                {
                  v253 = (__m128 *)v131;
                  sub_17140(
                    *(double *)a4.m128_u64,
                    *(double *)a5.m128_u64,
                    *(double *)a6.m128_u64,
                    a7,
                    v37,
                    v38,
                    a10,
                    a11);
                  v131 = (__int64)v253;
                }
                if ( (*(__int64 (__fastcall **)(_QWORD *, __int64, unsigned __int64))(v133 + 56))(v57, v131, v132) != v132 )
                  goto LABEL_80;
                v134 = 0;
                v135 = v132 + (int)v256;
                if ( v135 < 0 || v135 < v132 )
                  v134 = 1;
                LODWORD(v256) = v132 + (_DWORD)v256;
                v36 = 1LL;
                if ( v135 != (int)v135 )
                  v134 = 1;
                if ( v134 )
                  goto LABEL_128;
                if ( (int)v135 < 0 )
                  goto LABEL_81;
                ++v255;
                v56 += 18;
                if ( v240 <= v255 )
                  goto LABEL_81;
                continue;
              }
              v189 = (_BYTE *)v57[5];
              if ( (unsigned __int64)v189 < v57[6] )
              {
                v57[5] = v189 + 1;
                *v189 = 32;
                goto LABEL_262;
              }
              LODWORD(v251) = v60;
              v222 = 32;
              v252 = v142;
            }
            v223 = sub_1A150(
                     (__int64)v57,
                     v222,
                     *(double *)a4.m128_u64,
                     *(double *)a5.m128_u64,
                     *(double *)a6.m128_u64,
                     a7,
                     v37,
                     v38,
                     a10,
                     a11);
            v142 = v252;
            v60 = v251;
            if ( v223 == -1 )
              goto LABEL_80;
            goto LABEL_262;
          }
          v145 = v137 - (_QWORD)v120;
          if ( v145 < 0 )
            LODWORD(v145) = v250;
          v60 = v145;
LABEL_371:
          if ( !(_DWORD)v252 )
          {
            v250 = 0LL;
            v146 = (_DWORD)v253 - ((_DWORD)v120 + v145);
            goto LABEL_205;
          }
          v250 = 0LL;
          goto LABEL_259;
      }
    }
  }
LABEL_358:
  LODWORD(v256) = (_DWORD)v252;
LABEL_81:
  if ( (char *)v263[0] != v238 )
    sub_21B70(v263[0]);
  if ( v260 != v244 )
    sub_21B70(v260);
  return (unsigned int)v256;
}
// 5EFB8: variable 'v31' is possibly undefined
// 5EFB8: variable 'v32' is possibly undefined
// 5EFB8: variable 'v28' is possibly undefined
// 5EFB8: variable 'v29' is possibly undefined
// 5EFB8: variable 'v30' is possibly undefined
// 5F507: variable 'v37' is possibly undefined
// 5F507: variable 'v38' is possibly undefined
// 5F7DF: variable 'v36' is possibly undefined
// 60EE4: variable 'v100' is possibly undefined
// 60EE4: variable 'v101' is possibly undefined
// 5FA43: variable 'v66' is possibly undefined
// 5FA43: variable 'v62' is possibly undefined
// 5FA43: variable 'v98' is possibly undefined
// 60BDD: variable 'v204' is possibly undefined
// 60BDD: variable 'v205' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);
// 6: using guessed type char;
// 9040: using guessed type __int64 __fastcall sub_9040(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// 5EA90: using guessed type __int64 sub_5EA90(void);
// C0308: using guessed type void *off_C0308;
// C1788: using guessed type __int64 qword_C1788;
// C1B10: using guessed type __int64 qword_C1B10;
// C1B18: using guessed type __int64 qword_C1B18;

//----- (0000000000061370) ----------------------------------------------------
__int64 __fastcall sub_61370(__int64 a1, unsigned __int64 a2, __m128i *a3, unsigned int a4, __m128 a5, double a6, __m128i a7, __m128 a8, double a9, double a10, double a11, double a12)
{
  int v14; // eax
  int v15; // ebx
  __m128 v16; // xmm1
  __int64 v17; // rcx
  u32 *v18; // r8
  u32 v19; // er9
  double v20; // xmm4_8
  double v21; // xmm5_8
  unsigned __int64 v23; // rbx
  __int64 v25; // r12
  unsigned __int64 v26; // rbx
  _BYTE *v27; // rcx
  unsigned __int64 v28; // r8
  __int64 *v29; // r9
  double v30; // xmm4_8
  double v31; // xmm5_8
  int v32; // er12
  unsigned __int64 v33; // rax
  _BYTE *v34; // rax
  unsigned __int8 v35; // bl
  int v36; // eax
  __int64 v38; // rdi
  int v39; // eax
  int v40; // er14
  int v41; // er13
  int v42; // er11
  unsigned int v43; // eax
  unsigned int *v44; // rcx
  __int64 v45; // rax
  double v46; // xmm4_8
  double v47; // xmm5_8
  unsigned __int64 v48; // r13
  int v49; // ebx
  __int64 v50; // rcx
  double v51; // xmm4_8
  double v52; // xmm5_8
  int v53; // edx
  __int64 v54; // rax
  __int64 v55; // r13
  _BYTE *v56; // rax
  double v57; // xmm4_8
  double v58; // xmm5_8
  __int64 v59; // r14
  unsigned __int64 v60; // rbx
  int v61; // edx
  __int64 v62; // rax
  int v63; // ebx
  unsigned __int32 v64; // eax
  int *v65; // rdx
  int v66; // edx
  _BYTE *v67; // rax
  int v68; // eax
  unsigned __int32 v69; // eax
  const char **v70; // rdx
  const char *v71; // r13
  __int64 v72; // rax
  unsigned __int64 v73; // r14
  __int64 v74; // rcx
  int v75; // edx
  __int64 v76; // rax
  __int64 v77; // rax
  unsigned int v78; // eax
  unsigned __int8 *v79; // rax
  unsigned __int32 v80; // edx
  char v81; // di
  unsigned int v82; // eax
  _QWORD **v83; // rdx
  unsigned __int32 v84; // eax
  signed __int64 v85; // r10
  __int64 v86; // rax
  bool v87; // zf
  __int64 v88; // rax
  __int64 v89; // rax
  __int64 *v90; // rax
  char *v91; // rcx
  int v92; // er13
  char v93; // dl
  _BYTE *v94; // rax
  _BYTE *v95; // rax
  unsigned __int8 *v96; // rax
  unsigned int v97; // er13
  __int64 v98; // rbx
  int v99; // edx
  __int64 v100; // rax
  int v101; // edx
  u32 *v102; // r8
  unsigned int v103; // eax
  _QWORD *v104; // rdx
  unsigned __int8 v105; // dl
  __int64 v106; // r8
  unsigned int v107; // eax
  _QWORD *v108; // rdx
  unsigned int v109; // eax
  signed __int64 *v110; // rdx
  unsigned int v111; // eax
  signed __int64 *v112; // rdx
  unsigned __int8 *v113; // rdx
  _BYTE *v114; // rax
  _BYTE *v115; // rax
  _BYTE *v116; // rax
  unsigned __int8 *v117; // rax
  int v118; // er13
  unsigned int v119; // er14
  int v120; // edx
  int v121; // eax
  bool v122; // sf
  __int64 v123; // r13
  int v124; // edx
  __int64 v125; // rax
  bool v126; // of
  long double *v127; // rax
  int v128; // edx
  _BYTE *v129; // rax
  unsigned int v130; // er13
  unsigned int v131; // eax
  int v132; // eax
  _BYTE *v133; // rax
  unsigned int *v134; // rdx
  _BYTE *v135; // rax
  int v136; // eax
  long double *v137; // rax
  int *v138; // rdx
  int **v139; // rdx
  __int64 v140; // rbx
  unsigned __int16 *v141; // rdx
  _BYTE **v142; // rdx
  unsigned int v143; // edx
  const __m128i *v144; // rax
  char *v145; // rdx
  unsigned int v146; // edx
  const __m128i *v147; // rax
  __int64 v148; // rax
  double v149; // xmm4_8
  double v150; // xmm5_8
  int v151; // eax
  double v152; // xmm4_8
  double v153; // xmm5_8
  unsigned __int32 v154; // eax
  int *v155; // rdx
  int v156; // edx
  int v157; // eax
  int v158; // eax
  __int64 v159; // rax
  _BYTE *v160; // rdi
  _BYTE *v161; // rax
  _BYTE *v162; // rax
  signed __int64 v163; // rax
  _WORD **v164; // rdx
  __int16 *v165; // rdx
  unsigned int v166; // esi
  int v167; // eax
  unsigned int v168; // esi
  int v169; // eax
  int v170; // eax
  int v171; // eax
  int v172; // eax
  int v173; // eax
  int v174; // eax
  int v176; // [rsp+8h] [rbp-540h]
  __int64 v177; // [rsp+8h] [rbp-540h]
  char *v178; // [rsp+8h] [rbp-540h]
  char *v179; // [rsp+8h] [rbp-540h]
  unsigned __int64 v180; // [rsp+8h] [rbp-540h]
  char *v181; // [rsp+8h] [rbp-540h]
  int v182; // [rsp+8h] [rbp-540h]
  char *v183; // [rsp+8h] [rbp-540h]
  char *v184; // [rsp+8h] [rbp-540h]
  __int64 v185; // [rsp+8h] [rbp-540h]
  __int64 v186; // [rsp+8h] [rbp-540h]
  unsigned int v187; // [rsp+8h] [rbp-540h]
  unsigned __int64 v188; // [rsp+10h] [rbp-538h]
  unsigned int v189; // [rsp+18h] [rbp-530h]
  __int64 *v190; // [rsp+18h] [rbp-530h]
  int v191; // [rsp+18h] [rbp-530h]
  __int64 *v192; // [rsp+18h] [rbp-530h]
  unsigned int v193; // [rsp+18h] [rbp-530h]
  __int64 *v194; // [rsp+18h] [rbp-530h]
  __int64 *v195; // [rsp+18h] [rbp-530h]
  signed __int64 v196; // [rsp+18h] [rbp-530h]
  char *v197; // [rsp+18h] [rbp-530h]
  char *v198; // [rsp+18h] [rbp-530h]
  unsigned int v199; // [rsp+20h] [rbp-528h]
  signed __int64 v200; // [rsp+20h] [rbp-528h]
  signed __int64 v201; // [rsp+20h] [rbp-528h]
  char *v202; // [rsp+20h] [rbp-528h]
  unsigned int v203; // [rsp+20h] [rbp-528h]
  unsigned int v204; // [rsp+20h] [rbp-528h]
  char *v205; // [rsp+20h] [rbp-528h]
  char *v206; // [rsp+20h] [rbp-528h]
  unsigned int v207; // [rsp+28h] [rbp-520h]
  unsigned int v208; // [rsp+28h] [rbp-520h]
  unsigned int v209; // [rsp+28h] [rbp-520h]
  __int64 *v210; // [rsp+28h] [rbp-520h]
  __int64 *v211; // [rsp+28h] [rbp-520h]
  __int64 *v212; // [rsp+28h] [rbp-520h]
  __int64 *v213; // [rsp+28h] [rbp-520h]
  unsigned __int8 v214; // [rsp+30h] [rbp-518h]
  char *v215; // [rsp+30h] [rbp-518h]
  char *v216; // [rsp+30h] [rbp-518h]
  unsigned int v217; // [rsp+30h] [rbp-518h]
  int v218; // [rsp+38h] [rbp-510h]
  __int64 *v219; // [rsp+38h] [rbp-510h]
  __int64 *v220; // [rsp+38h] [rbp-510h]
  int v221; // [rsp+40h] [rbp-508h]
  int v222; // [rsp+44h] [rbp-504h]
  char v223; // [rsp+48h] [rbp-500h]
  int v224; // [rsp+4Ch] [rbp-4FCh]
  _BYTE *v225; // [rsp+50h] [rbp-4F8h]
  unsigned int v226; // [rsp+58h] [rbp-4F0h]
  signed __int64 v227; // [rsp+58h] [rbp-4F0h]
  __int64 *v228; // [rsp+58h] [rbp-4F0h]
  int v229; // [rsp+60h] [rbp-4E8h]
  unsigned int v230; // [rsp+64h] [rbp-4E4h]
  __int64 v231; // [rsp+68h] [rbp-4E0h]
  signed __int64 v232; // [rsp+70h] [rbp-4D8h]
  __int64 v233; // [rsp+78h] [rbp-4D0h]
  unsigned int v234; // [rsp+80h] [rbp-4C8h]
  int v235; // [rsp+84h] [rbp-4C4h]
  _BYTE *v236; // [rsp+90h] [rbp-4B8h] BYREF
  const __m128i *v237; // [rsp+98h] [rbp-4B0h] BYREF
  long double v238; // [rsp+A0h] [rbp-4A8h] BYREF
  _BYTE *v239; // [rsp+B0h] [rbp-498h] BYREF
  int v240; // [rsp+B8h] [rbp-490h]
  int v241; // [rsp+BCh] [rbp-48Ch]
  int v242; // [rsp+C0h] [rbp-488h]
  __int64 v243[4]; // [rsp+D0h] [rbp-478h] BYREF
  __int64 v244; // [rsp+F0h] [rbp-458h] BYREF
  __m128 v245; // [rsp+F8h] [rbp-450h] BYREF
  __int64 v246; // [rsp+108h] [rbp-440h]
  char v247[16]; // [rsp+110h] [rbp-438h] BYREF
  char v248[999]; // [rsp+120h] [rbp-428h] BYREF
  char v249; // [rsp+507h] [rbp-41h] BYREF
  __int64 v250[8]; // [rsp+508h] [rbp-40h] BYREF

  v223 = a4;
  v250[0] = __readfsqword(0x28u);
  v230 = __readfsdword(0xFFFFFFC0);
  v14 = *(_DWORD *)(a1 + 192);
  if ( v14 )
  {
    if ( v14 != -1 )
      return (unsigned int)-1;
  }
  else
  {
    *(_DWORD *)(a1 + 192) = -1;
  }
  v15 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 8) != 0 )
  {
    v32 = -1;
    *(_DWORD *)a1 = v15 | 0x20;
    __writefsdword(0xFFFFFFC0, 9u);
    return (unsigned int)v32;
  }
  if ( !a2 )
  {
    v32 = -1;
    __writefsdword(0xFFFFFFC0, 0x16u);
    return (unsigned int)v32;
  }
  v221 = *(_DWORD *)a1 & 2;
  if ( (v15 & 2) == 0 )
  {
    v16 = (__m128)_mm_loadu_si128(a3);
    v246 = a3[1].m128i_i64[0];
    v245 = v16;
    v225 = (_BYTE *)sub_9100(a2, 37LL);
    v236 = v225;
    if ( (v15 & 0x8000) == 0 )
    {
      v243[1] = a1;
      v243[0] = (__int64)sub_7F4E0;
      _RDI = *(_QWORD *)(a1 + 136);
      v23 = __readfsqword(0x10u);
      if ( *(_QWORD *)(_RDI + 8) != v23 )
      {
        if ( __readfsdword(0x18u) )
        {
          if ( _InterlockedCompareExchange((volatile signed __int32 *)_RDI, 1, 0) )
            sub_1C7D0((volatile __int32 *)_RDI, 37LL, 1LL, v17, v18, v19);
        }
        else
        {
          _EDX = 1;
          __asm { cmpxchg [rdi], edx }
        }
        _RDI = *(_QWORD *)(a1 + 136);
        *(_QWORD *)(_RDI + 8) = v23;
      }
      ++*(_DWORD *)(_RDI + 4);
    }
    v25 = *(_QWORD *)(a1 + 216);
    v26 = (unsigned __int64)&v225[-a2];
    v188 = (char *)&off_C0308 - (char *)&unk_BFAE0;
    if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v25 - (_QWORD)&unk_BFAE0) )
      sub_17140(
        *(double *)a5.m128_u64,
        *(double *)v16.m128_u64,
        *(double *)a7.m128i_i64,
        *(double *)a8.m128_u64,
        v20,
        v21,
        a11,
        a12);
    if ( v26 != (*(__int64 (__fastcall **)(__int64, unsigned __int64, unsigned __int64))(v25 + 56))(a1, a2, v26) )
    {
LABEL_279:
      v32 = -1;
      if ( (*(_DWORD *)a1 & 0x8000) != 0 )
        goto LABEL_29;
      goto LABEL_33;
    }
    v32 = (_DWORD)v225 - a2;
    v33 = v26 >> 63;
    if ( v26 != (int)v26 )
      LODWORD(v33) = 1;
    if ( (_DWORD)v33 )
    {
LABEL_80:
      v32 = -1;
      __writefsdword(0xFFFFFFC0, 0x4Bu);
    }
    else if ( (v26 & 0x80000000) == 0LL )
    {
      v34 = v236;
      if ( *v236 )
      {
        v233 = qword_C1788;
        if ( qword_C1788 )
        {
          v36 = sub_5EE80(
                  a1,
                  a2,
                  0,
                  a5,
                  v16,
                  (__m128)a7,
                  *(double *)a8.m128_u64,
                  v30,
                  v31,
                  a11,
                  a12,
                  (__int64)a3,
                  (__int64)&v245,
                  v26,
                  0,
                  v225,
                  v248,
                  v230,
                  (char *)0xFFFFFFFFFFFFFFFFLL,
                  0LL,
                  v223);
          goto LABEL_27;
        }
        if ( qword_C1798 || (v235 = 0, qword_C1B18) )
        {
          v36 = sub_5EE80(
                  a1,
                  a2,
                  0,
                  a5,
                  v16,
                  (__m128)a7,
                  *(double *)a8.m128_u64,
                  v30,
                  v31,
                  a11,
                  a12,
                  (__int64)a3,
                  (__int64)&v245,
                  v26,
                  0,
                  v225,
                  v248,
                  v230,
                  (char *)0xFFFFFFFFFFFFFFFFLL,
                  qword_C1788,
                  v223);
          goto LABEL_27;
        }
        v229 = 0;
        v231 = -1LL;
        while ( 2 )
        {
          v236 = v34 + 1;
          v35 = v34[1];
          if ( (unsigned __int8)(v35 - 32) <= 0x5Au )
          {
            v29 = 0LL;
            v40 = 0;
            v41 = 0;
            v42 = 0;
            v226 = 0;
            v28 = 0LL;
            v189 = 0;
            v218 = 0;
            v199 = 0;
            v222 = 0;
            v224 = 0;
            v214 = 32;
            v176 = -1;
            switch ( v35 )
            {
              case ' ':
LABEL_83:
                while ( 2 )
                {
                  v35 = *++v236;
                  if ( (unsigned __int8)(*v236 - 32) <= 0x5Au )
                  {
                    v222 = 1;
                    switch ( v35 )
                    {
                      case ' ':
                        continue;
                      case '!':
                      case '"':
                      case '$':
                      case '&':
                      case '(':
                      case ')':
                      case ',':
                      case '/':
                      case ':':
                      case ';':
                      case '<':
                      case '=':
                      case '>':
                      case '?':
                      case '@':
                      case 'B':
                      case 'D':
                      case 'H':
                      case 'J':
                      case 'K':
                      case 'M':
                      case 'N':
                      case 'O':
                      case 'P':
                      case 'Q':
                      case 'R':
                      case 'T':
                      case 'U':
                      case 'V':
                      case 'W':
                      case 'Y':
                      case '[':
                      case '\\':
                      case ']':
                      case '^':
                      case '_':
                      case '`':
                      case 'b':
                      case 'k':
                      case 'r':
                      case 'v':
                      case 'w':
                      case 'y':
                      case '{':
                      case '|':
                      case '}':
                      case '~':
                      case '\x7F':
                        goto LABEL_25;
                      case '#':
                        goto LABEL_132;
                      case '%':
                        goto LABEL_225;
                      case '\'':
                        goto LABEL_125;
                      case '*':
                        goto LABEL_116;
                      case '+':
                        goto LABEL_81;
                      case '-':
                        goto LABEL_134;
                      case '.':
                        goto LABEL_108;
                      case '0':
                        goto LABEL_128;
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                      case '8':
                      case '9':
                        goto LABEL_112;
                      case 'A':
                      case 'a':
                        goto LABEL_193;
                      case 'C':
                        goto LABEL_41;
                      case 'E':
                      case 'F':
                      case 'G':
                      case 'e':
                      case 'f':
                      case 'g':
                        goto LABEL_199;
                      case 'I':
                        goto LABEL_123;
                      case 'L':
                      case 'q':
                        goto LABEL_215;
                      case 'S':
                      case 's':
                        goto LABEL_85;
                      case 'X':
                      case 'x':
                        goto LABEL_219;
                      case 'Z':
                      case 'j':
                      case 't':
                      case 'z':
                        goto LABEL_38;
                      case 'c':
                        goto LABEL_67;
                      case 'd':
                      case 'i':
                        goto LABEL_205;
                      case 'h':
                        goto LABEL_231;
                      case 'l':
                        goto LABEL_217;
                      case 'm':
                        goto LABEL_136;
                      case 'n':
                        goto LABEL_137;
                      case 'o':
                        goto LABEL_209;
                      case 'p':
                        goto LABEL_143;
                      case 'u':
                        goto LABEL_224;
                    }
                  }
                  goto LABEL_25;
                }
              case '!':
              case '"':
              case '$':
              case '&':
              case '(':
              case ')':
              case ',':
              case '/':
              case ':':
              case ';':
              case '<':
              case '=':
              case '>':
              case '?':
              case '@':
              case 'B':
              case 'D':
              case 'H':
              case 'J':
              case 'K':
              case 'M':
              case 'N':
              case 'O':
              case 'P':
              case 'Q':
              case 'R':
              case 'T':
              case 'U':
              case 'V':
              case 'W':
              case 'Y':
              case '[':
              case '\\':
              case ']':
              case '^':
              case '_':
              case '`':
              case 'b':
              case 'k':
              case 'r':
              case 'v':
              case 'w':
              case 'y':
              case '{':
              case '|':
              case '}':
              case '~':
              case '\x7F':
                break;
              case '#':
LABEL_132:
                v224 = 1;
                v35 = *++v236;
                if ( (unsigned __int8)(*v236 - 32) <= 0x5Au )
                  goto LABEL_124;
                break;
              case '%':
LABEL_225:
                v114 = *(_BYTE **)(a1 + 40);
                if ( (unsigned __int64)v114 >= *(_QWORD *)(a1 + 48) )
                {
                  if ( (unsigned int)sub_1A150(
                                       a1,
                                       0x25u,
                                       *(double *)a5.m128_u64,
                                       *(double *)v16.m128_u64,
                                       *(double *)a7.m128i_i64,
                                       *(double *)a8.m128_u64,
                                       v30,
                                       v31,
                                       a11,
                                       a12) == -1 )
                    goto LABEL_279;
                }
                else
                {
                  *(_QWORD *)(a1 + 40) = v114 + 1;
                  *v114 = 37;
                }
                if ( v32 == 0x7FFFFFFF )
                  goto LABEL_279;
                ++v32;
                goto LABEL_56;
              case '\'':
LABEL_125:
                if ( v231 == -1 )
                {
                  v159 = *(_QWORD *)__readfsqword(0xFFFFFFB0);
                  v160 = *(_BYTE **)(v159 + 80);
                  v27 = *(_BYTE **)(v159 + 72);
                  v233 = (__int64)v27;
                  if ( !*v160 || *v160 == 127 )
                  {
                    v231 = 0LL;
                  }
                  else
                  {
                    v161 = 0LL;
                    if ( *v27 )
                      v161 = v160;
                    v231 = (__int64)v161;
                  }
                }
                v28 = 1LL;
                v35 = *++v236;
                if ( (unsigned __int8)(*v236 - 32) <= 0x5Au )
                  goto LABEL_124;
                break;
              case '*':
LABEL_116:
                v79 = v236 + 1;
                v236 = v79;
                v239 = v79;
                if ( (unsigned int)*v79 - 48 > 9 )
                  goto LABEL_117;
                v193 = v28;
                v158 = ((__int64 (__fastcall *)(_BYTE **, void **))loc_5E4E0)(&v239, jpt_625C0);
                v28 = v193;
                v29 = 0LL;
                if ( v158 == -1 )
                  goto LABEL_80;
                if ( v158 && *v239 == 36 )
                  goto LABEL_26;
                v79 = v236;
LABEL_117:
                v80 = a3->m128i_i32[0];
                if ( a3->m128i_i32[0] > 0x2Fu )
                {
                  v27 = (_BYTE *)a3->m128i_i64[1];
                  a3->m128i_i64[1] = (__int64)(v27 + 8);
                }
                else
                {
                  v27 = (_BYTE *)(a3[1].m128i_i64[0] + v80);
                  a3->m128i_i32[0] = v80 + 8;
                }
                v189 = *(_DWORD *)v27;
                if ( *(int *)v27 < 0 )
                {
                  v214 = 32;
                  v189 = -*(_DWORD *)v27;
                  v199 = 1;
                }
                v35 = *v79;
                if ( (unsigned __int8)(*v79 - 32) <= 0x5Au )
                {
LABEL_115:
                  switch ( v35 )
                  {
                    case ' ':
                    case '!':
                    case '"':
                    case '#':
                    case '$':
                    case '&':
                    case '\'':
                    case '(':
                    case ')':
                    case '*':
                    case '+':
                    case ',':
                    case '-':
                    case '/':
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case ':':
                    case ';':
                    case '<':
                    case '=':
                    case '>':
                    case '?':
                    case '@':
                    case 'B':
                    case 'D':
                    case 'H':
                    case 'I':
                    case 'J':
                    case 'K':
                    case 'M':
                    case 'N':
                    case 'O':
                    case 'P':
                    case 'Q':
                    case 'R':
                    case 'T':
                    case 'U':
                    case 'V':
                    case 'W':
                    case 'Y':
                    case '[':
                    case '\\':
                    case ']':
                    case '^':
                    case '_':
                    case '`':
                    case 'b':
                    case 'k':
                    case 'r':
                    case 'v':
                    case 'w':
                    case 'y':
                    case '{':
                    case '|':
                    case '}':
                    case '~':
                    case '\x7F':
                      goto LABEL_25;
                    case '%':
                      goto LABEL_225;
                    case '.':
                      goto LABEL_108;
                    case 'A':
                    case 'a':
                      goto LABEL_193;
                    case 'C':
                      goto LABEL_41;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_199;
                    case 'L':
                    case 'q':
                      goto LABEL_215;
                    case 'S':
                    case 's':
                      goto LABEL_85;
                    case 'X':
                    case 'x':
                      goto LABEL_219;
                    case 'Z':
                    case 'j':
                    case 't':
                    case 'z':
                      goto LABEL_38;
                    case 'c':
                      goto LABEL_67;
                    case 'd':
                    case 'i':
                      goto LABEL_205;
                    case 'h':
                      goto LABEL_231;
                    case 'l':
                      goto LABEL_217;
                    case 'm':
                      goto LABEL_136;
                    case 'n':
                      goto LABEL_137;
                    case 'o':
                      goto LABEL_209;
                    case 'p':
                      goto LABEL_143;
                    case 'u':
                      goto LABEL_224;
                  }
                }
                break;
              case '+':
LABEL_81:
                while ( 2 )
                {
                  v218 = 1;
                  v35 = *++v236;
                  if ( (unsigned __int8)(*v236 - 32) <= 0x5Au )
                  {
                    switch ( v35 )
                    {
                      case ' ':
                        goto LABEL_83;
                      case '!':
                      case '"':
                      case '$':
                      case '&':
                      case '(':
                      case ')':
                      case ',':
                      case '/':
                      case ':':
                      case ';':
                      case '<':
                      case '=':
                      case '>':
                      case '?':
                      case '@':
                      case 'B':
                      case 'D':
                      case 'H':
                      case 'J':
                      case 'K':
                      case 'M':
                      case 'N':
                      case 'O':
                      case 'P':
                      case 'Q':
                      case 'R':
                      case 'T':
                      case 'U':
                      case 'V':
                      case 'W':
                      case 'Y':
                      case '[':
                      case '\\':
                      case ']':
                      case '^':
                      case '_':
                      case '`':
                      case 'b':
                      case 'k':
                      case 'r':
                      case 'v':
                      case 'w':
                      case 'y':
                      case '{':
                      case '|':
                      case '}':
                      case '~':
                      case '\x7F':
                        goto LABEL_25;
                      case '#':
                        goto LABEL_132;
                      case '%':
                        goto LABEL_225;
                      case '\'':
                        goto LABEL_125;
                      case '*':
                        goto LABEL_116;
                      case '+':
                        continue;
                      case '-':
                        goto LABEL_134;
                      case '.':
                        goto LABEL_108;
                      case '0':
                        goto LABEL_128;
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                      case '8':
                      case '9':
                        goto LABEL_112;
                      case 'A':
                      case 'a':
                        goto LABEL_193;
                      case 'C':
                        goto LABEL_41;
                      case 'E':
                      case 'F':
                      case 'G':
                      case 'e':
                      case 'f':
                      case 'g':
                        goto LABEL_199;
                      case 'I':
                        goto LABEL_123;
                      case 'L':
                      case 'q':
                        goto LABEL_215;
                      case 'S':
                      case 's':
                        goto LABEL_85;
                      case 'X':
                      case 'x':
                        goto LABEL_219;
                      case 'Z':
                      case 'j':
                      case 't':
                      case 'z':
                        goto LABEL_38;
                      case 'c':
                        goto LABEL_67;
                      case 'd':
                      case 'i':
                        goto LABEL_205;
                      case 'h':
                        goto LABEL_231;
                      case 'l':
                        goto LABEL_217;
                      case 'm':
                        goto LABEL_136;
                      case 'n':
                        goto LABEL_137;
                      case 'o':
                        goto LABEL_209;
                      case 'p':
                        goto LABEL_143;
                      case 'u':
                        goto LABEL_224;
                    }
                  }
                  goto LABEL_25;
                }
              case '-':
LABEL_134:
                while ( 2 )
                {
                  v35 = *++v236;
                  if ( (unsigned __int8)(*v236 - 32) <= 0x5Au )
                  {
                    v214 = 32;
                    v199 = 1;
                    switch ( v35 )
                    {
                      case ' ':
                        goto LABEL_83;
                      case '!':
                      case '"':
                      case '$':
                      case '&':
                      case '(':
                      case ')':
                      case ',':
                      case '/':
                      case ':':
                      case ';':
                      case '<':
                      case '=':
                      case '>':
                      case '?':
                      case '@':
                      case 'B':
                      case 'D':
                      case 'H':
                      case 'J':
                      case 'K':
                      case 'M':
                      case 'N':
                      case 'O':
                      case 'P':
                      case 'Q':
                      case 'R':
                      case 'T':
                      case 'U':
                      case 'V':
                      case 'W':
                      case 'Y':
                      case '[':
                      case '\\':
                      case ']':
                      case '^':
                      case '_':
                      case '`':
                      case 'b':
                      case 'k':
                      case 'r':
                      case 'v':
                      case 'w':
                      case 'y':
                      case '{':
                      case '|':
                      case '}':
                      case '~':
                      case '\x7F':
                        goto LABEL_25;
                      case '#':
                        goto LABEL_132;
                      case '%':
                        goto LABEL_225;
                      case '\'':
                        goto LABEL_125;
                      case '*':
                        goto LABEL_116;
                      case '+':
                        goto LABEL_81;
                      case '-':
                        continue;
                      case '.':
                        goto LABEL_108;
                      case '0':
                        goto LABEL_128;
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                      case '8':
                      case '9':
                        goto LABEL_112;
                      case 'A':
                      case 'a':
                        goto LABEL_193;
                      case 'C':
                        goto LABEL_41;
                      case 'E':
                      case 'F':
                      case 'G':
                      case 'e':
                      case 'f':
                      case 'g':
                        goto LABEL_199;
                      case 'I':
                        goto LABEL_123;
                      case 'L':
                      case 'q':
                        goto LABEL_215;
                      case 'S':
                      case 's':
                        goto LABEL_85;
                      case 'X':
                      case 'x':
                        goto LABEL_219;
                      case 'Z':
                      case 'j':
                      case 't':
                      case 'z':
                        goto LABEL_38;
                      case 'c':
                        goto LABEL_67;
                      case 'd':
                      case 'i':
                        goto LABEL_205;
                      case 'h':
                        goto LABEL_231;
                      case 'l':
                        goto LABEL_217;
                      case 'm':
                        goto LABEL_136;
                      case 'n':
                        goto LABEL_137;
                      case 'o':
                        goto LABEL_209;
                      case 'p':
                        goto LABEL_143;
                      case 'u':
                        goto LABEL_224;
                    }
                  }
                  goto LABEL_25;
                }
              case '.':
LABEL_108:
                v77 = (__int64)v236++;
                v35 = *v236;
                if ( *v236 == 42 )
                {
                  v236 = (_BYTE *)(v77 + 2);
                  v239 = (_BYTE *)(v77 + 2);
                  if ( (unsigned int)*(unsigned __int8 *)(v77 + 2) - 48 <= 9 )
                  {
                    v187 = v28;
                    v170 = ((__int64 (__fastcall *)(_BYTE **, void **))loc_5E4E0)(&v239, jpt_625C0);
                    v28 = v187;
                    v29 = 0LL;
                    if ( v170 == -1 )
                      goto LABEL_80;
                    if ( v170 && *v239 == 36 )
                      goto LABEL_26;
                  }
                  v154 = a3->m128i_i32[0];
                  if ( a3->m128i_i32[0] > 0x2Fu )
                  {
                    v155 = (int *)a3->m128i_i64[1];
                    a3->m128i_i64[1] = (__int64)(v155 + 2);
                  }
                  else
                  {
                    v155 = (int *)(a3[1].m128i_i64[0] + v154);
                    a3->m128i_i32[0] = v154 + 8;
                  }
                  v156 = *v155;
                  v157 = -1;
                  if ( v156 >= 0 )
                    v157 = v156;
                  v176 = v157;
                  v35 = *v236;
                }
                else
                {
                  v176 = 0;
                  if ( (unsigned int)v35 - 48 <= 9 )
                  {
                    v209 = v28;
                    v176 = ((__int64 (__fastcall *)(_BYTE **, void **))loc_5E4E0)(&v236, jpt_625C0);
                    if ( v176 == -1 )
                      goto LABEL_80;
                    v29 = 0LL;
                    v28 = v209;
                    v35 = *v236;
                  }
                }
                if ( (unsigned __int8)(v35 - 32) <= 0x5Au )
                {
                  v27 = &unk_A3A40;
                  switch ( v35 )
                  {
                    case ' ':
                    case '!':
                    case '"':
                    case '#':
                    case '$':
                    case '&':
                    case '\'':
                    case '(':
                    case ')':
                    case '*':
                    case '+':
                    case ',':
                    case '-':
                    case '.':
                    case '/':
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case ':':
                    case ';':
                    case '<':
                    case '=':
                    case '>':
                    case '?':
                    case '@':
                    case 'B':
                    case 'D':
                    case 'H':
                    case 'I':
                    case 'J':
                    case 'K':
                    case 'M':
                    case 'N':
                    case 'O':
                    case 'P':
                    case 'Q':
                    case 'R':
                    case 'T':
                    case 'U':
                    case 'V':
                    case 'W':
                    case 'Y':
                    case '[':
                    case '\\':
                    case ']':
                    case '^':
                    case '_':
                    case '`':
                    case 'b':
                    case 'k':
                    case 'r':
                    case 'v':
                    case 'w':
                    case 'y':
                    case '{':
                    case '|':
                    case '}':
                    case '~':
                    case '\x7F':
                      goto LABEL_25;
                    case '%':
                      goto LABEL_225;
                    case 'A':
                    case 'a':
                      goto LABEL_193;
                    case 'C':
                      goto LABEL_41;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_199;
                    case 'L':
                    case 'q':
                      goto LABEL_215;
                    case 'S':
                    case 's':
                      goto LABEL_85;
                    case 'X':
                    case 'x':
                      goto LABEL_219;
                    case 'Z':
                    case 'j':
                    case 't':
                    case 'z':
                      goto LABEL_38;
                    case 'c':
                      goto LABEL_67;
                    case 'd':
                    case 'i':
                      goto LABEL_205;
                    case 'h':
                      goto LABEL_231;
                    case 'l':
                      goto LABEL_217;
                    case 'm':
                      goto LABEL_136;
                    case 'n':
                      goto LABEL_137;
                    case 'o':
                      goto LABEL_209;
                    case 'p':
                      goto LABEL_143;
                    case 'u':
                      goto LABEL_224;
                  }
                }
                break;
              case '0':
LABEL_128:
                v81 = v214;
                if ( !v199 )
                  v81 = 48;
                v214 = v81;
                v35 = *++v236;
                if ( (unsigned __int8)(*v236 - 32) <= 0x5Au )
                  goto LABEL_124;
                break;
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
LABEL_112:
                v207 = v28;
                v78 = ((__int64 (__fastcall *)(_BYTE **, void **))loc_5E4E0)(&v236, jpt_625C0);
                v28 = v207;
                v29 = 0LL;
                v189 = v78;
                if ( v78 == -1 )
                  goto LABEL_80;
                v35 = *v236;
                if ( *v236 == 36 )
                  goto LABEL_26;
                if ( (unsigned __int8)(v35 - 32) <= 0x5Au )
                  goto LABEL_115;
                break;
              case 'A':
              case 'a':
LABEL_193:
                if ( (v223 & 1) != 0 )
                {
                  v42 = 0;
                  v101 = 0;
                }
                else
                {
                  v101 = v42 & 1;
                }
                v239 = (_BYTE *)__PAIR64__(v189, v176);
                v240 = (char)v35;
                v102 = (u32 *)(((unsigned __int8)v218 << 6) | (32 * (unsigned __int8)v199) | (16 * (unsigned __int8)v222) | (8 * (unsigned __int8)v224) | (4 * v40) | (unsigned int)v101 | ((_DWORD)v28 << 7));
                v241 = (unsigned __int8)v102;
                v242 = v214;
                if ( v42 )
                {
                  if ( (v223 & 8) != 0 )
                  {
                    v146 = a3->m128i_u32[1];
                    BYTE1(v241) |= 0x10u;
                    if ( v146 > 0xAF )
                    {
                      v147 = (const __m128i *)((a3->m128i_i64[1] + 15) & 0xFFFFFFFFFFFFFFF0LL);
                      a3->m128i_i64[1] = (__int64)v147[1].m128i_i64;
                    }
                    else
                    {
                      v147 = (const __m128i *)(a3[1].m128i_i64[0] + v146);
                      a3->m128i_i32[1] = v146 + 16;
                    }
                    a8 = (__m128)_mm_load_si128(v147);
                    v238 = *(long double *)&a8;
                  }
                  else
                  {
                    v137 = (long double *)((a3->m128i_i64[1] + 15) & 0xFFFFFFFFFFFFFFF0LL);
                    a3->m128i_i64[1] = (__int64)(v137 + 1);
                    v238 = *v137;
                  }
                }
                else
                {
                  v103 = a3->m128i_u32[1];
                  if ( v103 > 0xAF )
                  {
                    v104 = (_QWORD *)a3->m128i_i64[1];
                    a3->m128i_i64[1] = (__int64)(v104 + 1);
                  }
                  else
                  {
                    v104 = (_QWORD *)(a3[1].m128i_i64[0] + v103);
                    a3->m128i_i32[1] = v103 + 16;
                  }
                  a5 = (__m128)(unsigned __int64)*v104;
                  *(_QWORD *)&v238 = *v104;
                }
                v237 = (const __m128i *)&v238;
                v128 = sub_7D370(
                         (_QWORD *)a1,
                         (unsigned __int64)&v239,
                         &v237,
                         a5,
                         v16,
                         (__m128)a7,
                         *(double *)a8.m128_u64,
                         v30,
                         v31,
                         a11,
                         a12,
                         (__int64)v27,
                         v102);
                if ( v128 >= 0 )
                  goto LABEL_330;
                goto LABEL_279;
              case 'C':
                goto LABEL_41;
              case 'E':
              case 'F':
              case 'G':
              case 'e':
              case 'f':
              case 'g':
LABEL_199:
                if ( (v223 & 1) != 0 )
                {
                  v42 = 0;
                  v105 = 0;
                }
                else
                {
                  v105 = v42 & 1;
                }
                v239 = (_BYTE *)__PAIR64__(v189, v176);
                v240 = (char)v35;
                v106 = ((unsigned __int16)v226 << 11) | ((unsigned __int16)v218 << 6) | (32 * (unsigned __int16)v199) | (16 * (unsigned __int16)v222) | (8 * (unsigned __int16)v224) | (4 * v40) | (unsigned int)v105 | ((_DWORD)v28 << 7);
                v241 = (unsigned __int16)v106;
                v242 = v214;
                if ( v42 )
                {
                  if ( (v223 & 8) != 0 )
                  {
                    v143 = a3->m128i_u32[1];
                    BYTE1(v241) |= 0x10u;
                    if ( v143 > 0xAF )
                    {
                      v144 = (const __m128i *)((a3->m128i_i64[1] + 15) & 0xFFFFFFFFFFFFFFF0LL);
                      a3->m128i_i64[1] = (__int64)v144[1].m128i_i64;
                    }
                    else
                    {
                      v144 = (const __m128i *)(a3[1].m128i_i64[0] + v143);
                      a3->m128i_i32[1] = v143 + 16;
                    }
                    a7 = _mm_load_si128(v144);
                    v238 = *(long double *)&a7;
                  }
                  else
                  {
                    v127 = (long double *)((a3->m128i_i64[1] + 15) & 0xFFFFFFFFFFFFFFF0LL);
                    a3->m128i_i64[1] = (__int64)(v127 + 1);
                    v238 = *v127;
                  }
                }
                else
                {
                  v107 = a3->m128i_u32[1];
                  if ( v107 > 0xAF )
                  {
                    v108 = (_QWORD *)a3->m128i_i64[1];
                    a3->m128i_i64[1] = (__int64)(v108 + 1);
                  }
                  else
                  {
                    v108 = (_QWORD *)(a3[1].m128i_i64[0] + v107);
                    a3->m128i_i32[1] = v107 + 16;
                  }
                  a5 = (__m128)(unsigned __int64)*v108;
                  *(_QWORD *)&v238 = *v108;
                }
                v237 = (const __m128i *)&v238;
                v128 = sub_7D1B0(
                         (_QWORD *)a1,
                         (__int64)&v239,
                         &v237,
                         (__m128i)a5,
                         v16,
                         a7,
                         *(double *)a8.m128_u64,
                         v30,
                         v31,
                         a11,
                         a12,
                         (__int64)v27,
                         v106,
                         (__int64)v29);
                if ( v128 < 0 )
                  goto LABEL_279;
LABEL_330:
                v68 = 0;
                v32 += v128;
                if ( v32 < 0 || v32 < (unsigned int)v128 )
                  goto LABEL_332;
                goto LABEL_79;
              case 'I':
LABEL_123:
                while ( 2 )
                {
                  v226 = 1;
                  v35 = *++v236;
                  if ( (unsigned __int8)(*v236 - 32) <= 0x5Au )
                  {
LABEL_124:
                    switch ( v35 )
                    {
                      case ' ':
                        goto LABEL_83;
                      case '!':
                      case '"':
                      case '$':
                      case '&':
                      case '(':
                      case ')':
                      case ',':
                      case '/':
                      case ':':
                      case ';':
                      case '<':
                      case '=':
                      case '>':
                      case '?':
                      case '@':
                      case 'B':
                      case 'D':
                      case 'H':
                      case 'J':
                      case 'K':
                      case 'M':
                      case 'N':
                      case 'O':
                      case 'P':
                      case 'Q':
                      case 'R':
                      case 'T':
                      case 'U':
                      case 'V':
                      case 'W':
                      case 'Y':
                      case '[':
                      case '\\':
                      case ']':
                      case '^':
                      case '_':
                      case '`':
                      case 'b':
                      case 'k':
                      case 'r':
                      case 'v':
                      case 'w':
                      case 'y':
                      case '{':
                      case '|':
                      case '}':
                      case '~':
                      case '\x7F':
                        goto LABEL_25;
                      case '#':
                        goto LABEL_132;
                      case '%':
                        goto LABEL_225;
                      case '\'':
                        goto LABEL_125;
                      case '*':
                        goto LABEL_116;
                      case '+':
                        goto LABEL_81;
                      case '-':
                        goto LABEL_134;
                      case '.':
                        goto LABEL_108;
                      case '0':
                        goto LABEL_128;
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                      case '8':
                      case '9':
                        goto LABEL_112;
                      case 'A':
                      case 'a':
                        goto LABEL_193;
                      case 'C':
                        goto LABEL_41;
                      case 'E':
                      case 'F':
                      case 'G':
                      case 'e':
                      case 'f':
                      case 'g':
                        goto LABEL_199;
                      case 'I':
                        continue;
                      case 'L':
                      case 'q':
                        goto LABEL_215;
                      case 'S':
                      case 's':
                        goto LABEL_85;
                      case 'X':
                      case 'x':
                        goto LABEL_219;
                      case 'Z':
                      case 'j':
                      case 't':
                      case 'z':
                        goto LABEL_38;
                      case 'c':
                        goto LABEL_67;
                      case 'd':
                      case 'i':
                        goto LABEL_205;
                      case 'h':
                        goto LABEL_231;
                      case 'l':
                        goto LABEL_217;
                      case 'm':
                        goto LABEL_136;
                      case 'n':
                        goto LABEL_137;
                      case 'o':
                        goto LABEL_209;
                      case 'p':
                        goto LABEL_143;
                      case 'u':
                        goto LABEL_224;
                    }
                  }
                  goto LABEL_25;
                }
              case 'L':
              case 'q':
LABEL_215:
                v35 = *++v236;
                if ( (unsigned __int8)(*v236 - 32) <= 0x5Au )
                {
                  v40 = 1;
                  v42 = 1;
                  switch ( v35 )
                  {
                    case ' ':
                    case '!':
                    case '"':
                    case '#':
                    case '$':
                    case '&':
                    case '\'':
                    case '(':
                    case ')':
                    case '*':
                    case '+':
                    case ',':
                    case '-':
                    case '.':
                    case '/':
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case ':':
                    case ';':
                    case '<':
                    case '=':
                    case '>':
                    case '?':
                    case '@':
                    case 'B':
                    case 'D':
                    case 'H':
                    case 'I':
                    case 'J':
                    case 'K':
                    case 'L':
                    case 'M':
                    case 'N':
                    case 'O':
                    case 'P':
                    case 'Q':
                    case 'R':
                    case 'T':
                    case 'U':
                    case 'V':
                    case 'W':
                    case 'Y':
                    case 'Z':
                    case '[':
                    case '\\':
                    case ']':
                    case '^':
                    case '_':
                    case '`':
                    case 'b':
                    case 'h':
                    case 'j':
                    case 'k':
                    case 'l':
                    case 'q':
                    case 'r':
                    case 't':
                    case 'v':
                    case 'w':
                    case 'y':
                    case 'z':
                    case '{':
                    case '|':
                    case '}':
                    case '~':
                    case '\x7F':
                      goto LABEL_25;
                    case '%':
                      goto LABEL_225;
                    case 'A':
                    case 'a':
                      goto LABEL_193;
                    case 'C':
                      goto LABEL_41;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_199;
                    case 'S':
                    case 's':
                      goto LABEL_85;
                    case 'X':
                    case 'x':
                      goto LABEL_219;
                    case 'c':
                      goto LABEL_67;
                    case 'd':
                    case 'i':
                      goto LABEL_205;
                    case 'm':
                      goto LABEL_136;
                    case 'n':
                      goto LABEL_137;
                    case 'o':
                      goto LABEL_209;
                    case 'p':
                      goto LABEL_143;
                    case 'u':
                      goto LABEL_224;
                  }
                }
                break;
              case 'S':
              case 's':
LABEL_85:
                v69 = a3->m128i_i32[0];
                if ( a3->m128i_i32[0] > 0x2Fu )
                {
                  v70 = (const char **)a3->m128i_i64[1];
                  a3->m128i_i64[1] = (__int64)(v70 + 1);
                }
                else
                {
                  v70 = (const char **)(a3[1].m128i_i64[0] + v69);
                  a3->m128i_i32[0] = v69 + 8;
                }
                v71 = *v70;
                goto LABEL_88;
              case 'X':
              case 'x':
LABEL_219:
                v208 = 16;
                v111 = a3->m128i_i32[0];
                if ( !v40 )
                  goto LABEL_220;
                goto LABEL_211;
              case 'Z':
              case 'j':
              case 't':
              case 'z':
LABEL_38:
                v35 = *++v236;
                if ( (unsigned __int8)(*v236 - 32) <= 0x5Au )
                {
                  v42 = 0;
                  v40 = 1;
                  switch ( v35 )
                  {
                    case ' ':
                    case '!':
                    case '"':
                    case '#':
                    case '$':
                    case '&':
                    case '\'':
                    case '(':
                    case ')':
                    case '*':
                    case '+':
                    case ',':
                    case '-':
                    case '.':
                    case '/':
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case ':':
                    case ';':
                    case '<':
                    case '=':
                    case '>':
                    case '?':
                    case '@':
                    case 'B':
                    case 'D':
                    case 'H':
                    case 'I':
                    case 'J':
                    case 'K':
                    case 'L':
                    case 'M':
                    case 'N':
                    case 'O':
                    case 'P':
                    case 'Q':
                    case 'R':
                    case 'T':
                    case 'U':
                    case 'V':
                    case 'W':
                    case 'Y':
                    case 'Z':
                    case '[':
                    case '\\':
                    case ']':
                    case '^':
                    case '_':
                    case '`':
                    case 'b':
                    case 'h':
                    case 'j':
                    case 'k':
                    case 'l':
                    case 'q':
                    case 'r':
                    case 't':
                    case 'v':
                    case 'w':
                    case 'y':
                    case 'z':
                    case '{':
                    case '|':
                    case '}':
                    case '~':
                    case '\x7F':
                      goto LABEL_25;
                    case '%':
                      goto LABEL_225;
                    case 'A':
                    case 'a':
                      goto LABEL_193;
                    case 'C':
                      goto LABEL_41;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_199;
                    case 'S':
                    case 's':
                      goto LABEL_85;
                    case 'X':
                    case 'x':
                      goto LABEL_219;
                    case 'c':
                      goto LABEL_67;
                    case 'd':
                    case 'i':
                      goto LABEL_205;
                    case 'm':
                      goto LABEL_136;
                    case 'n':
                      goto LABEL_137;
                    case 'o':
                      goto LABEL_209;
                    case 'p':
                      goto LABEL_143;
                    case 'u':
                      goto LABEL_224;
                  }
                }
                break;
              case 'c':
LABEL_67:
                if ( v40 )
                {
LABEL_41:
                  v43 = a3->m128i_i32[0];
                  v244 = 0LL;
                  if ( v43 > 0x2F )
                  {
                    v44 = (unsigned int *)a3->m128i_i64[1];
                    a3->m128i_i64[1] = (__int64)(v44 + 2);
                  }
                  else
                  {
                    v44 = (unsigned int *)(a3[1].m128i_i64[0] + v43);
                    a3->m128i_i32[0] = v43 + 8;
                  }
                  v45 = sub_6D090(
                          v247,
                          *v44,
                          &v244,
                          (__int64)v44,
                          (u32 *)v28,
                          (u32)v29,
                          *(double *)a5.m128_u64,
                          *(double *)v16.m128_u64,
                          *(double *)a7.m128i_i64,
                          *(double *)a8.m128_u64,
                          v30,
                          v31,
                          a11,
                          a12);
                  v48 = v45;
                  if ( v45 == -1 )
                    goto LABEL_279;
                  v49 = v189 - v45;
                  if ( !v199 && v49 > 0 )
                  {
                    if ( v49 != sub_6A2A0(
                                  a1,
                                  32,
                                  v49,
                                  *(double *)a5.m128_u64,
                                  *(double *)v16.m128_u64,
                                  *(double *)a7.m128i_i64,
                                  *(double *)a8.m128_u64,
                                  v46,
                                  v47,
                                  a11,
                                  a12) )
                      goto LABEL_279;
                    v32 += v49;
                    if ( v32 < 0 || v32 < (unsigned int)v49 )
                      goto LABEL_80;
                  }
                  v50 = *(_QWORD *)(a1 + 216);
                  if ( v188 <= v50 - (__int64)&unk_BFAE0 )
                  {
                    v186 = *(_QWORD *)(a1 + 216);
                    sub_17140(
                      *(double *)a5.m128_u64,
                      *(double *)v16.m128_u64,
                      *(double *)a7.m128i_i64,
                      *(double *)a8.m128_u64,
                      v46,
                      v47,
                      a11,
                      a12);
                    v50 = v186;
                  }
                  if ( v48 != (*(__int64 (__fastcall **)(__int64, char *, unsigned __int64))(v50 + 56))(a1, v247, v48) )
                    goto LABEL_279;
                  v53 = 0;
                  v54 = v48 + v32;
                  if ( v54 < 0 || v54 < v48 )
                    v53 = 1;
                  v32 += v48;
                  if ( v54 != (int)v54 )
                    v53 = 1;
                  if ( v53 )
                    goto LABEL_80;
                  if ( (int)v54 < 0 )
                    goto LABEL_28;
                  if ( v199 )
                    goto LABEL_263;
                }
                else
                {
                  v63 = v189 - 1;
                  if ( !v199 && v63 > 0 )
                  {
                    if ( v63 != sub_6A2A0(
                                  a1,
                                  32,
                                  v63,
                                  *(double *)a5.m128_u64,
                                  *(double *)v16.m128_u64,
                                  *(double *)a7.m128i_i64,
                                  *(double *)a8.m128_u64,
                                  v30,
                                  v31,
                                  a11,
                                  a12) )
                      goto LABEL_279;
                    v32 += v63;
                    if ( v32 < 0 || v32 < (unsigned int)v63 )
                      goto LABEL_80;
                  }
                  v64 = a3->m128i_i32[0];
                  if ( a3->m128i_i32[0] > 0x2Fu )
                  {
                    v65 = (int *)a3->m128i_i64[1];
                    a3->m128i_i64[1] = (__int64)(v65 + 2);
                  }
                  else
                  {
                    v65 = (int *)(a3[1].m128i_i64[0] + v64);
                    a3->m128i_i32[0] = v64 + 8;
                  }
                  v66 = *v65;
                  v67 = *(_BYTE **)(a1 + 40);
                  if ( (unsigned __int64)v67 >= *(_QWORD *)(a1 + 48) )
                  {
                    if ( (unsigned int)sub_1A150(
                                         a1,
                                         (unsigned __int8)v66,
                                         *(double *)a5.m128_u64,
                                         *(double *)v16.m128_u64,
                                         *(double *)a7.m128i_i64,
                                         *(double *)a8.m128_u64,
                                         v30,
                                         v31,
                                         a11,
                                         a12) == -1 )
                      goto LABEL_279;
                  }
                  else
                  {
                    *(_QWORD *)(a1 + 40) = v67 + 1;
                    *v67 = v66;
                  }
                  if ( v32 == 0x7FFFFFFF )
                    goto LABEL_279;
                  ++v32;
                  if ( v199 && v63 > 0 )
                  {
                    if ( v63 != sub_6A2A0(
                                  a1,
                                  32,
                                  v63,
                                  *(double *)a5.m128_u64,
                                  *(double *)v16.m128_u64,
                                  *(double *)a7.m128i_i64,
                                  *(double *)a8.m128_u64,
                                  v30,
                                  v31,
                                  a11,
                                  a12) )
                      goto LABEL_279;
                    v68 = 0;
                    v32 += v63;
                    if ( v32 < 0 || v32 < (unsigned int)v63 )
LABEL_332:
                      v68 = 1;
LABEL_79:
                    if ( v68 )
                      goto LABEL_80;
                    goto LABEL_266;
                  }
                }
                goto LABEL_56;
              case 'd':
              case 'i':
LABEL_205:
                v109 = a3->m128i_i32[0];
                if ( v40 )
                {
                  if ( v109 > 0x2F )
                  {
                    v110 = (signed __int64 *)a3->m128i_i64[1];
                    a3->m128i_i64[1] = (__int64)(v110 + 1);
                  }
                  else
                  {
                    v110 = (signed __int64 *)(a3[1].m128i_i64[0] + v109);
                    a3->m128i_i32[0] = v109 + 8;
                  }
                  v85 = *v110;
                }
                else if ( (_DWORD)v29 )
                {
                  if ( v109 > 0x2F )
                  {
                    v145 = (char *)a3->m128i_i64[1];
                    a3->m128i_i64[1] = (__int64)(v145 + 8);
                  }
                  else
                  {
                    v145 = (char *)(a3[1].m128i_i64[0] + v109);
                    a3->m128i_i32[0] = v109 + 8;
                  }
                  v85 = *v145;
                }
                else if ( v41 )
                {
                  if ( v109 > 0x2F )
                  {
                    v165 = (__int16 *)a3->m128i_i64[1];
                    a3->m128i_i64[1] = (__int64)(v165 + 4);
                  }
                  else
                  {
                    v165 = (__int16 *)(a3[1].m128i_i64[0] + v109);
                    a3->m128i_i32[0] = v109 + 8;
                  }
                  v85 = *v165;
                }
                else
                {
                  if ( v109 > 0x2F )
                  {
                    v138 = (int *)a3->m128i_i64[1];
                    a3->m128i_i64[1] = (__int64)(v138 + 2);
                  }
                  else
                  {
                    v138 = (int *)(a3[1].m128i_i64[0] + v109);
                    a3->m128i_i32[0] = v109 + 8;
                  }
                  v85 = *v138;
                }
                v208 = 10;
                if ( v85 < 0 )
                {
                  v85 = -v85;
                  v40 = 1;
                }
                else
                {
                  v40 = 0;
                }
                goto LABEL_147;
              case 'h':
LABEL_231:
                v41 = 1;
                v35 = *++v236;
                if ( (unsigned __int8)(*v236 - 32) <= 0x5Au )
                {
                  switch ( v35 )
                  {
                    case ' ':
                    case '!':
                    case '"':
                    case '#':
                    case '$':
                    case '&':
                    case '\'':
                    case '(':
                    case ')':
                    case '*':
                    case '+':
                    case ',':
                    case '-':
                    case '.':
                    case '/':
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case ':':
                    case ';':
                    case '<':
                    case '=':
                    case '>':
                    case '?':
                    case '@':
                    case 'A':
                    case 'B':
                    case 'C':
                    case 'D':
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'H':
                    case 'I':
                    case 'J':
                    case 'K':
                    case 'L':
                    case 'M':
                    case 'N':
                    case 'O':
                    case 'P':
                    case 'Q':
                    case 'R':
                    case 'S':
                    case 'T':
                    case 'U':
                    case 'V':
                    case 'W':
                    case 'Y':
                    case 'Z':
                    case '[':
                    case '\\':
                    case ']':
                    case '^':
                    case '_':
                    case '`':
                    case 'a':
                    case 'b':
                    case 'c':
                    case 'e':
                    case 'f':
                    case 'g':
                    case 'j':
                    case 'k':
                    case 'l':
                    case 'm':
                    case 'p':
                    case 'q':
                    case 'r':
                    case 's':
                    case 't':
                    case 'v':
                    case 'w':
                    case 'y':
                    case 'z':
                    case '{':
                    case '|':
                    case '}':
                    case '~':
                    case '\x7F':
                      goto LABEL_25;
                    case '%':
                      goto LABEL_225;
                    case 'X':
                    case 'x':
                      goto LABEL_219;
                    case 'd':
                    case 'i':
                      goto LABEL_205;
                    case 'h':
                      v35 = *++v236;
                      if ( (unsigned __int8)(*v236 - 32) <= 0x5Au )
                      {
                        v27 = &unk_A3A40;
                        v41 = 0;
                        v29 = (__int64 *)(&dword_0 + 1);
                        switch ( v35 )
                        {
                          case ' ':
                          case '!':
                          case '"':
                          case '#':
                          case '$':
                          case '&':
                          case '\'':
                          case '(':
                          case ')':
                          case '*':
                          case '+':
                          case ',':
                          case '-':
                          case '.':
                          case '/':
                          case '0':
                          case '1':
                          case '2':
                          case '3':
                          case '4':
                          case '5':
                          case '6':
                          case '7':
                          case '8':
                          case '9':
                          case ':':
                          case ';':
                          case '<':
                          case '=':
                          case '>':
                          case '?':
                          case '@':
                          case 'B':
                          case 'D':
                          case 'H':
                          case 'I':
                          case 'J':
                          case 'K':
                          case 'L':
                          case 'M':
                          case 'N':
                          case 'O':
                          case 'P':
                          case 'Q':
                          case 'R':
                          case 'T':
                          case 'U':
                          case 'V':
                          case 'W':
                          case 'Y':
                          case 'Z':
                          case '[':
                          case '\\':
                          case ']':
                          case '^':
                          case '_':
                          case '`':
                          case 'b':
                          case 'h':
                          case 'j':
                          case 'k':
                          case 'l':
                          case 'q':
                          case 'r':
                          case 't':
                          case 'v':
                          case 'w':
                          case 'y':
                          case 'z':
                          case '{':
                          case '|':
                          case '}':
                          case '~':
                          case '\x7F':
                            goto LABEL_25;
                          case '%':
                            goto LABEL_225;
                          case 'A':
                          case 'a':
                            goto LABEL_193;
                          case 'C':
                            goto LABEL_41;
                          case 'E':
                          case 'F':
                          case 'G':
                          case 'e':
                          case 'f':
                          case 'g':
                            goto LABEL_199;
                          case 'S':
                          case 's':
                            goto LABEL_85;
                          case 'X':
                          case 'x':
                            goto LABEL_219;
                          case 'c':
                            goto LABEL_67;
                          case 'd':
                          case 'i':
                            goto LABEL_205;
                          case 'm':
                            goto LABEL_136;
                          case 'n':
                            goto LABEL_137;
                          case 'o':
                            goto LABEL_209;
                          case 'p':
                            goto LABEL_143;
                          case 'u':
                            goto LABEL_224;
                        }
                      }
                      goto LABEL_25;
                    case 'n':
                      goto LABEL_137;
                    case 'o':
                      goto LABEL_209;
                    case 'u':
                      goto LABEL_224;
                  }
                }
                break;
              case 'l':
LABEL_217:
                v40 = 1;
                v35 = *++v236;
                if ( (unsigned __int8)(*v236 - 32) <= 0x5Au )
                {
                  v27 = &unk_A3A40;
                  switch ( v35 )
                  {
                    case ' ':
                    case '!':
                    case '"':
                    case '#':
                    case '$':
                    case '&':
                    case '\'':
                    case '(':
                    case ')':
                    case '*':
                    case '+':
                    case ',':
                    case '-':
                    case '.':
                    case '/':
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case ':':
                    case ';':
                    case '<':
                    case '=':
                    case '>':
                    case '?':
                    case '@':
                    case 'B':
                    case 'D':
                    case 'H':
                    case 'I':
                    case 'J':
                    case 'K':
                    case 'L':
                    case 'M':
                    case 'N':
                    case 'O':
                    case 'P':
                    case 'Q':
                    case 'R':
                    case 'T':
                    case 'U':
                    case 'V':
                    case 'W':
                    case 'Y':
                    case 'Z':
                    case '[':
                    case '\\':
                    case ']':
                    case '^':
                    case '_':
                    case '`':
                    case 'b':
                    case 'h':
                    case 'j':
                    case 'k':
                    case 'q':
                    case 'r':
                    case 't':
                    case 'v':
                    case 'w':
                    case 'y':
                    case 'z':
                    case '{':
                    case '|':
                    case '}':
                    case '~':
                    case '\x7F':
                      goto LABEL_25;
                    case '%':
                      goto LABEL_225;
                    case 'A':
                    case 'a':
                      goto LABEL_193;
                    case 'C':
                      goto LABEL_41;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_199;
                    case 'S':
                    case 's':
                      goto LABEL_85;
                    case 'X':
                    case 'x':
                      goto LABEL_219;
                    case 'c':
                      goto LABEL_67;
                    case 'd':
                    case 'i':
                      goto LABEL_205;
                    case 'l':
                      goto LABEL_215;
                    case 'm':
                      goto LABEL_136;
                    case 'n':
                      goto LABEL_137;
                    case 'o':
                      goto LABEL_209;
                    case 'p':
                      goto LABEL_143;
                    case 'u':
                      goto LABEL_224;
                  }
                }
                break;
              case 'm':
LABEL_136:
                v40 = 0;
                v71 = (const char *)sub_23140(
                                      v230,
                                      v248,
                                      1000LL,
                                      *(double *)a5.m128_u64,
                                      *(double *)v16.m128_u64,
                                      *(double *)a7.m128i_i64,
                                      *(double *)a8.m128_u64,
                                      v30,
                                      v31,
                                      a11,
                                      a12);
LABEL_88:
                if ( !v71 )
                {
                  if ( v176 == -1 || v176 > 5 )
                  {
                    LODWORD(v72) = 6;
                    v73 = 6LL;
                    v71 = "(null)";
                  }
                  else
                  {
                    LODWORD(v72) = 0;
                    v73 = 0LL;
                    v71 = (const char *)&unk_A6E65;
                  }
                  goto LABEL_93;
                }
                if ( v40 || v35 == 83 )
                  goto LABEL_325;
                if ( v176 == -1 )
                {
                  v72 = strlen((__int64)v71);
                  v73 = v72;
                  goto LABEL_93;
                }
                goto LABEL_92;
              case 'n':
LABEL_137:
                if ( (v223 & 2) != 0 && !v235 )
                {
                  v182 = (int)v29;
                  v148 = strlen(a2);
                  v151 = sub_6EE40(
                           a2,
                           v148 + 1,
                           *(double *)a5.m128_u64,
                           *(double *)v16.m128_u64,
                           *(double *)a7.m128i_i64,
                           *(double *)a8.m128_u64,
                           v149,
                           v150,
                           a11,
                           a12);
                  LODWORD(v29) = v182;
                  v235 = v151;
                  if ( v151 < 0 )
                    sub_17110(
                      (__int64)"*** %n in writable segment detected ***\n",
                      *(double *)a5.m128_u64,
                      *(double *)v16.m128_u64,
                      *(double *)a7.m128i_i64,
                      *(double *)a8.m128_u64,
                      v152,
                      v153,
                      a11,
                      a12);
                }
                v82 = a3->m128i_i32[0];
                if ( v40 )
                {
                  if ( v82 > 0x2F )
                  {
                    v83 = (_QWORD **)a3->m128i_i64[1];
                    a3->m128i_i64[1] = (__int64)(v83 + 1);
                  }
                  else
                  {
                    v83 = (_QWORD **)(a3[1].m128i_i64[0] + v82);
                    a3->m128i_i32[0] = v82 + 8;
                  }
                  **v83 = v32;
                }
                else if ( (_DWORD)v29 )
                {
                  if ( v82 > 0x2F )
                  {
                    v142 = (_BYTE **)a3->m128i_i64[1];
                    a3->m128i_i64[1] = (__int64)(v142 + 1);
                  }
                  else
                  {
                    v142 = (_BYTE **)(a3[1].m128i_i64[0] + v82);
                    a3->m128i_i32[0] = v82 + 8;
                  }
                  **v142 = v32;
                }
                else if ( v41 )
                {
                  if ( v82 > 0x2F )
                  {
                    v164 = (_WORD **)a3->m128i_i64[1];
                    a3->m128i_i64[1] = (__int64)(v164 + 1);
                  }
                  else
                  {
                    v164 = (_WORD **)(a3[1].m128i_i64[0] + v82);
                    a3->m128i_i32[0] = v82 + 8;
                  }
                  **v164 = v32;
                }
                else
                {
                  if ( v82 > 0x2F )
                  {
                    v139 = (int **)a3->m128i_i64[1];
                    a3->m128i_i64[1] = (__int64)(v139 + 1);
                  }
                  else
                  {
                    v139 = (int **)(a3[1].m128i_i64[0] + v82);
                    a3->m128i_i32[0] = v82 + 8;
                  }
                  **v139 = v32;
                }
                goto LABEL_56;
              case 'o':
LABEL_209:
                v208 = 8;
                goto LABEL_210;
              case 'p':
LABEL_143:
                v84 = a3->m128i_i32[0];
                if ( a3->m128i_i32[0] > 0x2Fu )
                {
                  v70 = (const char **)a3->m128i_i64[1];
                  a3->m128i_i64[1] = (__int64)(v70 + 1);
                }
                else
                {
                  v70 = (const char **)(a3[1].m128i_i64[0] + v84);
                  a3->m128i_i32[0] = v84 + 8;
                }
                v85 = (signed __int64)*v70;
                if ( *v70 )
                {
                  v224 = 1;
                  v28 = 0LL;
                  v40 = 0;
                  v35 = 120;
                  v208 = 16;
LABEL_147:
                  v86 = v176;
                  v87 = v176 == 0;
                  if ( v176 < 0 )
                  {
LABEL_214:
                    v177 = 1LL;
                    goto LABEL_150;
                  }
LABEL_148:
                  if ( v87 )
                  {
                    if ( v85 )
                    {
                      v177 = 0LL;
                      v214 = 32;
                      goto LABEL_150;
                    }
                    if ( v208 == 8 && v224 )
                    {
                      v249 = 48;
                      v91 = (_BYTE *)(&dword_0 + 1);
                      v29 = (__int64 *)&v249;
                    }
                    else
                    {
                      v91 = 0LL;
                      v29 = v250;
                    }
                    v214 = 32;
                    v92 = 0;
                  }
                  else
                  {
                    v177 = v86;
                    v214 = 32;
LABEL_150:
                    v232 = v85;
                    v234 = v28;
                    v88 = sub_7A1B0(v85, (__int64)v250, v208, v35 == 88);
                    v85 = v232;
                    v29 = (__int64 *)v88;
                    if ( v231 )
                    {
                      v28 = v234;
                      if ( v234 )
                      {
                        v89 = sub_5E560((unsigned __int64)v248, v88, (__int64)v250, (_BYTE *)v231, v233);
                        v85 = v232;
                        v29 = (__int64 *)v89;
                      }
                    }
                    if ( v208 == 10 )
                    {
                      v28 = v226;
                      if ( v226 )
                      {
                        v227 = v85;
                        v90 = sub_5E770(
                                (__int64)v29,
                                (__int64)v250,
                                v250,
                                *(double *)a5.m128_u64,
                                *(double *)v16.m128_u64,
                                *(double *)a7.m128i_i64,
                                *(double *)a8.m128_u64,
                                v30,
                                v31,
                                a11,
                                a12);
                        v85 = v227;
                        v29 = v90;
                      }
                    }
                    v91 = (char *)((char *)v250 - (char *)v29);
                    if ( (char *)v250 - (char *)v29 < v177 )
                    {
                      v92 = v177 - (_DWORD)v91;
                      if ( v177 - (__int64)v91 < 0 )
                        v92 = 0;
                      v176 = v92;
                      if ( !v199 )
                      {
                        v28 = v189 - (unsigned int)v91 - v92;
                        if ( v85 )
                        {
                          v93 = v224 & 1;
                          goto LABEL_162;
                        }
                        goto LABEL_165;
                      }
                      goto LABEL_233;
                    }
                    if ( v85 )
                    {
                      v93 = v224 & 1;
                      if ( v208 == 8 && v93 )
                      {
                        *((_BYTE *)v29 - 1) = 48;
                        v91 = (char *)((char *)v250 - ((char *)v29 - 1));
                        v29 = (__int64 *)((char *)v29 - 1);
                      }
                      v92 = v177 - (_DWORD)v91;
                      if ( v177 - (__int64)v91 < 0 )
                        v92 = 0;
                      v176 = v92;
                      if ( !v199 )
                      {
                        v28 = v189 - (unsigned int)v91 - v92;
LABEL_162:
                        if ( v208 == 16 && v93 )
                          v28 = (unsigned int)(v28 - 2);
LABEL_165:
                        if ( v40 | v218 | v222 )
                        {
                          v28 = (unsigned int)(v28 - 1);
                          if ( v214 != 32 )
                            goto LABEL_167;
                          if ( (int)v28 <= 0 )
                          {
                            v28 = 0LL;
                            goto LABEL_167;
                          }
LABEL_294:
                          v130 = v28;
                          v228 = v29;
                          v215 = v91;
                          v200 = v85;
                          v191 = v28;
                          if ( (int)v28 != sub_6A2A0(
                                             a1,
                                             32,
                                             v28,
                                             *(double *)a5.m128_u64,
                                             *(double *)v16.m128_u64,
                                             *(double *)a7.m128i_i64,
                                             *(double *)a8.m128_u64,
                                             v30,
                                             v31,
                                             a11,
                                             a12) )
                            goto LABEL_279;
                          v131 = 0;
                          v85 = v200;
                          v91 = v215;
                          v29 = v228;
                          v32 += v191;
                          if ( v32 < 0 || v32 < v130 )
                            v131 = 1;
                          v28 = v131;
                          if ( v131 )
                            goto LABEL_80;
                          if ( v32 < 0 )
                            goto LABEL_28;
LABEL_167:
                          if ( v40 )
                          {
                            v94 = *(_BYTE **)(a1 + 40);
                            if ( (unsigned __int64)v94 < *(_QWORD *)(a1 + 48) )
                            {
                              *(_QWORD *)(a1 + 40) = v94 + 1;
                              *v94 = 45;
                              goto LABEL_170;
                            }
                            v220 = v29;
                            v168 = 45;
                            v217 = v28;
                            v202 = v91;
                            v196 = v85;
LABEL_441:
                            v169 = sub_1A150(
                                     a1,
                                     v168,
                                     *(double *)a5.m128_u64,
                                     *(double *)v16.m128_u64,
                                     *(double *)a7.m128i_i64,
                                     *(double *)a8.m128_u64,
                                     v30,
                                     v31,
                                     a11,
                                     a12);
                            v85 = v196;
                            v91 = v202;
                            v28 = v217;
                            v29 = v220;
                            if ( v169 == -1 )
                              goto LABEL_279;
                            goto LABEL_170;
                          }
                          if ( v218 )
                          {
                            v133 = *(_BYTE **)(a1 + 40);
                            if ( (unsigned __int64)v133 >= *(_QWORD *)(a1 + 48) )
                            {
                              v220 = v29;
                              v168 = 43;
                              v217 = v28;
                              v202 = v91;
                              v196 = v85;
                              goto LABEL_441;
                            }
                            *(_QWORD *)(a1 + 40) = v133 + 1;
                            *v133 = 43;
LABEL_170:
                            if ( v32 == 0x7FFFFFFF )
                              goto LABEL_279;
                            ++v32;
                          }
                          else if ( v222 )
                          {
                            v162 = *(_BYTE **)(a1 + 40);
                            if ( (unsigned __int64)v162 >= *(_QWORD *)(a1 + 48) )
                            {
                              v220 = v29;
                              v168 = 32;
                              v217 = v28;
                              v202 = v91;
                              v196 = v85;
                              goto LABEL_441;
                            }
                            *(_QWORD *)(a1 + 40) = v162 + 1;
                            *v162 = 32;
                            goto LABEL_170;
                          }
                        }
                        else if ( v214 == 32 )
                        {
                          if ( (int)v28 > 0 )
                            goto LABEL_294;
                          v28 = 0LL;
                        }
                        if ( v85 && v208 == 16 && v224 )
                        {
                          v95 = *(_BYTE **)(a1 + 40);
                          if ( (unsigned __int64)v95 >= *(_QWORD *)(a1 + 48) )
                          {
                            v210 = v29;
                            v203 = v28;
                            v197 = v91;
                            v171 = sub_1A150(
                                     a1,
                                     0x30u,
                                     *(double *)a5.m128_u64,
                                     *(double *)v16.m128_u64,
                                     *(double *)a7.m128i_i64,
                                     *(double *)a8.m128_u64,
                                     v30,
                                     v31,
                                     a11,
                                     a12);
                            v91 = v197;
                            v28 = v203;
                            v29 = v210;
                            if ( v171 == -1 )
                              goto LABEL_279;
                          }
                          else
                          {
                            *(_QWORD *)(a1 + 40) = v95 + 1;
                            *v95 = 48;
                          }
                          if ( v32 == 0x7FFFFFFF )
                            goto LABEL_279;
                          v96 = *(unsigned __int8 **)(a1 + 40);
                          if ( (unsigned __int64)v96 >= *(_QWORD *)(a1 + 48) )
                          {
                            v211 = v29;
                            v204 = v28;
                            v198 = v91;
                            v172 = sub_1A150(
                                     a1,
                                     v35,
                                     *(double *)a5.m128_u64,
                                     *(double *)v16.m128_u64,
                                     *(double *)a7.m128i_i64,
                                     *(double *)a8.m128_u64,
                                     v30,
                                     v31,
                                     a11,
                                     a12);
                            v91 = v198;
                            v28 = v204;
                            v29 = v211;
                            if ( v172 == -1 )
                              goto LABEL_279;
                          }
                          else
                          {
                            *(_QWORD *)(a1 + 40) = v96 + 1;
                            *v96 = v35;
                          }
                          if ( v32 == 2147483646 )
                            goto LABEL_279;
                          v32 += 2;
                        }
                        v97 = v28 + v176;
                        if ( (int)v28 + v176 > 0 )
                        {
                          v192 = v29;
                          v181 = v91;
                          if ( v97 != sub_6A2A0(
                                        a1,
                                        48,
                                        v97,
                                        *(double *)a5.m128_u64,
                                        *(double *)v16.m128_u64,
                                        *(double *)a7.m128i_i64,
                                        *(double *)a8.m128_u64,
                                        v30,
                                        v31,
                                        a11,
                                        a12) )
                            goto LABEL_279;
                          v132 = 0;
                          v122 = (int)(v97 + v32) < 0;
                          v32 += v97;
                          v91 = v181;
                          v29 = v192;
                          if ( v122 || v32 < v97 )
                            v132 = 1;
                          if ( v132 )
                            goto LABEL_80;
                          if ( v32 < 0 )
                            goto LABEL_28;
                        }
                        v98 = *(_QWORD *)(a1 + 216);
                        if ( v188 <= v98 - (__int64)&unk_BFAE0 )
                        {
                          v195 = v29;
                          v184 = v91;
                          sub_17140(
                            *(double *)a5.m128_u64,
                            *(double *)v16.m128_u64,
                            *(double *)a7.m128i_i64,
                            *(double *)a8.m128_u64,
                            v30,
                            v31,
                            a11,
                            a12);
                          v29 = v195;
                          v91 = v184;
                        }
                        v178 = v91;
                        if ( v91 != (char *)(*(__int64 (__fastcall **)(__int64, __int64 *, char *))(v98 + 56))(
                                              a1,
                                              v29,
                                              v91) )
                          goto LABEL_279;
                        v99 = 0;
                        v100 = (__int64)&v178[v32];
                        if ( v100 < 0 || v100 < (unsigned __int64)v178 )
LABEL_352:
                          v99 = 1;
LABEL_188:
                        v32 = v100;
                        if ( v100 != (int)v100 )
                          v99 = 1;
                        if ( v99 )
                          goto LABEL_80;
                        if ( (int)v100 < 0 )
                          goto LABEL_28;
                        goto LABEL_56;
                      }
LABEL_233:
                      if ( v40 )
                      {
                        v115 = *(_BYTE **)(a1 + 40);
                        if ( (unsigned __int64)v115 < *(_QWORD *)(a1 + 48) )
                        {
                          *(_QWORD *)(a1 + 40) = v115 + 1;
                          *v115 = 45;
                          goto LABEL_236;
                        }
                        v219 = v29;
                        v166 = 45;
                        v216 = v91;
                        v201 = v85;
LABEL_438:
                        v167 = sub_1A150(
                                 a1,
                                 v166,
                                 *(double *)a5.m128_u64,
                                 *(double *)v16.m128_u64,
                                 *(double *)a7.m128i_i64,
                                 *(double *)a8.m128_u64,
                                 v30,
                                 v31,
                                 a11,
                                 a12);
                        v85 = v201;
                        v91 = v216;
                        v29 = v219;
                        if ( v167 == -1 )
                          goto LABEL_279;
                        goto LABEL_236;
                      }
                      if ( v218 )
                      {
                        v129 = *(_BYTE **)(a1 + 40);
                        if ( (unsigned __int64)v129 >= *(_QWORD *)(a1 + 48) )
                        {
                          v219 = v29;
                          v166 = 43;
                          v216 = v91;
                          v201 = v85;
                          goto LABEL_438;
                        }
                        *(_QWORD *)(a1 + 40) = v129 + 1;
                        *v129 = 43;
LABEL_236:
                        if ( v32 == 0x7FFFFFFF )
                          goto LABEL_279;
                        --v189;
                        ++v32;
                      }
                      else if ( v222 )
                      {
                        v135 = *(_BYTE **)(a1 + 40);
                        if ( (unsigned __int64)v135 >= *(_QWORD *)(a1 + 48) )
                        {
                          v219 = v29;
                          v166 = 32;
                          v216 = v91;
                          v201 = v85;
                          goto LABEL_438;
                        }
                        *(_QWORD *)(a1 + 40) = v135 + 1;
                        *v135 = 32;
                        goto LABEL_236;
                      }
                      if ( v85 && v208 == 16 && v224 )
                      {
                        v116 = *(_BYTE **)(a1 + 40);
                        if ( (unsigned __int64)v116 >= *(_QWORD *)(a1 + 48) )
                        {
                          v212 = v29;
                          v205 = v91;
                          v173 = sub_1A150(
                                   a1,
                                   0x30u,
                                   *(double *)a5.m128_u64,
                                   *(double *)v16.m128_u64,
                                   *(double *)a7.m128i_i64,
                                   *(double *)a8.m128_u64,
                                   v30,
                                   v31,
                                   a11,
                                   a12);
                          v91 = v205;
                          v29 = v212;
                          if ( v173 == -1 )
                            goto LABEL_279;
                        }
                        else
                        {
                          *(_QWORD *)(a1 + 40) = v116 + 1;
                          *v116 = 48;
                        }
                        if ( v32 == 0x7FFFFFFF )
                          goto LABEL_279;
                        v117 = *(unsigned __int8 **)(a1 + 40);
                        if ( (unsigned __int64)v117 >= *(_QWORD *)(a1 + 48) )
                        {
                          v213 = v29;
                          v206 = v91;
                          v174 = sub_1A150(
                                   a1,
                                   v35,
                                   *(double *)a5.m128_u64,
                                   *(double *)v16.m128_u64,
                                   *(double *)a7.m128i_i64,
                                   *(double *)a8.m128_u64,
                                   v30,
                                   v31,
                                   a11,
                                   a12);
                          v91 = v206;
                          v29 = v213;
                          if ( v174 == -1 )
                            goto LABEL_279;
                        }
                        else
                        {
                          *(_QWORD *)(a1 + 40) = v117 + 1;
                          *v117 = v35;
                        }
                        if ( v32 == 2147483646 )
                          goto LABEL_279;
                        v189 -= 2;
                        v32 += 2;
                      }
                      v49 = v189 - ((_DWORD)v91 + v92);
                      v118 = v176;
                      if ( v176 > 0 )
                      {
                        v119 = v176;
                        v190 = v29;
                        v120 = v176;
                        v179 = v91;
                        if ( v118 != sub_6A2A0(
                                       a1,
                                       48,
                                       v120,
                                       *(double *)a5.m128_u64,
                                       *(double *)v16.m128_u64,
                                       *(double *)a7.m128i_i64,
                                       *(double *)a8.m128_u64,
                                       v30,
                                       v31,
                                       a11,
                                       a12) )
                          goto LABEL_279;
                        v121 = 0;
                        v122 = v118 + v32 < 0;
                        v32 += v118;
                        v91 = v179;
                        v29 = v190;
                        if ( v122 || v32 < v119 )
                          v121 = 1;
                        if ( v121 )
                          goto LABEL_80;
                        if ( v32 < 0 )
                          goto LABEL_28;
                      }
                      v123 = *(_QWORD *)(a1 + 216);
                      if ( v188 <= v123 - (__int64)&unk_BFAE0 )
                      {
                        v194 = v29;
                        v183 = v91;
                        sub_17140(
                          *(double *)a5.m128_u64,
                          *(double *)v16.m128_u64,
                          *(double *)a7.m128i_i64,
                          *(double *)a8.m128_u64,
                          v30,
                          v31,
                          a11,
                          a12);
                        v91 = v183;
                        v29 = v194;
                      }
                      v180 = (unsigned __int64)v91;
                      if ( (char *)(*(__int64 (__fastcall **)(__int64, __int64 *, char *))(v123 + 56))(a1, v29, v91) != v91 )
                        goto LABEL_279;
                      v124 = 0;
                      v125 = v180 + v32;
                      if ( v125 < 0 || v125 < v180 )
                        v124 = 1;
                      v32 += v180;
                      if ( v125 != (int)v125 )
                        v124 = 1;
                      if ( v124 )
                        goto LABEL_80;
                      if ( (int)v125 < 0 )
                        goto LABEL_28;
LABEL_263:
                      if ( v49 > 0 )
                        goto LABEL_264;
                      goto LABEL_56;
                    }
                    v92 = v177 - (_DWORD)v91;
                    if ( v177 - (__int64)v91 < 0 )
                      v92 = 0;
                    v176 = v92;
                  }
                  if ( !v199 )
                  {
                    v28 = v189 - ((_DWORD)v91 + v92);
                    goto LABEL_165;
                  }
                  goto LABEL_233;
                }
                v136 = 5;
                v71 = "(nil)";
                if ( v176 >= 5 )
                  v136 = v176;
                v176 = v136;
                if ( v35 == 83 )
LABEL_325:
                  ((void (__fastcall *)(__int64, const char *, _QWORD, _QWORD, _QWORD, _QWORD))loc_5EAC0)(
                    a1,
                    v71,
                    (unsigned int)v176,
                    v189,
                    v199,
                    (unsigned int)v32);
LABEL_92:
                v72 = sub_9040(v71, v176, v70, v27, v28, v29);
                v73 = v72;
LABEL_93:
                v49 = v189 - v72;
                if ( (int)(v189 - v72) < 0 )
                {
                  v140 = *(_QWORD *)(a1 + 216);
                  if ( v188 <= v140 - (__int64)&unk_BFAE0 )
                    sub_17140(
                      *(double *)a5.m128_u64,
                      *(double *)v16.m128_u64,
                      *(double *)a7.m128i_i64,
                      *(double *)a8.m128_u64,
                      v30,
                      v31,
                      a11,
                      a12);
                  if ( (*(__int64 (__fastcall **)(__int64, const char *, unsigned __int64))(v140 + 56))(a1, v71, v73) != v73 )
                    goto LABEL_279;
                  v99 = 0;
                  v100 = v73 + v32;
                  if ( v100 < 0 || v100 < v73 )
                    goto LABEL_352;
                  goto LABEL_188;
                }
                if ( !v199 && v49 )
                {
                  if ( v49 != sub_6A2A0(
                                a1,
                                32,
                                v49,
                                *(double *)a5.m128_u64,
                                *(double *)v16.m128_u64,
                                *(double *)a7.m128i_i64,
                                *(double *)a8.m128_u64,
                                v30,
                                v31,
                                a11,
                                a12) )
                    goto LABEL_279;
                  v32 += v49;
                  if ( v32 < 0 || v32 < (unsigned int)v49 )
                    goto LABEL_80;
                }
                v74 = *(_QWORD *)(a1 + 216);
                if ( v188 <= v74 - (__int64)&unk_BFAE0 )
                {
                  v185 = *(_QWORD *)(a1 + 216);
                  sub_17140(
                    *(double *)a5.m128_u64,
                    *(double *)v16.m128_u64,
                    *(double *)a7.m128i_i64,
                    *(double *)a8.m128_u64,
                    v30,
                    v31,
                    a11,
                    a12);
                  v74 = v185;
                }
                if ( (*(__int64 (__fastcall **)(__int64, const char *, unsigned __int64))(v74 + 56))(a1, v71, v73) != v73 )
                  goto LABEL_279;
                v75 = 0;
                v76 = v73 + v32;
                if ( v76 < 0 || v76 < v73 )
                  v75 = 1;
                v32 += v73;
                if ( v76 != (int)v76 )
                  v75 = 1;
                if ( v75 )
                  goto LABEL_80;
                if ( (int)v76 < 0 )
                  goto LABEL_28;
                if ( v199 && v49 )
                {
LABEL_264:
                  if ( v49 != sub_6A2A0(
                                a1,
                                32,
                                v49,
                                *(double *)a5.m128_u64,
                                *(double *)v16.m128_u64,
                                *(double *)a7.m128i_i64,
                                *(double *)a8.m128_u64,
                                v51,
                                v52,
                                a11,
                                a12) )
                    goto LABEL_279;
                  v126 = __OFADD__(v32, v49);
                  v32 += v49;
                  if ( v126 )
                    goto LABEL_80;
LABEL_266:
                  if ( v32 < 0 )
                    goto LABEL_28;
                }
LABEL_56:
                ++v229;
                v55 = (__int64)++v236;
                v56 = (_BYTE *)sub_9100(v236, 37LL);
                v59 = *(_QWORD *)(a1 + 216);
                v236 = v56;
                v60 = (unsigned __int64)&v56[-v55];
                if ( v188 <= v59 - (__int64)&unk_BFAE0 )
                  sub_17140(
                    *(double *)a5.m128_u64,
                    *(double *)v16.m128_u64,
                    *(double *)a7.m128i_i64,
                    *(double *)a8.m128_u64,
                    v57,
                    v58,
                    a11,
                    a12);
                if ( (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(v59 + 56))(a1, v55, v60) != v60 )
                  goto LABEL_279;
                v61 = 0;
                v62 = v60 + v32;
                if ( v62 < 0 || v62 < v60 )
                  v61 = 1;
                v32 += v60;
                v27 = (_BYTE *)(&dword_0 + 1);
                if ( v62 != (int)v62 )
                  v61 = 1;
                if ( v61 )
                  goto LABEL_80;
                if ( (int)v62 < 0 )
                  goto LABEL_28;
                v34 = v236;
                if ( !*v236 )
                  goto LABEL_28;
                continue;
              case 'u':
LABEL_224:
                v208 = 10;
LABEL_210:
                v111 = a3->m128i_i32[0];
                if ( !v40 )
                {
LABEL_220:
                  if ( (_DWORD)v29 )
                  {
                    if ( v111 > 0x2F )
                    {
                      v113 = (unsigned __int8 *)a3->m128i_i64[1];
                      a3->m128i_i64[1] = (__int64)(v113 + 8);
                    }
                    else
                    {
                      v113 = (unsigned __int8 *)(a3[1].m128i_i64[0] + v111);
                      a3->m128i_i32[0] = v111 + 8;
                    }
                    v218 = 0;
                    v85 = *v113;
                    v222 = 0;
                  }
                  else if ( v41 )
                  {
                    if ( v111 > 0x2F )
                    {
                      v141 = (unsigned __int16 *)a3->m128i_i64[1];
                      a3->m128i_i64[1] = (__int64)(v141 + 4);
                    }
                    else
                    {
                      v141 = (unsigned __int16 *)(a3[1].m128i_i64[0] + v111);
                      a3->m128i_i32[0] = v111 + 8;
                    }
                    v218 = 0;
                    v85 = *v141;
                    v40 = 0;
                    v222 = 0;
                  }
                  else
                  {
                    if ( v111 > 0x2F )
                    {
                      v134 = (unsigned int *)a3->m128i_i64[1];
                      a3->m128i_i64[1] = (__int64)(v134 + 2);
                    }
                    else
                    {
                      v134 = (unsigned int *)(a3[1].m128i_i64[0] + v111);
                      a3->m128i_i32[0] = v111 + 8;
                    }
                    v218 = 0;
                    v85 = *v134;
                    v40 = 0;
                    v222 = 0;
                  }
                  goto LABEL_147;
                }
LABEL_211:
                if ( v111 > 0x2F )
                {
                  v112 = (signed __int64 *)a3->m128i_i64[1];
                  a3->m128i_i64[1] = (__int64)(v112 + 1);
                }
                else
                {
                  v112 = (signed __int64 *)(a3[1].m128i_i64[0] + v111);
                  a3->m128i_i32[0] = v111 + 8;
                }
                v86 = v176;
                v218 = 0;
                v40 = 0;
                v222 = 0;
                v85 = *v112;
                v87 = v176 == 0;
                if ( v176 < 0 )
                  goto LABEL_214;
                goto LABEL_148;
            }
          }
          break;
        }
LABEL_25:
        if ( v35 )
        {
LABEL_26:
          v36 = sub_5EE80(
                  a1,
                  a2,
                  v235,
                  a5,
                  v16,
                  (__m128)a7,
                  *(double *)a8.m128_u64,
                  v30,
                  v31,
                  a11,
                  a12,
                  (__int64)a3,
                  (__int64)&v245,
                  v32,
                  v229,
                  v225,
                  v248,
                  v230,
                  (char *)v231,
                  v233,
                  v223);
LABEL_27:
          v32 = v36;
          goto LABEL_28;
        }
        v32 = -1;
        __writefsdword(0xFFFFFFC0, 0x16u);
      }
    }
LABEL_28:
    if ( (*(_DWORD *)a1 & 0x8000) != 0 )
      goto LABEL_29;
LABEL_33:
    v38 = *(_QWORD *)(a1 + 136);
    v39 = *(_DWORD *)(v38 + 4) - 1;
    *(_DWORD *)(v38 + 4) = v39;
    if ( !v39 )
    {
      *(_QWORD *)(v38 + 8) = 0LL;
      if ( !__readfsdword(0x18u) )
      {
        --*(_DWORD *)v38;
        if ( !v221 )
          return (unsigned int)v32;
        goto LABEL_36;
      }
      if ( _InterlockedExchange((volatile __int32 *)v38, 0) > 1 )
        v163 = sys_futex((u32 *)v38, 129, 1u, 0LL, (u32 *)v28, (u32)v29);
    }
LABEL_29:
    if ( !v221 )
      return (unsigned int)v32;
LABEL_36:
    sub_90B0(v243, 0LL);
    return (unsigned int)v32;
  }
  return sub_636E0(
           a1,
           a2,
           (__int64)a3,
           a4,
           *(double *)a5.m128_u64,
           a6,
           *(double *)a7.m128i_i64,
           *(double *)a8.m128_u64,
           a9,
           a10,
           a11,
           a12);
}
// 62DF9: conditional instruction was optimized away because of 'er12.4>=0'
// 62E40: conditional instruction was optimized away because of 'er12.4>=0'
// 631F5: conditional instruction was optimized away because of 'er12.4>=0'
// 62B28: variable 'v20' is possibly undefined
// 62B28: variable 'v21' is possibly undefined
// 615F0: variable 'v30' is possibly undefined
// 615F0: variable 'v31' is possibly undefined
// 632CA: variable 'v46' is possibly undefined
// 632CA: variable 'v47' is possibly undefined
// 62920: variable 'v57' is possibly undefined
// 62920: variable 'v58' is possibly undefined
// 61AFD: variable 'v70' is possibly undefined
// 61AFD: variable 'v27' is possibly undefined
// 61AFD: variable 'v28' is possibly undefined
// 61AFD: variable 'v29' is possibly undefined
// 621AA: variable 'v42' is possibly undefined
// 6275B: variable 'v51' is possibly undefined
// 6275B: variable 'v52' is possibly undefined
// 62F6F: variable 'v149' is possibly undefined
// 62F6F: variable 'v150' is possibly undefined
// 62F8F: variable 'v152' is possibly undefined
// 62F8F: variable 'v153' is possibly undefined
// 6316E: variable 'v17' is possibly undefined
// 6316E: variable 'v18' is possibly undefined
// 6316E: variable 'v19' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);
// 9040: using guessed type __int64 __fastcall sub_9040(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 90B0: using guessed type __int64 __fastcall sub_90B0(_QWORD, _QWORD);
// 9100: using guessed type __int64 __fastcall sub_9100(_QWORD, _QWORD);
// 9160: using guessed type __int64 __fastcall sub_9160(_QWORD, _QWORD, _QWORD);
// BB420: using guessed type void *jpt_625C0[30];
// C0308: using guessed type void *off_C0308;
// C1788: using guessed type __int64 qword_C1788;
// C1798: using guessed type __int64 qword_C1798;
// C1B18: using guessed type __int64 qword_C1B18;

//----- (00000000000636E0) ----------------------------------------------------
__int64 __fastcall sub_636E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  int v13; // eax
  int v14; // eax
  u32 *v15; // r8
  u32 v16; // er9
  unsigned int v17; // er12
  double v18; // xmm4_8
  double v19; // xmm5_8
  __int64 v20; // rdx
  int v21; // er13
  __int64 v22; // r14
  __int64 v23; // rdi
  int v24; // eax
  unsigned __int64 v27; // r13
  int v29; // eax
  signed __int64 v30; // rax
  int v31[8]; // [rsp+20h] [rbp-2138h] BYREF
  char *v32; // [rsp+40h] [rbp-2118h]
  char *v33; // [rsp+48h] [rbp-2110h]
  char *v34; // [rsp+50h] [rbp-2108h]
  int v35; // [rsp+94h] [rbp-20C4h]
  __int64 v36; // [rsp+A8h] [rbp-20B0h]
  int v37; // [rsp+E0h] [rbp-2078h]
  void *v38; // [rsp+F8h] [rbp-2060h]
  __int64 v39; // [rsp+100h] [rbp-2058h]
  char v40[8192]; // [rsp+120h] [rbp-2038h] BYREF
  char v41; // [rsp+2120h] [rbp-38h] BYREF
  unsigned __int64 v42; // [rsp+2128h] [rbp-30h]

  v42 = __readfsqword(0x28u);
  v13 = *(_DWORD *)(a1 + 192);
  if ( v13 )
  {
    if ( v13 != -1 )
      return (unsigned int)-1;
  }
  else
  {
    *(_DWORD *)(a1 + 192) = -1;
  }
  v39 = a1;
  v33 = v40;
  v32 = v40;
  v34 = &v41;
  v14 = *(_DWORD *)(a1 + 116);
  v37 = -1;
  v35 = v14;
  v31[0] = -72515580;
  v36 = 0LL;
  v38 = &unk_C00E0;
  v17 = sub_61370(v31, a2, a3, a4);
  v20 = *(_DWORD *)a1 & 0x8000;
  if ( (*(_DWORD *)a1 & 0x8000) != 0 )
  {
    v21 = (_DWORD)v33 - (_DWORD)v32;
    if ( (int)v33 - (int)v32 <= 0 )
      return v17;
  }
  else
  {
    _RDI = *(_QWORD *)(a1 + 136);
    v27 = __readfsqword(0x10u);
    if ( *(_QWORD *)(_RDI + 8) != v27 )
    {
      if ( __readfsdword(0x18u) )
      {
        if ( (_DWORD)v20 != _InterlockedCompareExchange((volatile signed __int32 *)_RDI, 1, v20) )
          sub_1C7D0((volatile __int32 *)_RDI, a2, v20, 1LL, v15, v16);
      }
      else
      {
        _EDX = 1;
        __asm { cmpxchg [rdi], edx }
      }
      _RDI = *(_QWORD *)(a1 + 136);
      *(_QWORD *)(_RDI + 8) = v27;
    }
    v29 = (_DWORD)v33 - (_DWORD)v32;
    ++*(_DWORD *)(_RDI + 4);
    v21 = v29;
    if ( v29 <= 0 )
      goto LABEL_9;
  }
  v22 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v22 - (_QWORD)&unk_BFAE0) )
    sub_17140(a5, a6, a7, a8, v18, v19, a11, a12);
  if ( v21 != (*(unsigned int (__fastcall **)(__int64, char *, _QWORD))(v22 + 56))(a1, v32, v21) )
    v17 = -1;
LABEL_9:
  if ( (*(_DWORD *)a1 & 0x8000) == 0 )
  {
    v23 = *(_QWORD *)(a1 + 136);
    v24 = *(_DWORD *)(v23 + 4) - 1;
    *(_DWORD *)(v23 + 4) = v24;
    if ( !v24 )
    {
      *(_QWORD *)(v23 + 8) = 0LL;
      if ( __readfsdword(0x18u) )
      {
        if ( _InterlockedExchange((volatile __int32 *)v23, 0) > 1 )
          v30 = sys_futex((u32 *)v23, 129, 1u, 0LL, v15, v16);
      }
      else
      {
        --*(_DWORD *)v23;
      }
    }
  }
  return v17;
}
// 63908: variable 'v18' is possibly undefined
// 63908: variable 'v19' is possibly undefined
// 63925: variable 'v15' is possibly undefined
// 63925: variable 'v16' is possibly undefined
// 90B0: using guessed type __int64 __fastcall sub_90B0(_QWORD, _QWORD);
// 9160: using guessed type __int64 __fastcall sub_9160(_QWORD, _QWORD, _QWORD);
// 61370: using guessed type __int64 __fastcall sub_61370(_QWORD, _QWORD, _QWORD, _QWORD);
// C0308: using guessed type void *off_C0308;

//----- (0000000000063960) ----------------------------------------------------
__int64 __fastcall sub_63960(int **a1)
{
  int *v1; // rdx
  int v2; // eax
  __int64 result; // rax
  unsigned int v4; // ecx
  int *v5; // rdx
  signed int v6; // eax
  int v7; // ecx
  int *v8; // rsi

  v1 = *a1;
  v2 = *(*a1)++;
  result = (unsigned int)(v2 - 48);
  v4 = v1[1] - 48;
  if ( v4 <= 9 )
  {
    v5 = v1 + 2;
    while ( 1 )
    {
      if ( (int)result >= 0 )
      {
        if ( (int)result > 214748364 || (v6 = 10 * result, (int)(0x7FFFFFFF - v4) < v6) )
        {
          v8 = v5++;
          result = 0xFFFFFFFFLL;
          if ( (unsigned int)(*v8 - 48) > 9 )
          {
LABEL_9:
            *a1 = v8;
            return result;
          }
        }
        else
        {
          result = v4 + v6;
        }
      }
      v7 = *v5;
      v8 = v5++;
      v4 = v7 - 48;
      if ( v4 > 9 )
        goto LABEL_9;
    }
  }
  return result;
}

//----- (00000000000639E0) ----------------------------------------------------
__int64 __fastcall sub_639E0(__int64 a1, unsigned int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14)
{
  _QWORD *v16; // rdx
  unsigned int *v17; // rax
  __int64 v18; // rsi
  __int64 v19; // rbx
  __int64 v20; // rdi
  __int64 v21; // r13
  __int64 v22; // rax
  __int64 v23; // r13

  v16 = *(_QWORD **)(a1 + 160);
  v17 = (unsigned int *)v16[4];
  v18 = v16[3];
  v19 = ((__int64)v17 - v18) >> 2;
  if ( (_DWORD)v19 )
  {
    v20 = *(_QWORD *)(a1 + 456);
    v21 = *(_QWORD *)(v20 + 216);
    if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v21 - (_QWORD)&unk_BFAE0) )
    {
      sub_17140(a3, a4, a5, a6, a7, a8, a9, a10);
      v18 = *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL);
    }
    v22 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v21 + 56))(v20, v18, (int)v19);
    if ( !v22 || v22 == 0xFFFFFFFFLL )
      return 0xFFFFFFFFLL;
    v23 = 4 * v22;
    sub_6CEB0(
      *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL),
      *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL) + 4 * v22,
      (int)v19 - v22);
    v16 = *(_QWORD **)(a1 + 160);
    v17 = (unsigned int *)(v16[4] - v23);
    v16[4] = v17;
  }
  if ( v16[5] <= (unsigned __int64)v17 )
    return sub_6AB50(a1, a2, (__int64)v16, a12, a13, a14, a3, a4, a5, a6, a7, a8, a9, a10);
  v16[4] = v17 + 1;
  *v17 = a2;
  return a2;
}
// 63AEF: variable 'a12' is possibly undefined
// 63AEF: variable 'a13' is possibly undefined
// 63AEF: variable 'a14' is possibly undefined
// 63AEF: variable 'a7' is possibly undefined
// 63AEF: variable 'a8' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (0000000000063B00) ----------------------------------------------------
__int64 __fastcall sub_63B00(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, int a5)
{
  __int64 v5; // r9
  int v6; // ebp
  __int64 v8; // r12
  _BYTE *v9; // r13
  __int64 v11; // rbx
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // rdi
  int v15; // eax

  v5 = a2;
  v6 = (char)*a4;
  if ( (unsigned __int8)(*a4 - 1) > 0x7Du )
    return v5;
  v8 = a3;
  v9 = a4 + 1;
  v11 = a3 - a2;
  v12 = sub_9050(a1, a2, a3 - a2);
  v13 = v12 + v11;
  v14 = v12;
  if ( v12 >= v12 + v11 )
    return v8;
  while ( 1 )
  {
    v15 = *(_DWORD *)(v13 - 4);
    v13 -= 4LL;
    v5 = v8 - 4;
    *(_DWORD *)(v8 - 4) = v15;
    if ( !--v6 )
      break;
    if ( v14 >= v13 )
      return v5;
LABEL_10:
    v8 = v5;
  }
  if ( v14 >= v13 )
    return v5;
  if ( v13 != v5 )
  {
    *(_DWORD *)(v8 - 8) = a5;
    v6 = (char)*v9;
    v5 = v8 - 8;
    if ( *v9 <= 0x7Eu )
    {
      if ( (_BYTE)v6 )
        ++v9;
      else
        v6 = (char)*(v9 - 1);
      goto LABEL_10;
    }
  }
  return sub_9050(v5, v13, v14 - v13);
}
// 9050: using guessed type __int64 __fastcall sub_9050(_QWORD, _QWORD, _QWORD);

//----- (0000000000063BE0) ----------------------------------------------------
char *__fastcall sub_63BE0(char *a1, __int64 a2, char *a3)
{
  char *v3; // r14
  _DWORD *v5; // rbp
  unsigned __int64 v6; // r15
  __int64 v7; // rax
  int *v8; // rdx
  __int64 v9; // r8
  char *v10; // rsi
  _QWORD *v11; // r9
  int v12; // eax
  bool v14; // zf
  int v15; // [rsp+8h] [rbp-460h]
  int v16; // [rsp+Ch] [rbp-45Ch]
  __int64 v17[2]; // [rsp+10h] [rbp-458h] BYREF
  char v18[1032]; // [rsp+20h] [rbp-448h] BYREF
  unsigned __int64 v19; // [rsp+428h] [rbp-40h]

  v3 = a1;
  v19 = __readfsqword(0x28u);
  v5 = (_DWORD *)sub_6ED60((__int64)"to_outpunct");
  v15 = sub_6EDF0(0x2Eu, v5);
  v16 = sub_6EDF0(0x2Cu, v5);
  v17[0] = (__int64)v18;
  v17[1] = 1024LL;
  if ( (unsigned __int8)sub_6BAD0(v17, (a2 - (__int64)a1) >> 2, 4LL) )
  {
    v6 = v17[0];
    v7 = sub_91D0(v17[0], a1, a2 - (_QWORD)a1);
    v8 = (int *)(v7 - 4);
    v9 = v7;
    if ( v7 - 4 < v6 )
    {
      v3 = a3;
    }
    else
    {
      v10 = a3;
      v11 = (_QWORD *)__readfsqword(0xFFFFFFA0);
      do
      {
        v12 = *v8;
        v10 -= 4;
        if ( (unsigned int)(*v8 - 48) <= 9 )
        {
          *(_DWORD *)v10 = *(_DWORD *)(*v11 + 8LL * (v12 + 3) + 64);
        }
        else
        {
          if ( v5 )
          {
            if ( (v12 & 0xFFFFFFFD) == 44 )
            {
              v14 = v12 == 46;
              v12 = v15;
              if ( !v14 )
                v12 = v16;
            }
          }
          *(_DWORD *)v10 = v12;
        }
        --v8;
      }
      while ( v6 <= (unsigned __int64)v8 );
      v3 = &a3[~(v9 - v6 - 4) & 0xFFFFFFFFFFFFFFFCLL];
    }
    if ( (char *)v17[0] != v18 )
      sub_21B70(v17[0]);
  }
  return v3;
}
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (0000000000063D50) ----------------------------------------------------
void __fastcall __noreturn sub_63D50(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  sub_CF00(
    (__int64)"(size_t) done <= (size_t) INT_MAX",
    (__int64)"vfprintf-internal.c",
    0xEEu,
    "outstring_func",
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8);
}

//----- (0000000000063D80) ----------------------------------------------------
__int64 __fastcall sub_63D80(__int64 a1, __int64 a2, int a3, int a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v14; // rax
  int v15; // ebx
  unsigned __int64 v16; // r14
  unsigned __int64 v17; // r12
  void **v18; // rdx
  __int64 v19; // rax
  __int64 v20; // r13
  bool v21; // dl
  unsigned __int64 v22; // r15
  _BOOL4 v23; // eax
  void **v24; // rdx
  __int64 v25; // rax
  unsigned __int64 v26; // r13
  __int64 v27; // rcx
  int v28; // eax
  int v29; // er12
  bool v30; // of
  unsigned int v31; // er12
  int v33; // er13
  int v34; // ecx
  int v35; // er13
  unsigned __int64 v36; // [rsp+8h] [rbp-180h]
  bool v38; // [rsp+17h] [rbp-171h]
  __int64 v39; // [rsp+18h] [rbp-170h]
  int v40; // [rsp+20h] [rbp-168h]
  char v41; // [rsp+24h] [rbp-164h]
  __int64 v42; // [rsp+28h] [rbp-160h] BYREF
  __int64 v43; // [rsp+30h] [rbp-158h] BYREF
  __int64 v44; // [rsp+38h] [rbp-150h] BYREF
  char v45[264]; // [rsp+40h] [rbp-148h] BYREF
  unsigned __int64 v46; // [rsp+148h] [rbp-40h]

  v14 = a2;
  v15 = a6;
  v42 = a2;
  v40 = a4;
  v41 = a5;
  v46 = __readfsqword(0x28u);
  v38 = a4 > 0;
  if ( (_BYTE)a5 == 1 || a4 <= 0 )
    goto LABEL_15;
  v44 = 0LL;
  v43 = a2;
  if ( a3 < 0 )
  {
    v17 = sub_49010(0LL, &v43, 0LL, &v44, a7, a8, a9, a10, a11, a12, a13, a14, a5, a6);
    if ( v40 <= v17 )
      goto LABEL_14;
LABEL_53:
    v28 = v40 - v17;
    if ( v40 - (int)v17 <= 0 )
    {
LABEL_54:
      if ( v15 < 0 )
        return (unsigned int)v15;
      goto LABEL_14;
    }
LABEL_36:
    v29 = v28;
    if ( v28 != sub_6A3E0(a1, 32, v28, a7, a8, a9, a10, a11, a12, a13, a14) )
      return (unsigned int)-1;
    if ( v15 < 0 )
      return (unsigned int)v15;
    v30 = __OFADD__(v29, v15);
    v15 += v29;
    if ( v30 )
    {
LABEL_39:
      __writefsdword(0xFFFFFFC0, 0x4Bu);
      return (unsigned int)-1;
    }
    goto LABEL_54;
  }
  v16 = a3;
  v17 = 0LL;
  if ( !a3 )
  {
    v28 = a4;
    goto LABEL_36;
  }
  while ( v14 )
  {
    v18 = (void **)&dword_40;
    if ( v16 <= 0x3F )
      v18 = (void **)v16;
    v19 = sub_49010((__int64)v45, &v43, v18, &v44, a7, a8, a9, a10, a11, a12, a13, a14, a5, a6);
    if ( v19 == -1 )
      return (unsigned int)-1;
    if ( !v19 )
      break;
    v17 += v19;
    v16 -= v19;
    if ( !v16 )
      break;
    v14 = v43;
  }
  if ( v40 > v17 )
    goto LABEL_53;
LABEL_14:
  v14 = v42;
LABEL_15:
  v44 = 0LL;
  if ( a3 < 0 )
  {
    v21 = 1;
    v20 = -1LL;
  }
  else
  {
    v20 = a3;
    v21 = a3 != 0LL;
  }
  if ( v14 && v21 )
  {
    v22 = v20;
    v36 = 0LL;
    while ( 1 )
    {
      v24 = (void **)&dword_40;
      if ( v22 <= 0x3F )
        v24 = (void **)v22;
      v25 = sub_49010((__int64)v45, &v42, v24, &v44, a7, a8, a9, a10, a11, a12, a13, a14, a5, a6);
      v26 = v25;
      if ( v25 == -1 )
        return (unsigned int)-1;
      if ( v25 )
      {
        if ( v15 < 0 )
          sub_CF00(
            (__int64)"(size_t) done <= (size_t) INT_MAX",
            (__int64)"vfprintf-internal.c",
            0xEEu,
            "outstring_func",
            a7,
            a8,
            a9,
            a10,
            a11,
            a12,
            a13,
            a14);
        v27 = *(_QWORD *)(a1 + 216);
        if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v27 - (_QWORD)&unk_BFAE0) )
        {
          v39 = *(_QWORD *)(a1 + 216);
          sub_17140(a7, a8, a9, a10, a11, a12, a13, a14);
          v27 = v39;
        }
        if ( v26 != (*(__int64 (__fastcall **)(__int64, char *, unsigned __int64))(v27 + 56))(a1, v45, v26) )
          return (unsigned int)-1;
        a6 = v26 + v15;
        v15 += v26;
        v23 = a6 + 0x8000000000000000LL < v26;
        if ( a6 != (int)a6 )
          v23 = 1;
        if ( v23 )
          goto LABEL_39;
        if ( (int)a6 < 0 )
          return (unsigned int)a6;
        v36 += v26;
        if ( a3 >= 0 )
          v22 -= v26;
        if ( v42 && v22 )
          continue;
      }
      v31 = v15;
      if ( v38 && v41 && v40 > v36 )
      {
        v33 = v36;
        goto LABEL_46;
      }
      return v31;
    }
  }
  if ( !v38 )
    return (unsigned int)v15;
  v33 = 0;
  v31 = v15;
  if ( !v41 )
    return (unsigned int)v15;
LABEL_46:
  v34 = v40 - v33;
  if ( v40 - v33 <= 0 )
    return v31;
  v35 = v40 - v33;
  if ( v34 != sub_6A3E0(a1, 32, v34, a7, a8, a9, a10, a11, a12, a13, a14) )
    return (unsigned int)-1;
  if ( v15 >= 0 )
  {
    v31 = v35 + v15;
    if ( __OFADD__(v35, v15) )
      goto LABEL_39;
  }
  return v31;
}
// 63E2A: variable 'a11' is possibly undefined
// 63E2A: variable 'a12' is possibly undefined
// 63E2A: variable 'a5' is possibly undefined
// 63E2A: variable 'a6' is possibly undefined
// 40: using guessed type int dword_40;
// C0308: using guessed type void *off_C0308;

//----- (0000000000064130) ----------------------------------------------------
__int64 __fastcall sub_64130(_QWORD *a1, __int64 a2, int a3, __m128 a4, __m128 a5, __m128 a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, unsigned __int64 a13, int a14, int a15, _DWORD *a16, char *a17, unsigned int a18, _BYTE *a19, int a20, char a21)
{
  _DWORD *v21; // rbx
  unsigned __int64 v22; // r15
  unsigned __int64 v23; // r14
  u32 *v24; // r8
  __int64 v25; // rsi
  __int64 v26; // r12
  __int64 v27; // rax
  __int64 v28; // rdx
  __int64 v29; // rcx
  u32 v30; // er9
  double v31; // xmm4_8
  double v32; // xmm5_8
  __int64 v33; // rax
  double v34; // xmm4_8
  double v35; // xmm5_8
  __int64 v36; // rcx
  int v37; // er12
  int v38; // eax
  unsigned __int64 v40; // rbx
  u32 *v41; // r12
  u32 *v42; // r13
  unsigned __int64 v43; // rcx
  u32 *v44; // r15
  unsigned __int64 v45; // r12
  __int64 v46; // r14
  u32 *v47; // rbx
  __int64 v48; // rax
  __int64 v49; // rax
  __int64 v50; // rsi
  __int64 v51; // rdx
  __int64 v52; // rax
  u32 *v53; // rdi
  __m128 *v54; // rax
  __int64 v55; // rsi
  unsigned __int64 v56; // r15
  unsigned int v57; // ecx
  unsigned __int64 *v58; // rdi
  u32 *v59; // r15
  unsigned __int8 v60; // al
  __int64 v61; // r13
  signed int v62; // er11
  __int64 v63; // r9
  unsigned __int64 v64; // r8
  unsigned __int8 v65; // r14
  char v66; // dl
  bool v67; // bl
  unsigned __int64 v68; // rdx
  char v69; // si
  int v70; // er12
  __int64 v71; // rax
  __int64 (__fastcall *v72)(_QWORD *, u32 *, __int64 *); // rax
  unsigned __int64 v73; // rsi
  void *v74; // rsp
  unsigned int v75; // edx
  unsigned __int64 v76; // rdx
  _DWORD *v77; // rax
  unsigned __int64 v78; // rsi
  _DWORD *v79; // rcx
  char v80; // al
  int v81; // ebx
  __int64 v82; // rax
  __int64 v83; // rax
  __int64 v84; // rax
  char **v85; // r12
  unsigned int v86; // esi
  unsigned __int64 v87; // rax
  _QWORD *v88; // r14
  __int64 v89; // rax
  unsigned int v90; // ecx
  unsigned int *v91; // rdi
  unsigned int v92; // edi
  __int64 v93; // rax
  int v94; // ebx
  int v95; // er12
  unsigned int v96; // esi
  __int64 v97; // rax
  unsigned __int64 v98; // rsi
  unsigned __int64 v99; // r14
  unsigned __int64 v100; // r13
  __int64 v101; // r12
  int v102; // edx
  __int64 v103; // rax
  __int64 v104; // rsi
  __int64 v105; // rcx
  __int64 v106; // rax
  char *v107; // r14
  int v108; // eax
  __int64 v109; // r8
  int v110; // eax
  int v111; // ebx
  int v112; // er10
  __m128 *v113; // rax
  __int64 v114; // rcx
  int v115; // eax
  __int64 v116; // rcx
  __int64 v117; // rbx
  u32 *v118; // r8
  int v119; // eax
  int v120; // edi
  _QWORD *v121; // rax
  __int64 v122; // rax
  unsigned __int64 v123; // rsi
  void *v124; // rsp
  int v125; // edi
  unsigned int v126; // edx
  __int64 v127; // rcx
  __int64 v128; // r14
  const char *v129; // rsi
  __int64 v130; // rax
  int v131; // er12
  __int64 v132; // rax
  __int64 v133; // rax
  _DWORD *v134; // rsi
  unsigned __int64 v135; // rdi
  bool v136; // zf
  signed int *v137; // rdx
  int v138; // er12
  __int64 v139; // r12
  __int64 v140; // rax
  unsigned __int64 v141; // rax
  _BOOL4 v142; // edx
  __int64 v143; // rax
  __int64 v144; // rax
  _DWORD *v145; // rsi
  unsigned __int64 v146; // rdi
  signed int *v147; // rdx
  __int64 v148; // rcx
  int v149; // er12
  bool v150; // of
  int v151; // er13
  char *v152; // rcx
  __int64 v153; // rax
  unsigned __int64 v154; // rax
  unsigned __int64 v155; // rdi
  unsigned __int64 v156; // rax
  __int64 v157; // rax
  char *v158; // rax
  __int64 v159; // rax
  unsigned __int64 v160; // rax
  __int64 v161; // rax
  __int64 v162; // rax
  int v163; // edx
  __int64 v164; // rax
  int v165; // er14
  int v166; // er12
  int v167; // eax
  __int64 v168; // rax
  __int64 v169; // rax
  __int64 v170; // rax
  int v171; // edx
  __int64 v172; // rax
  __int64 v173; // rax
  char **v174; // r12
  unsigned int v175; // esi
  unsigned __int64 v176; // rax
  _QWORD *v177; // r14
  __int64 v178; // rax
  int v179; // eax
  __int64 v180; // rax
  __int64 v181; // rax
  _DWORD *v182; // rax
  __int64 v183; // rax
  int v184; // eax
  int v185; // eax
  unsigned __int64 v186; // rbx
  __int64 v187; // rax
  double v188; // xmm4_8
  double v189; // xmm5_8
  unsigned int v190; // esi
  __int64 v191; // rax
  int v192; // ebx
  __int64 v193; // rax
  unsigned int v194; // ecx
  __int64 v195; // rdi
  unsigned __int64 *v196; // rdi
  __int64 v197; // rax
  unsigned int v198; // esi
  int v199; // eax
  unsigned int v200; // esi
  int v201; // eax
  void *v202; // rsp
  int v203; // eax
  int v204; // eax
  int v205; // eax
  int v206; // eax
  int v207; // eax
  __int64 v208; // [rsp+0h] [rbp-960h] BYREF
  char *v209; // [rsp+8h] [rbp-958h]
  __int64 v210; // [rsp+10h] [rbp-950h]
  __int64 v211; // [rsp+18h] [rbp-948h]
  int v212; // [rsp+20h] [rbp-940h]
  int v213; // [rsp+24h] [rbp-93Ch]
  __int64 v214; // [rsp+28h] [rbp-938h]
  __int64 v215; // [rsp+30h] [rbp-930h]
  int v216; // [rsp+38h] [rbp-928h]
  int v217; // [rsp+3Ch] [rbp-924h]
  char *v218; // [rsp+40h] [rbp-920h]
  char *v219; // [rsp+48h] [rbp-918h]
  char *v220; // [rsp+50h] [rbp-910h]
  unsigned __int64 v221; // [rsp+58h] [rbp-908h]
  _BYTE *v222; // [rsp+60h] [rbp-900h]
  int v223; // [rsp+68h] [rbp-8F8h]
  int v224; // [rsp+6Ch] [rbp-8F4h]
  __int64 v225; // [rsp+70h] [rbp-8F0h]
  char *v226; // [rsp+78h] [rbp-8E8h]
  int v227; // [rsp+80h] [rbp-8E0h]
  _BOOL4 v228; // [rsp+84h] [rbp-8DCh]
  unsigned __int64 v229; // [rsp+88h] [rbp-8D8h]
  __int64 v230; // [rsp+90h] [rbp-8D0h]
  unsigned __int64 v231; // [rsp+98h] [rbp-8C8h]
  __m128 *v232; // [rsp+A0h] [rbp-8C0h]
  _QWORD *v233; // [rsp+A8h] [rbp-8B8h]
  unsigned __int64 v234; // [rsp+B0h] [rbp-8B0h]
  u32 *v235; // [rsp+B8h] [rbp-8A8h]
  unsigned __int64 v236; // [rsp+C0h] [rbp-8A0h]
  const __m128i *v237[7]; // [rsp+C8h] [rbp-898h] BYREF
  char *v238; // [rsp+100h] [rbp-860h] BYREF
  unsigned __int64 v239; // [rsp+108h] [rbp-858h]
  char v240[1024]; // [rsp+110h] [rbp-850h] BYREF
  __int64 v241[2]; // [rsp+510h] [rbp-450h] BYREF
  char v242[1032]; // [rsp+520h] [rbp-440h] BYREF
  unsigned __int64 v243; // [rsp+928h] [rbp-38h]

  v233 = a1;
  v231 = a13;
  v218 = a17;
  v215 = a2;
  v223 = a3;
  LODWORD(v230) = a14;
  v222 = a19;
  v243 = __readfsqword(0x28u);
  v219 = v242;
  v226 = v240;
  v238 = v240;
  v239 = 1024LL;
  v241[0] = (__int64)v242;
  v241[1] = 1024LL;
  v236 = 0LL;
  if ( a19 == (_BYTE *)-1LL )
  {
    v93 = *(_QWORD *)__readfsqword(0xFFFFFFB0);
    v94 = *(_DWORD *)(v93 + 96);
    v222 = *(_BYTE **)(v93 + 80);
    a20 = v94;
    if ( !*v222 || *v222 == 127 )
      v222 = 0LL;
  }
  if ( *a16 )
  {
    v21 = a16;
    v22 = 0LL;
    v23 = 0LL;
    v234 = 14LL;
    v24 = (u32 *)v226;
    while ( 1 )
    {
      v25 = v22;
      v26 = (__int64)&v24[18 * v23];
      v235 = v24;
      ++v23;
      v27 = sub_69640((__int64)v21, v22, v26);
      v21 = *(_DWORD **)(v26 + 32);
      v24 = v235;
      v22 += v27;
      if ( !*v21 )
        break;
      if ( v234 == v23 )
      {
        if ( !(unsigned __int8)sub_6BA10(
                                 (__int64)&v238,
                                 *(double *)a4.m128_u64,
                                 *(double *)a5.m128_u64,
                                 *(double *)a6.m128_u64,
                                 a7,
                                 v31,
                                 v32,
                                 a10,
                                 a11,
                                 v25,
                                 v28,
                                 v29,
                                 v235,
                                 v30) )
          goto LABEL_17;
        v24 = (u32 *)v238;
        v234 = v239 / 0x48;
      }
    }
    v40 = v22;
    v41 = v235;
    if ( v236 >= v22 )
      v40 = v236;
  }
  else
  {
    v41 = (u32 *)v226;
    v40 = 0LL;
    v23 = 0LL;
  }
  if ( !(unsigned __int8)sub_6BAD0(v241, v40, 24LL) )
  {
LABEL_17:
    LODWORD(v235) = -1;
    goto LABEL_18;
  }
  v232 = (__m128 *)v241[0];
  v235 = (u32 *)(v241[0] + 16 * v40);
  v42 = &v235[v40];
  v217 = a21 & 2;
  sub_9190((__int64)v42, (unsigned int)-(v217 != 0), 4 * v40);
  if ( !v23 )
  {
    if ( !v40 )
      goto LABEL_405;
LABEL_38:
    v54 = v232;
    v55 = v231;
    v56 = 0LL;
    while ( 1 )
    {
      v43 = v42[v56];
      if ( (int)v43 > 7 )
      {
        if ( (_DWORD)v43 == 263 )
        {
          if ( (a21 & 1) != 0 )
          {
            v194 = *(_DWORD *)(v55 + 4);
            if ( v194 > 0xAF )
            {
              v196 = *(unsigned __int64 **)(v55 + 8);
              v43 = (unsigned __int64)(v196 + 1);
              *(_QWORD *)(v55 + 8) = v196 + 1;
            }
            else
            {
              v195 = v194;
              v43 = v194 + 16;
              v196 = (unsigned __int64 *)(*(_QWORD *)(v55 + 16) + v195);
              *(_DWORD *)(v55 + 4) = v43;
            }
            a4 = (__m128)*v196;
            v54->m128_u64[0] = a4.m128_u64[0];
            v42[v56] &= 0xFFFFFEFF;
          }
          else if ( (a21 & 8) != 0 )
          {
            v92 = *(_DWORD *)(v55 + 4);
            if ( v92 > 0xAF )
            {
              v43 = (*(_QWORD *)(v55 + 8) + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
              *(_QWORD *)(v55 + 8) = v43 + 16;
            }
            else
            {
              v43 = *(_QWORD *)(v55 + 16) + v92;
              *(_DWORD *)(v55 + 4) = v92 + 16;
            }
            a5 = (__m128)_mm_load_si128((const __m128i *)v43);
            *v54 = a5;
          }
          else
          {
            v43 = (*(_QWORD *)(v55 + 8) + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
            *(_QWORD *)(v55 + 8) = v43 + 16;
            *v54 = *(__m128 *)v43;
          }
          goto LABEL_47;
        }
        if ( (int)v43 <= 263 )
        {
          if ( (_DWORD)v43 == 256 )
            goto LABEL_44;
          goto LABEL_117;
        }
        if ( (_DWORD)v43 == 512 )
          goto LABEL_44;
        if ( (_DWORD)v43 == 1024 )
        {
          v90 = *(_DWORD *)v55;
          if ( *(_DWORD *)v55 > 0x2Fu )
          {
            v91 = *(unsigned int **)(v55 + 8);
            *(_QWORD *)(v55 + 8) = v91 + 2;
          }
          else
          {
            v91 = (unsigned int *)(*(_QWORD *)(v55 + 16) + v90);
            *(_DWORD *)v55 = v90 + 8;
          }
          v43 = *v91;
          v54->m128_i32[0] = v43;
          goto LABEL_47;
        }
      }
      else if ( (int)v43 >= -1 )
      {
        if ( (unsigned int)v43 <= 7 )
          __asm { jmp     rcx }
        if ( v217 )
          sub_17110(
            (__int64)"*** invalid %N$ use detected ***\n",
            *(double *)a4.m128_u64,
            *(double *)a5.m128_u64,
            *(double *)a6.m128_u64,
            a7,
            v34,
            v35,
            a10,
            a11);
        sub_CF00(
          (__int64)"(mode_flags & PRINTF_FORTIFY) != 0",
          (__int64)"vfprintf-internal.c",
          0x760u,
          "printf_positional",
          *(double *)a4.m128_u64,
          *(double *)a5.m128_u64,
          *(double *)a6.m128_u64,
          a7,
          v34,
          v35,
          a10,
          a11);
      }
      if ( (v43 & 0x800) != 0 )
      {
LABEL_44:
        v57 = *(_DWORD *)v55;
        if ( *(_DWORD *)v55 > 0x2Fu )
        {
          v58 = *(unsigned __int64 **)(v55 + 8);
          *(_QWORD *)(v55 + 8) = v58 + 1;
        }
        else
        {
          v58 = (unsigned __int64 *)(*(_QWORD *)(v55 + 16) + v57);
          *(_DWORD *)v55 = v57 + 8;
        }
        v43 = *v58;
        v54->m128_u64[0] = *v58;
        goto LABEL_47;
      }
LABEL_117:
      if ( qword_C1B18 && (v43 = (int)v43, *(_QWORD *)(qword_C1B18 + 8LL * (int)v43 - 64)) )
      {
        v231 = (unsigned __int64)v54;
        v234 = v55;
        v202 = alloca((int)v235[v56] + 8LL);
        v54->m128_u64[0] = (unsigned __int64)&v208;
        (*(void (__fastcall **)(__int64 *, __int64, void *))(qword_C1B18 + 8LL * (int)v42[v56] - 64))(
          &v208,
          v55,
          &unk_A3AE0);
        v55 = v234;
        v54 = (__m128 *)v231;
      }
      else
      {
        a4 = 0LL;
        *v54 = 0LL;
      }
LABEL_47:
      ++v56;
      ++v54;
      if ( v56 >= v40 )
        goto LABEL_48;
    }
  }
  v234 = (unsigned __int64)v41;
  v44 = v41;
  v45 = v23;
  v229 = v40;
  v46 = 0LL;
  v47 = v235;
  do
  {
    while ( 1 )
    {
      v48 = (int)v44[11];
      if ( (_DWORD)v48 != -1 )
        v42[v48] = 0;
      v49 = (int)v44[10];
      if ( (_DWORD)v49 != -1 )
        v42[v49] = 0;
      v50 = *((_QWORD *)v44 + 7);
      if ( !v50 )
        goto LABEL_29;
      if ( v50 != 1 )
        break;
      v42[v44[12]] = v44[13];
      v47[v44[12]] = v44[16];
LABEL_29:
      ++v46;
      v44 += 18;
      if ( v46 == v45 )
        goto LABEL_37;
    }
    v51 = (int)v44[12];
    v52 = (int)v44[2];
    ++v46;
    v53 = v44;
    v44 += 18;
    (*(void (__fastcall **)(u32 *, __int64, u32 *, u32 *))(qword_C1B10 + 8 * v52))(v53, v50, &v42[v51], &v47[v51]);
  }
  while ( v46 != v45 );
LABEL_37:
  v40 = v229;
  v23 = v45;
  v41 = (u32 *)v234;
  if ( v229 )
    goto LABEL_38;
LABEL_48:
  v234 = a15;
  if ( v23 > a15 )
  {
    v221 = v23;
    v59 = &v41[18 * v234];
    v220 = v218 + 1000;
    v209 = v218 + 996;
    v211 = 4LL;
    v210 = 0LL;
    v212 = 0;
    LODWORD(v235) = v230;
    while ( 1 )
    {
      v60 = *((_BYTE *)v59 + 12);
      v61 = (int)*v59;
      v62 = v59[2];
      v63 = v60 >> 7;
      v64 = v60 & 1;
      v65 = (v60 & 8) != 0;
      v228 = (v60 & 0x10) != 0;
      LODWORD(v230) = (v60 & 0x20) != 0;
      LODWORD(v229) = (v60 & 0x40) != 0;
      v224 = (v60 & 2) != 0;
      v66 = *((_BYTE *)v59 + 13);
      v67 = (v66 & 8) != 0;
      LODWORD(v225) = (v66 & 2) != 0;
      v68 = (int)v59[11];
      v69 = *((_BYTE *)v59 + 16);
      LODWORD(v231) = (v60 & 4) != 0;
      LOBYTE(v227) = v69;
      if ( (_DWORD)v68 == -1 )
      {
        v70 = v59[1];
      }
      else
      {
        v68 *= 16LL;
        v70 = *(__int32 *)((char *)v232->m128_i32 + v68);
        if ( v70 < 0 )
        {
          LODWORD(v230) = 1;
          v70 = -v70;
          v59[1] = v70;
          *((_BYTE *)v59 + 12) = v60 | 0x20;
        }
        else
        {
          v59[1] = v70;
        }
      }
      v71 = (int)v59[10];
      if ( (_DWORD)v71 != -1 )
      {
        v61 = v232[v71].m128_i32[0];
        if ( (int)v61 < 0 )
        {
          *v59 = -1;
          v61 = -1LL;
        }
        else
        {
          *v59 = v61;
        }
      }
      if ( v62 > 255 )
        break;
      if ( !qword_C1788 )
        break;
      v72 = *(__int64 (__fastcall **)(_QWORD *, u32 *, __int64 *))(qword_C1788 + 8LL * v62);
      v214 = v62;
      if ( !v72 )
        break;
      v123 = *((_QWORD *)v59 + 7);
      v124 = alloca(8 * v123 + 8);
      if ( v123 )
      {
        LOBYTE(v216) = v65;
        v125 = v59[12];
        v126 = 0;
        v127 = 0LL;
        v128 = (__int64)v232;
        do
        {
          *(&v208 + v127) = v128 + 16LL * (v125 + v126++);
          v127 = v126;
        }
        while ( v123 > v126 );
        v65 = v216;
        v72 = *(__int64 (__fastcall **)(_QWORD *, u32 *, __int64 *))(qword_C1788 + 8 * v214);
      }
      v213 = v62;
      LOBYTE(v216) = v64;
      LOBYTE(v214) = v63;
      v110 = v72(v233, v59, &v208);
      v63 = (unsigned __int8)v214;
      v62 = v213;
      v64 = (unsigned __int8)v216;
      if ( v110 == -2 )
        break;
LABEL_160:
      if ( v110 < 0 )
        goto LABEL_17;
      v111 = (int)v235;
      if ( (int)v235 < 0 )
        goto LABEL_18;
      LODWORD(v235) = (_DWORD)v235 + v110;
      if ( __OFADD__(v111, v110) )
        goto LABEL_16;
LABEL_163:
      if ( (int)v235 < 0 )
        goto LABEL_18;
LABEL_153:
      v100 = (char *)&off_C0308 - (char *)&unk_BFAE0;
LABEL_154:
      v98 = *((_QWORD *)v59 + 3);
      v99 = (__int64)(*((_QWORD *)v59 + 4) - v98) >> 2;
LABEL_130:
      v101 = v233[27];
      if ( v100 <= v101 - (__int64)&unk_BFAE0 )
      {
        v231 = v98;
        sub_17140(*(double *)a4.m128_u64, *(double *)a5.m128_u64, *(double *)a6.m128_u64, a7, v34, v35, a10, a11);
        v98 = v231;
      }
      if ( (*(__int64 (__fastcall **)(_QWORD *, unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64, __int64))(v101 + 56))(
             v233,
             v98,
             v99,
             v43,
             v64,
             v63) != v99 )
        goto LABEL_17;
      v102 = 0;
      v103 = v99 + (int)v235;
      if ( v103 < 0 || v103 < v99 )
        v102 = 1;
      LODWORD(v235) = v99 + (_DWORD)v235;
      v43 = 1LL;
      if ( v103 != (int)v103 )
        v102 = 1;
      if ( v102 )
        goto LABEL_16;
      if ( (int)v103 >= 0 )
      {
        ++v234;
        v59 += 18;
        if ( v221 > v234 )
          continue;
      }
      goto LABEL_18;
    }
    switch ( v62 )
    {
      case '%':
        v122 = v233[20];
        if ( v122 && (v68 = *(_QWORD *)(v122 + 32), v68 < *(_QWORD *)(v122 + 40)) )
        {
          v43 = v68 + 4;
          *(_QWORD *)(v122 + 32) = v68 + 4;
          *(_DWORD *)v68 = 37;
        }
        else if ( (unsigned int)sub_6AB50(
                                  (__int64)v233,
                                  0x25u,
                                  v68,
                                  v43,
                                  (u32 *)v64,
                                  v63,
                                  *(double *)a4.m128_u64,
                                  *(double *)a5.m128_u64,
                                  *(double *)a6.m128_u64,
                                  a7,
                                  v34,
                                  v35,
                                  a10,
                                  a11) == -1 )
        {
          goto LABEL_17;
        }
        if ( (_DWORD)v235 == 0x7FFFFFFF )
          goto LABEL_17;
        LODWORD(v235) = (_DWORD)v235 + 1;
        goto LABEL_128;
      case 'A':
      case 'a':
        v237[0] = (const __m128i *)&v232[v59[12]];
        if ( (a21 & 1) != 0 )
          *((_BYTE *)v59 + 12) &= 0xFEu;
        if ( (a21 & 8) == 0 )
          LOBYTE(v64) = 0;
        v118 = (u32 *)(*((_BYTE *)v59 + 13) & 0xEF | (16 * (unsigned int)(v64 & 1)));
        *((_BYTE *)v59 + 13) = (_BYTE)v118;
        v119 = sub_7D370(v233, (unsigned __int64)v59, v237, a4, a5, a6, a7, v34, v35, a10, a11, v43, v118);
        if ( v119 < 0 )
          goto LABEL_17;
        v120 = (int)v235;
        if ( (int)v235 < 0 )
          goto LABEL_18;
        LODWORD(v235) = (_DWORD)v235 + v119;
        if ( __OFADD__(v120, v119) )
          goto LABEL_16;
        goto LABEL_163;
      case 'C':
        goto LABEL_122;
      case 'E':
      case 'F':
      case 'G':
      case 'e':
      case 'f':
      case 'g':
        v237[0] = (const __m128i *)&v232[v59[12]];
        if ( (a21 & 1) != 0 )
        {
          *((_BYTE *)v59 + 12) &= 0xFEu;
          v59[13] = 7;
        }
        if ( (a21 & 8) == 0 )
          LOBYTE(v64) = 0;
        v108 = 16 * (v64 & 1);
        v109 = v108 | *((_BYTE *)v59 + 13) & 0xEFu;
        *((_BYTE *)v59 + 13) = v108 | *((_BYTE *)v59 + 13) & 0xEF;
        v110 = sub_7D1B0(v233, (__int64)v59, v237, (__m128i)a4, a5, (__m128i)a6, a7, v34, v35, a10, a11, v43, v109, v63);
        goto LABEL_160;
      case 'S':
      case 's':
        v107 = (char *)v232[v59[12]].m128_u64[0];
        goto LABEL_149;
      case 'X':
      case 'x':
        v112 = 16;
        goto LABEL_166;
      case 'c':
        v104 = (unsigned int)v231;
        if ( (_DWORD)v231 )
        {
LABEL_122:
          v95 = v70 - 1;
          if ( !(_DWORD)v230 )
          {
            if ( v95 > 0 )
            {
              if ( v95 != sub_6A3E0(
                            (__int64)v233,
                            32,
                            v95,
                            *(double *)a4.m128_u64,
                            *(double *)a5.m128_u64,
                            *(double *)a6.m128_u64,
                            a7,
                            v34,
                            v35,
                            a10,
                            a11) )
                goto LABEL_17;
              v185 = (int)v235;
              if ( (int)v235 < 0 )
                goto LABEL_18;
              LODWORD(v235) = (_DWORD)v235 + v95;
              if ( __OFADD__(v185, v95) )
                goto LABEL_16;
            }
            if ( (int)v235 < 0 )
              goto LABEL_18;
          }
          v96 = v232[v59[12]].m128_u32[0];
          v97 = v233[20];
          if ( !v97 )
            goto LABEL_146;
        }
        else
        {
          v105 = (unsigned int)v230;
          v95 = v70 - 1;
          if ( !(_DWORD)v230 )
          {
            if ( v95 > 0 )
            {
              v104 = 32LL;
              if ( v95 != sub_6A3E0(
                            (__int64)v233,
                            32,
                            v95,
                            *(double *)a4.m128_u64,
                            *(double *)a5.m128_u64,
                            *(double *)a6.m128_u64,
                            a7,
                            v34,
                            v35,
                            a10,
                            a11) )
                goto LABEL_17;
              v205 = (int)v235;
              if ( (int)v235 < 0 )
                goto LABEL_18;
              LODWORD(v235) = (_DWORD)v235 + v95;
              if ( __OFADD__(v205, v95) )
                goto LABEL_16;
            }
            v68 = (unsigned int)v235;
            if ( (int)v235 < 0 )
              goto LABEL_18;
          }
          v96 = sub_6CEC0(
                  v232[v59[12]].m128_u8[0],
                  v104,
                  *(double *)a4.m128_u64,
                  *(double *)a5.m128_u64,
                  *(double *)a6.m128_u64,
                  a7,
                  v34,
                  v35,
                  a10,
                  a11,
                  v68,
                  v105,
                  (u32 *)v64,
                  v63);
          v97 = v233[20];
          if ( !v97 )
            goto LABEL_146;
        }
        v68 = *(_QWORD *)(v97 + 32);
        if ( v68 < *(_QWORD *)(v97 + 40) )
        {
          v43 = v68 + 4;
          *(_QWORD *)(v97 + 32) = v68 + 4;
          *(_DWORD *)v68 = v96;
          if ( v96 == -1 )
            goto LABEL_17;
          goto LABEL_126;
        }
LABEL_146:
        if ( (unsigned int)sub_6AB50(
                             (__int64)v233,
                             v96,
                             v68,
                             v43,
                             (u32 *)v64,
                             v63,
                             *(double *)a4.m128_u64,
                             *(double *)a5.m128_u64,
                             *(double *)a6.m128_u64,
                             a7,
                             v34,
                             v35,
                             a10,
                             a11) == -1 )
          goto LABEL_17;
LABEL_126:
        if ( (_DWORD)v235 == 0x7FFFFFFF )
          goto LABEL_17;
        LODWORD(v235) = (_DWORD)v235 + 1;
        if ( !(_DWORD)v230 )
        {
LABEL_128:
          v98 = *((_QWORD *)v59 + 3);
          v99 = (__int64)(*((_QWORD *)v59 + 4) - v98) >> 2;
          if ( (int)v235 < 0 )
            goto LABEL_384;
          v100 = (char *)&off_C0308 - (char *)&unk_BFAE0;
          goto LABEL_130;
        }
        if ( v95 > 0 )
        {
          if ( v95 != sub_6A3E0(
                        (__int64)v233,
                        32,
                        v95,
                        *(double *)a4.m128_u64,
                        *(double *)a5.m128_u64,
                        *(double *)a6.m128_u64,
                        a7,
                        v34,
                        v35,
                        a10,
                        a11) )
            goto LABEL_17;
          v179 = (int)v235;
          if ( (int)v235 < 0 )
            goto LABEL_18;
          LODWORD(v235) = (_DWORD)v235 + v95;
          if ( __OFADD__(v179, v95) )
            goto LABEL_16;
        }
        goto LABEL_163;
      case 'd':
      case 'i':
        v64 = (unsigned int)v231;
        if ( (_DWORD)v231 )
        {
          v114 = v232[v59[12]].m128_i64[0];
        }
        else
        {
          LODWORD(v114) = v232[v59[12]].m128_i32[0];
          if ( (_DWORD)v225 )
          {
            v114 = (char)v114;
          }
          else
          {
            v183 = (int)v114;
            v114 = (__int16)v114;
            if ( !v224 )
              v114 = v183;
          }
        }
        if ( v114 < 0 )
        {
          LODWORD(v231) = 1;
          v114 = -v114;
        }
        else
        {
          LODWORD(v231) = 0;
        }
        v112 = 10;
        goto LABEL_168;
      case 'm':
        LODWORD(v229) = v62;
        v106 = sub_23140(
                 a18,
                 v218,
                 1000LL,
                 *(double *)a4.m128_u64,
                 *(double *)a5.m128_u64,
                 *(double *)a6.m128_u64,
                 a7,
                 v34,
                 v35,
                 a10,
                 a11);
        v62 = v229;
        LODWORD(v231) = 0;
        v107 = (char *)v106;
LABEL_149:
        if ( !v107 )
        {
          if ( (_DWORD)v61 == -1 || (int)v61 > 5 )
          {
            LODWORD(v33) = 6;
            v36 = 6LL;
            v107 = (char *)&unk_A3B60;
          }
          else
          {
            LODWORD(v33) = 0;
            v36 = 0LL;
            v107 = (char *)&unk_A3AC8;
          }
          goto LABEL_10;
        }
        if ( !(_DWORD)v231 && v62 != 83 )
        {
          LODWORD(v235) = sub_63D80(
                            (__int64)v233,
                            (__int64)v107,
                            v61,
                            v70,
                            (unsigned int)v230,
                            (unsigned int)v235,
                            *(double *)a4.m128_u64,
                            *(double *)a5.m128_u64,
                            *(double *)a6.m128_u64,
                            a7,
                            v34,
                            v35,
                            a10,
                            a11);
          if ( (int)v235 < 0 )
            goto LABEL_18;
          goto LABEL_153;
        }
        if ( (_DWORD)v61 != -1 )
          goto LABEL_9;
        v33 = sub_90D0(v107);
        v36 = v33;
        goto LABEL_10;
      case 'n':
        if ( v217 )
        {
          if ( !v223 )
          {
            v186 = v215;
            v187 = sub_90D0(v215);
            v223 = sub_6EE40(
                     v186,
                     4 * v187 + 4,
                     *(double *)a4.m128_u64,
                     *(double *)a5.m128_u64,
                     *(double *)a6.m128_u64,
                     a7,
                     v188,
                     v189,
                     a10,
                     a11);
          }
          if ( v223 < 0 )
            sub_17110(
              (__int64)"*** %n in writable segment detected ***\n",
              *(double *)a4.m128_u64,
              *(double *)a5.m128_u64,
              *(double *)a6.m128_u64,
              a7,
              v34,
              v35,
              a10,
              a11);
        }
        v63 = (unsigned int)v231;
        v121 = (_QWORD *)v232[v59[12]].m128_u64[0];
        if ( (_DWORD)v231 )
        {
          *v121 = (int)v235;
        }
        else
        {
          v64 = (unsigned int)v225;
          if ( (_DWORD)v225 )
          {
            *(_BYTE *)v121 = (_BYTE)v235;
          }
          else if ( v224 )
          {
            *(_WORD *)v121 = (_WORD)v235;
          }
          else
          {
            *(_DWORD *)v121 = (_DWORD)v235;
          }
        }
        goto LABEL_128;
      case 'o':
        v112 = 8;
        goto LABEL_166;
      case 'p':
        v114 = v232[v59[12]].m128_i64[0];
        if ( v114 )
        {
          if ( (int)v61 < 0 )
          {
            v225 = v232[v59[12]].m128_i64[0];
            LODWORD(v63) = 0;
            v62 = 120;
            v129 = "0";
            v224 = 1;
            v61 = 1LL;
            LODWORD(v231) = 0;
            goto LABEL_318;
          }
          if ( !(_DWORD)v61 )
          {
            v115 = 0;
            v112 = 16;
            LODWORD(v231) = 0;
            v62 = 120;
            v224 = 1;
            goto LABEL_179;
          }
          v112 = 16;
          v115 = 0;
          v62 = 120;
          v224 = 1;
          LODWORD(v231) = 0;
          goto LABEL_299;
        }
        v107 = "(";
        if ( (int)v61 < 5 )
          LODWORD(v61) = 5;
LABEL_9:
        v33 = sub_91A0(v107, (int)v61);
        v36 = v33;
LABEL_10:
        v37 = v70 - v33;
        if ( v37 < 0 )
        {
          if ( (int)v235 < 0 )
LABEL_384:
            sub_63D50(*(double *)a4.m128_u64, *(double *)a5.m128_u64, *(double *)a6.m128_u64, a7, v34, v35, a10, a11);
          goto LABEL_253;
        }
        if ( (_DWORD)v230 )
        {
          if ( (int)v235 < 0 )
            goto LABEL_384;
        }
        else
        {
          if ( v37 )
          {
            v231 = v36;
            if ( v37 != sub_6A3E0(
                          (__int64)v233,
                          32,
                          v37,
                          *(double *)a4.m128_u64,
                          *(double *)a5.m128_u64,
                          *(double *)a6.m128_u64,
                          a7,
                          v34,
                          v35,
                          a10,
                          a11) )
              goto LABEL_17;
            v38 = (int)v235;
            if ( (int)v235 < 0 )
              goto LABEL_18;
            v36 = v231;
            LODWORD(v235) = (_DWORD)v235 + v37;
            if ( __OFADD__(v38, v37) )
              goto LABEL_16;
          }
          if ( (int)v235 < 0 )
            goto LABEL_18;
        }
        v169 = v233[27];
        v100 = (char *)&off_C0308 - (char *)&unk_BFAE0;
        if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v169 - (_QWORD)&unk_BFAE0) )
        {
          v229 = v233[27];
          v231 = v36;
          sub_17140(*(double *)a4.m128_u64, *(double *)a5.m128_u64, *(double *)a6.m128_u64, a7, v34, v35, a10, a11);
          v36 = v231;
          v169 = v229;
        }
        v231 = v36;
        v170 = (*(__int64 (__fastcall **)(_QWORD *, char *, __int64))(v169 + 56))(v233, v107, v36);
        if ( v231 != v170 )
          goto LABEL_17;
        v171 = 0;
        v172 = v231 + (int)v235;
        if ( v172 < 0 || v172 < v231 )
          v171 = 1;
        LODWORD(v235) = v231 + (_DWORD)v235;
        v43 = 1LL;
        if ( v172 != (int)v172 )
          v171 = 1;
        if ( v171 )
          goto LABEL_16;
        if ( (int)v172 < 0 )
          goto LABEL_18;
        v64 = (unsigned int)v230;
        if ( (_DWORD)v230 && v37 )
        {
          if ( v37 != sub_6A3E0(
                        (__int64)v233,
                        32,
                        v37,
                        *(double *)a4.m128_u64,
                        *(double *)a5.m128_u64,
                        *(double *)a6.m128_u64,
                        a7,
                        v34,
                        v35,
                        a10,
                        a11) )
            goto LABEL_17;
          v150 = __OFADD__((_DWORD)v235, v37);
          LODWORD(v235) = (_DWORD)v235 + v37;
          LODWORD(v141) = (_DWORD)v235;
          if ( v150 )
            goto LABEL_16;
          goto LABEL_259;
        }
        goto LABEL_154;
      case 'u':
        v112 = 10;
LABEL_166:
        v68 = (unsigned int)v231;
        v113 = &v232[v59[12]];
        if ( (_DWORD)v231 )
        {
          LODWORD(v229) = 0;
          v114 = v113->m128_u64[0];
          v228 = 0;
          LODWORD(v231) = 0;
        }
        else
        {
          v114 = v113->m128_u32[0];
          if ( (_DWORD)v225 )
          {
            LODWORD(v229) = 0;
            v114 = (unsigned __int8)v114;
            v228 = 0;
          }
          else
          {
            if ( v224 )
              v114 = (unsigned __int16)v114;
            LODWORD(v229) = 0;
            v228 = 0;
          }
        }
LABEL_168:
        v224 = v65;
        v115 = (unsigned __int8)v63;
        if ( (int)v61 < 0 )
        {
          v61 = 1LL;
        }
        else if ( (_DWORD)v61 )
        {
LABEL_299:
          LOBYTE(v227) = 32;
          LODWORD(v63) = v115 & 1;
        }
        else
        {
          if ( !v114 )
          {
            if ( v112 == 8 && v65 )
            {
              v116 = v211;
              v61 = v212;
              LODWORD(v117) = v210;
              *((_DWORD *)v218 + 249) = 48;
              if ( v116 < 0 )
              {
                LOBYTE(v227) = 32;
                v107 = v209;
                v225 = 0LL;
                goto LABEL_227;
              }
              LOBYTE(v227) = 32;
              v116 = v211;
              v112 = 8;
              v107 = v209;
            }
            else
            {
              LOBYTE(v227) = 32;
              v107 = v220;
              LODWORD(v117) = 0;
              v116 = 0LL;
            }
            goto LABEL_264;
          }
LABEL_179:
          LOBYTE(v227) = 32;
          v61 = 0LL;
          LODWORD(v63) = v115 & 1;
        }
        v129 = "0";
        LOBYTE(v115) = v222 != 0LL;
        LODWORD(v63) = v115 & v63;
        if ( v62 != 88 )
          v129 = "0";
        if ( v112 == 10 )
        {
          v107 = v220;
          v155 = v114;
          do
          {
            v107 -= 4;
            v68 = v155 / 0xA;
            v64 = v155 % 0xA;
            *(_DWORD *)v107 = *(_DWORD *)&v129[4 * (v155 % 0xA)];
            v156 = v155;
            v155 /= 0xAuLL;
          }
          while ( v156 > 9 );
          v225 = v114;
          if ( !(_BYTE)v63 )
          {
LABEL_306:
            if ( v112 == 10 && v67 )
            {
              v216 = 10;
              LODWORD(v214) = v62;
              v158 = sub_63BE0(v107, (__int64)v220, v220);
              v112 = v216;
              v62 = v214;
              v107 = v158;
            }
LABEL_223:
            v116 = v220 - v107;
            v130 = (v220 - v107) >> 2;
            if ( v130 < v61 )
            {
              LODWORD(v117) = v61 - v130;
              if ( v61 - v130 < 0 )
                LODWORD(v117) = 0;
              v61 = (int)v117;
LABEL_227:
              LODWORD(v63) = v230;
              if ( (_DWORD)v230 )
                goto LABEL_266;
              v36 = v116 >> 2;
              v131 = v70 - v117 - v36;
              if ( v225 )
              {
                v68 = v224 & 1;
LABEL_230:
                if ( v112 == 16 && (_BYTE)v68 )
                  v131 -= 2;
              }
LABEL_233:
              if ( (unsigned int)v229 | v228 | (unsigned int)v231 )
              {
                --v131;
                if ( (_BYTE)v227 != 32 )
                  goto LABEL_235;
              }
              else if ( (_BYTE)v227 != 32 )
              {
                goto LABEL_241;
              }
              if ( v131 > 0 )
              {
                v214 = v36;
                v227 = v112;
                LODWORD(v230) = v62;
                if ( v131 != sub_6A3E0(
                               (__int64)v233,
                               32,
                               v131,
                               *(double *)a4.m128_u64,
                               *(double *)a5.m128_u64,
                               *(double *)a6.m128_u64,
                               a7,
                               v34,
                               v35,
                               a10,
                               a11) )
                  goto LABEL_17;
                v184 = (int)v235;
                if ( (int)v235 < 0 )
                  goto LABEL_18;
                v62 = v230;
                v112 = v227;
                LODWORD(v235) = (_DWORD)v235 + v131;
                v36 = v214;
                if ( __OFADD__(v184, v131) )
                  goto LABEL_16;
              }
              if ( (int)v235 < 0 )
                goto LABEL_18;
              v131 = 0;
LABEL_235:
              if ( (_DWORD)v231 )
              {
                v132 = v233[20];
                if ( v132 )
                {
                  v68 = *(_QWORD *)(v132 + 32);
                  if ( v68 < *(_QWORD *)(v132 + 40) )
                  {
                    *(_QWORD *)(v132 + 32) = v68 + 4;
                    *(_DWORD *)v68 = 45;
LABEL_239:
                    if ( (_DWORD)v235 == 0x7FFFFFFF )
                      goto LABEL_17;
                    LODWORD(v235) = (_DWORD)v235 + 1;
LABEL_241:
                    if ( !v225 || v112 != 16 || (v224 & 1) == 0 )
                    {
LABEL_251:
                      v138 = v61 + v131;
                      if ( v138 > 0 )
                      {
                        v231 = v36;
                        if ( v138 != sub_6A3E0(
                                       (__int64)v233,
                                       48,
                                       v138,
                                       *(double *)a4.m128_u64,
                                       *(double *)a5.m128_u64,
                                       *(double *)a6.m128_u64,
                                       a7,
                                       v34,
                                       v35,
                                       a10,
                                       a11) )
                          goto LABEL_17;
                        v167 = (int)v235;
                        if ( (int)v235 < 0 )
                          goto LABEL_18;
                        v36 = v231;
                        LODWORD(v235) = (_DWORD)v235 + v138;
                        if ( __OFADD__(v167, v138) )
                          goto LABEL_16;
                      }
                      if ( (int)v235 < 0 )
                        goto LABEL_18;
LABEL_253:
                      v139 = v233[27];
                      v100 = (char *)&off_C0308 - (char *)&unk_BFAE0;
                      if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v139 - (_QWORD)&unk_BFAE0) )
                      {
                        v231 = v36;
                        sub_17140(
                          *(double *)a4.m128_u64,
                          *(double *)a5.m128_u64,
                          *(double *)a6.m128_u64,
                          a7,
                          v34,
                          v35,
                          a10,
                          a11);
                        v36 = v231;
                      }
                      v231 = v36;
                      v140 = (*(__int64 (__fastcall **)(_QWORD *, char *, __int64))(v139 + 56))(v233, v107, v36);
                      if ( v231 != v140 )
                        goto LABEL_17;
                      v141 = v231 + (int)v235;
                      LODWORD(v235) = v231 + (_DWORD)v235;
                      v43 = 1LL;
                      v142 = v141 + 0x8000000000000000LL < v231;
                      if ( v141 != (int)v141 )
                        v142 = 1;
                      if ( v142 )
                        goto LABEL_16;
LABEL_259:
                      if ( (v141 & 0x80000000) != 0LL )
                        goto LABEL_18;
                      goto LABEL_154;
                    }
                    v133 = v233[20];
                    if ( v133
                      && (v134 = *(_DWORD **)(v133 + 32), v135 = *(_QWORD *)(v133 + 40), (unsigned __int64)v134 < v135) )
                    {
                      v136 = (_DWORD)v235 == 0x7FFFFFFF;
                      v137 = v134 + 1;
                      *(_QWORD *)(v133 + 32) = v134 + 1;
                      *v134 = 48;
                      if ( v136 )
                        goto LABEL_17;
                    }
                    else
                    {
                      v230 = v36;
                      LODWORD(v231) = v62;
                      v204 = sub_6AB50(
                               (__int64)v233,
                               0x30u,
                               v68,
                               v36,
                               (u32 *)v64,
                               v63,
                               *(double *)a4.m128_u64,
                               *(double *)a5.m128_u64,
                               *(double *)a6.m128_u64,
                               a7,
                               v34,
                               v35,
                               a10,
                               a11);
                      v62 = v231;
                      v36 = v230;
                      if ( v204 == -1 || (_DWORD)v235 == 0x7FFFFFFF )
                        goto LABEL_17;
                      v133 = v233[20];
                      if ( !v133 )
                        goto LABEL_480;
                      v137 = *(signed int **)(v133 + 32);
                      v135 = *(_QWORD *)(v133 + 40);
                    }
                    if ( (unsigned __int64)v137 < v135 )
                    {
                      *(_QWORD *)(v133 + 32) = v137 + 1;
                      *v137 = v62;
LABEL_249:
                      if ( (_DWORD)v235 == 2147483646 )
                        goto LABEL_17;
                      LODWORD(v235) = (_DWORD)v235 + 2;
                      goto LABEL_251;
                    }
LABEL_480:
                    v231 = v36;
                    v203 = sub_6AB50(
                             (__int64)v233,
                             v62,
                             (__int64)v137,
                             v36,
                             (u32 *)v64,
                             v63,
                             *(double *)a4.m128_u64,
                             *(double *)a5.m128_u64,
                             *(double *)a6.m128_u64,
                             a7,
                             v34,
                             v35,
                             a10,
                             a11);
                    v36 = v231;
                    if ( v203 == -1 )
                      goto LABEL_17;
                    goto LABEL_249;
                  }
                }
                v229 = v36;
                v200 = 45;
                LODWORD(v230) = v112;
                LODWORD(v231) = v62;
              }
              else
              {
                v68 = (unsigned int)v229;
                if ( (_DWORD)v229 )
                {
                  v168 = v233[20];
                  if ( v168 )
                  {
                    v68 = *(_QWORD *)(v168 + 32);
                    if ( v68 < *(_QWORD *)(v168 + 40) )
                    {
                      *(_QWORD *)(v168 + 32) = v68 + 4;
                      *(_DWORD *)v68 = 43;
                      goto LABEL_239;
                    }
                  }
                  v229 = v36;
                  v200 = 43;
                  LODWORD(v230) = v112;
                  LODWORD(v231) = v62;
                }
                else
                {
                  if ( !v228 )
                    goto LABEL_241;
                  v197 = v233[20];
                  if ( v197 )
                  {
                    v68 = *(_QWORD *)(v197 + 32);
                    if ( v68 < *(_QWORD *)(v197 + 40) )
                    {
                      *(_QWORD *)(v197 + 32) = v68 + 4;
                      *(_DWORD *)v68 = 32;
                      goto LABEL_239;
                    }
                  }
                  v229 = v36;
                  v200 = 32;
                  LODWORD(v230) = v112;
                  LODWORD(v231) = v62;
                }
              }
              v201 = sub_6AB50(
                       (__int64)v233,
                       v200,
                       v68,
                       v36,
                       (u32 *)v64,
                       v63,
                       *(double *)a4.m128_u64,
                       *(double *)a5.m128_u64,
                       *(double *)a6.m128_u64,
                       a7,
                       v34,
                       v35,
                       a10,
                       a11);
              v62 = v231;
              v112 = v230;
              v36 = v229;
              if ( v201 == -1 )
                goto LABEL_17;
              goto LABEL_239;
            }
            if ( v225 )
            {
              v68 = v224 & 1;
              if ( v112 == 8 && (_BYTE)v68 )
              {
                v152 = v220;
                *((_DWORD *)v107 - 1) = 48;
                v107 -= 4;
                v116 = v152 - v107;
              }
              v153 = v116 >> 2;
              v117 = v61 - (v116 >> 2);
              if ( v117 < 0 )
                LODWORD(v117) = 0;
              v61 = (int)v117;
              if ( (_DWORD)v230 )
                goto LABEL_266;
              v36 = v116 >> 2;
              v131 = v70 - v153 - v117;
              goto LABEL_230;
            }
            LODWORD(v117) = v61 - v130;
            if ( v61 - v130 < 0 )
              LODWORD(v117) = v225;
            v61 = (int)v117;
LABEL_264:
            v64 = (unsigned int)v230;
            if ( (_DWORD)v230 )
            {
              v225 = 0LL;
LABEL_266:
              if ( (_DWORD)v231 )
              {
                v143 = v233[20];
                if ( v143 )
                {
                  v68 = *(_QWORD *)(v143 + 32);
                  if ( v68 < *(_QWORD *)(v143 + 40) )
                  {
                    *(_QWORD *)(v143 + 32) = v68 + 4;
                    *(_DWORD *)v68 = 45;
                    goto LABEL_270;
                  }
                }
                LODWORD(v229) = v112;
                v198 = 45;
                v230 = v116;
                LODWORD(v231) = v62;
LABEL_460:
                v199 = sub_6AB50(
                         (__int64)v233,
                         v198,
                         v68,
                         v116,
                         (u32 *)v64,
                         v63,
                         *(double *)a4.m128_u64,
                         *(double *)a5.m128_u64,
                         *(double *)a6.m128_u64,
                         a7,
                         v34,
                         v35,
                         a10,
                         a11);
                v62 = v231;
                v116 = v230;
                v112 = v229;
                if ( v199 == -1 )
                  goto LABEL_17;
                goto LABEL_270;
              }
              if ( (_DWORD)v229 )
              {
                v159 = v233[20];
                if ( !v159 || (v68 = *(_QWORD *)(v159 + 32), v68 >= *(_QWORD *)(v159 + 40)) )
                {
                  LODWORD(v229) = v112;
                  v198 = 43;
                  v230 = v116;
                  LODWORD(v231) = v62;
                  goto LABEL_460;
                }
                *(_QWORD *)(v159 + 32) = v68 + 4;
                *(_DWORD *)v68 = 43;
LABEL_270:
                if ( (_DWORD)v235 == 0x7FFFFFFF )
                  goto LABEL_17;
                --v70;
                LODWORD(v235) = (_DWORD)v235 + 1;
              }
              else if ( v228 )
              {
                v180 = v233[20];
                if ( !v180 || (v68 = *(_QWORD *)(v180 + 32), v68 >= *(_QWORD *)(v180 + 40)) )
                {
                  LODWORD(v229) = v112;
                  v198 = 32;
                  v230 = v116;
                  LODWORD(v231) = v62;
                  goto LABEL_460;
                }
                *(_QWORD *)(v180 + 32) = v68 + 4;
                *(_DWORD *)v68 = 32;
                goto LABEL_270;
              }
              if ( v225 && v112 == 16 && (v224 & 1) != 0 )
              {
                v144 = v233[20];
                if ( v144
                  && (v145 = *(_DWORD **)(v144 + 32), v146 = *(_QWORD *)(v144 + 40), (unsigned __int64)v145 < v146) )
                {
                  v136 = (_DWORD)v235 == 0x7FFFFFFF;
                  v147 = v145 + 1;
                  *(_QWORD *)(v144 + 32) = v145 + 1;
                  *v145 = 48;
                  if ( v136 )
                    goto LABEL_17;
LABEL_278:
                  if ( (unsigned __int64)v147 < v146 )
                  {
                    *(_QWORD *)(v144 + 32) = v147 + 1;
                    *v147 = v62;
                    goto LABEL_280;
                  }
                }
                else
                {
                  v230 = v116;
                  LODWORD(v231) = v62;
                  v207 = sub_6AB50(
                           (__int64)v233,
                           0x30u,
                           v68,
                           v116,
                           (u32 *)v64,
                           v63,
                           *(double *)a4.m128_u64,
                           *(double *)a5.m128_u64,
                           *(double *)a6.m128_u64,
                           a7,
                           v34,
                           v35,
                           a10,
                           a11);
                  v62 = v231;
                  v116 = v230;
                  if ( v207 == -1 || (_DWORD)v235 == 0x7FFFFFFF )
                    goto LABEL_17;
                  v144 = v233[20];
                  if ( v144 )
                  {
                    v147 = *(signed int **)(v144 + 32);
                    v146 = *(_QWORD *)(v144 + 40);
                    goto LABEL_278;
                  }
                }
                v231 = v116;
                v206 = sub_6AB50(
                         (__int64)v233,
                         v62,
                         (__int64)v147,
                         v116,
                         (u32 *)v64,
                         v63,
                         *(double *)a4.m128_u64,
                         *(double *)a5.m128_u64,
                         *(double *)a6.m128_u64,
                         a7,
                         v34,
                         v35,
                         a10,
                         a11);
                v116 = v231;
                if ( v206 == -1 )
                  goto LABEL_17;
LABEL_280:
                if ( (_DWORD)v235 == 2147483646 )
                  goto LABEL_17;
                v70 -= 2;
                LODWORD(v235) = (_DWORD)v235 + 2;
              }
              v148 = v116 >> 2;
              v149 = v70 - (v148 + v117);
              if ( (int)v61 <= 0 )
              {
                if ( (int)v235 < 0 )
                  goto LABEL_384;
              }
              else
              {
                v231 = v148;
                if ( v61 != sub_6A3E0(
                              (__int64)v233,
                              48,
                              v61,
                              *(double *)a4.m128_u64,
                              *(double *)a5.m128_u64,
                              *(double *)a6.m128_u64,
                              a7,
                              v34,
                              v35,
                              a10,
                              a11) )
                  goto LABEL_17;
                if ( (int)v235 < 0 )
                  goto LABEL_18;
                v150 = __OFADD__((_DWORD)v235, (_DWORD)v61);
                v151 = (_DWORD)v235 + v61;
                LODWORD(v235) = v151;
                if ( v150 )
                  goto LABEL_16;
                v148 = v231;
                if ( v151 < 0 )
                  goto LABEL_18;
              }
              v161 = v233[27];
              v100 = (char *)&off_C0308 - (char *)&unk_BFAE0;
              if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v161 - (_QWORD)&unk_BFAE0) )
              {
                v230 = v148;
                v231 = v161;
                sub_17140(
                  *(double *)a4.m128_u64,
                  *(double *)a5.m128_u64,
                  *(double *)a6.m128_u64,
                  a7,
                  v34,
                  v35,
                  a10,
                  a11);
                v161 = v231;
                v148 = v230;
              }
              v231 = v148;
              v162 = (*(__int64 (__fastcall **)(_QWORD *, char *, __int64))(v161 + 56))(v233, v107, v148);
              if ( v162 != v231 )
                goto LABEL_17;
              v163 = 0;
              v164 = v231 + (int)v235;
              if ( v164 < 0 || v164 < v231 )
                v163 = 1;
              LODWORD(v235) = v231 + (_DWORD)v235;
              v165 = v164;
              v43 = 1LL;
              if ( v164 != (int)v164 )
                v163 = 1;
              if ( v163 )
                goto LABEL_16;
              if ( (int)v164 < 0 )
                goto LABEL_18;
              if ( v149 > 0 )
              {
                if ( v149 != sub_6A3E0(
                               (__int64)v233,
                               32,
                               v149,
                               *(double *)a4.m128_u64,
                               *(double *)a5.m128_u64,
                               *(double *)a6.m128_u64,
                               a7,
                               v34,
                               v35,
                               a10,
                               a11) )
                  goto LABEL_17;
                v150 = __OFADD__(v165, v149);
                v166 = v165 + v149;
                LODWORD(v235) = v166;
                if ( v150 )
                  goto LABEL_16;
                if ( v166 < 0 )
                  goto LABEL_18;
              }
              goto LABEL_154;
            }
            v36 = v116 >> 2;
            v225 = 0LL;
            v131 = v70 - v117 - v36;
            goto LABEL_233;
          }
        }
        else
        {
          if ( v112 == 16 )
          {
            v225 = v114;
LABEL_318:
            v107 = v220;
            do
            {
              v107 -= 4;
              *(_DWORD *)v107 = *(_DWORD *)&v129[4 * (v114 & 0xF)];
              v160 = v114;
              v114 = (unsigned __int64)v114 >> 4;
            }
            while ( v160 > 0xF );
            v112 = 16;
          }
          else
          {
            v107 = v220;
            v154 = v114;
            do
            {
              v107 -= 4;
              *(_DWORD *)v107 = *(_DWORD *)&v129[4 * (v154 & 7)];
              v68 = v154;
              v154 >>= 3;
            }
            while ( v68 > 7 );
            v225 = v114;
          }
          if ( !(_BYTE)v63 )
            goto LABEL_223;
        }
        v216 = v112;
        LODWORD(v214) = v62;
        v157 = sub_63B00((__int64)v218, (__int64)v107, (__int64)v220, v222, a20);
        v112 = v216;
        v62 = v214;
        v107 = (char *)v157;
        goto LABEL_306;
      default:
        v73 = *((_QWORD *)v59 + 7);
        v74 = alloca(8 * v73 + 8);
        if ( v73 )
        {
          v64 = v59[12];
          v63 = (__int64)v232;
          v75 = 0;
          v43 = 0LL;
          do
          {
            *(&v208 + v43) = v63 + 16LL * ((unsigned int)v64 + v75++);
            v43 = v75;
          }
          while ( v73 > v75 );
        }
        v76 = v233[20];
        if ( v76 && (v77 = *(_DWORD **)(v76 + 32), v78 = *(_QWORD *)(v76 + 40), (unsigned __int64)v77 < v78) )
        {
          v79 = v77 + 1;
          *(_QWORD *)(v76 + 32) = v77 + 1;
          *v77 = 37;
          v80 = *((_BYTE *)v59 + 12);
          if ( (v80 & 8) == 0 )
          {
            v81 = 1;
            if ( v80 >= 0 )
              goto LABEL_68;
            goto LABEL_414;
          }
        }
        else
        {
          if ( (unsigned int)sub_6AB50(
                               (__int64)v233,
                               0x25u,
                               v76,
                               v43,
                               (u32 *)v64,
                               v63,
                               *(double *)a4.m128_u64,
                               *(double *)a5.m128_u64,
                               *(double *)a6.m128_u64,
                               a7,
                               v34,
                               v35,
                               a10,
                               a11) == -1 )
            goto LABEL_17;
          v80 = *((_BYTE *)v59 + 12);
          if ( (v80 & 8) == 0 )
          {
            v81 = 1;
            goto LABEL_472;
          }
          v76 = v233[20];
          if ( !v76 )
          {
LABEL_470:
            if ( (unsigned int)sub_6AB50(
                                 (__int64)v233,
                                 0x23u,
                                 v76,
                                 (__int64)v79,
                                 (u32 *)v64,
                                 v63,
                                 *(double *)a4.m128_u64,
                                 *(double *)a5.m128_u64,
                                 *(double *)a6.m128_u64,
                                 a7,
                                 v34,
                                 v35,
                                 a10,
                                 a11) == -1 )
              goto LABEL_17;
            v80 = *((_BYTE *)v59 + 12);
            v81 = 2;
LABEL_472:
            if ( v80 < 0 )
            {
              v76 = v233[20];
              if ( !v76 )
                goto LABEL_474;
LABEL_414:
              v182 = *(_DWORD **)(v76 + 32);
              if ( (unsigned __int64)v182 >= *(_QWORD *)(v76 + 40) )
              {
LABEL_474:
                if ( (unsigned int)sub_6AB50(
                                     (__int64)v233,
                                     0x27u,
                                     v76,
                                     (__int64)v79,
                                     (u32 *)v64,
                                     v63,
                                     *(double *)a4.m128_u64,
                                     *(double *)a5.m128_u64,
                                     *(double *)a6.m128_u64,
                                     a7,
                                     v34,
                                     v35,
                                     a10,
                                     a11) == -1 )
                  goto LABEL_17;
              }
              else
              {
                v79 = v182 + 1;
                *(_QWORD *)(v76 + 32) = v182 + 1;
                *v182 = 39;
              }
              v80 = *((_BYTE *)v59 + 12);
              ++v81;
            }
LABEL_68:
            if ( (v80 & 0x40) != 0 )
            {
              v82 = v233[20];
              if ( v82 && (v76 = *(_QWORD *)(v82 + 32), v76 < *(_QWORD *)(v82 + 40)) )
              {
                v79 = (_DWORD *)(v76 + 4);
                *(_QWORD *)(v82 + 32) = v76 + 4;
                *(_DWORD *)v76 = 43;
              }
              else if ( (unsigned int)sub_6AB50(
                                        (__int64)v233,
                                        0x2Bu,
                                        v76,
                                        (__int64)v79,
                                        (u32 *)v64,
                                        v63,
                                        *(double *)a4.m128_u64,
                                        *(double *)a5.m128_u64,
                                        *(double *)a6.m128_u64,
                                        a7,
                                        v34,
                                        v35,
                                        a10,
                                        a11) == -1 )
              {
                goto LABEL_17;
              }
            }
            else
            {
              if ( (v80 & 0x10) == 0 )
                goto LABEL_73;
              v181 = v233[20];
              if ( v181 && (v76 = *(_QWORD *)(v181 + 32), v76 < *(_QWORD *)(v181 + 40)) )
              {
                v79 = (_DWORD *)(v76 + 4);
                *(_QWORD *)(v181 + 32) = v76 + 4;
                *(_DWORD *)v76 = 32;
              }
              else if ( (unsigned int)sub_6AB50(
                                        (__int64)v233,
                                        0x20u,
                                        v76,
                                        (__int64)v79,
                                        (u32 *)v64,
                                        v63,
                                        *(double *)a4.m128_u64,
                                        *(double *)a5.m128_u64,
                                        *(double *)a6.m128_u64,
                                        a7,
                                        v34,
                                        v35,
                                        a10,
                                        a11) == -1 )
              {
                goto LABEL_17;
              }
            }
            v80 = *((_BYTE *)v59 + 12);
            ++v81;
LABEL_73:
            if ( (v80 & 0x20) != 0 )
            {
              v83 = v233[20];
              if ( v83 && (v76 = *(_QWORD *)(v83 + 32), v76 < *(_QWORD *)(v83 + 40)) )
              {
                v79 = (_DWORD *)(v76 + 4);
                *(_QWORD *)(v83 + 32) = v76 + 4;
                *(_DWORD *)v76 = 45;
              }
              else if ( (unsigned int)sub_6AB50(
                                        (__int64)v233,
                                        0x2Du,
                                        v76,
                                        (__int64)v79,
                                        (u32 *)v64,
                                        v63,
                                        *(double *)a4.m128_u64,
                                        *(double *)a5.m128_u64,
                                        *(double *)a6.m128_u64,
                                        a7,
                                        v34,
                                        v35,
                                        a10,
                                        a11) == -1 )
              {
                goto LABEL_17;
              }
              ++v81;
            }
            if ( v59[4] == 48 )
            {
              v193 = v233[20];
              if ( v193 && (v76 = *(_QWORD *)(v193 + 32), v76 < *(_QWORD *)(v193 + 40)) )
              {
                v79 = (_DWORD *)(v76 + 4);
                *(_QWORD *)(v193 + 32) = v76 + 4;
                *(_DWORD *)v76 = 48;
              }
              else if ( (unsigned int)sub_6AB50(
                                        (__int64)v233,
                                        0x30u,
                                        v76,
                                        (__int64)v79,
                                        (u32 *)v64,
                                        v63,
                                        *(double *)a4.m128_u64,
                                        *(double *)a5.m128_u64,
                                        *(double *)a6.m128_u64,
                                        a7,
                                        v34,
                                        v35,
                                        a10,
                                        a11) == -1 )
              {
                goto LABEL_17;
              }
              ++v81;
            }
            if ( (*((_BYTE *)v59 + 13) & 8) != 0 )
            {
              v84 = v233[20];
              if ( v84 && (v76 = *(_QWORD *)(v84 + 32), v76 < *(_QWORD *)(v84 + 40)) )
              {
                *(_QWORD *)(v84 + 32) = v76 + 4;
                *(_DWORD *)v76 = 73;
              }
              else if ( (unsigned int)sub_6AB50(
                                        (__int64)v233,
                                        0x49u,
                                        v76,
                                        (__int64)v79,
                                        (u32 *)v64,
                                        v63,
                                        *(double *)a4.m128_u64,
                                        *(double *)a5.m128_u64,
                                        *(double *)a6.m128_u64,
                                        a7,
                                        v34,
                                        v35,
                                        a10,
                                        a11) == -1 )
              {
                goto LABEL_17;
              }
              ++v81;
            }
            v43 = (int)v59[1];
            if ( (_DWORD)v43 )
            {
              v85 = &v238;
              do
              {
                v85 = (char **)((char *)v85 - 4);
                v76 = v43 / 0xA;
                v86 = *(_DWORD *)&a0_16[4 * (v43 % 0xA)];
                v87 = v43;
                v43 /= 0xAuLL;
                *(_DWORD *)v85 = v86;
              }
              while ( v87 > 9 );
              if ( v85 < &v238 )
              {
                v88 = v233;
                while ( 1 )
                {
                  v89 = v88[20];
                  v85 = (char **)((char *)v85 + 4);
                  if ( v89 && (v76 = *(_QWORD *)(v89 + 32), v76 < *(_QWORD *)(v89 + 40)) )
                  {
                    v43 = v76 + 4;
                    *(_QWORD *)(v89 + 32) = v76 + 4;
                    *(_DWORD *)v76 = v86;
                    if ( v86 == -1 )
                      goto LABEL_17;
                  }
                  else if ( (unsigned int)sub_6AB50(
                                            (__int64)v88,
                                            v86,
                                            v76,
                                            v43,
                                            (u32 *)v64,
                                            v63,
                                            *(double *)a4.m128_u64,
                                            *(double *)a5.m128_u64,
                                            *(double *)a6.m128_u64,
                                            a7,
                                            v34,
                                            v35,
                                            a10,
                                            a11) == -1 )
                  {
                    goto LABEL_17;
                  }
                  if ( v81 == 0x7FFFFFFF )
                    goto LABEL_17;
                  ++v81;
                  if ( v85 >= &v238 )
                    break;
                  v86 = *(_DWORD *)v85;
                }
              }
            }
            if ( *v59 != -1 )
            {
              v173 = v233[20];
              if ( v173 && (v76 = *(_QWORD *)(v173 + 32), v76 < *(_QWORD *)(v173 + 40)) )
              {
                *(_QWORD *)(v173 + 32) = v76 + 4;
                *(_DWORD *)v76 = 46;
              }
              else if ( (unsigned int)sub_6AB50(
                                        (__int64)v233,
                                        0x2Eu,
                                        v76,
                                        v43,
                                        (u32 *)v64,
                                        v63,
                                        *(double *)a4.m128_u64,
                                        *(double *)a5.m128_u64,
                                        *(double *)a6.m128_u64,
                                        a7,
                                        v34,
                                        v35,
                                        a10,
                                        a11) == -1 )
              {
                goto LABEL_17;
              }
              if ( v81 == 0x7FFFFFFF )
                goto LABEL_17;
              v43 = (int)*v59;
              ++v81;
              v174 = &v238;
              do
              {
                v174 = (char **)((char *)v174 - 4);
                v76 = v43 / 0xA;
                v175 = *(_DWORD *)&a0_16[4 * (v43 % 0xA)];
                v176 = v43;
                v43 /= 0xAuLL;
                *(_DWORD *)v174 = v175;
              }
              while ( v176 > 9 );
              if ( v174 < &v238 )
              {
                v177 = v233;
                while ( 1 )
                {
                  v178 = v177[20];
                  v174 = (char **)((char *)v174 + 4);
                  if ( v178 && (v76 = *(_QWORD *)(v178 + 32), v76 < *(_QWORD *)(v178 + 40)) )
                  {
                    v43 = v76 + 4;
                    *(_QWORD *)(v178 + 32) = v76 + 4;
                    *(_DWORD *)v76 = v175;
                    if ( v175 == -1 )
                      goto LABEL_17;
                  }
                  else if ( (unsigned int)sub_6AB50(
                                            (__int64)v177,
                                            v175,
                                            v76,
                                            v43,
                                            (u32 *)v64,
                                            v63,
                                            *(double *)a4.m128_u64,
                                            *(double *)a5.m128_u64,
                                            *(double *)a6.m128_u64,
                                            a7,
                                            v34,
                                            v35,
                                            a10,
                                            a11) == -1 )
                  {
                    goto LABEL_17;
                  }
                  if ( v81 == 0x7FFFFFFF )
                    goto LABEL_17;
                  ++v81;
                  if ( v174 >= &v238 )
                    break;
                  v175 = *(_DWORD *)v174;
                }
              }
            }
            v190 = v59[2];
            if ( v190 )
            {
              v191 = v233[20];
              if ( v191 && (v76 = *(_QWORD *)(v191 + 32), v76 < *(_QWORD *)(v191 + 40)) )
              {
                v43 = v76 + 4;
                *(_QWORD *)(v191 + 32) = v76 + 4;
                *(_DWORD *)v76 = v190;
                if ( v190 == -1 )
                  goto LABEL_17;
              }
              else if ( (unsigned int)sub_6AB50(
                                        (__int64)v233,
                                        v190,
                                        v76,
                                        v43,
                                        (u32 *)v64,
                                        v63,
                                        *(double *)a4.m128_u64,
                                        *(double *)a5.m128_u64,
                                        *(double *)a6.m128_u64,
                                        a7,
                                        v34,
                                        v35,
                                        a10,
                                        a11) == -1 )
              {
                goto LABEL_17;
              }
              if ( v81 == 0x7FFFFFFF )
                goto LABEL_17;
              ++v81;
            }
            if ( (int)v235 < 0 )
              goto LABEL_18;
            v150 = __OFADD__((_DWORD)v235, v81);
            v192 = (_DWORD)v235 + v81;
            LODWORD(v235) = v192;
            if ( v150 )
            {
LABEL_16:
              __writefsdword(0xFFFFFFC0, 0x4Bu);
              goto LABEL_17;
            }
            if ( v192 < 0 )
              goto LABEL_18;
            goto LABEL_153;
          }
          v79 = *(_DWORD **)(v76 + 32);
          v78 = *(_QWORD *)(v76 + 40);
        }
        if ( (unsigned __int64)v79 < v78 )
        {
          v81 = 2;
          *(_QWORD *)(v76 + 32) = v79 + 1;
          *v79 = 35;
          v80 = *((_BYTE *)v59 + 12);
          if ( v80 >= 0 )
            goto LABEL_68;
          goto LABEL_414;
        }
        goto LABEL_470;
    }
  }
LABEL_405:
  LODWORD(v235) = v230;
LABEL_18:
  if ( (char *)v241[0] != v219 )
    sub_21B70(v241[0]);
  if ( v238 != v226 )
    sub_21B70(v238);
  return (unsigned int)v235;
}
// 652B2: conditional instruction was optimized away because of 'er10.4==8'
// 64267: variable 'v31' is possibly undefined
// 64267: variable 'v32' is possibly undefined
// 64267: variable 'v28' is possibly undefined
// 64267: variable 'v29' is possibly undefined
// 64267: variable 'v30' is possibly undefined
// 642EF: variable 'v34' is possibly undefined
// 642EF: variable 'v35' is possibly undefined
// 6493C: variable 'v76' is possibly undefined
// 6493C: variable 'v43' is possibly undefined
// 6493C: variable 'v64' is possibly undefined
// 6493C: variable 'v63' is possibly undefined
// 64CCA: variable 'v68' is possibly undefined
// 64CCA: variable 'v105' is possibly undefined
// 660C7: variable 'v188' is possibly undefined
// 660C7: variable 'v189' is possibly undefined
// 663DA: variable 'v79' is possibly undefined
// 664DC: variable 'v137' is possibly undefined
// 66634: variable 'v147' is possibly undefined
// 90D0: using guessed type __int64 __fastcall sub_90D0(_QWORD);
// 91A0: using guessed type __int64 __fastcall sub_91A0(_QWORD, _QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// C0308: using guessed type void *off_C0308;
// C1788: using guessed type __int64 qword_C1788;
// C1B10: using guessed type __int64 qword_C1B10;
// C1B18: using guessed type __int64 qword_C1B18;

//----- (0000000000066830) ----------------------------------------------------
__int64 __fastcall sub_66830(_QWORD *a1, __int64 a2, __m128i *a3, __int64 a4, u32 *a5, u32 a6, __m128 a7, double a8, __m128i a9, __m128 a10, double a11, double a12, double a13, double a14)
{
  __int64 v16; // rdx
  __int64 v17; // rcx
  u32 *v18; // r8
  u32 v19; // er9
  double v20; // xmm4_8
  double v21; // xmm5_8
  u32 *v22; // r8
  u32 v23; // er9
  double v24; // xmm4_8
  double v25; // xmm5_8
  int v26; // ebx
  __m128 v27; // xmm1
  __int64 v28; // rcx
  u32 *v29; // r8
  u32 v30; // er9
  double v31; // xmm4_8
  double v32; // xmm5_8
  unsigned __int64 v34; // rbx
  __int64 v36; // r12
  __int64 v37; // rbx
  unsigned __int64 v38; // r8
  u32 v39; // er9
  double v40; // xmm4_8
  double v41; // xmm5_8
  int v42; // er13
  unsigned __int64 v43; // rax
  unsigned int *v44; // rax
  __int64 v45; // rcx
  unsigned int v46; // er14
  int v47; // eax
  __int64 v49; // rdi
  int v50; // eax
  _DWORD *v51; // rdx
  int v52; // er12
  int v53; // er10
  __int64 v54; // rbx
  int v55; // er14
  unsigned __int32 v56; // eax
  unsigned int *v57; // rdx
  __int64 v58; // rax
  unsigned int v59; // esi
  int *v60; // r12
  int *v61; // rax
  double v62; // xmm4_8
  double v63; // xmm5_8
  __int64 v64; // r14
  unsigned __int64 v65; // rbx
  int v66; // edx
  __int64 v67; // rax
  unsigned __int32 v68; // eax
  const char **v69; // rdx
  const char *v70; // r12
  unsigned __int32 v71; // eax
  unsigned __int8 *v72; // rdx
  __int64 v73; // rax
  unsigned int v74; // eax
  _QWORD **v75; // rdx
  unsigned int v76; // eax
  int v77; // er10
  unsigned int v78; // eax
  __int64 *v79; // rdx
  __int64 v80; // rcx
  char *v81; // r12
  _DWORD *v82; // rdx
  unsigned __int8 *v83; // rdx
  unsigned int *v84; // rax
  int v85; // eax
  unsigned int v86; // eax
  int *v87; // rax
  int v88; // ecx
  unsigned __int32 v89; // ecx
  __int64 v90; // rsi
  unsigned int *v91; // rsi
  int v92; // eax
  unsigned __int32 v93; // eax
  __int64 *v94; // rdx
  unsigned __int8 v95; // dl
  unsigned int v96; // eax
  _QWORD *v97; // rdx
  unsigned __int8 v98; // dl
  unsigned int v99; // eax
  _QWORD *v100; // rdx
  unsigned int v101; // eax
  __int64 *v102; // rdx
  __int64 v103; // rax
  __int64 v104; // rax
  const char *v105; // rcx
  __int64 v106; // rax
  char *v107; // rax
  __int64 v108; // rax
  __int64 v109; // rcx
  char v110; // si
  __int64 v111; // rax
  __int64 v112; // rax
  _DWORD *v113; // rsi
  unsigned __int64 v114; // rdi
  unsigned int *v115; // rdx
  int v116; // ebx
  __int64 v117; // rbx
  __int64 v118; // rax
  int v119; // edx
  __int64 v120; // rax
  __int64 v121; // rax
  _DWORD *v122; // rsi
  __int64 v123; // rax
  _DWORD *v124; // rdi
  unsigned int *v125; // rsi
  __int64 v126; // rcx
  unsigned __int64 v127; // r14
  int v128; // eax
  __int64 v129; // rbx
  double v130; // xmm4_8
  double v131; // xmm5_8
  int v132; // edx
  __int64 v133; // rax
  __int64 v134; // r14
  bool v135; // of
  unsigned __int64 v136; // rax
  unsigned __int64 v137; // rdx
  unsigned __int64 v138; // rax
  unsigned __int64 v139; // rdx
  __int64 v140; // rax
  _DWORD *v141; // rsi
  __int64 v142; // rax
  unsigned int v143; // eax
  unsigned __int64 v144; // rsi
  unsigned __int64 v145; // rax
  int v146; // eax
  bool v147; // sf
  __int64 v148; // rax
  __int64 v149; // rax
  unsigned __int64 v150; // rbx
  __int64 v151; // rax
  int v152; // edx
  __int64 v153; // rax
  unsigned int *v154; // rdx
  int v155; // eax
  __int64 v156; // rax
  _DWORD *v157; // rsi
  long double *v158; // rax
  int v159; // edx
  unsigned int v160; // edx
  const __m128i *v161; // rax
  int *v162; // rdx
  int **v163; // rdx
  __int64 v164; // r14
  unsigned __int16 *v165; // rdx
  long double *v166; // rax
  unsigned int v167; // edx
  const __m128i *v168; // rax
  char *v169; // rdx
  _BYTE **v170; // rdx
  __int64 v171; // rax
  double v172; // xmm4_8
  double v173; // xmm5_8
  int v174; // eax
  double v175; // xmm4_8
  double v176; // xmm5_8
  int *v177; // rcx
  unsigned int v178; // eax
  unsigned __int32 v179; // eax
  int v180; // eax
  __int64 v181; // rax
  __int64 v182; // rax
  unsigned int v183; // esi
  int v184; // eax
  unsigned int v185; // esi
  int v186; // eax
  int v187; // eax
  signed __int64 v188; // rax
  int v189; // eax
  int v190; // eax
  _WORD **v191; // rdx
  __int16 *v192; // rdx
  int v193; // eax
  int v194; // eax
  int v195; // eax
  unsigned __int64 v196; // [rsp+0h] [rbp-528h]
  unsigned __int64 v197; // [rsp+8h] [rbp-520h]
  int v198; // [rsp+10h] [rbp-518h]
  unsigned __int64 v199; // [rsp+10h] [rbp-518h]
  int v200; // [rsp+10h] [rbp-518h]
  _DWORD *v201; // [rsp+10h] [rbp-518h]
  unsigned __int64 v202; // [rsp+10h] [rbp-518h]
  u32 v203; // [rsp+10h] [rbp-518h]
  unsigned int v204; // [rsp+10h] [rbp-518h]
  unsigned __int64 v205; // [rsp+10h] [rbp-518h]
  unsigned int v206; // [rsp+10h] [rbp-518h]
  int v207; // [rsp+10h] [rbp-518h]
  __int64 v208; // [rsp+10h] [rbp-518h]
  unsigned int v209; // [rsp+18h] [rbp-510h]
  int v210; // [rsp+18h] [rbp-510h]
  int v211; // [rsp+18h] [rbp-510h]
  __int64 v212; // [rsp+18h] [rbp-510h]
  int v213; // [rsp+18h] [rbp-510h]
  unsigned __int64 v214; // [rsp+18h] [rbp-510h]
  unsigned __int64 v215; // [rsp+18h] [rbp-510h]
  __int64 v216; // [rsp+18h] [rbp-510h]
  __int64 v217; // [rsp+18h] [rbp-510h]
  __int64 v218; // [rsp+20h] [rbp-508h]
  _DWORD *v219; // [rsp+20h] [rbp-508h]
  int v220; // [rsp+20h] [rbp-508h]
  int v221; // [rsp+28h] [rbp-500h]
  _DWORD *v222; // [rsp+28h] [rbp-500h]
  unsigned __int64 v223; // [rsp+28h] [rbp-500h]
  int v224; // [rsp+34h] [rbp-4F4h]
  u32 v225; // [rsp+34h] [rbp-4F4h]
  int v226; // [rsp+34h] [rbp-4F4h]
  int v227; // [rsp+38h] [rbp-4F0h]
  int v228; // [rsp+40h] [rbp-4E8h]
  unsigned int v229; // [rsp+44h] [rbp-4E4h]
  int *v230; // [rsp+48h] [rbp-4E0h]
  int v231; // [rsp+50h] [rbp-4D8h]
  int v232; // [rsp+50h] [rbp-4D8h]
  __int64 v233; // [rsp+58h] [rbp-4D0h]
  unsigned int v234; // [rsp+60h] [rbp-4C8h]
  unsigned int v235; // [rsp+64h] [rbp-4C4h]
  int v236; // [rsp+68h] [rbp-4C0h]
  u32 v237; // [rsp+68h] [rbp-4C0h]
  unsigned __int64 v238; // [rsp+68h] [rbp-4C0h]
  int v239; // [rsp+70h] [rbp-4B8h]
  int v240; // [rsp+74h] [rbp-4B4h]
  u32 v241; // [rsp+78h] [rbp-4B0h]
  int v242; // [rsp+7Ch] [rbp-4ACh]
  unsigned int *v243; // [rsp+80h] [rbp-4A8h] BYREF
  const __m128i *v244; // [rsp+88h] [rbp-4A0h] BYREF
  long double v245; // [rsp+90h] [rbp-498h] BYREF
  int *v246; // [rsp+A0h] [rbp-488h] BYREF
  unsigned int v247; // [rsp+A8h] [rbp-480h]
  int v248; // [rsp+ACh] [rbp-47Ch]
  int v249; // [rsp+B0h] [rbp-478h]
  signed __int64 (__fastcall *v250)(__int64, __int64, __int64, __int64, u32 *, u32); // [rsp+C0h] [rbp-468h]
  _QWORD *v251; // [rsp+C8h] [rbp-460h]
  __m128 v252; // [rsp+E8h] [rbp-440h] BYREF
  __int64 v253; // [rsp+F8h] [rbp-430h]
  char v254[996]; // [rsp+100h] [rbp-428h] BYREF
  int v255; // [rsp+4E4h] [rbp-44h] BYREF
  __int64 v256[8]; // [rsp+4E8h] [rbp-40h] BYREF

  v196 = a2;
  v229 = a4;
  v256[0] = __readfsqword(0x28u);
  v235 = __readfsdword(0xFFFFFFC0);
  if ( (unsigned int)sub_16780(
                       (__int64)a1,
                       1LL,
                       (__int64)a3,
                       a4,
                       a5,
                       a6,
                       *(double *)a7.m128_u64,
                       a8,
                       *(double *)a9.m128i_i64,
                       *(double *)a10.m128_u64,
                       a11,
                       a12,
                       a13,
                       a14) != 1 )
    return (unsigned int)-1;
  if ( (*(_DWORD *)a1 & 8) != 0 )
  {
    v42 = -1;
    *(_DWORD *)a1 |= 0x20u;
    __writefsdword(0xFFFFFFC0, 9u);
    return (unsigned int)v42;
  }
  if ( !a2 )
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    return (unsigned int)-1;
  }
  if ( (unsigned int)sub_16780(
                       (__int64)a1,
                       1LL,
                       v16,
                       v17,
                       v18,
                       v19,
                       *(double *)a7.m128_u64,
                       a8,
                       *(double *)a9.m128i_i64,
                       *(double *)a10.m128_u64,
                       v20,
                       v21,
                       a13,
                       a14) != 1 )
    return (unsigned int)-1;
  v26 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 2) == 0 )
  {
    v27 = (__m128)_mm_loadu_si128(a3);
    v253 = a3[1].m128i_i64[0];
    v252 = v27;
    v230 = sub_6D5D0((_DWORD *)a2, 37);
    v243 = (unsigned int *)v230;
    if ( (v26 & 0x8000) == 0 )
    {
      v251 = a1;
      v250 = sub_7F4E0;
      _RDI = a1[17];
      v34 = __readfsqword(0x10u);
      if ( *(_QWORD *)(_RDI + 8) != v34 )
      {
        if ( __readfsdword(0x18u) )
        {
          if ( _InterlockedCompareExchange((volatile signed __int32 *)_RDI, 1, 0) )
            sub_1C7D0((volatile __int32 *)_RDI, 37LL, 1LL, v28, v29, v30);
        }
        else
        {
          _EDX = 1;
          __asm { cmpxchg [rdi], edx }
        }
        _RDI = a1[17];
        *(_QWORD *)(_RDI + 8) = v34;
      }
      ++*(_DWORD *)(_RDI + 4);
    }
    v36 = a1[27];
    v37 = ((__int64)v230 - a2) >> 2;
    v197 = (char *)&off_C0308 - (char *)&unk_BFAE0;
    if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v36 - (_QWORD)&unk_BFAE0) )
      sub_17140(
        *(double *)a7.m128_u64,
        *(double *)v27.m128_u64,
        *(double *)a9.m128i_i64,
        *(double *)a10.m128_u64,
        v31,
        v32,
        a13,
        a14);
    if ( v37 != (*(__int64 (__fastcall **)(_QWORD *, __int64, __int64))(v36 + 56))(a1, a2, v37) )
    {
LABEL_73:
      v42 = -1;
      if ( (*(_DWORD *)a1 & 0x8000) != 0 )
        return (unsigned int)v42;
      goto LABEL_30;
    }
    v42 = ((__int64)v230 - a2) >> 2;
    v43 = ((unsigned __int64)v230 - a2) >> 63;
    if ( v37 != (int)v37 )
      LODWORD(v43) = 1;
    if ( (_DWORD)v43 )
      goto LABEL_317;
    if ( (int)v37 < 0 || (v44 = v243, v45 = *v243, !(_DWORD)v45) )
    {
LABEL_28:
      if ( (*(_DWORD *)a1 & 0x8000) != 0 )
        return (unsigned int)v42;
LABEL_30:
      v49 = a1[17];
      v50 = *(_DWORD *)(v49 + 4) - 1;
      *(_DWORD *)(v49 + 4) = v50;
      if ( !v50 )
      {
        *(_QWORD *)(v49 + 8) = 0LL;
        if ( __readfsdword(0x18u) )
        {
          if ( _InterlockedExchange((volatile __int32 *)v49, 0) > 1 )
            v188 = sys_futex((u32 *)v49, 129, 1u, 0LL, (u32 *)v38, v39);
        }
        else
        {
          --*(_DWORD *)v49;
        }
      }
      return (unsigned int)v42;
    }
    if ( qword_C1788 || qword_C1798 || (v239 = 0, v227 = 0, qword_C1B18) )
    {
      v47 = sub_64130(
              a1,
              a2,
              0,
              a7,
              v27,
              (__m128)a9,
              *(double *)a10.m128_u64,
              v40,
              v41,
              a13,
              a14,
              (__int64)a3,
              (unsigned __int64)&v252,
              v37,
              0,
              v230,
              v254,
              v235,
              (_BYTE *)0xFFFFFFFFFFFFFFFFLL,
              0,
              v229);
    }
    else
    {
      v240 = 0;
      v233 = -1LL;
      while ( 2 )
      {
        v46 = v44[1];
        v243 = v44 + 1;
        v236 = 0;
        v51 = 0LL;
        v39 = 0;
        v52 = 0;
        v198 = 0;
        v53 = 0;
        v231 = 0;
        v54 = -1LL;
        v221 = 0;
        v209 = 0;
        v228 = 0;
        v234 = 0;
        v224 = 32;
        switch ( v46 )
        {
          case ' ':
LABEL_129:
            while ( 2 )
            {
              v46 = v243[1];
              v45 = (__int64)++v243;
              v228 = 1;
              switch ( v46 )
              {
                case ' ':
                  continue;
                case '#':
                  goto LABEL_82;
                case '%':
                  goto LABEL_152;
                case '\'':
                  goto LABEL_121;
                case '*':
                  goto LABEL_112;
                case '+':
                  goto LABEL_128;
                case '-':
                  goto LABEL_130;
                case '.':
                  goto LABEL_105;
                case '0':
                  goto LABEL_124;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  goto LABEL_108;
                case 'A':
                case 'a':
                  goto LABEL_135;
                case 'C':
                  goto LABEL_36;
                case 'E':
                case 'F':
                case 'G':
                case 'e':
                case 'f':
                case 'g':
                  goto LABEL_141;
                case 'I':
                  goto LABEL_119;
                case 'L':
                case 'q':
                  goto LABEL_101;
                case 'S':
                case 's':
                  goto LABEL_55;
                case 'X':
                case 'x':
                  goto LABEL_147;
                case 'Z':
                case 'j':
                case 't':
                case 'z':
                  goto LABEL_34;
                case 'c':
                  goto LABEL_63;
                case 'd':
                case 'i':
                  goto LABEL_148;
                case 'h':
                  goto LABEL_104;
                case 'l':
                  goto LABEL_102;
                case 'm':
                  goto LABEL_75;
                case 'n':
                  goto LABEL_76;
                case 'o':
                  goto LABEL_84;
                case 'p':
                  goto LABEL_131;
                case 'u':
                  goto LABEL_96;
                default:
                  goto LABEL_25;
              }
            }
          case '#':
LABEL_82:
            v234 = 1;
            v46 = v243[1];
            v45 = (__int64)++v243;
            v76 = v46 - 32;
            goto LABEL_83;
          case '%':
LABEL_152:
            v104 = a1[20];
            if ( v104 && (v51 = *(_DWORD **)(v104 + 32), (unsigned __int64)v51 < *(_QWORD *)(v104 + 40)) )
            {
              *(_QWORD *)(v104 + 32) = v51 + 1;
              *v51 = 37;
            }
            else if ( (unsigned int)sub_6AB50(
                                      (__int64)a1,
                                      0x25u,
                                      (__int64)v51,
                                      v45,
                                      (u32 *)v38,
                                      v39,
                                      *(double *)a7.m128_u64,
                                      *(double *)v27.m128_u64,
                                      *(double *)a9.m128i_i64,
                                      *(double *)a10.m128_u64,
                                      v40,
                                      v41,
                                      a13,
                                      a14) == -1 )
            {
              goto LABEL_73;
            }
            if ( v42 == 0x7FFFFFFF )
              goto LABEL_73;
            ++v42;
            goto LABEL_44;
          case '\'':
LABEL_121:
            if ( v233 == -1 )
            {
              v181 = *(_QWORD *)__readfsqword(0xFFFFFFB0);
              v233 = *(_QWORD *)(v181 + 80);
              v240 = *(_DWORD *)(v181 + 96);
              if ( *(_BYTE *)v233 == 127 || *(_BYTE *)v233 == 0 || !*(_DWORD *)(v181 + 96) )
                v233 = 0LL;
            }
            v231 = 1;
            v46 = v243[1];
            v45 = (__int64)++v243;
            v76 = v46 - 32;
            if ( v46 - 32 <= 0x5A )
              goto LABEL_83;
            goto LABEL_25;
          case '*':
LABEL_112:
            v87 = (int *)(v243 + 1);
            v88 = v243[1];
            v243 = (unsigned int *)v87;
            v246 = v87;
            if ( (unsigned int)(v88 - 48) > 9 )
              goto LABEL_113;
            v180 = sub_63960(&v246);
            v51 = 0LL;
            v38 = (unsigned __int64)jpt_6711A;
            if ( v180 == -1 )
              goto LABEL_317;
            if ( v180 && *v246 == 36 )
              goto LABEL_26;
            v87 = (int *)v243;
LABEL_113:
            v89 = a3->m128i_i32[0];
            if ( a3->m128i_i32[0] > 0x2Fu )
            {
              v91 = (unsigned int *)a3->m128i_i64[1];
              v45 = (__int64)(v91 + 2);
              a3->m128i_i64[1] = (__int64)(v91 + 2);
            }
            else
            {
              v90 = v89;
              v45 = v89 + 8;
              v91 = (unsigned int *)(a3[1].m128i_i64[0] + v90);
              a3->m128i_i32[0] = v45;
            }
            a2 = *v91;
            v198 = a2;
            if ( (int)a2 < 0 )
            {
              a2 = (unsigned int)-(int)a2;
              v209 = 1;
              v198 = a2;
              v224 = 32;
            }
            v46 = *v87;
            v86 = v46 - 32;
            if ( v46 - 32 <= 0x5A )
            {
LABEL_111:
              switch ( v86 )
              {
                case 5u:
                  goto LABEL_152;
                case 0xEu:
                  goto LABEL_105;
                case 0x21u:
                case 0x41u:
                  goto LABEL_135;
                case 0x23u:
                  goto LABEL_36;
                case 0x25u:
                case 0x26u:
                case 0x27u:
                case 0x45u:
                case 0x46u:
                case 0x47u:
                  goto LABEL_141;
                case 0x2Cu:
                case 0x51u:
                  goto LABEL_101;
                case 0x33u:
                case 0x53u:
                  goto LABEL_55;
                case 0x38u:
                case 0x58u:
                  goto LABEL_147;
                case 0x3Au:
                case 0x4Au:
                case 0x54u:
                case 0x5Au:
                  goto LABEL_34;
                case 0x43u:
                  goto LABEL_63;
                case 0x44u:
                case 0x49u:
                  goto LABEL_148;
                case 0x48u:
                  goto LABEL_104;
                case 0x4Cu:
                  goto LABEL_102;
                case 0x4Du:
                  goto LABEL_75;
                case 0x4Eu:
                  goto LABEL_76;
                case 0x4Fu:
                  goto LABEL_84;
                case 0x50u:
                  goto LABEL_131;
                case 0x55u:
                  goto LABEL_96;
                default:
                  goto LABEL_25;
              }
            }
            goto LABEL_25;
          case '+':
LABEL_128:
            while ( 2 )
            {
              v221 = 1;
              v46 = v243[1];
              v45 = (__int64)++v243;
              switch ( v46 )
              {
                case ' ':
                  goto LABEL_129;
                case '#':
                  goto LABEL_82;
                case '%':
                  goto LABEL_152;
                case '\'':
                  goto LABEL_121;
                case '*':
                  goto LABEL_112;
                case '+':
                  continue;
                case '-':
                  goto LABEL_130;
                case '.':
                  goto LABEL_105;
                case '0':
                  goto LABEL_124;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  goto LABEL_108;
                case 'A':
                case 'a':
                  goto LABEL_135;
                case 'C':
                  goto LABEL_36;
                case 'E':
                case 'F':
                case 'G':
                case 'e':
                case 'f':
                case 'g':
                  goto LABEL_141;
                case 'I':
                  goto LABEL_119;
                case 'L':
                case 'q':
                  goto LABEL_101;
                case 'S':
                case 's':
                  goto LABEL_55;
                case 'X':
                case 'x':
                  goto LABEL_147;
                case 'Z':
                case 'j':
                case 't':
                case 'z':
                  goto LABEL_34;
                case 'c':
                  goto LABEL_63;
                case 'd':
                case 'i':
                  goto LABEL_148;
                case 'h':
                  goto LABEL_104;
                case 'l':
                  goto LABEL_102;
                case 'm':
                  goto LABEL_75;
                case 'n':
                  goto LABEL_76;
                case 'o':
                  goto LABEL_84;
                case 'p':
                  goto LABEL_131;
                case 'u':
                  goto LABEL_96;
                default:
                  goto LABEL_25;
              }
            }
          case '-':
LABEL_130:
            while ( 2 )
            {
              v46 = v243[1];
              v45 = (__int64)++v243;
              v209 = 1;
              v224 = 32;
              switch ( v46 )
              {
                case ' ':
                  goto LABEL_129;
                case '#':
                  goto LABEL_82;
                case '%':
                  goto LABEL_152;
                case '\'':
                  goto LABEL_121;
                case '*':
                  goto LABEL_112;
                case '+':
                  goto LABEL_128;
                case '-':
                  continue;
                case '.':
                  goto LABEL_105;
                case '0':
                  goto LABEL_124;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  goto LABEL_108;
                case 'A':
                case 'a':
                  goto LABEL_135;
                case 'C':
                  goto LABEL_36;
                case 'E':
                case 'F':
                case 'G':
                case 'e':
                case 'f':
                case 'g':
                  goto LABEL_141;
                case 'I':
                  goto LABEL_119;
                case 'L':
                case 'q':
                  goto LABEL_101;
                case 'S':
                case 's':
                  goto LABEL_55;
                case 'X':
                case 'x':
                  goto LABEL_147;
                case 'Z':
                case 'j':
                case 't':
                case 'z':
                  goto LABEL_34;
                case 'c':
                  goto LABEL_63;
                case 'd':
                case 'i':
                  goto LABEL_148;
                case 'h':
                  goto LABEL_104;
                case 'l':
                  goto LABEL_102;
                case 'm':
                  goto LABEL_75;
                case 'n':
                  goto LABEL_76;
                case 'o':
                  goto LABEL_84;
                case 'p':
                  goto LABEL_131;
                case 'u':
                  goto LABEL_96;
                default:
                  goto LABEL_25;
              }
            }
          case '.':
LABEL_105:
            v84 = v243;
            v46 = v243[1];
            v45 = (__int64)++v243;
            if ( v46 != 42 )
            {
              v54 = 0LL;
              if ( v46 - 48 > 9 )
                goto LABEL_107;
              v187 = sub_63960((int **)&v243);
              v54 = v187;
              if ( v187 != -1 )
              {
                v51 = 0LL;
                v38 = (unsigned __int64)jpt_6711A;
                v46 = *v243;
                goto LABEL_107;
              }
              goto LABEL_317;
            }
            v177 = (int *)(v84 + 2);
            v178 = v84[2];
            v243 = (unsigned int *)v177;
            v246 = v177;
            if ( v178 - 48 > 9 )
              goto LABEL_398;
            v193 = sub_63960(&v246);
            v51 = 0LL;
            v38 = (unsigned __int64)jpt_6711A;
            if ( v193 == -1 )
            {
LABEL_317:
              v42 = -1;
              __writefsdword(0xFFFFFFC0, 0x4Bu);
              goto LABEL_28;
            }
            if ( !v193 || *v246 != 36 )
            {
LABEL_398:
              v179 = a3->m128i_i32[0];
              if ( a3->m128i_i32[0] > 0x2Fu )
              {
                v45 = a3->m128i_i64[1];
                a3->m128i_i64[1] = v45 + 8;
              }
              else
              {
                v45 = a3[1].m128i_i64[0] + v179;
                a3->m128i_i32[0] = v179 + 8;
              }
              v54 = *(int *)v45;
              if ( (int)v54 < 0 )
                v54 = -1LL;
              v46 = *v243;
LABEL_107:
              switch ( v46 )
              {
                case '%':
                  goto LABEL_152;
                case 'A':
                case 'a':
                  goto LABEL_135;
                case 'C':
                  goto LABEL_36;
                case 'E':
                case 'F':
                case 'G':
                case 'e':
                case 'f':
                case 'g':
                  goto LABEL_141;
                case 'L':
                case 'q':
                  goto LABEL_101;
                case 'S':
                case 's':
                  goto LABEL_55;
                case 'X':
                case 'x':
                  goto LABEL_147;
                case 'Z':
                case 'j':
                case 't':
                case 'z':
                  goto LABEL_34;
                case 'c':
                  goto LABEL_63;
                case 'd':
                case 'i':
                  goto LABEL_148;
                case 'h':
                  goto LABEL_104;
                case 'l':
                  goto LABEL_102;
                case 'm':
                  goto LABEL_75;
                case 'n':
                  goto LABEL_76;
                case 'o':
                  goto LABEL_84;
                case 'p':
                  goto LABEL_131;
                case 'u':
                  goto LABEL_96;
                default:
                  goto LABEL_25;
              }
            }
LABEL_26:
            v47 = sub_64130(
                    a1,
                    v196,
                    v239,
                    a7,
                    v27,
                    (__m128)a9,
                    *(double *)a10.m128_u64,
                    v40,
                    v41,
                    a13,
                    a14,
                    (__int64)a3,
                    (unsigned __int64)&v252,
                    v42,
                    v227,
                    v230,
                    v254,
                    v235,
                    (_BYTE *)v233,
                    v240,
                    v229);
            break;
          case '0':
LABEL_124:
            v92 = 48;
            if ( v209 )
              v92 = v224;
            v224 = v92;
            v46 = v243[1];
            v45 = (__int64)++v243;
            v76 = v46 - 32;
            if ( v46 - 32 <= 0x5A )
              goto LABEL_83;
            goto LABEL_25;
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
LABEL_108:
            v85 = sub_63960((int **)&v243);
            v51 = 0LL;
            v38 = (unsigned __int64)jpt_6711A;
            v198 = v85;
            if ( v85 == -1 )
              goto LABEL_317;
            v46 = *v243;
            if ( *v243 == 36 )
              goto LABEL_26;
            v86 = v46 - 32;
            goto LABEL_111;
          case 'A':
          case 'a':
LABEL_135:
            if ( (v229 & 1) != 0 )
            {
              v53 = 0;
              v95 = 0;
            }
            else
            {
              v95 = v53 & 1;
            }
            v246 = (int *)__PAIR64__(v198, v54);
            v247 = v46;
            v248 = (unsigned __int16)(((_WORD)v231 << 7) | ((_WORD)v221 << 6) | (32 * v209) | (16 * v228) | (8 * v234) | (4 * v39) | v95 | 0x400);
            v249 = v224;
            if ( v53 )
            {
              if ( (v229 & 8) != 0 )
              {
                v167 = a3->m128i_u32[1];
                BYTE1(v248) |= 0x10u;
                if ( v167 > 0xAF )
                {
                  v168 = (const __m128i *)((a3->m128i_i64[1] + 15) & 0xFFFFFFFFFFFFFFF0LL);
                  a3->m128i_i64[1] = (__int64)v168[1].m128i_i64;
                }
                else
                {
                  v168 = (const __m128i *)(a3[1].m128i_i64[0] + v167);
                  a3->m128i_i32[1] = v167 + 16;
                }
                a10 = (__m128)_mm_load_si128(v168);
                v245 = *(long double *)&a10;
              }
              else
              {
                v158 = (long double *)((a3->m128i_i64[1] + 15) & 0xFFFFFFFFFFFFFFF0LL);
                a3->m128i_i64[1] = (__int64)(v158 + 1);
                v245 = *v158;
              }
            }
            else
            {
              v96 = a3->m128i_u32[1];
              if ( v96 > 0xAF )
              {
                v97 = (_QWORD *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v97 + 1);
              }
              else
              {
                v97 = (_QWORD *)(a3[1].m128i_i64[0] + v96);
                a3->m128i_i32[1] = v96 + 16;
              }
              a7 = (__m128)(unsigned __int64)*v97;
              *(_QWORD *)&v245 = *v97;
            }
            v244 = (const __m128i *)&v245;
            v159 = sub_7D370(
                     a1,
                     (unsigned __int64)&v246,
                     &v244,
                     a7,
                     v27,
                     (__m128)a9,
                     *(double *)a10.m128_u64,
                     v40,
                     v41,
                     a13,
                     a14,
                     v45,
                     (u32 *)v38);
            if ( v159 >= 0 )
              goto LABEL_326;
            goto LABEL_73;
          case 'C':
            goto LABEL_36;
          case 'E':
          case 'F':
          case 'G':
          case 'e':
          case 'f':
          case 'g':
LABEL_141:
            if ( (v229 & 1) != 0 )
            {
              v53 = 0;
              v98 = 0;
            }
            else
            {
              v98 = v53 & 1;
            }
            v246 = (int *)__PAIR64__(v198, v54);
            v247 = v46;
            v248 = (unsigned __int16)(((_WORD)v236 << 11) | ((_WORD)v231 << 7) | ((_WORD)v221 << 6) | (32 * v209) | (16 * v228) | (8 * v234) | (4 * v39) | v98 | 0x400);
            v249 = v224;
            if ( v53 )
            {
              if ( (v229 & 8) != 0 )
              {
                v160 = a3->m128i_u32[1];
                BYTE1(v248) |= 0x10u;
                if ( v160 > 0xAF )
                {
                  v161 = (const __m128i *)((a3->m128i_i64[1] + 15) & 0xFFFFFFFFFFFFFFF0LL);
                  a3->m128i_i64[1] = (__int64)v161[1].m128i_i64;
                }
                else
                {
                  v161 = (const __m128i *)(a3[1].m128i_i64[0] + v160);
                  a3->m128i_i32[1] = v160 + 16;
                }
                a9 = _mm_load_si128(v161);
                v245 = *(long double *)&a9;
              }
              else
              {
                v166 = (long double *)((a3->m128i_i64[1] + 15) & 0xFFFFFFFFFFFFFFF0LL);
                a3->m128i_i64[1] = (__int64)(v166 + 1);
                v245 = *v166;
              }
            }
            else
            {
              v99 = a3->m128i_u32[1];
              if ( v99 > 0xAF )
              {
                v100 = (_QWORD *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v100 + 1);
              }
              else
              {
                v100 = (_QWORD *)(a3[1].m128i_i64[0] + v99);
                a3->m128i_i32[1] = v99 + 16;
              }
              a7 = (__m128)(unsigned __int64)*v100;
              *(_QWORD *)&v245 = *v100;
            }
            v244 = (const __m128i *)&v245;
            v159 = sub_7D1B0(
                     a1,
                     (__int64)&v246,
                     &v244,
                     (__m128i)a7,
                     v27,
                     a9,
                     *(double *)a10.m128_u64,
                     v40,
                     v41,
                     a13,
                     a14,
                     v45,
                     v38,
                     16 * (unsigned int)(unsigned __int16)v228);
            if ( v159 < 0 )
              goto LABEL_73;
LABEL_326:
            v155 = 0;
            v42 += v159;
            if ( v42 < 0 || v42 < (unsigned int)v159 )
              goto LABEL_328;
            goto LABEL_316;
          case 'I':
LABEL_119:
            while ( 2 )
            {
              v236 = 1;
              v46 = v243[1];
              v45 = (__int64)++v243;
              v76 = v46 - 32;
              if ( v46 - 32 <= 0x5A )
              {
LABEL_83:
                switch ( v76 )
                {
                  case 0u:
                    goto LABEL_129;
                  case 3u:
                    goto LABEL_82;
                  case 5u:
                    goto LABEL_152;
                  case 7u:
                    goto LABEL_121;
                  case 0xAu:
                    goto LABEL_112;
                  case 0xBu:
                    goto LABEL_128;
                  case 0xDu:
                    goto LABEL_130;
                  case 0xEu:
                    goto LABEL_105;
                  case 0x10u:
                    goto LABEL_124;
                  case 0x11u:
                  case 0x12u:
                  case 0x13u:
                  case 0x14u:
                  case 0x15u:
                  case 0x16u:
                  case 0x17u:
                  case 0x18u:
                  case 0x19u:
                    goto LABEL_108;
                  case 0x21u:
                  case 0x41u:
                    goto LABEL_135;
                  case 0x23u:
                    goto LABEL_36;
                  case 0x25u:
                  case 0x26u:
                  case 0x27u:
                  case 0x45u:
                  case 0x46u:
                  case 0x47u:
                    goto LABEL_141;
                  case 0x29u:
                    continue;
                  case 0x2Cu:
                  case 0x51u:
                    goto LABEL_101;
                  case 0x33u:
                  case 0x53u:
                    goto LABEL_55;
                  case 0x38u:
                  case 0x58u:
                    goto LABEL_147;
                  case 0x3Au:
                  case 0x4Au:
                  case 0x54u:
                  case 0x5Au:
                    goto LABEL_34;
                  case 0x43u:
                    goto LABEL_63;
                  case 0x44u:
                  case 0x49u:
                    goto LABEL_148;
                  case 0x48u:
                    goto LABEL_104;
                  case 0x4Cu:
                    goto LABEL_102;
                  case 0x4Du:
                    goto LABEL_75;
                  case 0x4Eu:
                    goto LABEL_76;
                  case 0x4Fu:
                    goto LABEL_84;
                  case 0x50u:
                    goto LABEL_131;
                  case 0x55u:
                    goto LABEL_96;
                  default:
                    goto LABEL_25;
                }
              }
              goto LABEL_25;
            }
          case 'L':
          case 'q':
LABEL_101:
            v46 = v243[1];
            v45 = (__int64)++v243;
            v39 = 1;
            v53 = 1;
            switch ( v46 )
            {
              case '%':
                goto LABEL_152;
              case 'A':
              case 'a':
                goto LABEL_135;
              case 'C':
                goto LABEL_36;
              case 'E':
              case 'F':
              case 'G':
              case 'e':
              case 'f':
              case 'g':
                goto LABEL_141;
              case 'S':
              case 's':
                goto LABEL_55;
              case 'X':
              case 'x':
                goto LABEL_147;
              case 'c':
                goto LABEL_63;
              case 'd':
              case 'i':
                goto LABEL_148;
              case 'm':
                goto LABEL_75;
              case 'n':
                goto LABEL_76;
              case 'o':
                goto LABEL_84;
              case 'p':
                goto LABEL_131;
              case 'u':
                goto LABEL_96;
              default:
                goto LABEL_25;
            }
          case 'S':
          case 's':
LABEL_55:
            v68 = a3->m128i_i32[0];
            if ( a3->m128i_i32[0] > 0x2Fu )
            {
              v69 = (const char **)a3->m128i_i64[1];
              a3->m128i_i64[1] = (__int64)(v69 + 1);
            }
            else
            {
              v69 = (const char **)(a3[1].m128i_i64[0] + v68);
              a3->m128i_i32[0] = v68 + 8;
            }
            v70 = *v69;
            goto LABEL_58;
          case 'X':
          case 'x':
LABEL_147:
            v77 = 16;
            goto LABEL_85;
          case 'Z':
          case 'j':
          case 't':
          case 'z':
LABEL_34:
            v46 = v243[1];
            v45 = (__int64)++v243;
            v39 = 1;
            v53 = 0;
            switch ( v46 )
            {
              case '%':
                goto LABEL_152;
              case 'A':
              case 'a':
                goto LABEL_135;
              case 'C':
                goto LABEL_36;
              case 'E':
              case 'F':
              case 'G':
              case 'e':
              case 'f':
              case 'g':
                goto LABEL_141;
              case 'S':
              case 's':
                goto LABEL_55;
              case 'X':
              case 'x':
                goto LABEL_147;
              case 'c':
                goto LABEL_63;
              case 'd':
              case 'i':
                goto LABEL_148;
              case 'm':
                goto LABEL_75;
              case 'n':
                goto LABEL_76;
              case 'o':
                goto LABEL_84;
              case 'p':
                goto LABEL_131;
              case 'u':
                goto LABEL_96;
              default:
                goto LABEL_25;
            }
          case 'c':
LABEL_63:
            if ( v39 )
            {
LABEL_36:
              v55 = v198 - 1;
              if ( !v209 && v55 > 0 )
              {
                if ( v55 != sub_6A3E0(
                              (__int64)a1,
                              32,
                              v55,
                              *(double *)a7.m128_u64,
                              *(double *)v27.m128_u64,
                              *(double *)a9.m128i_i64,
                              *(double *)a10.m128_u64,
                              v40,
                              v41,
                              a13,
                              a14) )
                  goto LABEL_73;
                v42 += v55;
                if ( v42 < 0 || v42 < (unsigned int)v55 )
                  goto LABEL_317;
              }
              v56 = a3->m128i_i32[0];
              if ( a3->m128i_i32[0] > 0x2Fu )
              {
                v57 = (unsigned int *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v57 + 2);
              }
              else
              {
                v57 = (unsigned int *)(a3[1].m128i_i64[0] + v56);
                a3->m128i_i32[0] = v56 + 8;
              }
              v58 = a1[20];
              v59 = *v57;
              if ( !v58 )
                goto LABEL_72;
            }
            else
            {
              v55 = v198 - 1;
              if ( !v209 && v55 > 0 )
              {
                a2 = 32LL;
                if ( v55 != sub_6A3E0(
                              (__int64)a1,
                              32,
                              v55,
                              *(double *)a7.m128_u64,
                              *(double *)v27.m128_u64,
                              *(double *)a9.m128i_i64,
                              *(double *)a10.m128_u64,
                              v40,
                              v41,
                              a13,
                              a14) )
                  goto LABEL_73;
                v42 += v55;
                if ( v42 < 0 || v42 < (unsigned int)v55 )
                  goto LABEL_317;
              }
              v71 = a3->m128i_i32[0];
              if ( a3->m128i_i32[0] > 0x2Fu )
              {
                v72 = (unsigned __int8 *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v72 + 8);
              }
              else
              {
                v72 = (unsigned __int8 *)(a3[1].m128i_i64[0] + v71);
                a3->m128i_i32[0] = v71 + 8;
              }
              v59 = sub_6CEC0(
                      *v72,
                      a2,
                      *(double *)a7.m128_u64,
                      *(double *)v27.m128_u64,
                      *(double *)a9.m128i_i64,
                      *(double *)a10.m128_u64,
                      v40,
                      v41,
                      a13,
                      a14,
                      (__int64)v72,
                      v45,
                      (u32 *)v38,
                      v39);
              v58 = a1[20];
              if ( !v58 )
                goto LABEL_72;
            }
            v57 = *(unsigned int **)(v58 + 32);
            if ( (unsigned __int64)v57 < *(_QWORD *)(v58 + 40) )
            {
              *(_QWORD *)(v58 + 32) = v57 + 1;
              *v57 = v59;
              if ( v59 == -1 )
                goto LABEL_73;
              goto LABEL_42;
            }
LABEL_72:
            if ( (unsigned int)sub_6AB50(
                                 (__int64)a1,
                                 v59,
                                 (__int64)v57,
                                 v45,
                                 (u32 *)v38,
                                 v39,
                                 *(double *)a7.m128_u64,
                                 *(double *)v27.m128_u64,
                                 *(double *)a9.m128i_i64,
                                 *(double *)a10.m128_u64,
                                 v40,
                                 v41,
                                 a13,
                                 a14) == -1 )
              goto LABEL_73;
LABEL_42:
            if ( v42 == 0x7FFFFFFF )
              goto LABEL_73;
            ++v42;
            if ( !v209 || v55 <= 0 )
              goto LABEL_44;
            if ( v55 != sub_6A3E0(
                          (__int64)a1,
                          32,
                          v55,
                          *(double *)a7.m128_u64,
                          *(double *)v27.m128_u64,
                          *(double *)a9.m128i_i64,
                          *(double *)a10.m128_u64,
                          v40,
                          v41,
                          a13,
                          a14) )
              goto LABEL_73;
            v155 = 0;
            v42 += v55;
            if ( v42 < 0 || v42 < (unsigned int)v55 )
LABEL_328:
              v155 = 1;
LABEL_316:
            if ( v155 )
              goto LABEL_317;
            goto LABEL_242;
          case 'd':
          case 'i':
LABEL_148:
            v101 = a3->m128i_i32[0];
            if ( v39 )
            {
              if ( v101 > 0x2F )
              {
                v102 = (__int64 *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v102 + 1);
              }
              else
              {
                v102 = (__int64 *)(a3[1].m128i_i64[0] + v101);
                a3->m128i_i32[0] = v101 + 8;
              }
              v103 = *v102;
            }
            else if ( (_DWORD)v51 )
            {
              if ( v101 > 0x2F )
              {
                v169 = (char *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v169 + 8);
              }
              else
              {
                v169 = (char *)(a3[1].m128i_i64[0] + v101);
                a3->m128i_i32[0] = v101 + 8;
              }
              v103 = *v169;
            }
            else if ( v52 )
            {
              if ( v101 > 0x2F )
              {
                v192 = (__int16 *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v192 + 4);
              }
              else
              {
                v192 = (__int16 *)(a3[1].m128i_i64[0] + v101);
                a3->m128i_i32[0] = v101 + 8;
              }
              v103 = *v192;
            }
            else
            {
              if ( v101 > 0x2F )
              {
                v162 = (int *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v162 + 2);
              }
              else
              {
                v162 = (int *)(a3[1].m128i_i64[0] + v101);
                a3->m128i_i32[0] = v101 + 8;
              }
              v103 = *v162;
            }
            if ( v103 < 0 )
            {
              v39 = 1;
              v77 = 10;
              v218 = -v103;
            }
            else
            {
              v218 = v103;
              v39 = 0;
              v77 = 10;
            }
            goto LABEL_89;
          case 'h':
LABEL_104:
            v52 = 1;
            v46 = v243[1];
            v45 = (__int64)++v243;
            switch ( v46 )
            {
              case '%':
                goto LABEL_152;
              case 'X':
              case 'x':
                goto LABEL_147;
              case 'd':
              case 'i':
                goto LABEL_148;
              case 'h':
                v46 = v243[1];
                ++v243;
                v51 = (_DWORD *)(&dword_0 + 1);
                v52 = 0;
                switch ( v46 )
                {
                  case '%':
                    goto LABEL_152;
                  case 'A':
                  case 'a':
                    goto LABEL_135;
                  case 'C':
                    goto LABEL_36;
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'e':
                  case 'f':
                  case 'g':
                    goto LABEL_141;
                  case 'S':
                  case 's':
                    goto LABEL_55;
                  case 'X':
                  case 'x':
                    goto LABEL_147;
                  case 'c':
                    goto LABEL_63;
                  case 'd':
                  case 'i':
                    goto LABEL_148;
                  case 'm':
                    goto LABEL_75;
                  case 'n':
                    goto LABEL_76;
                  case 'o':
                    goto LABEL_84;
                  case 'p':
                    goto LABEL_131;
                  case 'u':
                    goto LABEL_96;
                  default:
                    goto LABEL_25;
                }
              case 'n':
                goto LABEL_76;
              case 'o':
                goto LABEL_84;
              case 'u':
                goto LABEL_96;
              default:
                goto LABEL_25;
            }
          case 'l':
LABEL_102:
            v39 = 1;
            v46 = v243[1];
            v45 = (__int64)++v243;
            switch ( v46 )
            {
              case '%':
                goto LABEL_152;
              case 'A':
              case 'a':
                goto LABEL_135;
              case 'C':
                goto LABEL_36;
              case 'E':
              case 'F':
              case 'G':
              case 'e':
              case 'f':
              case 'g':
                goto LABEL_141;
              case 'S':
              case 's':
                goto LABEL_55;
              case 'X':
              case 'x':
                goto LABEL_147;
              case 'c':
                goto LABEL_63;
              case 'd':
              case 'i':
                goto LABEL_148;
              case 'l':
                goto LABEL_101;
              case 'm':
                goto LABEL_75;
              case 'n':
                goto LABEL_76;
              case 'o':
                goto LABEL_84;
              case 'p':
                goto LABEL_131;
              case 'u':
                goto LABEL_96;
              default:
                goto LABEL_25;
            }
          case 'm':
LABEL_75:
            v73 = sub_23140(
                    v235,
                    v254,
                    1000LL,
                    *(double *)a7.m128_u64,
                    *(double *)v27.m128_u64,
                    *(double *)a9.m128i_i64,
                    *(double *)a10.m128_u64,
                    v40,
                    v41,
                    a13,
                    a14);
            v39 = 0;
            v70 = (const char *)v73;
LABEL_58:
            if ( !v70 )
            {
              if ( (_DWORD)v54 == -1 || (int)v54 > 5 )
              {
                LODWORD(v149) = 6;
                v150 = 6LL;
                v70 = (const char *)&unk_A3B60;
              }
              else
              {
                LODWORD(v149) = 0;
                v150 = 0LL;
                v70 = (const char *)&unk_A3AC8;
              }
              goto LABEL_288;
            }
            if ( !v39 && v46 != 83 )
            {
              v42 = sub_63D80(
                      (__int64)a1,
                      (__int64)v70,
                      v54,
                      v198,
                      v209,
                      (unsigned int)v42,
                      *(double *)a7.m128_u64,
                      *(double *)v27.m128_u64,
                      *(double *)a9.m128i_i64,
                      *(double *)a10.m128_u64,
                      v40,
                      v41,
                      a13,
                      a14);
              if ( v42 < 0 )
                goto LABEL_28;
              goto LABEL_44;
            }
            if ( (_DWORD)v54 != -1 )
              goto LABEL_287;
            v149 = sub_90D0(v70);
            v150 = v149;
            goto LABEL_288;
          case 'n':
LABEL_76:
            if ( (v229 & 2) != 0 && !v239 )
            {
              v211 = (int)v51;
              v203 = v39;
              v171 = sub_90D0(v196);
              v174 = sub_6EE40(
                       v196,
                       4 * v171 + 4,
                       *(double *)a7.m128_u64,
                       *(double *)v27.m128_u64,
                       *(double *)a9.m128i_i64,
                       *(double *)a10.m128_u64,
                       v172,
                       v173,
                       a13,
                       a14);
              v39 = v203;
              LODWORD(v51) = v211;
              v239 = v174;
              if ( v174 < 0 )
                sub_17110(
                  (__int64)"*** %n in writable segment detected ***\n",
                  *(double *)a7.m128_u64,
                  *(double *)v27.m128_u64,
                  *(double *)a9.m128i_i64,
                  *(double *)a10.m128_u64,
                  v175,
                  v176,
                  a13,
                  a14);
            }
            v74 = a3->m128i_i32[0];
            if ( v39 )
            {
              if ( v74 <= 0x2F )
              {
                v75 = (_QWORD **)(a3[1].m128i_i64[0] + v74);
                a3->m128i_i32[0] = v74 + 8;
              }
              else
              {
                v75 = (_QWORD **)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v75 + 1);
              }
              **v75 = v42;
            }
            else if ( (_DWORD)v51 )
            {
              if ( v74 > 0x2F )
              {
                v170 = (_BYTE **)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v170 + 1);
              }
              else
              {
                v170 = (_BYTE **)(a3[1].m128i_i64[0] + v74);
                a3->m128i_i32[0] = v74 + 8;
              }
              **v170 = v42;
            }
            else if ( v52 )
            {
              if ( v74 > 0x2F )
              {
                v191 = (_WORD **)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v191 + 1);
              }
              else
              {
                v191 = (_WORD **)(a3[1].m128i_i64[0] + v74);
                a3->m128i_i32[0] = v74 + 8;
              }
              **v191 = v42;
            }
            else
            {
              if ( v74 > 0x2F )
              {
                v163 = (int **)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v163 + 1);
              }
              else
              {
                v163 = (int **)(a3[1].m128i_i64[0] + v74);
                a3->m128i_i32[0] = v74 + 8;
              }
              **v163 = v42;
            }
            goto LABEL_44;
          case 'o':
LABEL_84:
            v77 = 8;
LABEL_85:
            v78 = a3->m128i_i32[0];
            if ( v39 )
              goto LABEL_86;
            goto LABEL_97;
          case 'p':
LABEL_131:
            v93 = a3->m128i_i32[0];
            if ( a3->m128i_i32[0] > 0x2Fu )
            {
              v94 = (__int64 *)a3->m128i_i64[1];
              a3->m128i_i64[1] = (__int64)(v94 + 1);
            }
            else
            {
              v94 = (__int64 *)(a3[1].m128i_i64[0] + v93);
              a3->m128i_i32[0] = v93 + 8;
            }
            if ( *v94 )
            {
              v218 = *v94;
              v39 = 0;
              v46 = 120;
              v77 = 16;
              v231 = 0;
              v234 = 1;
LABEL_89:
              if ( (int)v54 < 0 )
              {
                v54 = 1LL;
              }
              else
              {
                if ( !(_DWORD)v54 )
                {
                  if ( !v218 )
                  {
                    if ( v77 == 8 && v234 )
                    {
                      v255 = 48;
                      v80 = 4LL;
                      v81 = (char *)&v255;
                    }
                    else
                    {
                      v80 = 0LL;
                      v81 = (char *)v256;
                    }
                    v224 = 32;
                    v82 = 0LL;
LABEL_351:
                    if ( !v209 )
                    {
                      v38 = v80 >> 2;
                      v109 = v198 - (_DWORD)v82 - (unsigned int)(v80 >> 2);
                      goto LABEL_179;
                    }
                    goto LABEL_208;
                  }
                  v54 = 0LL;
                }
                v224 = 32;
              }
              v105 = "0";
              if ( v46 != 88 )
                v105 = "0";
              if ( v77 == 10 )
              {
                v144 = v218;
                v81 = (char *)v256;
                do
                {
                  v81 -= 4;
                  *(_DWORD *)v81 = *(_DWORD *)&v105[4 * (v144 % 0xA)];
                  v145 = v144;
                  v144 /= 0xAuLL;
                }
                while ( v145 > 9 );
                if ( v233 && v231 )
                  goto LABEL_166;
LABEL_167:
                if ( v77 == 10 && v236 )
                {
                  v237 = v39;
                  v107 = sub_63BE0(v81, (__int64)v256, (char *)v256);
                  v77 = 10;
                  v39 = v237;
                  v81 = v107;
                }
              }
              else
              {
                if ( v77 == 16 )
                {
                  v138 = v218;
                  v81 = (char *)v256;
                  do
                  {
                    v81 -= 4;
                    *(_DWORD *)v81 = *(_DWORD *)&v105[4 * (v138 & 0xF)];
                    v139 = v138;
                    v138 >>= 4;
                  }
                  while ( v139 > 0xF );
                }
                else
                {
                  v136 = v218;
                  v81 = (char *)v256;
                  do
                  {
                    v81 -= 4;
                    *(_DWORD *)v81 = *(_DWORD *)&v105[4 * (v136 & 7)];
                    v137 = v136;
                    v136 >>= 3;
                  }
                  while ( v137 > 7 );
                }
                if ( v233 && v231 )
                {
LABEL_166:
                  v242 = v77;
                  v241 = v39;
                  v106 = sub_63B00((__int64)v254, (__int64)v81, (__int64)v256, (_BYTE *)v233, v240);
                  v77 = v242;
                  v39 = v241;
                  v81 = (char *)v106;
                  goto LABEL_167;
                }
              }
              v80 = (char *)v256 - v81;
              v108 = ((char *)v256 - v81) >> 2;
              v38 = v108;
              if ( v108 >= v54 )
              {
                if ( !v218 )
                {
                  v82 = (_DWORD *)(v54 - v108);
                  if ( v54 - v108 < 0 )
                    v82 = 0LL;
                  LODWORD(v54) = (_DWORD)v82;
                  goto LABEL_351;
                }
                v110 = v234 & 1;
                if ( v77 == 8 && v110 )
                {
                  *((_DWORD *)v81 - 1) = 48;
                  v80 = (char *)v256 - (v81 - 4);
                  v81 -= 4;
                }
                v38 = v80 >> 2;
                v82 = (_DWORD *)(v54 - (v80 >> 2));
                if ( (__int64)v82 < 0 )
                  v82 = 0LL;
                LODWORD(v54) = (_DWORD)v82;
                if ( !v209 )
                {
                  v109 = (unsigned int)(v198 - v38 - (_DWORD)v82);
LABEL_176:
                  if ( v77 == 16 && v110 )
                    v109 = (unsigned int)(v109 - 2);
LABEL_179:
                  if ( v39 | v221 | v228 )
                  {
                    v109 = (unsigned int)(v109 - 1);
                    if ( v224 != 32 )
                      goto LABEL_181;
                    if ( (int)v109 <= 0 )
                    {
                      v109 = 0LL;
                      goto LABEL_181;
                    }
LABEL_265:
                    v238 = v38;
                    v201 = (_DWORD *)(int)v109;
                    v232 = v77;
                    v225 = v39;
                    v210 = v109;
                    v142 = sub_6A3E0(
                             (__int64)a1,
                             32,
                             v109,
                             *(double *)a7.m128_u64,
                             *(double *)v27.m128_u64,
                             *(double *)a9.m128i_i64,
                             *(double *)a10.m128_u64,
                             v40,
                             v41,
                             a13,
                             a14);
                    v82 = v201;
                    if ( v201 != (_DWORD *)v142 )
                      goto LABEL_73;
                    v143 = 0;
                    v39 = v225;
                    v77 = v232;
                    v38 = v238;
                    v42 += v210;
                    if ( v42 < 0 || v42 < (unsigned int)v201 )
                      v143 = 1;
                    v109 = v143;
                    if ( v143 )
                      goto LABEL_317;
                    if ( v42 < 0 )
                      goto LABEL_28;
LABEL_181:
                    if ( v39 )
                    {
                      v111 = a1[20];
                      if ( v111 )
                      {
                        v82 = *(_DWORD **)(v111 + 32);
                        if ( (unsigned __int64)v82 < *(_QWORD *)(v111 + 40) )
                        {
                          *(_QWORD *)(v111 + 32) = v82 + 1;
                          *v82 = 45;
                          goto LABEL_185;
                        }
                      }
                      v223 = v38;
                      v185 = 45;
                      v213 = v77;
                      v204 = v109;
LABEL_424:
                      v186 = sub_6AB50(
                               (__int64)a1,
                               v185,
                               (__int64)v82,
                               v109,
                               (u32 *)v38,
                               v39,
                               *(double *)a7.m128_u64,
                               *(double *)v27.m128_u64,
                               *(double *)a9.m128i_i64,
                               *(double *)a10.m128_u64,
                               v40,
                               v41,
                               a13,
                               a14);
                      v109 = v204;
                      v77 = v213;
                      v38 = v223;
                      if ( v186 == -1 )
                        goto LABEL_73;
                      goto LABEL_185;
                    }
                    if ( v221 )
                    {
                      v148 = a1[20];
                      if ( !v148 || (v82 = *(_DWORD **)(v148 + 32), (unsigned __int64)v82 >= *(_QWORD *)(v148 + 40)) )
                      {
                        v223 = v38;
                        v185 = 43;
                        v213 = v77;
                        v204 = v109;
                        goto LABEL_424;
                      }
                      *(_QWORD *)(v148 + 32) = v82 + 1;
                      *v82 = 43;
LABEL_185:
                      if ( v42 == 0x7FFFFFFF )
                        goto LABEL_73;
                      ++v42;
                    }
                    else if ( v228 )
                    {
                      v182 = a1[20];
                      if ( !v182 || (v82 = *(_DWORD **)(v182 + 32), (unsigned __int64)v82 >= *(_QWORD *)(v182 + 40)) )
                      {
                        v223 = v38;
                        v185 = 32;
                        v213 = v77;
                        v204 = v109;
                        goto LABEL_424;
                      }
                      *(_QWORD *)(v182 + 32) = v82 + 1;
                      *v82 = 32;
                      goto LABEL_185;
                    }
                  }
                  else if ( v224 == 32 )
                  {
                    if ( (int)v109 > 0 )
                      goto LABEL_265;
                    v109 = 0LL;
                  }
                  if ( v218 && v77 == 16 && v234 )
                  {
                    v112 = a1[20];
                    if ( v112
                      && (v113 = *(_DWORD **)(v112 + 32), v114 = *(_QWORD *)(v112 + 40), (unsigned __int64)v113 < v114) )
                    {
                      v115 = v113 + 1;
                      *(_QWORD *)(v112 + 32) = v113 + 1;
                      *v113 = 48;
                      if ( v42 == 0x7FFFFFFF )
                        goto LABEL_73;
LABEL_193:
                      if ( (unsigned __int64)v115 < v114 )
                      {
                        *(_QWORD *)(v112 + 32) = v115 + 1;
                        *v115 = v46;
                        if ( v46 == -1 )
                          goto LABEL_73;
                        goto LABEL_195;
                      }
                    }
                    else
                    {
                      v214 = v38;
                      v206 = v109;
                      v189 = sub_6AB50(
                               (__int64)a1,
                               0x30u,
                               v234,
                               v109,
                               (u32 *)v38,
                               v39,
                               *(double *)a7.m128_u64,
                               *(double *)v27.m128_u64,
                               *(double *)a9.m128i_i64,
                               *(double *)a10.m128_u64,
                               v40,
                               v41,
                               a13,
                               a14);
                      v109 = v206;
                      v38 = v214;
                      if ( v189 == -1 || v42 == 0x7FFFFFFF )
                        goto LABEL_73;
                      v112 = a1[20];
                      if ( v112 )
                      {
                        v115 = *(unsigned int **)(v112 + 32);
                        v114 = *(_QWORD *)(v112 + 40);
                        goto LABEL_193;
                      }
                    }
                    v215 = v38;
                    v207 = v109;
                    v190 = sub_6AB50(
                             (__int64)a1,
                             v46,
                             (__int64)v115,
                             v109,
                             (u32 *)v38,
                             v39,
                             *(double *)a7.m128_u64,
                             *(double *)v27.m128_u64,
                             *(double *)a9.m128i_i64,
                             *(double *)a10.m128_u64,
                             v40,
                             v41,
                             a13,
                             a14);
                    LODWORD(v109) = v207;
                    v38 = v215;
                    if ( v190 == -1 )
                      goto LABEL_73;
LABEL_195:
                    if ( v42 == 2147483646 )
                      goto LABEL_73;
                    v42 += 2;
                  }
                  v116 = v109 + v54;
                  if ( v116 > 0 )
                  {
                    v202 = v38;
                    if ( v116 != sub_6A3E0(
                                   (__int64)a1,
                                   48,
                                   v116,
                                   *(double *)a7.m128_u64,
                                   *(double *)v27.m128_u64,
                                   *(double *)a9.m128i_i64,
                                   *(double *)a10.m128_u64,
                                   v40,
                                   v41,
                                   a13,
                                   a14) )
                      goto LABEL_73;
                    v146 = 0;
                    v147 = v116 + v42 < 0;
                    v42 += v116;
                    v38 = v202;
                    if ( v147 || v42 < (unsigned int)v116 )
                      v146 = 1;
                    if ( v146 )
                      goto LABEL_317;
                    if ( v42 < 0 )
                      goto LABEL_28;
                  }
                  v117 = a1[27];
                  if ( v197 <= v117 - (__int64)&unk_BFAE0 )
                  {
                    v205 = v38;
                    sub_17140(
                      *(double *)a7.m128_u64,
                      *(double *)v27.m128_u64,
                      *(double *)a9.m128i_i64,
                      *(double *)a10.m128_u64,
                      v40,
                      v41,
                      a13,
                      a14);
                    v38 = v205;
                  }
                  v199 = v38;
                  v118 = (*(__int64 (__fastcall **)(_QWORD *, char *, unsigned __int64))(v117 + 56))(a1, v81, v38);
                  v38 = v199;
                  if ( v199 != v118 )
                    goto LABEL_73;
                  v119 = 0;
                  v120 = v199 + v42;
                  if ( v120 < 0 || v120 < v199 )
LABEL_358:
                    v119 = 1;
LABEL_203:
                  v42 = v120;
                  if ( v120 != (int)v120 )
                    v119 = 1;
                  if ( v119 )
                    goto LABEL_317;
                  if ( (int)v120 < 0 )
                    goto LABEL_28;
                  goto LABEL_44;
                }
              }
              else
              {
                v82 = (_DWORD *)(v54 - v108);
                if ( v54 - v108 < 0 )
                  v82 = 0LL;
                LODWORD(v54) = (_DWORD)v82;
                if ( !v209 )
                {
                  v109 = (unsigned int)(v198 - v108 - (_DWORD)v82);
                  if ( v218 )
                  {
                    v110 = v234 & 1;
                    goto LABEL_176;
                  }
                  goto LABEL_179;
                }
              }
LABEL_208:
              if ( v39 )
              {
                v121 = a1[20];
                if ( v121 )
                {
                  v122 = *(_DWORD **)(v121 + 32);
                  if ( (unsigned __int64)v122 < *(_QWORD *)(v121 + 40) )
                  {
                    *(_QWORD *)(v121 + 32) = v122 + 1;
                    *v122 = 45;
                    goto LABEL_212;
                  }
                }
                v226 = v77;
                v183 = 45;
                v222 = v82;
                v212 = v80;
LABEL_421:
                v184 = sub_6AB50(
                         (__int64)a1,
                         v183,
                         (__int64)v82,
                         v80,
                         (u32 *)v38,
                         v39,
                         *(double *)a7.m128_u64,
                         *(double *)v27.m128_u64,
                         *(double *)a9.m128i_i64,
                         *(double *)a10.m128_u64,
                         v40,
                         v41,
                         a13,
                         a14);
                v80 = v212;
                v82 = v222;
                v77 = v226;
                if ( v184 == -1 )
                  goto LABEL_73;
                goto LABEL_212;
              }
              if ( v221 )
              {
                v140 = a1[20];
                if ( !v140 || (v141 = *(_DWORD **)(v140 + 32), (unsigned __int64)v141 >= *(_QWORD *)(v140 + 40)) )
                {
                  v226 = v77;
                  v183 = 43;
                  v222 = v82;
                  v212 = v80;
                  goto LABEL_421;
                }
                *(_QWORD *)(v140 + 32) = v141 + 1;
                *v141 = 43;
LABEL_212:
                if ( v42 == 0x7FFFFFFF )
                  goto LABEL_73;
                --v198;
                ++v42;
              }
              else if ( v228 )
              {
                v156 = a1[20];
                if ( !v156 || (v157 = *(_DWORD **)(v156 + 32), (unsigned __int64)v157 >= *(_QWORD *)(v156 + 40)) )
                {
                  v226 = v77;
                  v183 = 32;
                  v222 = v82;
                  v212 = v80;
                  goto LABEL_421;
                }
                *(_QWORD *)(v156 + 32) = v157 + 1;
                *v157 = 32;
                goto LABEL_212;
              }
              if ( v218 && v77 == 16 && v234 )
              {
                v123 = a1[20];
                if ( v123
                  && (v124 = *(_DWORD **)(v123 + 32), v38 = *(_QWORD *)(v123 + 40), (unsigned __int64)v124 < v38) )
                {
                  v125 = v124 + 1;
                  *(_QWORD *)(v123 + 32) = v124 + 1;
                  *v124 = 48;
                  if ( v42 == 0x7FFFFFFF )
                    goto LABEL_73;
LABEL_220:
                  if ( v38 > (unsigned __int64)v125 )
                  {
                    *(_QWORD *)(v123 + 32) = v125 + 1;
                    *v125 = v46;
                    if ( v46 == -1 )
                      goto LABEL_73;
                    goto LABEL_222;
                  }
                }
                else
                {
                  v219 = v82;
                  v216 = v80;
                  v194 = sub_6AB50(
                           (__int64)a1,
                           0x30u,
                           (__int64)v82,
                           v80,
                           (u32 *)v38,
                           v39,
                           *(double *)a7.m128_u64,
                           *(double *)v27.m128_u64,
                           *(double *)a9.m128i_i64,
                           *(double *)a10.m128_u64,
                           v40,
                           v41,
                           a13,
                           a14);
                  v80 = v216;
                  v82 = v219;
                  if ( v194 == -1 || v42 == 0x7FFFFFFF )
                    goto LABEL_73;
                  v123 = a1[20];
                  if ( v123 )
                  {
                    v125 = *(unsigned int **)(v123 + 32);
                    v38 = *(_QWORD *)(v123 + 40);
                    goto LABEL_220;
                  }
                }
                v220 = (int)v82;
                v217 = v80;
                v195 = sub_6AB50(
                         (__int64)a1,
                         v46,
                         (__int64)v82,
                         v80,
                         (u32 *)v38,
                         v39,
                         *(double *)a7.m128_u64,
                         *(double *)v27.m128_u64,
                         *(double *)a9.m128i_i64,
                         *(double *)a10.m128_u64,
                         v40,
                         v41,
                         a13,
                         a14);
                v80 = v217;
                LODWORD(v82) = v220;
                if ( v195 == -1 )
                  goto LABEL_73;
LABEL_222:
                if ( v42 == 2147483646 )
                  goto LABEL_73;
                v198 -= 2;
                v42 += 2;
              }
              v126 = v80 >> 2;
              v127 = v126;
              v200 = v198 - (v126 + (_DWORD)v82);
              if ( (int)v54 > 0 )
              {
                if ( (int)v54 != sub_6A3E0(
                                   (__int64)a1,
                                   48,
                                   v54,
                                   *(double *)a7.m128_u64,
                                   *(double *)v27.m128_u64,
                                   *(double *)a9.m128i_i64,
                                   *(double *)a10.m128_u64,
                                   v40,
                                   v41,
                                   a13,
                                   a14) )
                  goto LABEL_73;
                v128 = 0;
                v42 += v54;
                if ( v42 < 0 || v42 < (unsigned int)v54 )
                  v128 = 1;
                if ( v128 )
                  goto LABEL_317;
                if ( v42 < 0 )
                  goto LABEL_28;
              }
              v129 = a1[27];
              if ( v197 <= v129 - (__int64)&unk_BFAE0 )
                sub_17140(
                  *(double *)a7.m128_u64,
                  *(double *)v27.m128_u64,
                  *(double *)a9.m128i_i64,
                  *(double *)a10.m128_u64,
                  v40,
                  v41,
                  a13,
                  a14);
              if ( (*(__int64 (__fastcall **)(_QWORD *, char *, unsigned __int64, __int64, unsigned __int64))(v129 + 56))(
                     a1,
                     v81,
                     v127,
                     v126,
                     v38) != v127 )
                goto LABEL_73;
              v132 = 0;
              v133 = v127 + v42;
              if ( v133 < 0 || v133 < v127 )
                v132 = 1;
              v42 += v127;
              if ( v133 != (int)v133 )
                v132 = 1;
              if ( v132 )
                goto LABEL_317;
              if ( (int)v133 < 0 )
                goto LABEL_28;
              v134 = v200;
              if ( v200 <= 0 )
                goto LABEL_44;
              goto LABEL_240;
            }
            v70 = "(";
            if ( (int)v54 < 5 )
              LODWORD(v54) = 5;
LABEL_287:
            v149 = sub_91A0(v70, (int)v54);
            v150 = v149;
LABEL_288:
            LODWORD(v134) = v198 - v149;
            if ( v198 - (int)v149 < 0 )
            {
              v164 = a1[27];
              if ( v197 <= v164 - (__int64)&unk_BFAE0 )
                sub_17140(
                  *(double *)a7.m128_u64,
                  *(double *)v27.m128_u64,
                  *(double *)a9.m128i_i64,
                  *(double *)a10.m128_u64,
                  v40,
                  v41,
                  a13,
                  a14);
              if ( (*(__int64 (__fastcall **)(_QWORD *, const char *, unsigned __int64))(v164 + 56))(a1, v70, v150) != v150 )
                goto LABEL_73;
              v119 = 0;
              v120 = v150 + v42;
              if ( v120 < 0 || v120 < v150 )
                goto LABEL_358;
              goto LABEL_203;
            }
            if ( !v209 && (_DWORD)v134 )
            {
              if ( (int)v134 != sub_6A3E0(
                                  (__int64)a1,
                                  32,
                                  v134,
                                  *(double *)a7.m128_u64,
                                  *(double *)v27.m128_u64,
                                  *(double *)a9.m128i_i64,
                                  *(double *)a10.m128_u64,
                                  v40,
                                  v41,
                                  a13,
                                  a14) )
                goto LABEL_73;
              v42 += v134;
              if ( v42 < 0 || v42 < (unsigned int)v134 )
                goto LABEL_317;
            }
            v151 = a1[27];
            if ( v197 <= v151 - (__int64)&unk_BFAE0 )
            {
              v208 = a1[27];
              sub_17140(
                *(double *)a7.m128_u64,
                *(double *)v27.m128_u64,
                *(double *)a9.m128i_i64,
                *(double *)a10.m128_u64,
                v40,
                v41,
                a13,
                a14);
              v151 = v208;
            }
            if ( (*(__int64 (__fastcall **)(_QWORD *, const char *, unsigned __int64))(v151 + 56))(a1, v70, v150) != v150 )
              goto LABEL_73;
            v152 = 0;
            v153 = v150 + v42;
            if ( v153 < 0 || v153 < v150 )
              v152 = 1;
            v42 += v150;
            if ( v153 != (int)v153 )
              v152 = 1;
            if ( v152 )
              goto LABEL_317;
            if ( (int)v153 < 0 )
              goto LABEL_28;
            if ( v209 && (_DWORD)v134 )
            {
              v134 = (int)v134;
LABEL_240:
              if ( v134 != sub_6A3E0(
                             (__int64)a1,
                             32,
                             v134,
                             *(double *)a7.m128_u64,
                             *(double *)v27.m128_u64,
                             *(double *)a9.m128i_i64,
                             *(double *)a10.m128_u64,
                             v130,
                             v131,
                             a13,
                             a14) )
                goto LABEL_73;
              v135 = __OFADD__(v42, (_DWORD)v134);
              v42 += v134;
              if ( v135 )
                goto LABEL_317;
LABEL_242:
              if ( v42 < 0 )
                goto LABEL_28;
            }
LABEL_44:
            ++v227;
            v60 = (int *)++v243;
            v61 = sub_6D5D0(v243, 37);
            v64 = a1[27];
            v243 = (unsigned int *)v61;
            v65 = v61 - v60;
            if ( v197 <= v64 - (__int64)&unk_BFAE0 )
              sub_17140(
                *(double *)a7.m128_u64,
                *(double *)v27.m128_u64,
                *(double *)a9.m128i_i64,
                *(double *)a10.m128_u64,
                v62,
                v63,
                a13,
                a14);
            a2 = (__int64)v60;
            if ( (*(__int64 (__fastcall **)(_QWORD *, int *, unsigned __int64))(v64 + 56))(a1, v60, v65) != v65 )
              goto LABEL_73;
            v66 = 0;
            v67 = v65 + v42;
            if ( v67 < 0 || v67 < v65 )
              v66 = 1;
            v42 += v65;
            v45 = 1LL;
            if ( v67 != (int)v67 )
              v66 = 1;
            if ( v66 )
              goto LABEL_317;
            if ( (int)v67 < 0 )
              goto LABEL_28;
            v44 = v243;
            v39 = *v243;
            if ( !*v243 )
              goto LABEL_28;
            continue;
          case 'u':
LABEL_96:
            v78 = a3->m128i_i32[0];
            v77 = 10;
            if ( v39 )
            {
LABEL_86:
              if ( v78 > 0x2F )
              {
                v79 = (__int64 *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v79 + 1);
              }
              else
              {
                v79 = (__int64 *)(a3[1].m128i_i64[0] + v78);
                a3->m128i_i32[0] = v78 + 8;
              }
              v221 = 0;
              v39 = 0;
              v228 = 0;
              v218 = *v79;
            }
            else
            {
LABEL_97:
              if ( (_DWORD)v51 )
              {
                if ( v78 > 0x2F )
                {
                  v83 = (unsigned __int8 *)a3->m128i_i64[1];
                  a3->m128i_i64[1] = (__int64)(v83 + 8);
                }
                else
                {
                  v83 = (unsigned __int8 *)(a3[1].m128i_i64[0] + v78);
                  a3->m128i_i32[0] = v78 + 8;
                }
                v221 = 0;
                v228 = 0;
                v218 = *v83;
              }
              else if ( v52 )
              {
                if ( v78 > 0x2F )
                {
                  v165 = (unsigned __int16 *)a3->m128i_i64[1];
                  a3->m128i_i64[1] = (__int64)(v165 + 4);
                }
                else
                {
                  v165 = (unsigned __int16 *)(a3[1].m128i_i64[0] + v78);
                  a3->m128i_i32[0] = v78 + 8;
                }
                v221 = 0;
                v39 = 0;
                v228 = 0;
                v218 = *v165;
              }
              else
              {
                if ( v78 > 0x2F )
                {
                  v154 = (unsigned int *)a3->m128i_i64[1];
                  a3->m128i_i64[1] = (__int64)(v154 + 2);
                }
                else
                {
                  v154 = (unsigned int *)(a3[1].m128i_i64[0] + v78);
                  a3->m128i_i32[0] = v78 + 8;
                }
                v221 = 0;
                v39 = 0;
                v228 = 0;
                v218 = *v154;
              }
            }
            goto LABEL_89;
          default:
LABEL_25:
            if ( v46 )
              goto LABEL_26;
            v42 = -1;
            __writefsdword(0xFFFFFFC0, 0x16u);
            goto LABEL_28;
        }
        break;
      }
    }
    v42 = v47;
    goto LABEL_28;
  }
  return sub_68C50(
           (__int64)a1,
           a2,
           (__int64)a3,
           v229,
           v22,
           v23,
           *(double *)a7.m128_u64,
           a8,
           *(double *)a9.m128i_i64,
           *(double *)a10.m128_u64,
           v24,
           v25,
           a13,
           a14);
}
// 66AE0: conditional instruction was optimized away because of '%var_4EC.4==0'
// 66B45: conditional instruction was optimized away because of '%var_4EC.4==0'
// 66E50: conditional instruction was optimized away because of 'er13.4>=0'
// 67798: conditional instruction was optimized away because of 'er10.4==8'
// 683BA: conditional instruction was optimized away because of 'er13.4>=0'
// 68479: conditional instruction was optimized away because of 'er13.4>=0'
// 668A3: variable 'v16' is possibly undefined
// 668A3: variable 'v17' is possibly undefined
// 668A3: variable 'v18' is possibly undefined
// 668A3: variable 'v19' is possibly undefined
// 668A3: variable 'v20' is possibly undefined
// 668A3: variable 'v21' is possibly undefined
// 68098: variable 'v31' is possibly undefined
// 68098: variable 'v32' is possibly undefined
// 66AC3: variable 'v40' is possibly undefined
// 66AC3: variable 'v41' is possibly undefined
// 67D68: variable 'v62' is possibly undefined
// 67D68: variable 'v63' is possibly undefined
// 66DC3: variable 'v39' is possibly undefined
// 66E7B: variable 'v45' is possibly undefined
// 66E7B: variable 'v38' is possibly undefined
// 66E9B: variable 'v57' is possibly undefined
// 67522: variable 'v53' is possibly undefined
// 67B85: variable 'v126' is possibly undefined
// 67BE3: variable 'v130' is possibly undefined
// 67BE3: variable 'v131' is possibly undefined
// 67C56: variable 'v22' is possibly undefined
// 67C56: variable 'v23' is possibly undefined
// 67C56: variable 'v24' is possibly undefined
// 67C56: variable 'v25' is possibly undefined
// 685E6: variable 'v172' is possibly undefined
// 685E6: variable 'v173' is possibly undefined
// 68607: variable 'v175' is possibly undefined
// 68607: variable 'v176' is possibly undefined
// 687BF: variable 'v28' is possibly undefined
// 687BF: variable 'v29' is possibly undefined
// 687BF: variable 'v30' is possibly undefined
// 6896B: variable 'v115' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);
// 90B0: using guessed type __int64 __fastcall sub_90B0(_QWORD, _QWORD);
// 90D0: using guessed type __int64 __fastcall sub_90D0(_QWORD);
// 9160: using guessed type __int64 __fastcall sub_9160(_QWORD, _QWORD, _QWORD);
// 91A0: using guessed type __int64 __fastcall sub_91A0(_QWORD, _QWORD);
// BB920: using guessed type void *jpt_6711A[30];
// C0308: using guessed type void *off_C0308;
// C1788: using guessed type __int64 qword_C1788;
// C1798: using guessed type __int64 qword_C1798;
// C1B18: using guessed type __int64 qword_C1B18;

//----- (0000000000068C50) ----------------------------------------------------
__int64 __fastcall sub_68C50(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  unsigned int v14; // er13
  int v17; // eax
  u32 *v18; // r8
  u32 v19; // er9
  unsigned int v20; // er12
  double v21; // xmm4_8
  double v22; // xmm5_8
  __int64 v23; // rdx
  __int64 v24; // rax
  int v25; // ebp
  __int64 v26; // r14
  __int64 v27; // rdi
  int v28; // eax
  unsigned __int64 v31; // rbp
  signed __int64 v33; // rax
  int v34[34]; // [rsp+20h] [rbp-8218h] BYREF
  __int64 v35; // [rsp+A8h] [rbp-8190h]
  char *v36; // [rsp+C0h] [rbp-8178h]
  int v37; // [rsp+E0h] [rbp-8158h]
  void *v38; // [rsp+F8h] [rbp-8140h]
  char v39; // [rsp+100h] [rbp-8138h] BYREF
  char *v40; // [rsp+118h] [rbp-8120h]
  char *v41; // [rsp+120h] [rbp-8118h]
  char *v42; // [rsp+128h] [rbp-8110h]
  __int64 v43; // [rsp+1E8h] [rbp-8050h]
  char v44[32768]; // [rsp+200h] [rbp-8038h] BYREF
  char v45; // [rsp+8200h] [rbp-38h] BYREF
  unsigned __int64 v46; // [rsp+8208h] [rbp-30h]

  v14 = a4;
  v46 = __readfsqword(0x28u);
  if ( (unsigned int)sub_16780(a1, 1LL, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) != 1 )
    return (unsigned int)-1;
  v43 = a1;
  v36 = &v39;
  v41 = v44;
  v40 = v44;
  v42 = &v45;
  v17 = *(_DWORD *)(a1 + 116);
  v37 = 1;
  v34[29] = v17;
  v34[0] = -72515580;
  v35 = 0LL;
  v38 = &unk_C01A0;
  v20 = sub_66830(v34, a2, a3, v14);
  v23 = *(_DWORD *)a1 & 0x8000;
  if ( (*(_DWORD *)a1 & 0x8000) != 0 )
  {
    v24 = (__int64)v36;
    v25 = (__int64)(*((_QWORD *)v36 + 4) - *((_QWORD *)v36 + 3)) >> 2;
    if ( v25 <= 0 )
      return v20;
  }
  else
  {
    _RDI = *(_QWORD *)(a1 + 136);
    v31 = __readfsqword(0x10u);
    if ( *(_QWORD *)(_RDI + 8) != v31 )
    {
      if ( __readfsdword(0x18u) )
      {
        if ( (_DWORD)v23 != _InterlockedCompareExchange((volatile signed __int32 *)_RDI, 1, v23) )
          sub_1C7D0((volatile __int32 *)_RDI, a2, v23, 1LL, v18, v19);
      }
      else
      {
        _EDX = 1;
        __asm { cmpxchg [rdi], edx }
      }
      _RDI = *(_QWORD *)(a1 + 136);
      *(_QWORD *)(_RDI + 8) = v31;
    }
    v24 = (__int64)v36;
    ++*(_DWORD *)(_RDI + 4);
    v25 = (__int64)(*(_QWORD *)(v24 + 32) - *(_QWORD *)(v24 + 24)) >> 2;
    if ( v25 <= 0 )
      goto LABEL_8;
  }
  v26 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v26 - (_QWORD)&unk_BFAE0) )
  {
    sub_17140(a7, a8, a9, a10, v21, v22, a13, a14);
    v24 = (__int64)v36;
  }
  if ( v25 != (*(unsigned int (__fastcall **)(__int64, _QWORD, _QWORD))(v26 + 56))(a1, *(_QWORD *)(v24 + 24), v25) )
    v20 = -1;
LABEL_8:
  if ( (*(_DWORD *)a1 & 0x8000) == 0 )
  {
    v27 = *(_QWORD *)(a1 + 136);
    v28 = *(_DWORD *)(v27 + 4) - 1;
    *(_DWORD *)(v27 + 4) = v28;
    if ( !v28 )
    {
      *(_QWORD *)(v27 + 8) = 0LL;
      if ( __readfsdword(0x18u) )
      {
        if ( _InterlockedExchange((volatile __int32 *)v27, 0) > 1 )
          v33 = sys_futex((u32 *)v27, 129, 1u, 0LL, v18, v19);
      }
      else
      {
        --*(_DWORD *)v27;
      }
    }
  }
  return v20;
}
// 68E98: variable 'v21' is possibly undefined
// 68E98: variable 'v22' is possibly undefined
// 68ED1: variable 'v18' is possibly undefined
// 68ED1: variable 'v19' is possibly undefined
// 90B0: using guessed type __int64 __fastcall sub_90B0(_QWORD, _QWORD);
// 9160: using guessed type __int64 __fastcall sub_9160(_QWORD, _QWORD, _QWORD);
// 66830: using guessed type __int64 __fastcall sub_66830(_QWORD, _QWORD, _QWORD, _QWORD);
// C0308: using guessed type void *off_C0308;

//----- (0000000000068F10) ----------------------------------------------------
char *__fastcall sub_68F10(unsigned int a1)
{
  char *result; // rax

  result = 0LL;
  if ( a1 <= 0x85 )
    result = off_BBF20[a1];
  return result;
}
// BBF20: using guessed type char *off_BBF20[41];

//----- (0000000000068F70) ----------------------------------------------------
__int64 __fastcall sub_68F70(__int64 *a1)
{
  __int64 v1; // rdx
  int v2; // er8
  unsigned int v3; // eax
  unsigned __int8 *v4; // rdx
  int v5; // esi
  int v6; // eax
  int v7; // eax

  v1 = *a1;
  v2 = *(unsigned __int8 *)(*a1)++ - 48;
  v3 = *(unsigned __int8 *)(v1 + 1) - 48;
  if ( v3 <= 9 )
  {
    v4 = (unsigned __int8 *)(v1 + 2);
    do
    {
      if ( v2 >= 0 )
      {
        if ( v2 <= 214748364 )
        {
          v5 = 0x7FFFFFFF - v3;
          v6 = 10 * v2 + v3;
          if ( v5 < 10 * v2 )
            v6 = -1;
          v2 = v6;
        }
        else
        {
          v2 = -1;
        }
      }
      *a1 = (__int64)v4;
      v7 = *v4++;
      v3 = v7 - 48;
    }
    while ( v3 <= 9 );
  }
  return (unsigned int)v2;
}

//----- (0000000000068FF0) ----------------------------------------------------
__int64 __fastcall sub_68FF0(__int64 a1, int a2, __int64 a3, __int64 *a4)
{
  unsigned __int8 *v4; // r11
  int v5; // er12
  int v8; // eax
  unsigned __int8 v9; // al
  int v10; // eax
  __int64 v11; // r13
  __int64 v12; // rax
  unsigned __int8 *v13; // rdx
  __int64 v14; // rdx
  bool v15; // zf
  __int64 v16; // rax
  int v17; // eax
  int v18; // eax
  unsigned __int8 *v19; // r13
  __int64 v20; // rax
  unsigned __int8 *v21; // rdx
  int v22; // ecx
  unsigned __int8 *v23; // rdi
  unsigned __int8 *v24; // rdi
  __int64 result; // rax
  int v26; // eax
  unsigned __int8 *v27; // r14
  __int64 v28; // rax
  unsigned __int8 *v29; // rcx
  int v30; // edx
  __int64 (__fastcall *v31)(__int64, __int64, __int64, __int64); // rax
  int v32; // eax
  int v33; // eax
  __int64 v34; // rax
  unsigned __int8 *v35; // rcx
  int v36; // edx
  unsigned __int8 *v37[6]; // [rsp+8h] [rbp-30h] BYREF

  v4 = (unsigned __int8 *)(a1 + 1);
  v5 = a2;
  *(_DWORD *)(a3 + 48) = -1;
  *(_WORD *)(a3 + 12) &= 0xE207u;
  v37[0] = (unsigned __int8 *)(a1 + 1);
  *(_DWORD *)(a3 + 16) = 32;
  v8 = *(unsigned __int8 *)(a1 + 1);
  if ( (unsigned int)(v8 - 48) <= 9 )
  {
    LODWORD(v20) = sub_68F70((__int64 *)v37);
    if ( (_DWORD)v20 && (v21 = v37[0], *v37[0] == 36) )
    {
      v4 = ++v37[0];
      if ( (_DWORD)v20 != -1 )
      {
        v22 = v20 - 1;
        v20 = (unsigned int)v20;
        if ( *a4 >= (unsigned __int64)(unsigned int)v20 )
          v20 = *a4;
        *(_DWORD *)(a3 + 48) = v22;
        *a4 = v20;
      }
      LOBYTE(v8) = v21[1];
    }
    else
    {
      v37[0] = v4;
      LOBYTE(v8) = *(_BYTE *)(a1 + 1);
    }
  }
  v9 = v8 - 32;
  if ( v9 <= 0x29u )
    __asm { jmp     rax }
  if ( (*(_BYTE *)(a3 + 12) & 0x20) != 0 )
    *(_DWORD *)(a3 + 16) = 32;
  *(_DWORD *)(a3 + 44) = -1;
  *(_DWORD *)(a3 + 4) = 0;
  v10 = *v4;
  if ( (_BYTE)v10 == 42 )
  {
    v19 = v4 + 1;
    v37[0] = v4 + 1;
    if ( (unsigned int)v4[1] - 48 > 9 )
      goto LABEL_22;
    LODWORD(v28) = sub_68F70((__int64 *)v37);
    if ( (_DWORD)v28 && (v29 = v37[0], *v37[0] == 36) )
    {
      if ( (_DWORD)v28 == -1 )
      {
        v30 = *(_DWORD *)(a3 + 44);
      }
      else
      {
        v30 = v28 - 1;
        v28 = (unsigned int)v28;
        if ( *a4 >= (unsigned __int64)(unsigned int)v28 )
          v28 = *a4;
        *(_DWORD *)(a3 + 44) = v30;
        *a4 = v28;
      }
      v37[0] = v29 + 1;
    }
    else
    {
      v30 = *(_DWORD *)(a3 + 44);
    }
    if ( v30 < 0 )
    {
LABEL_22:
      *(_DWORD *)(a3 + 44) = a2;
      v4 = v19;
      v5 = a2 + 1;
      v37[0] = v19;
      v11 = 1LL;
    }
    else
    {
      v4 = v37[0];
      v11 = 0LL;
    }
  }
  else
  {
    v11 = 0LL;
    if ( (unsigned int)(v10 - 48) <= 9 )
    {
      v17 = sub_68F70((__int64 *)v37);
      if ( v17 != -1 )
        *(_DWORD *)(a3 + 4) = v17;
      v4 = v37[0];
    }
  }
  *(_DWORD *)(a3 + 40) = -1;
  *(_DWORD *)a3 = -1;
  if ( *v4 == 46 )
  {
    v37[0] = v4 + 1;
    v18 = v4[1];
    if ( (_BYTE)v18 == 42 )
    {
      v27 = v4 + 2;
      v37[0] = v4 + 2;
      if ( (unsigned int)v4[2] - 48 > 9 )
        goto LABEL_39;
      LODWORD(v34) = sub_68F70((__int64 *)v37);
      if ( (_DWORD)v34 && (v35 = v37[0], *v37[0] == 36) )
      {
        if ( (_DWORD)v34 == -1 )
        {
          v36 = *(_DWORD *)(a3 + 40);
        }
        else
        {
          v36 = v34 - 1;
          v34 = (unsigned int)v34;
          if ( *a4 >= (unsigned __int64)(unsigned int)v34 )
            v34 = *a4;
          *(_DWORD *)(a3 + 40) = v36;
          *a4 = v34;
        }
        v37[0] = v35 + 1;
      }
      else
      {
        v36 = *(_DWORD *)(a3 + 40);
      }
      if ( v36 < 0 )
      {
LABEL_39:
        *(_DWORD *)(a3 + 40) = v5;
        ++v11;
        v4 = v27;
        ++v5;
        v37[0] = v27;
        goto LABEL_9;
      }
    }
    else
    {
      if ( (unsigned int)(v18 - 48) > 9 )
      {
        *(_DWORD *)a3 = 0;
        ++v4;
        goto LABEL_9;
      }
      v26 = sub_68F70((__int64 *)v37);
      if ( v26 != -1 )
        *(_DWORD *)a3 = v26;
    }
    v4 = v37[0];
  }
LABEL_9:
  v12 = qword_C1798;
  *(_DWORD *)(a3 + 12) &= 0xFDF8u;
  if ( v12 && *(_QWORD *)(v12 + 8LL * *v4) && (v33 = sub_7F220(v37, a3), v4 = v37[0], !v33) )
  {
    v13 = v37[0] + 1;
  }
  else
  {
    v13 = v4 + 1;
    v37[0] = v4 + 1;
    if ( (unsigned __int8)(*v4 - 76) <= 0x2Eu )
      __asm { jmp     rax }
  }
  v37[0] = v13;
  v14 = *v4;
  v15 = qword_C1788 == 0;
  *(_DWORD *)(a3 + 64) = -1;
  *(_DWORD *)(a3 + 8) = v14;
  if ( v15
    || (v31 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(qword_C1B10 + 8 * v14)) == 0LL
    || (v32 = v31(a3, 1LL, a3 + 52, a3 + 64), *(_QWORD *)(a3 + 56) = v32, LODWORD(v14) = *(_DWORD *)(a3 + 8), v32 < 0) )
  {
    v16 = (unsigned int)(v14 - 65);
    *(_QWORD *)(a3 + 56) = 1LL;
    if ( (unsigned int)v16 <= 0x37 )
      __asm { jmp     rax }
    *(_QWORD *)(a3 + 56) = 0LL;
  }
  else if ( *(_DWORD *)(a3 + 48) == -1 && v32 )
  {
    *(_DWORD *)(a3 + 48) = v5;
    v11 += v32;
  }
  v23 = v37[0];
  if ( (_DWORD)v14 )
  {
    *(unsigned __int8 **)(a3 + 24) = v37[0];
    *(_QWORD *)(a3 + 32) = sub_9100(v23, 37LL);
    result = v11;
  }
  else
  {
    v24 = v37[0] - 1;
    result = v11;
    *(_QWORD *)(a3 + 32) = v37[0] - 1;
    *(_QWORD *)(a3 + 24) = v24;
  }
  return result;
}
// 69093: variable 'v4' is possibly undefined
// 9100: using guessed type __int64 __fastcall sub_9100(_QWORD, _QWORD);
// C1788: using guessed type __int64 qword_C1788;
// C1798: using guessed type __int64 qword_C1798;
// C1B10: using guessed type __int64 qword_C1B10;

//----- (00000000000695C0) ----------------------------------------------------
__int64 __fastcall sub_695C0(int **a1)
{
  int *v1; // rdx
  int v2; // eax
  __int64 result; // rax
  unsigned int v4; // ecx
  int *v5; // rdx
  signed int v6; // eax
  int v7; // ecx
  int *v8; // rsi

  v1 = *a1;
  v2 = *(*a1)++;
  result = (unsigned int)(v2 - 48);
  v4 = v1[1] - 48;
  if ( v4 <= 9 )
  {
    v5 = v1 + 2;
    while ( 1 )
    {
      if ( (int)result >= 0 )
      {
        if ( (int)result > 214748364 || (v6 = 10 * result, (int)(0x7FFFFFFF - v4) < v6) )
        {
          v8 = v5++;
          result = 0xFFFFFFFFLL;
          if ( (unsigned int)(*v8 - 48) > 9 )
          {
LABEL_9:
            *a1 = v8;
            return result;
          }
        }
        else
        {
          result = v4 + v6;
        }
      }
      v7 = *v5;
      v8 = v5++;
      v4 = v7 - 48;
      if ( v4 > 9 )
        goto LABEL_9;
    }
  }
  return result;
}

//----- (0000000000069640) ----------------------------------------------------
__int64 __fastcall sub_69640(__int64 a1, int a2, __int64 a3)
{
  int *v3; // r9
  int v4; // ebp
  __int16 v6; // ax
  int v7; // eax
  __int64 v8; // rax
  __int64 v9; // r12
  __int64 v10; // rdx
  int v11; // eax
  int *v12; // rdx
  __int64 v13; // rcx
  bool v14; // zf
  __int64 v15; // rdx
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int *v19; // r11
  __int64 v20; // rax
  __int64 *v21; // r10
  __int64 v22; // r11
  int *v23; // rdx
  int v24; // ecx
  int *v25; // rdi
  int *v26; // rdi
  __int64 result; // rax
  int v28; // eax
  __int64 (__fastcall *v29)(__int64, __int64, __int64, __int64); // r8
  int v30; // eax
  __int64 v31; // rdx
  bool v32; // sf
  int v33; // eax
  int *v34; // r11
  __int64 v35; // rax
  __int64 *v36; // r10
  int *v37; // rcx
  int v38; // edx
  __int64 v39; // rax
  __int64 *v40; // r10
  int *v41; // rcx
  int v42; // edx
  int *v43[4]; // [rsp+8h] [rbp-20h] BYREF

  v3 = (int *)(a1 + 4);
  v4 = a2;
  v6 = *(_WORD *)(a3 + 12);
  *(_DWORD *)(a3 + 48) = -1;
  *(_DWORD *)(a3 + 16) = 32;
  v6 &= 0xE207u;
  v43[0] = (int *)(a1 + 4);
  HIBYTE(v6) |= 4u;
  *(_WORD *)(a3 + 12) = v6;
  v7 = *(_DWORD *)(a1 + 4);
  if ( (unsigned int)(v7 - 48) <= 9 )
  {
    LODWORD(v20) = sub_695C0(v43);
    if ( (_DWORD)v20 && (v23 = v43[0], *v43[0] == 36) )
    {
      v3 = ++v43[0];
      if ( (_DWORD)v20 != -1 )
      {
        v24 = v20 - 1;
        v20 = (unsigned int)v20;
        if ( *v21 >= (unsigned __int64)(unsigned int)v20 )
          v20 = *v21;
        *(_DWORD *)(a3 + 48) = v24;
        *v21 = v20;
      }
      v7 = v23[1];
    }
    else
    {
      v43[0] = v3;
      v7 = *(_DWORD *)(v22 + 4);
    }
  }
  v8 = (unsigned int)(v7 - 32);
  if ( (unsigned int)v8 <= 0x29 )
    __asm { jmp     rax }
  if ( (*(_BYTE *)(a3 + 12) & 0x20) != 0 )
    *(_DWORD *)(a3 + 16) = 32;
  *(_DWORD *)(a3 + 44) = -1;
  *(_DWORD *)(a3 + 4) = 0;
  if ( *v3 == 42 )
  {
    v18 = v3[1];
    v19 = v3 + 1;
    v43[0] = v3 + 1;
    if ( (unsigned int)(v18 - 48) > 9 )
      goto LABEL_24;
    LODWORD(v35) = sub_695C0(v43);
    if ( (_DWORD)v35 && (v37 = v43[0], *v43[0] == 36) )
    {
      if ( (_DWORD)v35 == -1 )
      {
        v38 = *(_DWORD *)(a3 + 44);
      }
      else
      {
        v38 = v35 - 1;
        v35 = (unsigned int)v35;
        if ( *v36 >= (unsigned __int64)(unsigned int)v35 )
          v35 = *v36;
        *(_DWORD *)(a3 + 44) = v38;
        *v36 = v35;
      }
      v43[0] = v37 + 1;
    }
    else
    {
      v38 = *(_DWORD *)(a3 + 44);
    }
    if ( v38 < 0 )
    {
LABEL_24:
      *(_DWORD *)(a3 + 44) = a2;
      v3 = v19;
      v4 = a2 + 1;
      v9 = 1LL;
      v43[0] = v19;
    }
    else
    {
      v3 = v43[0];
      v9 = 0LL;
    }
  }
  else
  {
    v9 = 0LL;
    if ( (unsigned int)(*v3 - 48) <= 9 )
    {
      v16 = sub_695C0(v43);
      if ( v16 != -1 )
        *(_DWORD *)(a3 + 4) = v16;
      v3 = v43[0];
    }
  }
  *(_DWORD *)(a3 + 40) = -1;
  *(_DWORD *)a3 = -1;
  if ( *v3 == 46 )
  {
    v17 = v3[1];
    v43[0] = v3 + 1;
    if ( v17 == 42 )
    {
      v33 = v3[2];
      v34 = v3 + 2;
      v43[0] = v3 + 2;
      if ( (unsigned int)(v33 - 48) > 9 )
        goto LABEL_46;
      LODWORD(v39) = sub_695C0(v43);
      if ( (_DWORD)v39 && (v41 = v43[0], *v43[0] == 36) )
      {
        if ( (_DWORD)v39 == -1 )
        {
          v42 = *(_DWORD *)(a3 + 40);
        }
        else
        {
          v42 = v39 - 1;
          v39 = (unsigned int)v39;
          if ( *v40 >= (unsigned __int64)(unsigned int)v39 )
            v39 = *v40;
          *(_DWORD *)(a3 + 40) = v42;
          *v40 = v39;
        }
        v43[0] = v41 + 1;
      }
      else
      {
        v42 = *(_DWORD *)(a3 + 40);
      }
      if ( v42 < 0 )
      {
LABEL_46:
        *(_DWORD *)(a3 + 40) = v4;
        ++v9;
        v3 = v34;
        ++v4;
        v43[0] = v34;
        goto LABEL_9;
      }
    }
    else
    {
      if ( (unsigned int)(v17 - 48) > 9 )
      {
        *(_DWORD *)a3 = 0;
        ++v3;
        goto LABEL_9;
      }
      v28 = sub_695C0(v43);
      if ( v28 != -1 )
        *(_DWORD *)a3 = v28;
    }
    v3 = v43[0];
  }
LABEL_9:
  v10 = qword_C1798;
  *(_DWORD *)(a3 + 12) &= 0xFDF8u;
  if ( !v10 )
  {
LABEL_10:
    v11 = *v3;
    goto LABEL_11;
  }
  v11 = *v3;
  if ( *(_QWORD *)(v10 + 8LL * (unsigned int)*v3) )
  {
    if ( !(unsigned int)sub_7F2F0((unsigned int **)v43, a3) )
    {
      v12 = v43[0] + 1;
      v11 = *v43[0];
      goto LABEL_13;
    }
    v3 = v43[0];
    goto LABEL_10;
  }
LABEL_11:
  v12 = v3 + 1;
  v13 = (unsigned int)(v11 - 76);
  v43[0] = v3 + 1;
  if ( (unsigned int)v13 <= 0x2E )
    __asm { jmp     rcx }
LABEL_13:
  v14 = qword_C1788 == 0;
  v43[0] = v12;
  *(_DWORD *)(a3 + 8) = v11;
  *(_DWORD *)(a3 + 64) = -1;
  if ( v14
    || v11 > 255
    || (v29 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(qword_C1B10 + 8LL * v11)) == 0LL
    || (v30 = v29(a3, 1LL, a3 + 52, a3 + 64),
        v31 = v30,
        v32 = v30 < 0,
        v11 = *(_DWORD *)(a3 + 8),
        *(_QWORD *)(a3 + 56) = v31,
        v32) )
  {
    v15 = (unsigned int)(v11 - 65);
    *(_QWORD *)(a3 + 56) = 1LL;
    if ( (unsigned int)v15 <= 0x37 )
      __asm { jmp     rdx }
    *(_QWORD *)(a3 + 56) = 0LL;
  }
  else if ( *(_DWORD *)(a3 + 48) == -1 && v31 )
  {
    *(_DWORD *)(a3 + 48) = v4;
    v9 += v31;
  }
  v25 = v43[0];
  if ( v11 )
  {
    *(int **)(a3 + 24) = v43[0];
    *(_QWORD *)(a3 + 32) = sub_6D5D0(v25, 37);
    result = v9;
  }
  else
  {
    v26 = v43[0] - 1;
    result = v9;
    *(_QWORD *)(a3 + 32) = v43[0] - 1;
    *(_QWORD *)(a3 + 24) = v26;
  }
  return result;
}
// 696E0: variable 'v3' is possibly undefined
// 6989C: variable 'v19' is possibly undefined
// 698E6: variable 'v21' is possibly undefined
// 69905: variable 'v22' is possibly undefined
// 69AE0: variable 'v34' is possibly undefined
// 69B98: variable 'v36' is possibly undefined
// 69BFA: variable 'v40' is possibly undefined
// C1788: using guessed type __int64 qword_C1788;
// C1798: using guessed type __int64 qword_C1798;
// C1B10: using guessed type __int64 qword_C1B10;

//----- (0000000000069C30) ----------------------------------------------------
__int64 __fastcall sub_69C30(__int64 a1, _WORD *a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v14; // rbx
  u32 *v15; // rbx
  __int64 v16; // rax
  __int64 v17; // rsi
  unsigned int v19; // er12
  _BOOL4 v20; // eax
  _WORD v21[20]; // [rsp+0h] [rbp-B8h] BYREF
  unsigned __int64 v22; // [rsp+28h] [rbp-90h]
  u32 *v23; // [rsp+38h] [rbp-80h]
  unsigned __int64 v24; // [rsp+98h] [rbp-20h]

  v24 = __readfsqword(0x28u);
  if ( *(int *)(a1 + 112) < 0 )
    goto LABEL_9;
  v14 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v14 - (_QWORD)&unk_BFAE0) )
    sub_17140(a7, a8, a9, a10, a11, a12, a13, a14);
  a2 = v21;
  if ( (*(int (__fastcall **)(__int64, _WORD *))(v14 + 144))(a1, v21) < 0 )
    goto LABEL_9;
  if ( (v21[12] & 0xF000) == 0x2000 )
  {
    a3 = (v22 >> 8) & 0xFFF;
    if ( ((unsigned int)a3 | HIDWORD(v22) & 0xFFFFF000) - 136 <= 7
      || (v19 = __readfsdword(0xFFFFFFC0), v20 = sub_6EBE0(*(_DWORD *)(a1 + 112)), __writefsdword(0xFFFFFFC0, v19), v20) )
    {
      *(_DWORD *)a1 |= 0x200u;
    }
  }
  v15 = v23;
  if ( (unsigned __int64)v23 - 1 > 0x1FFE )
  {
LABEL_9:
    v15 = (_DWORD *)(&stru_1FF0 + 16);
    v16 = sub_21500((u32 *)&stru_1FF0.r_addend, (__int64)a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
    v17 = v16;
    if ( v16 )
      goto LABEL_8;
  }
  else
  {
    v16 = sub_21500(v23, (__int64)v21, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
    v17 = v16;
    if ( v16 )
    {
LABEL_8:
      sub_1A4A0((int *)a1, v17, (__int64)v15 + v16, 1);
      return 1LL;
    }
  }
  return 0xFFFFFFFFLL;
}
// 69CC0: variable 'a3' is possibly undefined
// 69CC0: variable 'a4' is possibly undefined
// 69CC0: variable 'a5' is possibly undefined
// 69CC0: variable 'a6' is possibly undefined
// 69CC0: variable 'a11' is possibly undefined
// 69CC0: variable 'a12' is possibly undefined
// 1FF0: using guessed type Elf64_Rela stru_1FF0;
// C0308: using guessed type void *off_C0308;

//----- (0000000000069DA0) ----------------------------------------------------
__int64 __fastcall sub_69DA0(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  u32 *v11; // r8
  u32 v12; // er9
  __int64 v13; // r12
  double v14; // xmm4_8
  double v15; // xmm5_8
  __int64 v16; // rdx
  unsigned __int64 v18; // r13
  int v20; // eax
  __int64 v21; // r13
  __int64 v22; // rax
  __int64 v23; // r8
  __int64 v25; // rdi
  int v26; // eax
  signed __int64 v27; // rax

  v13 = strlen(a1);
  v16 = *(_DWORD *)a2 & 0x8000;
  if ( (*(_DWORD *)a2 & 0x8000) == 0 )
  {
    _RDI = *(_QWORD *)(a2 + 136);
    v18 = __readfsqword(0x10u);
    if ( *(_QWORD *)(_RDI + 8) != v18 )
    {
      if ( __readfsdword(0x18u) )
      {
        if ( (_DWORD)v16 != _InterlockedCompareExchange((volatile signed __int32 *)_RDI, 1, v16) )
          sub_1C7D0((volatile __int32 *)_RDI, a2, v16, 1LL, v11, v12);
      }
      else
      {
        _EDX = 1;
        __asm { cmpxchg [rdi], edx }
      }
      _RDI = *(_QWORD *)(a2 + 136);
      *(_QWORD *)(_RDI + 8) = v18;
    }
    ++*(_DWORD *)(_RDI + 4);
  }
  v20 = *(_DWORD *)(a2 + 192);
  if ( v20 )
  {
    if ( v20 != -1 )
      goto LABEL_15;
  }
  else
  {
    *(_DWORD *)(a2 + 192) = -1;
  }
  v21 = *(_QWORD *)(a2 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v21 - (_QWORD)&unk_BFAE0) )
    sub_17140(a3, a4, a5, a6, v14, v15, a9, a10);
  v22 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v21 + 56))(a2, a1, v13);
  v23 = 1LL;
  if ( v13 != v22 )
  {
LABEL_15:
    v23 = 0xFFFFFFFFLL;
    if ( (*(_DWORD *)a2 & 0x8000) != 0 )
      return (unsigned int)v23;
    goto LABEL_16;
  }
  if ( (*(_DWORD *)a2 & 0x8000) != 0 )
    return (unsigned int)v23;
LABEL_16:
  v25 = *(_QWORD *)(a2 + 136);
  v26 = *(_DWORD *)(v25 + 4) - 1;
  *(_DWORD *)(v25 + 4) = v26;
  if ( v26 )
    return (unsigned int)v23;
  *(_QWORD *)(v25 + 8) = 0LL;
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedExchange((volatile __int32 *)v25, 0) > 1 )
      v27 = sys_futex((u32 *)v25, 129, 1u, 0LL, (u32 *)v23, v12);
    return (unsigned int)v23;
  }
  --*(_DWORD *)v25;
  return (unsigned int)v23;
}
// 69EE0: variable 'v14' is possibly undefined
// 69EE0: variable 'v15' is possibly undefined
// 69E63: variable 'v23' is possibly undefined
// 69ED1: variable 'v11' is possibly undefined
// 69ED1: variable 'v12' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (0000000000069F20) ----------------------------------------------------
__int64 __fastcall sub_69F20(__int64 a1, _WORD *a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rbx
  __int64 v17; // rax

  v14 = *(_QWORD *)(a1 + 56);
  if ( !v14 )
  {
    sub_69C30(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
    v14 = *(_QWORD *)(a1 + 56);
  }
  v15 = *(_QWORD *)(a1 + 64) - v14;
  if ( (*(_BYTE *)a1 & 1) != 0 )
    v15 = (unsigned __int64)(v15 + 3) >> 2;
  v16 = 4 * v15;
  v17 = sub_21500((u32 *)(4 * v15), (__int64)a2, v15, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
  if ( !v17 )
    return 0xFFFFFFFFLL;
  sub_6A820(a1, v17, v17 + v16, 1);
  return 1LL;
}
// 69F58: variable 'a4' is possibly undefined
// 69F58: variable 'a5' is possibly undefined
// 69F58: variable 'a6' is possibly undefined
// 69F58: variable 'a11' is possibly undefined
// 69F58: variable 'a12' is possibly undefined

//----- (0000000000069FB0) ----------------------------------------------------
__int64 __fastcall sub_69FB0(const char **a1, unsigned __int64 *a2, unsigned int a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  int v14; // edx
  __int64 v17; // rcx
  __int64 v18; // rax
  u32 *v19; // r8
  signed __int64 v20; // r14
  __int64 v21; // r15
  __int64 v22; // r12
  const char *v23; // rdi
  unsigned __int64 v24; // rsi
  __int64 v25; // rax
  double v26; // xmm4_8
  double v27; // xmm5_8
  __int64 v28; // rax
  __int64 v29; // rdx
  __int64 v30; // rcx
  double v31; // xmm4_8
  double v32; // xmm5_8
  __int64 v33; // r13
  __int64 v34; // rax
  int v35; // eax
  int v37; // eax
  unsigned __int64 v39; // r12
  __int64 v41; // rdi
  signed __int64 v42; // rax
  u32 *uaddr2; // [rsp+8h] [rbp-50h]

  if ( !a1 || !a2 )
  {
    v22 = -1LL;
    __writefsdword(0xFFFFFFC0, 0x16u);
    return v22;
  }
  v14 = *(_DWORD *)a4;
  v17 = *(_DWORD *)a4 & 0x8000;
  if ( (_DWORD)v17 )
  {
    if ( (v14 & 0x20) != 0 )
      return -1LL;
  }
  else
  {
    _RDI = *(_QWORD *)(a4 + 136);
    v39 = __readfsqword(0x10u);
    if ( *(_QWORD *)(_RDI + 8) == v39 )
    {
      ++*(_DWORD *)(_RDI + 4);
      if ( (v14 & 0x20) != 0 )
      {
        v22 = -1LL;
        goto LABEL_25;
      }
    }
    else
    {
      _EDX = 1;
      if ( __readfsdword(0x18u) )
      {
        if ( _InterlockedCompareExchange((volatile signed __int32 *)_RDI, 1, 0) )
          sub_1C7D0((volatile __int32 *)_RDI, (__int64)a2, 1LL, v17, a5, a6);
      }
      else
      {
        __asm { cmpxchg [rdi], edx }
      }
      v41 = *(_QWORD *)(a4 + 136);
      v35 = *(_DWORD *)a4;
      *(_QWORD *)(v41 + 8) = v39;
      ++*(_DWORD *)(v41 + 4);
      if ( (v35 & 0x20) != 0 )
      {
        v22 = -1LL;
        goto LABEL_23;
      }
    }
  }
  if ( *a1 && *a2 || (*a2 = 120LL, v18 = sub_21500(120LL), (*a1 = (const char *)v18) != 0LL) )
  {
    v19 = *(u32 **)(a4 + 8);
    v20 = *(_QWORD *)(a4 + 16) - (_QWORD)v19;
    if ( v20 > 0 )
      goto LABEL_9;
    if ( (unsigned int)sub_1A1C0(a4, a7, a8, a9, a10, a11, a12, a13, a14) != -1 )
    {
      v19 = *(u32 **)(a4 + 8);
      v20 = *(_QWORD *)(a4 + 16) - (_QWORD)v19;
LABEL_9:
      v21 = 0LL;
      while ( 1 )
      {
        uaddr2 = v19;
        v28 = sub_9110(v19, a3, v20);
        a5 = uaddr2;
        v33 = v28;
        v34 = v28 - (_QWORD)uaddr2 + 1;
        if ( v33 )
          v20 = v34;
        if ( 0x7FFFFFFFFFFFFFFFLL - v21 <= v20 )
        {
          __writefsdword(0xFFFFFFC0, 0x4Bu);
          goto LABEL_22;
        }
        v22 = v21 + v20;
        v23 = *a1;
        v24 = v21 + v20 + 1;
        if ( *a2 < v24 )
        {
          if ( 2 * *a2 >= v24 )
            v24 = 2 * *a2;
          v25 = sub_21DF0(v23, v24, v29, v30, uaddr2, a6, a7, a8, a9, a10, v31, v32, a13, a14);
          v23 = (const char *)v25;
          if ( !v25 )
            goto LABEL_22;
          *a1 = (const char *)v25;
          a5 = *(u32 **)(a4 + 8);
          *a2 = v24;
        }
        memcpy((void *)&v23[v21], a5, v20);
        *(_QWORD *)(a4 + 8) += v20;
        if ( v33 || (unsigned int)sub_1A1C0(a4, a7, a8, a9, a10, v26, v27, a13, a14) == -1 )
          break;
        v19 = *(u32 **)(a4 + 8);
        v21 += v20;
        v20 = *(_QWORD *)(a4 + 16) - (_QWORD)v19;
      }
      (*a1)[v22] = 0;
      v35 = *(_DWORD *)a4;
      goto LABEL_23;
    }
  }
LABEL_22:
  v35 = *(_DWORD *)a4;
  v22 = -1LL;
LABEL_23:
  if ( (v35 & 0x8000) != 0 )
    return v22;
  _RDI = *(_QWORD *)(a4 + 136);
LABEL_25:
  v37 = *(_DWORD *)(_RDI + 4) - 1;
  *(_DWORD *)(_RDI + 4) = v37;
  if ( !v37 )
  {
    *(_QWORD *)(_RDI + 8) = 0LL;
    if ( __readfsdword(0x18u) )
    {
      if ( _InterlockedExchange((volatile __int32 *)_RDI, 0) > 1 )
        v42 = sys_futex((u32 *)_RDI, 129, 1u, 0LL, a5, a6);
    }
    else
    {
      --*(_DWORD *)_RDI;
    }
  }
  return v22;
}
// 6A079: variable 'v29' is possibly undefined
// 6A079: variable 'v30' is possibly undefined
// 6A079: variable 'a6' is possibly undefined
// 6A079: variable 'v31' is possibly undefined
// 6A079: variable 'v32' is possibly undefined
// 6A0BD: variable 'v26' is possibly undefined
// 6A0BD: variable 'v27' is possibly undefined
// 6A1F3: variable 'a11' is possibly undefined
// 6A1F3: variable 'a12' is possibly undefined
// 6A264: variable 'a5' is possibly undefined
// 9110: using guessed type __int64 __fastcall sub_9110(_QWORD, _QWORD, _QWORD);
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);

//----- (000000000006A2A0) ----------------------------------------------------
__int64 __fastcall sub_6A2A0(__int64 a1, int a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  const char *v11; // r13
  int v12; // ebx
  __int64 v13; // r12
  __int64 v14; // rax
  __int64 v15; // r14
  __int64 v16; // rbp
  unsigned __int128 v18; // [rsp+10h] [rbp-58h] BYREF
  unsigned __int64 v19; // [rsp+28h] [rbp-40h]

  v11 = "                ";
  v19 = __readfsqword(0x28u);
  if ( a2 != 32 )
  {
    v11 = "0000000000000000";
    if ( a2 != 48 )
    {
      v11 = (const char *)&v18;
      v18 = __PAIR128__((unsigned __int8)a2, (unsigned __int8)a2) * 0x101010101010101LL;
    }
  }
  v12 = a3;
  if ( a3 <= 15 )
  {
    v13 = 0LL;
LABEL_11:
    if ( v12 > 0 )
    {
      v16 = *(_QWORD *)(a1 + 216);
      if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v16 - (_QWORD)&unk_BFAE0) )
        sub_17140(a4, a5, a6, a7, a8, a9, a10, a11);
      v13 += (*(__int64 (__fastcall **)(__int64, const char *, _QWORD))(v16 + 56))(a1, v11, v12);
    }
  }
  else
  {
    v13 = 0LL;
    while ( 1 )
    {
      v15 = *(_QWORD *)(a1 + 216);
      if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v15 - (_QWORD)&unk_BFAE0) )
        sub_17140(a4, a5, a6, a7, a8, a9, a10, a11);
      v14 = (*(__int64 (__fastcall **)(__int64, const char *, __int64))(v15 + 56))(a1, v11, 16LL);
      v13 += v14;
      if ( v14 != 16 )
        break;
      v12 -= 16;
      if ( v12 <= 15 )
        goto LABEL_11;
    }
  }
  return v13;
}
// 6A364: variable 'a8' is possibly undefined
// 6A364: variable 'a9' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (000000000006A3E0) ----------------------------------------------------
__int64 __fastcall sub_6A3E0(__int64 a1, int a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  const char *v13; // r13
  char *v14; // rax
  char *v15; // rdx
  int v16; // ebx
  __int64 v17; // r12
  __int64 v18; // rax
  __int64 v19; // r14
  __int64 v20; // rbp
  char v22[60]; // [rsp+10h] [rbp-88h] BYREF
  char v23; // [rsp+4Ch] [rbp-4Ch] BYREF
  unsigned __int64 v24; // [rsp+58h] [rbp-40h]

  v13 = " ";
  v24 = __readfsqword(0x28u);
  if ( a2 != 32 )
  {
    v13 = "0";
    if ( a2 != 48 )
    {
      v14 = &v23;
      do
      {
        v15 = v14;
        *(_DWORD *)v14 = a2;
        v14 -= 4;
      }
      while ( v15 != v22 );
      v13 = v22;
    }
  }
  v16 = a3;
  if ( a3 <= 15 )
  {
    v17 = 0LL;
LABEL_13:
    if ( v16 > 0 )
    {
      v20 = *(_QWORD *)(a1 + 216);
      if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v20 - (_QWORD)&unk_BFAE0) )
        sub_17140(a4, a5, a6, a7, a8, a9, a10, a11);
      v17 += (*(__int64 (__fastcall **)(__int64, const char *, _QWORD))(v20 + 56))(a1, v13, v16);
    }
  }
  else
  {
    v17 = 0LL;
    while ( 1 )
    {
      v19 = *(_QWORD *)(a1 + 216);
      if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v19 - (_QWORD)&unk_BFAE0) )
        sub_17140(a4, a5, a6, a7, a8, a9, a10, a11);
      v18 = (*(__int64 (__fastcall **)(__int64, const char *, __int64))(v19 + 56))(a1, v13, 16LL);
      v17 += v18;
      if ( v18 != 16 )
        break;
      v16 -= 16;
      if ( v16 <= 15 )
        goto LABEL_13;
    }
  }
  return v17;
}
// 6A49C: variable 'a8' is possibly undefined
// 6A49C: variable 'a9' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (000000000006A520) ----------------------------------------------------
__int64 __fastcall sub_6A520(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  __int64 v11; // rbp
  _QWORD *v12; // rdi
  __int64 *v13; // rax
  u32 *v14; // r8
  __int64 v15; // r9
  __int64 **v16; // rdx
  __int64 v17; // r10
  __int64 v18; // rcx
  __int64 v19; // r13
  __int64 v20; // r14
  unsigned __int64 v21; // r11
  __int64 v22; // rbx
  __int64 v23; // rcx
  __int64 v24; // rdx
  __int64 v25; // r15
  __int64 v26; // r10
  __int64 v28; // rax
  __int64 v29; // r15
  __int64 v30; // rsi
  __int64 v31; // r13
  const void *v32; // rsi
  __int64 v33; // rdx
  unsigned __int64 v34; // rcx
  u32 *v35; // r8
  __int64 v36; // r9
  double v37; // xmm4_8
  double v38; // xmm5_8
  _QWORD *v39; // rcx
  __int64 v40; // rdx
  __int64 v41; // rax
  u32 *v42; // rsi
  void *v43; // rdi
  __int64 v44; // rax
  u32 *v45; // [rsp+0h] [rbp-58h]
  __int64 v46; // [rsp+10h] [rbp-48h]
  __int64 v47; // [rsp+18h] [rbp-40h]

  v11 = a2;
  v12 = *(_QWORD **)(a1 + 160);
  v13 = *(__int64 **)(a1 + 96);
  v14 = (u32 *)v12[2];
  v15 = v12[10];
  v16 = (__int64 **)v13;
  v17 = v12[8];
  v18 = a2 - (_QWORD)v14;
  v19 = v15 - v17;
  v20 = (a2 - (__int64)v14) >> 2;
  v21 = (v15 - v17) >> 2;
  v22 = v20;
  LODWORD(a2) = v20;
  if ( !v13 )
  {
    v25 = (v12[10] - v17) >> 2;
    if ( v18 >= 0 )
    {
      v12[9] = v15;
      return 0LL;
    }
    v26 = v12[10];
    goto LABEL_18;
  }
  do
  {
    v23 = *((int *)v16 + 4);
    v16 = (__int64 **)*v16;
    if ( v22 > v23 )
      v22 = v23;
  }
  while ( v16 );
  v24 = v20 - v22;
  if ( v20 - v22 <= v21 )
  {
    v25 = v21 - v24;
    v19 = 4 * (v21 - v24);
    v26 = v19 + v17;
    if ( v22 >= 0 )
    {
      if ( !v24 )
      {
        v12[9] = v26;
        goto LABEL_9;
      }
      v42 = &v14[v22];
      v43 = (void *)v26;
      goto LABEL_19;
    }
LABEL_18:
    sub_6CEB0(v26, v15 + 4 * v22, -v22);
    v41 = *(_QWORD *)(a1 + 160);
    v42 = *(u32 **)(v41 + 16);
    v43 = (void *)(*(_QWORD *)(v41 + 64) + 4 * (v25 - v22));
    v24 = (v11 - (__int64)v42) >> 2;
LABEL_19:
    sub_6CEA0(v43, v42, v24);
    v39 = *(_QWORD **)(a1 + 160);
    v31 = v39[8] + v19;
    goto LABEL_15;
  }
  v47 = v12[10];
  v46 = v12[2];
  v45 = (u32 *)(4 * v24 + 400);
  v28 = sub_21500(v45, v20, v24, v23, v14, v15, a3, a4, a5, a6, a7, a8, a9, a10);
  v29 = v28;
  if ( v28 )
  {
    v30 = 4 * v22;
    v31 = v28 + 400;
    if ( v22 < 0 )
    {
      v44 = sub_49000(v28 + 400, v47 + v30, -v22);
      v32 = (const void *)v46;
      sub_49000(v44, v46, v20);
    }
    else
    {
      v32 = (const void *)(v46 + v30);
      sub_6CEA0((void *)(v28 + 400), v32, v20 - v22);
    }
    sub_21B70(
      *(_QWORD *)(*(_QWORD *)(a1 + 160) + 64LL),
      a3,
      a4,
      a5,
      a6,
      v37,
      v38,
      a9,
      a10,
      (__int64)v32,
      v33,
      v34,
      v35,
      v36);
    v39 = *(_QWORD **)(a1 + 160);
    v39[8] = v29;
    v39[10] = (char *)v45 + v29;
LABEL_15:
    v13 = *(__int64 **)(a1 + 96);
    v40 = v11 - v39[2];
    v39[9] = v31;
    a2 = v40 >> 2;
    while ( v13 )
    {
LABEL_9:
      *((_DWORD *)v13 + 4) -= a2;
      v13 = (__int64 *)*v13;
    }
    return 0LL;
  }
  return 0xFFFFFFFFLL;
}
// 6A658: variable 'v37' is possibly undefined
// 6A658: variable 'v38' is possibly undefined
// 6A658: variable 'v33' is possibly undefined
// 6A658: variable 'v34' is possibly undefined
// 6A658: variable 'v35' is possibly undefined
// 6A658: variable 'v36' is possibly undefined

//----- (000000000006A820) ----------------------------------------------------
__int64 __fastcall sub_6A820(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v7; // rdx
  int v8; // eax
  __int64 v9; // rdi
  int v10; // edx
  __int64 result; // rax
  unsigned int v12; // edx

  v7 = *(_QWORD *)(a1 + 160);
  v8 = *(_DWORD *)(a1 + 116);
  v9 = *(_QWORD *)(v7 + 48);
  if ( v9 && (v8 & 8) == 0 )
  {
    sub_21B70(v9);
    v7 = *(_QWORD *)(a1 + 160);
    v8 = *(_DWORD *)(a1 + 116);
  }
  *(_QWORD *)(v7 + 48) = a2;
  *(_QWORD *)(v7 + 56) = a3;
  v10 = v8;
  result = v8 | 8u;
  v12 = v10 & 0xFFFFFFF7;
  if ( a4 )
    result = v12;
  *(_DWORD *)(a1 + 116) = result;
  return result;
}
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (000000000006A890) ----------------------------------------------------
__int64 __fastcall sub_6A890(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 *v14; // rbx
  int v15; // er13
  _DWORD *v16; // r12
  const void *v17; // r14
  int v18; // eax
  __int64 result; // rax
  __int64 v20; // r12
  __int64 v21; // rbx
  u32 *v22; // r13
  __int64 v23; // rax
  __int64 v24; // rdx
  unsigned __int64 v25; // rcx
  u32 *v26; // r8
  __int64 v27; // r9
  double v28; // xmm4_8
  double v29; // xmm5_8
  __int64 v30; // rcx
  __int64 v31; // rax
  __int64 v32; // rdx
  __int64 v33; // [rsp+8h] [rbp-40h]

  v14 = *(__int64 **)(a1 + 160);
  v15 = *(_DWORD *)a1;
  v16 = (_DWORD *)*v14;
  v17 = (const void *)v14[2];
  v18 = *(_DWORD *)a1 & 0x100;
  if ( *v14 > (unsigned __int64)v17 )
  {
    if ( v18 )
    {
LABEL_3:
      *v14 = (__int64)(v16 - 1);
      result = (unsigned int)a2;
      *(v16 - 1) = a2;
      return result;
    }
    a3 = *(_QWORD *)(a1 + 8);
    result = (unsigned int)*(char *)(a3 - 1);
    if ( (_DWORD)result == (_DWORD)a2 )
    {
      *(_QWORD *)(a1 + 8) = a3 - 1;
      return result;
    }
    if ( v14[8] )
    {
      if ( !(unsigned int)sub_6A520(a1, *v14, a7, a8, a9, a10, a11, a12, a13, a14) )
      {
        v14 = *(__int64 **)(a1 + 160);
        v15 = *(_DWORD *)a1;
        v30 = *v14;
        v16 = (_DWORD *)v14[10];
        v31 = v14[8];
LABEL_13:
        v32 = v14[1];
        *(_DWORD *)a1 = v15 | 0x100;
        v14[1] = (__int64)v16;
        v14[10] = v32;
        v14[2] = v31;
        v14[8] = v30;
        *v14 = (__int64)v16;
        goto LABEL_3;
      }
      return 0xFFFFFFFFLL;
    }
    goto LABEL_14;
  }
  if ( !v18 )
  {
    v31 = v14[8];
    if ( v31 )
    {
      v30 = *v14;
      v16 = (_DWORD *)v14[10];
      goto LABEL_13;
    }
LABEL_14:
    v31 = sub_21500((u32 *)&dword_200, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
    if ( v31 )
    {
      v30 = (__int64)v16;
      v14[8] = v31;
      v14[10] = v31 + 512;
      v16 = (_DWORD *)(v31 + 512);
      v14[9] = v31 + 512;
      goto LABEL_13;
    }
    return 0xFFFFFFFFLL;
  }
  v20 = v14[1] - (_QWORD)v17;
  v21 = v20 >> 2;
  v22 = (u32 *)(8 * (v20 >> 2));
  v23 = sub_21500(v22, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
  if ( v23 )
  {
    v16 = (_DWORD *)(v23 + v20);
    v33 = v23;
    sub_6CEA0(v16, v17, v21);
    sub_21B70(
      *(_QWORD *)(*(_QWORD *)(a1 + 160) + 16LL),
      a7,
      a8,
      a9,
      a10,
      v28,
      v29,
      a13,
      a14,
      (__int64)v17,
      v24,
      v25,
      v26,
      v27);
    v14 = *(__int64 **)(a1 + 160);
    v14[2] = v33;
    *v14 = (__int64)v16;
    v14[1] = (__int64)v22 + v33;
    v14[9] = (__int64)v16;
    goto LABEL_3;
  }
  return 0xFFFFFFFFLL;
}
// 6A940: variable 'v28' is possibly undefined
// 6A940: variable 'v29' is possibly undefined
// 6A940: variable 'v24' is possibly undefined
// 6A940: variable 'v25' is possibly undefined
// 6A940: variable 'v26' is possibly undefined
// 6A940: variable 'v27' is possibly undefined
// 200: using guessed type int;

//----- (000000000006AA40) ----------------------------------------------------
void __fastcall sub_6AA40(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14)
{
  _QWORD *v14; // rdx
  __int64 v16; // rdi
  _QWORD *i; // rax

  v14 = *(_QWORD **)(a1 + 160);
  v16 = v14[6];
  if ( v16 && (*(_BYTE *)(a1 + 116) & 8) == 0 )
  {
    sub_21B70(v16, a3, a4, a5, a6, a7, a8, a9, a10, a2, (__int64)v14, a12, a13, a14);
    v14 = *(_QWORD **)(a1 + 160);
    v14[7] = 0LL;
    v14[6] = 0LL;
  }
  for ( i = *(_QWORD **)(a1 + 96); i; i = (_QWORD *)*i )
    i[1] = 0LL;
  if ( *(_QWORD *)(a1 + 72) )
  {
    sub_21B70(v14[8], a3, a4, a5, a6, a7, a8, a9, a10, a2, (__int64)v14, a12, a13, a14);
    *(_QWORD *)(a1 + 72) = 0LL;
  }
  sub_19CF0(a1, a2, (__int64)v14, a12, (__int64)a13, a14);
}
// 6AA8B: variable 'a7' is possibly undefined
// 6AA8B: variable 'a8' is possibly undefined
// 6AA8B: variable 'a12' is possibly undefined
// 6AA8B: variable 'a13' is possibly undefined
// 6AA8B: variable 'a14' is possibly undefined
// 6AA9C: variable 'v14' is possibly undefined

//----- (000000000006AAD0) ----------------------------------------------------
__int64 __fastcall sub_6AAD0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 v9; // rbp
  _QWORD *v10; // rdx
  __int64 result; // rax

  v9 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v9 - (_QWORD)&unk_BFAE0) )
    sub_17140(a2, a3, a4, a5, a6, a7, a8, a9);
  if ( (*(unsigned int (__fastcall **)(__int64))(v9 + 32))(a1) == -1 )
    return 0xFFFFFFFFLL;
  v10 = *(_QWORD **)(a1 + 160);
  result = *(unsigned int *)*v10;
  *v10 += 4LL;
  return result;
}
// C0308: using guessed type void *off_C0308;

//----- (000000000006AB50) ----------------------------------------------------
__int64 __fastcall sub_6AB50(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v14; // rbx

  if ( !*(_DWORD *)(a1 + 192) )
    sub_16780(a1, 1LL, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
  v14 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v14 - (_QWORD)&unk_BFAE0) )
    sub_17140(a7, a8, a9, a10, a11, a12, a13, a14);
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(v14 + 24))(a1, a2);
}
// 6ABB0: variable 'a11' is possibly undefined
// 6ABB0: variable 'a12' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (000000000006ABD0) ----------------------------------------------------
__int64 __fastcall sub_6ABD0(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, u32 *a13, u32 a14)
{
  __int64 v16; // r12
  unsigned __int64 i; // rbp
  __int64 v18; // rbx
  __int64 v19; // r15
  unsigned int *v20; // rcx
  __int64 v21; // rdi
  __int64 v22; // rax
  __int64 v23; // rbx
  unsigned int v24; // er15
  __int64 v26; // rsi
  __int64 v27; // rax

  if ( !a3 )
    return 0LL;
  v16 = a3;
  for ( i = a3; ; --i )
  {
    v19 = *(_QWORD *)(a1 + 160);
    v20 = (unsigned int *)a2;
    v21 = *(_QWORD *)(v19 + 32);
    if ( *(_QWORD *)(v19 + 40) - v21 <= 0 )
      goto LABEL_11;
    v22 = (*(_QWORD *)(v19 + 40) - v21) >> 2;
    if ( v22 > i )
      v22 = i;
    v23 = v22;
    if ( v22 <= 20 )
    {
      if ( v22 )
      {
        v26 = 4 * v22;
        v27 = 0LL;
        do
        {
          a3 = *(unsigned int *)(a2 + v27);
          *(_DWORD *)(v21 + v27) = a3;
          v27 += 4LL;
        }
        while ( v26 != v27 );
        v20 = (unsigned int *)(a2 + v26);
        i -= v23;
        *(_QWORD *)(v19 + 32) = v26 + v21;
      }
LABEL_11:
      if ( !i )
        return v16;
      goto LABEL_12;
    }
    i -= v22;
    *(_QWORD *)(v19 + 32) = sub_49000(v21, a2, v22);
    v20 = (unsigned int *)(a2 + 4 * v23);
    if ( !i )
      return v16;
LABEL_12:
    v24 = *v20;
    a2 = (__int64)(v20 + 1);
    if ( !*(_DWORD *)(a1 + 192) )
      sub_16780(a1, 1LL, a3, (__int64)v20, a13, a14, a4, a5, a6, a7, a8, a9, a10, a11);
    v18 = *(_QWORD *)(a1 + 216);
    if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v18 - (_QWORD)&unk_BFAE0) )
      break;
    if ( (*(unsigned int (__fastcall **)(__int64, _QWORD))(v18 + 24))(a1, v24) == -1 )
      goto LABEL_20;
LABEL_5:
    ;
  }
  sub_17140(a4, a5, a6, a7, a8, a9, a10, a11);
  if ( (*(unsigned int (__fastcall **)(__int64, _QWORD))(v18 + 24))(a1, v24) != -1 )
    goto LABEL_5;
LABEL_20:
  v16 -= i;
  return v16;
}
// 6AC94: variable 'a3' is possibly undefined
// 6AC94: variable 'a13' is possibly undefined
// 6AC94: variable 'a14' is possibly undefined
// 6AC94: variable 'a8' is possibly undefined
// 6AC94: variable 'a9' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (000000000006AD40) ----------------------------------------------------
_QWORD *__fastcall sub_6AD40(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  _QWORD *result; // rax
  unsigned __int64 v12; // rcx
  u32 *v13; // r8
  __int64 v14; // r9
  double v15; // xmm4_8
  double v16; // xmm5_8
  __int64 v17; // rdx
  __int64 v18; // rdi
  char *v19; // r12
  _QWORD *v20; // rbp

  result = *(_QWORD **)(a1 + 160);
  if ( !result[6] )
  {
    if ( (*(_BYTE *)a1 & 2) != 0 )
    {
      LODWORD(v17) = *(_DWORD *)(a1 + 116);
      v19 = (char *)result + 220;
      v20 = result + 27;
    }
    else
    {
      result = (_QWORD *)(*(__int64 (**)(void))(result[28] + 104LL))();
      if ( (_DWORD)result != -1 )
        return result;
      result = *(_QWORD **)(a1 + 160);
      v17 = *(unsigned int *)(a1 + 116);
      v18 = result[6];
      v19 = (char *)result + 220;
      v20 = result + 27;
      if ( v18 )
      {
        if ( (v17 & 8) == 0 )
        {
          sub_21B70(v18, a3, a4, a5, a6, v15, v16, a9, a10, a2, v17, v12, v13, v14);
          result = *(_QWORD **)(a1 + 160);
          LODWORD(v17) = *(_DWORD *)(a1 + 116);
        }
      }
    }
    result[6] = v20;
    result[7] = v19;
    *(_DWORD *)(a1 + 116) = v17 | 8;
  }
  return result;
}
// 6ADB0: variable 'v15' is possibly undefined
// 6ADB0: variable 'v16' is possibly undefined
// 6ADB0: variable 'v12' is possibly undefined
// 6ADB0: variable 'v13' is possibly undefined
// 6ADB0: variable 'v14' is possibly undefined

//----- (000000000006ADE0) ----------------------------------------------------
__int64 __fastcall sub_6ADE0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v15; // rax
  unsigned __int64 v16; // rcx
  u32 *v17; // r8
  __int64 v18; // r9
  double v19; // xmm4_8
  double v20; // xmm5_8
  __int64 v21; // rdx
  __int64 v22; // rbp
  __int64 v23; // r12
  int v24; // eax
  __int64 v25; // rdi

  v15 = sub_21500((u32 *)&stru_1FF0.r_addend, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
  if ( !v15 )
    return 0xFFFFFFFFLL;
  v21 = *(_QWORD *)(a1 + 160);
  v22 = v15;
  v23 = v15 + 0x8000;
  v24 = *(_DWORD *)(a1 + 116);
  v25 = *(_QWORD *)(v21 + 48);
  if ( v25 )
  {
    if ( (v24 & 8) == 0 )
    {
      sub_21B70(v25, a7, a8, a9, a10, v19, v20, a13, a14, a2, v21, v16, v17, v18);
      v21 = *(_QWORD *)(a1 + 160);
      v24 = *(_DWORD *)(a1 + 116);
    }
  }
  *(_QWORD *)(v21 + 48) = v22;
  *(_QWORD *)(v21 + 56) = v23;
  *(_DWORD *)(a1 + 116) = v24 & 0xFFFFFFF7;
  return 1LL;
}
// 6AE38: variable 'v19' is possibly undefined
// 6AE38: variable 'v20' is possibly undefined
// 6AE38: variable 'v16' is possibly undefined
// 6AE38: variable 'v17' is possibly undefined
// 6AE38: variable 'v18' is possibly undefined
// 1FF0: using guessed type Elf64_Rela stru_1FF0;

//----- (000000000006AE60) ----------------------------------------------------
__int64 __fastcall sub_6AE60(int *a1)
{
  unsigned __int64 *v1; // rax
  unsigned __int64 v2; // rdx
  __int64 result; // rax
  int v4; // ecx

  v1 = (unsigned __int64 *)*((_QWORD *)a1 + 20);
  v2 = v1[4];
  if ( v2 > v1[3] )
  {
    result = (*(__int64 (__fastcall **)(int *, __int64))(v1[28] + 24))(a1, 0xFFFFFFFFLL);
    if ( (_DWORD)result == -1 )
      return result;
    v1 = (unsigned __int64 *)*((_QWORD *)a1 + 20);
    v2 = v1[4];
  }
  v4 = *a1;
  if ( (*a1 & 0x100) != 0 )
  {
    v1[2] = v1[9];
  }
  else
  {
    v1[2] = v1[6];
    if ( v1[1] < v2 )
      v1[1] = v2;
  }
  BYTE1(v4) &= 0xF7u;
  *v1 = v2;
  v1[5] = v2;
  v1[3] = v2;
  result = 0LL;
  *a1 = v4;
  return result;
}

//----- (000000000006AEE0) ----------------------------------------------------
_QWORD *__fastcall sub_6AEE0(int *a1)
{
  int v1; // edx
  _QWORD *v3; // rax
  __int64 v4; // rdi
  _QWORD *result; // rax
  __int64 v6; // rcx
  __int64 v7; // rdx
  __int64 v8; // rdx

  v1 = *a1;
  v3 = (_QWORD *)*((_QWORD *)a1 + 20);
  v4 = v3[8];
  if ( (v1 & 0x100) != 0 )
  {
    BYTE1(v1) &= 0xFEu;
    v6 = v3[10];
    *a1 = v1;
    v7 = v3[1];
    *v3 = v4;
    v3[10] = v7;
    v8 = v3[2];
    v3[1] = v6;
    v3[2] = v4;
    v4 = v8;
    v3[8] = v8;
  }
  sub_21B70(v4);
  result = (_QWORD *)*((_QWORD *)a1 + 20);
  result[8] = 0LL;
  result[10] = 0LL;
  result[9] = 0LL;
  return result;
}
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (000000000006B0C0) ----------------------------------------------------
__int64 __fastcall sub_6B0C0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, u32 *a13, u32 a14)
{
  __int64 v14; // rdx
  unsigned __int64 *v15; // rax
  unsigned int *v16; // rdx
  unsigned int *v17; // rcx
  int v18; // edx
  __int64 v19; // rbx
  unsigned __int64 v21; // rsi
  unsigned int *v22; // rcx
  __int64 v23; // rdx
  __int64 v24; // rcx
  u32 *v25; // r8
  u32 v26; // er9

  v14 = *(unsigned int *)(a1 + 192);
  if ( (int)v14 < 0 )
    return 0xFFFFFFFFLL;
  if ( !(_DWORD)v14 )
  {
    if ( (unsigned int)sub_16780(a1, 1LL, v14, a12, a13, a14, a2, a3, a4, a5, a6, a7, a8, a9) != 1 )
      return 0xFFFFFFFFLL;
    if ( !*(_DWORD *)(a1 + 192) )
      sub_16780(a1, 1LL, v23, v24, v25, v26, a2, a3, a4, a5, a6, a7, a8, a9);
  }
  if ( (*(_DWORD *)a1 & 0x800) != 0 && (unsigned int)sub_6AE60((int *)a1) == -1 )
    return 0xFFFFFFFFLL;
  v15 = *(unsigned __int64 **)(a1 + 160);
  v16 = (unsigned int *)*v15;
  v17 = (unsigned int *)v15[1];
  if ( *v15 < (unsigned __int64)v17 )
    return *v16;
  v18 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 0x100) != 0 )
  {
    BYTE1(v18) &= 0xFEu;
    v21 = v15[10];
    *(_DWORD *)a1 = v18;
    v16 = (unsigned int *)v15[8];
    v15[10] = (unsigned __int64)v17;
    v22 = (unsigned int *)v15[2];
    v15[1] = v21;
    v15[2] = (unsigned __int64)v16;
    v15[8] = (unsigned __int64)v22;
    *v15 = (unsigned __int64)v16;
    if ( v21 > (unsigned __int64)v16 )
      return *v16;
  }
  if ( !*(_QWORD *)(a1 + 96) )
  {
    if ( *(_QWORD *)(a1 + 72) )
      sub_6AEE0((int *)a1);
    goto LABEL_8;
  }
  if ( (unsigned int)sub_6A520(a1, v15[1], a2, a3, a4, a5, a6, a7, a8, a9) )
    return 0xFFFFFFFFLL;
LABEL_8:
  v19 = *(_QWORD *)(a1 + 216);
  if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v19 - (_QWORD)&unk_BFAE0) )
    sub_17140(a2, a3, a4, a5, a6, a7, a8, a9);
  return (*(__int64 (__fastcall **)(__int64))(v19 + 32))(a1);
}
// 6B11B: variable 'a6' is possibly undefined
// 6B11B: variable 'a7' is possibly undefined
// 6B1E5: variable 'v23' is possibly undefined
// 6B1E5: variable 'v24' is possibly undefined
// 6B1E5: variable 'v25' is possibly undefined
// 6B1E5: variable 'v26' is possibly undefined
// C0308: using guessed type void *off_C0308;

//----- (000000000006B220) ----------------------------------------------------
unsigned __int64 __fastcall sub_6B220(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  unsigned __int64 v15; // r12
  unsigned __int64 v16; // rbp
  __int64 *v17; // rdx
  __int64 v18; // rsi
  __int64 v19; // rbx
  __int64 v20; // rax
  __int64 i; // rax

  v15 = a3;
  v16 = a3;
  do
  {
    v17 = *(__int64 **)(a1 + 160);
    v18 = *v17;
    if ( v17[1] - *v17 <= 0 )
      goto LABEL_3;
    v19 = (v17[1] - *v17) >> 2;
    if ( v19 > v16 )
      v19 = v16;
    if ( v19 <= 20 )
    {
      if ( v19 )
      {
        for ( i = 0LL; i != v19; ++i )
          *(_DWORD *)(a2 + 4 * i) = *(_DWORD *)(v18 + 4 * i);
        a4 = 4 * i;
        v16 -= i;
        v18 += 4 * i;
        a2 += 4 * i;
        *v17 = v18;
      }
LABEL_3:
      if ( !v16 )
        return v15;
      continue;
    }
    v16 -= v19;
    v20 = sub_49000(a2, v18, v19);
    v17 = (__int64 *)(4 * v19);
    a2 = v20;
    **(_QWORD **)(a1 + 160) += 4 * v19;
    if ( !v16 )
      return v15;
  }
  while ( (unsigned int)sub_6B0C0(a1, a7, a8, a9, a10, a11, a12, a13, a14, v18, (__int64)v17, a4, a5, a6) != -1 );
  return v15 - v16;
}
// 6B24D: variable 'a11' is possibly undefined
// 6B24D: variable 'a12' is possibly undefined
// 6B24D: variable 'a4' is possibly undefined
// 6B24D: variable 'a5' is possibly undefined
// 6B24D: variable 'a6' is possibly undefined

//----- (000000000006B660) ----------------------------------------------------
__int64 __fastcall sub_6B660(__int64 a1, unsigned int a2)
{
  __int64 v2; // rbp
  __int64 result; // rax

  v2 = a1 + 240;
  if ( *(_QWORD *)(a1 + 56) != a1 + 240 )
  {
    **(_BYTE **)(a1 + 40) = 0;
    sub_1A4A0((int *)a1, a1 + 240, a1 + 304, 0);
    *(_QWORD *)(a1 + 32) = v2;
    *(_QWORD *)(a1 + 24) = v2;
    *(_QWORD *)(a1 + 8) = v2;
    *(_QWORD *)(a1 + 16) = a1 + 304;
  }
  *(_QWORD *)(a1 + 40) = v2;
  result = a2;
  *(_QWORD *)(a1 + 48) = v2;
  return result;
}

//----- (000000000006B6D0) ----------------------------------------------------
__int64 __fastcall sub_6B6D0(char *a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 v9; // r12
  __int64 result; // rax
  char v11[40]; // [rsp+10h] [rbp-178h] BYREF
  _BYTE *v12; // [rsp+38h] [rbp-150h]
  char *v13; // [rsp+48h] [rbp-140h]
  __int64 v14; // [rsp+98h] [rbp-F0h]
  void *v15; // [rsp+E8h] [rbp-A0h]
  char v16[72]; // [rsp+100h] [rbp-88h] BYREF
  unsigned __int64 v17; // [rsp+148h] [rbp-40h]

  v17 = __readfsqword(0x28u);
  v14 = 0LL;
  if ( a2 )
  {
    v9 = a2 - 1;
  }
  else
  {
    v9 = 63LL;
    a1 = v16;
  }
  sub_1AD10((__int64)v11, 0x8000, -1, 0LL, 0LL);
  v15 = &unk_C0260;
  *a1 = 0;
  sub_1C580((__int64)v11, (unsigned __int64)a1, v9, (__int64)a1);
  result = sub_61370(v11, a3, a4, a5);
  if ( v13 != v16 )
    *v12 = 0;
  return result;
}
// 61370: using guessed type __int64 __fastcall sub_61370(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000006B7F0) ----------------------------------------------------
void __fastcall sub_6B7F0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  unsigned __int64 v8; // rcx
  signed __int32 i; // er8
  int v10; // edx
  signed __int32 v11; // eax
  unsigned __int64 v12; // rdi
  double v13; // xmm4_8
  double v14; // xmm5_8

  v8 = __readfsqword(0x10u);
  for ( i = __readfsdword(0x308u); ; i = v11 )
  {
    v10 = i | 2;
    if ( i == (i | 2) )
      break;
    v11 = _InterlockedCompareExchange((volatile signed __int32 *)(v8 + 776), v10, i);
    if ( i == v11 )
    {
      if ( (v10 & 0xFFFFFFBB) == 10 )
      {
        __writefsqword(0x630u, 0xFFFFFFFFFFFFFFFFLL);
        _InterlockedOr((volatile signed __int32 *)(__readfsqword(0x10u) + 776), 0x10u);
        v12 = __readfsqword(0x300u);
        sub_9180(v12);
        sub_6B870(v12, a1, a2, a3, a4, v13, v14, a7, a8);
      }
      return;
    }
  }
}
// 6B86E: variable 'v13' is possibly undefined
// 6B86E: variable 'v14' is possibly undefined
// 9180: using guessed type __int64 __fastcall sub_9180(_QWORD);

//----- (000000000006B870) ----------------------------------------------------
void __fastcall sub_6B870(char a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  signed __int32 v9; // edx
  volatile signed __int32 *v10; // rdi
  u32 *v11; // r8
  signed __int32 v12; // eax
  u32 v13; // er9
  unsigned __int64 v14; // rax
  double v15; // xmm4_8
  double v16; // xmm5_8

  if ( (a1 & 2) == 0 )
  {
    v9 = __readfsdword(0x308u);
    v10 = (volatile signed __int32 *)(__readfsqword(0x10u) + 776);
    while ( 1 )
    {
      v11 = (u32 *)(v9 & 0xFFFFFFFD);
      v12 = _InterlockedCompareExchange(v10, (signed __int32)v11, v9);
      if ( v9 == v12 )
        break;
      v9 = v12;
    }
    if ( (v9 & 0xC) == 4 )
    {
      v13 = 202;
      do
      {
        v14 = sys_futex((u32 *)v10, 128, (u32)v11, 0LL, v11, v13);
        if ( v14 > 0xFFFFFFFFFFFFF000LL
          && ((unsigned int)v14 < 0xFFFFFFF5 && (_DWORD)v14 != 0 || ((1LL << ((unsigned __int8)v14 + 11)) & 0x881) == 0) )
        {
          sub_17110(
            (__int64)"The futex facility returned an unexpected error code.\n",
            a2,
            a3,
            a4,
            a5,
            v15,
            v16,
            a8,
            a9);
        }
        LODWORD(v11) = __readfsdword(0x308u);
      }
      while ( ((unsigned __int8)v11 & 0xC) == 4 );
    }
  }
}
// 6B8CA: variable 'v11' is possibly undefined
// 6B8CA: variable 'v13' is possibly undefined
// 6B910: variable 'v15' is possibly undefined
// 6B910: variable 'v16' is possibly undefined

//----- (000000000006B920) ----------------------------------------------------
__int64 __fastcall sub_6B920(int a1, const __m128i *a2, sigset_t *a3)
{
  sigset_t *v3; // r8
  signed __int64 v4; // rax
  unsigned int v5; // edx
  bool v6; // cc
  __int64 result; // rax
  __m128i v8; // xmm1
  __m128i v9; // xmm2
  __m128i v10; // xmm3
  unsigned __int64 v11; // rax
  __m128i v12; // xmm4
  __m128i v13; // xmm5
  __m128i v14; // xmm6
  __m128i v15; // xmm7
  __int128 v16[8]; // [rsp+0h] [rbp-98h] BYREF
  unsigned __int64 v17; // [rsp+88h] [rbp-10h]

  v3 = 0LL;
  v17 = __readfsqword(0x28u);
  if ( a2 )
  {
    if ( (a2->m128i_i64[0] & 0x180000000LL) != 0 )
    {
      v8 = _mm_loadu_si128(a2 + 1);
      v3 = (sigset_t *)v16;
      v9 = _mm_loadu_si128(a2 + 2);
      v10 = _mm_loadu_si128(a2 + 3);
      v11 = a2->m128i_i64[0] & 0xFFFFFFFE7FFFFFFFLL;
      v12 = _mm_loadu_si128(a2 + 4);
      v13 = _mm_loadu_si128(a2 + 5);
      v16[0] = (__int128)_mm_loadu_si128(a2);
      v14 = _mm_loadu_si128(a2 + 6);
      v15 = _mm_loadu_si128(a2 + 7);
      *(_QWORD *)&v16[0] = v11;
      v16[1] = (__int128)v8;
      v16[2] = (__int128)v9;
      v16[3] = (__int128)v10;
      v16[4] = (__int128)v12;
      v16[5] = (__int128)v13;
      v16[6] = (__int128)v14;
      v16[7] = (__int128)v15;
    }
    else
    {
      v3 = (sigset_t *)a2;
    }
  }
  v4 = sys_rt_sigprocmask(a1, v3, a3, 8uLL);
  v5 = -(int)v4;
  v6 = (unsigned int)v4 <= 0xFFFFF000;
  result = 0LL;
  if ( !v6 )
    result = v5;
  return result;
}

//----- (000000000006BA10) ----------------------------------------------------
__int64 __fastcall sub_6BA10(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, u32 *a13, u32 a14)
{
  size_t v14; // r13
  const char *v15; // r12
  unsigned __int64 v16; // rbp
  __int64 v17; // rcx
  __int64 result; // rax
  void *v19; // rax

  v14 = *(_QWORD *)(a1 + 8);
  v15 = *(const char **)a1;
  v16 = 2 * v14;
  if ( *(_QWORD *)a1 == a1 + 16 )
  {
    v19 = (void *)sub_21500(2 * v14);
    if ( v19 )
    {
      v17 = (__int64)memcpy(v19, v15, v14);
      goto LABEL_4;
    }
    result = 0LL;
  }
  else
  {
    if ( v14 > v16 )
    {
      __writefsdword(0xFFFFFFC0, 0xCu);
    }
    else
    {
      v17 = sub_21DF0(*(const char **)a1, 2 * v14, a11, a12, a13, a14, a2, a3, a4, a5, a6, a7, a8, a9);
      if ( v17 )
      {
LABEL_4:
        *(_QWORD *)a1 = v17;
        result = 1LL;
        *(_QWORD *)(a1 + 8) = v16;
        return result;
      }
      v15 = *(const char **)a1;
    }
    sub_21B70(v15);
    *(_QWORD *)a1 = a1 + 16;
    result = 0LL;
    *(_QWORD *)(a1 + 8) = 1024LL;
  }
  return result;
}
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (000000000006BAD0) ----------------------------------------------------
__int64 __fastcall sub_6BAD0(__int64 *a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // r12
  __int64 result; // rax
  __int64 v6; // rdi
  __int64 *v7; // rdi

  v3 = a3 * a2;
  if ( (a3 | a2) >> 32 && a2 && v3 / a2 != a3 )
  {
    v7 = (__int64 *)*a1;
    if ( v7 != a1 + 2 )
      sub_21B70(v7);
    *a1 = (__int64)(a1 + 2);
    a1[1] = 1024LL;
    __writefsdword(0xFFFFFFC0, 0xCu);
    result = 0LL;
  }
  else
  {
    result = 1LL;
    if ( a1[1] < v3 )
    {
      v6 = *a1;
      if ( (__int64 *)*a1 != a1 + 2 )
        sub_21B70(v6);
      result = sub_21500(v3);
      if ( result )
      {
        a1[1] = v3;
        *a1 = result;
        result = 1LL;
      }
      else
      {
        *a1 = (__int64)(a1 + 2);
        a1[1] = 1024LL;
      }
    }
  }
  return result;
}
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (000000000006BB80) ----------------------------------------------------
void *__fastcall sub_6BB80(void *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  size_t v14; // r12
  __int64 v15; // rdx
  __int64 v16; // rcx
  u32 *v17; // r8
  u32 v18; // er9
  double v19; // xmm4_8
  double v20; // xmm5_8
  _BYTE *v21; // rax

  v14 = sub_9040(a1, a2, a3, a4, a5, a6);
  v21 = (_BYTE *)sub_21500((u32 *)(v14 + 1), a2, v15, v16, v17, v18, a7, a8, a9, a10, v19, v20, a13, a14);
  if ( !v21 )
    return 0LL;
  v21[v14] = 0;
  return memcpy(v21, a1, v14);
}
// 6BB9A: variable 'v15' is possibly undefined
// 6BB9A: variable 'v16' is possibly undefined
// 6BB9A: variable 'v17' is possibly undefined
// 6BB9A: variable 'v18' is possibly undefined
// 6BB9A: variable 'v19' is possibly undefined
// 6BB9A: variable 'v20' is possibly undefined
// 9040: using guessed type __int64 __fastcall sub_9040(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000006BBD0) ----------------------------------------------------
void *sub_6BBD0()
{
  void *result; // rax

  result = sub_6C930;
  if ( (dword_C1434 & 0x800) == 0 && (BYTE4(xmmword_C1384) & 0x20) != 0 && (dword_C1434 & 0x100) != 0 )
    result = sub_6CB50;
  return result;
}
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (000000000006BC00) ----------------------------------------------------
void *sub_6BC00()
{
  void *result; // rax

  result = sub_6C460;
  if ( (dword_C1434 & 0x800) == 0 && (BYTE4(xmmword_C1384) & 0x20) != 0 && (dword_C1434 & 0x100) != 0 )
    result = sub_6C760;
  return result;
}
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (000000000006BC30) ----------------------------------------------------
_BYTE *__fastcall sub_6BC30(_BYTE *a1, __int64 a2, _BYTE **a3)
{
  _BYTE *v3; // r12
  _BYTE *v5; // rax
  _BYTE *result; // rax

  v3 = a1;
  if ( !a1 )
    v3 = *a3;
  if ( *v3 && (v3 += sub_91F0(v3, a2), *v3) )
  {
    v5 = &v3[sub_91E0(v3, a2)];
    if ( *v5 )
      *v5++ = 0;
    *a3 = v5;
    result = v3;
  }
  else
  {
    *a3 = v3;
    result = 0LL;
  }
  return result;
}
// 91E0: using guessed type __int64 __fastcall sub_91E0(_QWORD, _QWORD);
// 91F0: using guessed type __int64 __fastcall sub_91F0(_QWORD, _QWORD);

//----- (000000000006BCB0) ----------------------------------------------------
unsigned __int64 __fastcall sub_6BCB0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // rdx
  __int64 v11; // r13
  __int64 v12; // rax
  unsigned __int8 v13; // di
  __int64 v14; // rcx
  __int64 v15; // r9
  __int64 v16; // rdx
  __int64 v17; // rsi
  __int64 v18; // rax
  unsigned __int8 v19; // di
  unsigned __int64 v20; // rsi
  unsigned __int64 v21; // r13
  char *v22; // rax
  unsigned __int64 v23; // r12
  unsigned __int8 *v24; // rax
  __int64 v25; // rdx
  unsigned __int64 v26; // rcx
  unsigned __int64 v27; // r14
  unsigned __int64 v28; // rdi
  unsigned __int64 v29; // rcx
  unsigned __int64 v30; // rbx
  unsigned __int64 v31; // rdx
  unsigned __int64 result; // rax
  unsigned __int64 v33; // rdx
  unsigned __int64 v34; // rsi
  unsigned __int64 v35; // rbx
  unsigned __int64 v36; // rsi
  __int64 v37; // rax
  unsigned __int64 v38; // rax
  unsigned __int64 v40; // [rsp+0h] [rbp-858h]
  __int64 v41[256]; // [rsp+10h] [rbp-848h] BYREF
  char v42; // [rsp+810h] [rbp-48h] BYREF
  unsigned __int64 v43; // [rsp+818h] [rbp-40h]

  v43 = __readfsqword(0x28u);
  if ( a4 <= 1 )
  {
    v9 = 1LL;
    v21 = 0LL;
    goto LABEL_16;
  }
  v8 = 0LL;
  v9 = 1LL;
  v10 = 1LL;
  v11 = -1LL;
  v12 = 1LL;
  do
  {
    while ( 1 )
    {
      v13 = *(_BYTE *)(a3 + v11 + v10);
      if ( *(_BYTE *)(a3 + v12) >= v13 )
        break;
      v8 = v12;
      v10 = 1LL;
      v9 = v12 - v11;
LABEL_4:
      v12 = v8 + v10;
      if ( a4 <= v8 + v10 )
        goto LABEL_8;
    }
    if ( *(_BYTE *)(a3 + v12) == v13 )
    {
      if ( v9 == v10 )
      {
        v8 += v9;
        v10 = 1LL;
      }
      else
      {
        ++v10;
      }
      goto LABEL_4;
    }
    v11 = v8;
    v10 = 1LL;
    ++v8;
    v9 = 1LL;
    v12 = v8 + 1;
  }
  while ( a4 > v8 + 1 );
LABEL_8:
  v14 = 0LL;
  v15 = 1LL;
  v16 = 1LL;
  v17 = -1LL;
  v18 = 1LL;
  do
  {
    while ( 1 )
    {
      v19 = *(_BYTE *)(a3 + v17 + v16);
      if ( *(_BYTE *)(a3 + v18) <= v19 )
        break;
      v14 = v18;
      v16 = 1LL;
      v15 = v18 - v17;
LABEL_10:
      v18 = v14 + v16;
      if ( a4 <= v14 + v16 )
        goto LABEL_14;
    }
    if ( *(_BYTE *)(a3 + v18) == v19 )
    {
      if ( v15 == v16 )
      {
        v14 += v15;
        v16 = 1LL;
      }
      else
      {
        ++v16;
      }
      goto LABEL_10;
    }
    v17 = v14;
    v16 = 1LL;
    ++v14;
    v15 = 1LL;
    v18 = v14 + 1;
  }
  while ( a4 > v14 + 1 );
LABEL_14:
  v20 = v17 + 1;
  v21 = v11 + 1;
  if ( v21 <= v20 )
  {
    v9 = v15;
    v21 = v20;
  }
LABEL_16:
  v22 = (char *)v41;
  do
  {
    *(_QWORD *)v22 = a4;
    v22 += 8;
  }
  while ( v22 != &v42 );
  v23 = a4 - 1;
  v24 = (unsigned __int8 *)a3;
  if ( a4 )
  {
    do
    {
      v25 = *v24;
      v26 = a3 + a4 - 1 - (_QWORD)v24++;
      v41[v25] = v26;
    }
    while ( v24 != (unsigned __int8 *)(a3 + a4) );
  }
  v40 = v9;
  v27 = a2 - a4;
  if ( !(unsigned int)memcmp(a3, a3 + v9, v21) )
  {
    v28 = 0LL;
    v29 = 0LL;
    v30 = a4 - v40;
    while ( 1 )
    {
      while ( 1 )
      {
        result = a1 + v29;
        v31 = v41[*(unsigned __int8 *)(a1 + v29 + v23)];
        if ( !v31 )
          break;
        if ( v31 < v40 && v28 )
          v31 = v30;
LABEL_25:
        v29 += v31;
        v28 = 0LL;
        if ( v29 > v27 )
          return 0LL;
      }
      v31 = v21;
      if ( v28 >= v21 )
        v31 = v28;
      if ( v31 < v23 )
      {
        while ( *(_BYTE *)(a3 + v31) == *(_BYTE *)(result + v31) )
        {
          if ( ++v31 >= v23 )
            goto LABEL_38;
        }
        v29 += 1 - v21;
        goto LABEL_25;
      }
LABEL_38:
      v33 = v21 - 1;
      v34 = v21;
      if ( v28 < v21 )
      {
        while ( 1 )
        {
          v34 = v33 + 1;
          if ( *(_BYTE *)(a3 + v33) != *(_BYTE *)(v33 + a1 + v29) )
          {
            result = a1 + v29;
            goto LABEL_44;
          }
          if ( v28 == v33 )
            break;
          --v33;
        }
        result = a1 + v29;
        v34 = v28;
      }
LABEL_44:
      if ( v28 + 1 > v34 )
        return result;
      v29 += v40;
      v28 = v30;
      if ( v29 > v27 )
        return 0LL;
    }
  }
  v35 = a4 - v21;
  if ( v35 < v21 )
    v35 = v21;
  v36 = 0LL;
  while ( 2 )
  {
    v37 = v41[*(unsigned __int8 *)(a1 + v36 + v23)];
    if ( v37 )
      goto LABEL_51;
    v37 = v21;
    if ( v23 > v21 )
    {
      while ( *(_BYTE *)(a3 + v37) == *(_BYTE *)(a1 + v36 + v37) )
      {
        if ( ++v37 >= v23 )
          goto LABEL_59;
      }
      v36 += 1 - v21;
LABEL_51:
      v36 += v37;
      goto LABEL_52;
    }
LABEL_59:
    v38 = v21 - 1;
    if ( v21 )
    {
      while ( *(_BYTE *)(a3 + v38) == *(_BYTE *)(v38 + a1 + v36) )
      {
        if ( v38-- == 0 )
          return a1 + v36;
      }
      v36 += v35 + 1;
LABEL_52:
      if ( v36 > v27 )
        return 0LL;
      continue;
    }
    return a1 + v36;
  }
}

//----- (000000000006C060) ----------------------------------------------------
unsigned __int64 __fastcall sub_6C060(unsigned __int8 *a1, unsigned __int64 a2, unsigned __int8 *a3, unsigned __int64 a4)
{
  unsigned __int8 *v4; // rbp
  unsigned __int8 *v6; // r14
  unsigned __int64 v7; // r13
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // r12
  unsigned __int64 v10; // rbx
  __int64 v11; // rax
  __int64 v12; // rdx
  char v13; // dl
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // rax
  unsigned __int64 result; // rax
  unsigned __int8 *v17; // rbp
  int v18; // ecx
  int i; // edx
  int v20; // eax
  __int64 v21; // [rsp+8h] [rbp-150h]
  char v22[264]; // [rsp+10h] [rbp-148h] BYREF
  unsigned __int64 v23; // [rsp+118h] [rbp-40h]

  v4 = a1;
  v23 = __readfsqword(0x28u);
  if ( !a4 )
    return (unsigned __int64)v4;
  if ( a4 == 1 )
    return sub_9110(a1, *a3, a2);
  if ( a4 > a2 )
    return 0LL;
  v6 = &a1[a2 - a4];
  if ( a4 == 2 )
  {
    v17 = a1 + 1;
    v18 = a3[1] | (*a3 << 16);
    for ( i = a1[1] | (*a1 << 16); v6 >= v17; i = v20 | (i << 16) )
    {
      if ( v18 == i )
        break;
      v20 = *++v17;
    }
    result = (unsigned __int64)(v17 - 1);
    if ( v18 == i )
      return result;
    return 0LL;
  }
  if ( a4 <= 0x100 )
  {
    v7 = a4 - 1;
    memset(v22, 0, 0x100uLL);
    v8 = 1LL;
    do
    {
      v22[(unsigned __int8)(a3[v8] - 8 * a3[v8 - 1])] = v8;
      ++v8;
    }
    while ( v7 > v8 );
    v9 = 0LL;
    v10 = a4 - 9;
    v11 = (unsigned __int8)(a3[a4 - 1] - 8 * a3[a4 - 2]);
    v12 = (unsigned __int8)v22[v11];
    v22[v11] = v7;
    v21 = v7 - v12;
    while ( v6 >= v4 )
    {
      while ( 1 )
      {
        do
        {
          v4 += v7;
          v13 = 8 * *(v4 - 1);
          v14 = (unsigned __int8)v22[(unsigned __int8)(*v4 - v13)];
        }
        while ( !v22[(unsigned __int8)(*v4 - v13)] && v6 >= v4 );
        v4 -= v14;
        if ( v7 > v14 )
          break;
        if ( v7 <= 0xE || *(_QWORD *)&a3[v9] == *(_QWORD *)&v4[v9] )
        {
          if ( !(unsigned int)memcmp((__int64)v4, (__int64)a3, v7) )
            return (unsigned __int64)v4;
          v15 = v9 - 8;
          if ( v9 < 8 )
            v15 = v10;
          v9 = v15;
        }
        v4 += v21;
        if ( v6 < v4 )
          return 0LL;
      }
    }
    return 0LL;
  }
  return sub_6BCB0((__int64)a1, a2, (__int64)a3, a4);
}
// 9110: using guessed type __int64 __fastcall sub_9110(_QWORD, _QWORD, _QWORD);

//----- (000000000006C2B0) ----------------------------------------------------
__int64 __fastcall sub_6C2B0(__int64 a1, __int64 a2, __int64 *a3, __int64 *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  char *v14; // rbx
  __int64 v15; // rax
  __int64 v16; // rdx
  __int64 v17; // rcx
  u32 *v18; // r8
  u32 v19; // er9
  double v20; // xmm4_8
  double v21; // xmm5_8
  __int64 result; // rax
  __int64 v23; // r14
  __int64 v24; // rax
  u32 *v25; // r8
  __int64 v26; // r9
  double v27; // xmm4_8
  double v28; // xmm5_8
  unsigned __int64 v29; // rdi
  _BYTE *v30; // rdx
  unsigned __int64 v31; // rcx
  char v32; // al

  v14 = (char *)a1;
  v15 = strlen(a1);
  if ( !v15 )
  {
    *a3 = 0LL;
    result = 0LL;
    *a4 = 0LL;
    return result;
  }
  v23 = v15 + 1;
  v24 = sub_21500((u32 *)(v15 + 1), a2, v16, v17, v18, v19, a5, a6, a7, a8, v20, v21, a11, a12);
  *a3 = v24;
  v29 = v24;
  if ( !v24 )
    return 12LL;
  v30 = (_BYTE *)v24;
  do
  {
    while ( 1 )
    {
      v31 = (unsigned int)*v14;
      v32 = *v14;
      if ( (_DWORD)v31 == (_DWORD)a2 )
        break;
      *v30++ = *v14;
LABEL_6:
      ++v14;
      if ( !v32 )
        goto LABEL_11;
    }
    if ( v29 >= (unsigned __int64)v30 || !*(v30 - 1) )
    {
      --v23;
      goto LABEL_6;
    }
    *v30 = 0;
    ++v14;
    ++v30;
  }
  while ( v32 );
LABEL_11:
  if ( !v23 )
  {
    sub_21B70(v29, a5, a6, a7, a8, v27, v28, a11, a12, a2, (__int64)v30, v31, v25, v26);
    *a3 = 0LL;
  }
  result = 0LL;
  *a4 = v23;
  return result;
}
// 6C2F7: variable 'v16' is possibly undefined
// 6C2F7: variable 'v17' is possibly undefined
// 6C2F7: variable 'v18' is possibly undefined
// 6C2F7: variable 'v19' is possibly undefined
// 6C2F7: variable 'v20' is possibly undefined
// 6C2F7: variable 'v21' is possibly undefined
// 6C370: variable 'v27' is possibly undefined
// 6C370: variable 'v28' is possibly undefined
// 6C370: variable 'v25' is possibly undefined
// 6C370: variable 'v26' is possibly undefined

//----- (000000000006C390) ----------------------------------------------------
__int64 __fastcall sub_6C390(const char **a1, _QWORD *a2, __int64 a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  char *v13; // rbx
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // r9
  double v18; // xmm4_8
  double v19; // xmm5_8
  unsigned int v20; // er8
  __int64 v22; // r14
  const char *v23; // rax
  char *v24; // rdx
  int v25; // ecx
  char v26; // al
  char v27; // al

  v13 = (char *)a3;
  v14 = strlen(a3);
  v20 = 0;
  if ( !v14 )
    return v20;
  v22 = v14 + 1;
  v23 = (const char *)sub_21DF0(*a1, v14 + 1 + *a2, v15, v16, 0LL, v17, a5, a6, a7, a8, v18, v19, a11, a12);
  *a1 = v23;
  if ( !v23 )
    return 12;
  v24 = (char *)&v23[*a2];
  do
  {
    while ( 1 )
    {
      v25 = *v13;
      v26 = *v13;
      if ( v25 == a4 )
        break;
      *v24++ = v25;
LABEL_6:
      ++v13;
      if ( !v26 )
        goto LABEL_11;
    }
    if ( *a1 >= v24 || !*(v24 - 1) )
    {
      --v22;
      goto LABEL_6;
    }
    *v24 = 0;
    v27 = *v13;
    ++v24;
    ++v13;
  }
  while ( v27 );
LABEL_11:
  *a2 += v22;
  return 0LL;
}
// 6C3D7: variable 'v15' is possibly undefined
// 6C3D7: variable 'v16' is possibly undefined
// 6C3D7: variable 'v17' is possibly undefined
// 6C3D7: variable 'v18' is possibly undefined
// 6C3D7: variable 'v19' is possibly undefined

//----- (000000000006C460) ----------------------------------------------------
char *__fastcall sub_6C460(const __m128i *a1, unsigned int a2)
{
  __m128i v2; // xmm1
  __m128i v3; // xmm1
  __m128i v4; // xmm1
  __m128i v5; // xmm3
  unsigned int v6; // ecx
  unsigned int v7; // edx
  unsigned __int64 v8; // rax
  __m128i v10; // xmm5
  __m128i v11; // xmm4
  __m128i v12; // xmm0
  unsigned int v13; // edx
  __m128i v14; // xmm5
  __int64 v15; // rsi
  unsigned __int64 v16; // rax
  __int64 v17; // rsi
  const __m128i *v18; // rcx
  const __m128i *i; // rdi
  __m128i v20; // xmm3
  __m128i v21; // xmm2
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  unsigned __int64 v24; // rdx
  unsigned __int64 v25; // rax
  __int64 v26; // rdx
  __m128i v27; // xmm6
  __m128i v28; // xmm5
  unsigned int v29; // esi
  __m128i v30; // xmm6
  __m128i v31; // xmm2
  __m128i v32; // xmm4
  unsigned int v33; // edx
  __m128i v34; // xmm6
  unsigned __int64 v35; // rdx
  __int64 v36; // rsi
  unsigned __int64 v37; // rax

  v2 = _mm_cvtsi32_si128(a2);
  v3 = _mm_unpacklo_epi8(v2, v2);
  v4 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v3, v3), 0);
  if ( ((unsigned __int16)a1 & 0xFFFu) <= 0xFC0uLL )
  {
    v5 = _mm_loadu_si128(a1);
    v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(v5, v4));
    v7 = _mm_movemask_epi8(_mm_cmpeq_epi8(v5, (__m128i)0LL));
    if ( v7 )
    {
      if ( (v6 & (v7 ^ (v7 - 1LL))) != 0 )
      {
        _BitScanReverse64(&v8, v6 & (v7 ^ (v7 - 1LL)));
        return (char *)a1 + v8;
      }
      return 0LL;
    }
    v10 = _mm_loadu_si128(a1 + 1);
    v11 = _mm_cmpeq_epi8(v10, v4);
    v12 = _mm_loadu_si128(a1 + 3);
    v13 = _mm_movemask_epi8(_mm_cmpeq_epi8(v10, (__m128i)0LL));
    v14 = _mm_loadu_si128(a1 + 2);
    v15 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v12, v4)) << 48) | v6 | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v14, v4)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v11) << 16);
    v16 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, v12)) << 48) | ((unsigned __int64)v13 << 16) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v14, (__m128i)0LL)) << 32);
    if ( v16 )
    {
      v17 = (v16 ^ (v16 - 1)) & v15;
      if ( v17 )
      {
        _BitScanReverse64((unsigned __int64 *)&v17, v17);
        return (char *)a1 + v17;
      }
      return 0LL;
    }
    goto LABEL_8;
  }
  v27 = _mm_loadu_si128((const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL));
  v28 = _mm_cmpeq_epi8(v27, v4);
  v29 = _mm_movemask_epi8(_mm_cmpeq_epi8(v27, (__m128i)0LL));
  v30 = _mm_loadu_si128((const __m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 16));
  v31 = _mm_loadu_si128((const __m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 48));
  v32 = _mm_cmpeq_epi8(v30, v4);
  v33 = _mm_movemask_epi8(_mm_cmpeq_epi8(v30, (__m128i)0LL));
  v34 = _mm_loadu_si128((const __m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 32));
  v35 = (((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, v31)) << 48) | v29 | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v34, (__m128i)0LL)) << 32) | ((unsigned __int64)v33 << 16)) >> ((unsigned __int8)a1 - ((unsigned __int8)a1 & 0xC0u));
  v15 = (((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v31, v4)) << 48) | (unsigned int)_mm_movemask_epi8(v28) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v34, v4)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v32) << 16)) >> ((unsigned __int8)a1 - ((unsigned __int8)a1 & 0xC0u));
  if ( !v35 )
  {
LABEL_8:
    v18 = a1;
    if ( !v15 )
    {
      v15 = 1LL;
      v18 = 0LL;
    }
    for ( i = (const __m128i *)((unsigned __int64)&a1[4] & 0xFFFFFFFFFFFFFFC0LL); ; i += 4 )
    {
      v20 = _mm_load_si128(i + 2);
      v21 = _mm_load_si128(i + 3);
      v22 = _mm_load_si128(i + 1);
      v23 = _mm_load_si128(i);
      v24 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v21, v4)) << 48) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v23, v4)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v20, v4)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v22, v4)) << 16);
      if ( _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(_mm_min_epu8(v20, v21), v22), v23), (__m128i)0LL)) )
        break;
      if ( v24 )
        v15 = v24;
      if ( v24 )
        v18 = i;
    }
    v25 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v21, (__m128i)0LL)) << 48) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v23, (__m128i)0LL)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v20, (__m128i)0LL)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v22, (__m128i)0LL)) << 16);
    v26 = (v25 ^ (v25 - 1)) & v24;
    if ( v26 )
      v18 = i;
    if ( v26 )
      v15 = v26;
    _BitScanReverse64((unsigned __int64 *)&v15, v15);
    return (char *)v18 + v15;
  }
  v36 = (v35 ^ (v35 - 1)) & v15;
  if ( !v36 )
    return 0LL;
  _BitScanReverse64(&v37, v36);
  return (char *)a1 + v37;
}

//----- (000000000006C760) ----------------------------------------------------
unsigned __int64 __fastcall sub_6C760(__int64 _RDI, unsigned __int64 a2, __m128 _XMM0)
{
  unsigned __int64 v12; // rdi
  unsigned int v14; // edx
  __int64 v15; // rcx
  __int64 v36; // rax
  unsigned __int64 result; // rax
  __int64 v39; // rax
  __int64 v40; // rax

  _XMM4 = _mm_cvtsi32_si128(a2);
  __asm
  {
    vpbroadcastb ymm4, xmm4
    vpxor   xmm0, xmm0, xmm0
  }
  if ( ((unsigned __int8)_RDI & 0x3Fu) > 0x20 )
  {
    v15 = _RDI & 0x1F;
    _RDI = _RDI & 0xFFFFFFFFFFFFFFE0LL;
    __asm
    {
      vmovdqa ymm1, ymmword ptr [rdi]
      vpcmpeqb ymm2, ymm0, ymm1
      vpcmpeqb ymm3, ymm4, ymm1
      vpmovmskb edx, ymm2
      vpmovmskb eax, ymm3
    }
    v14 = _EDX >> v15;
    _EAX = _EAX >> v15;
    _RDI = _RDI + 32;
    if ( !_EAX )
    {
      if ( !v14 )
        goto LABEL_12;
      goto LABEL_26;
    }
    if ( !v14 )
    {
      v14 = _EAX;
      a2 = _RDI + v15;
      goto LABEL_12;
    }
    v12 = v15 + _RDI;
    _ECX = v14;
LABEL_24:
    LODWORD(v40) = (_ECX ^ (_ECX - 1)) & _EAX;
    if ( (_DWORD)v40 )
    {
      _BitScanReverse((unsigned int *)&v40, v40);
      result = v12 + v40 - 32;
      __asm { vzeroupper }
      return result;
    }
    goto LABEL_26;
  }
  __asm
  {
    vmovdqu ymm1, ymmword ptr [rdi]
    vpcmpeqb ymm2, ymm0, ymm1
    vpcmpeqb ymm3, ymm4, ymm1
    vpmovmskb ecx, ymm2
    vpmovmskb eax, ymm3
  }
  v12 = _RDI + 32;
  if ( _EAX )
  {
    if ( !_ECX )
    {
      v14 = _EAX;
      a2 = v12;
      _RDI = v12 & 0xFFFFFFFFFFFFFFE0LL;
      goto LABEL_12;
    }
    goto LABEL_24;
  }
  if ( _ECX )
  {
LABEL_26:
    result = 0LL;
    __asm { vzeroupper }
    return result;
  }
  _RDI = v12 & 0xFFFFFFFFFFFFFFE0LL;
  v14 = 0;
  while ( 1 )
  {
    do
    {
LABEL_12:
      __asm
      {
        vmovdqa ymm1, ymmword ptr [rdi]
        vpcmpeqb ymm2, ymm0, ymm1
      }
      _RDI += 32LL;
      __asm
      {
        vpcmpeqb ymm3, ymm4, ymm1
        vpmovmskb ecx, ymm2
        vpmovmskb eax, ymm3
      }
      if ( _EAX | _ECX )
        break;
      __asm
      {
        vmovdqa ymm1, ymmword ptr [rdi]
        vpcmpeqb ymm2, ymm0, ymm1
      }
      _RDI += 32LL;
      __asm
      {
        vpcmpeqb ymm3, ymm4, ymm1
        vpmovmskb ecx, ymm2
        vpmovmskb eax, ymm3
      }
      if ( _EAX | _ECX )
        break;
      __asm
      {
        vmovdqa ymm1, ymmword ptr [rdi]
        vpcmpeqb ymm2, ymm0, ymm1
      }
      _RDI += 32LL;
      __asm
      {
        vpcmpeqb ymm3, ymm4, ymm1
        vpmovmskb ecx, ymm2
        vpmovmskb eax, ymm3
      }
      if ( _EAX | _ECX )
        break;
      __asm
      {
        vmovdqa ymm1, ymmword ptr [rdi]
        vpcmpeqb ymm2, ymm0, ymm1
      }
      _RDI += 32LL;
      __asm
      {
        vpcmpeqb ymm3, ymm4, ymm1
        vpmovmskb ecx, ymm2
        vpmovmskb eax, ymm3
      }
    }
    while ( !(_EAX | _ECX) );
    if ( !_EAX )
      break;
    __asm { vpmovmskb ecx, ymm2 }
    if ( _ECX )
    {
      LODWORD(v39) = (_ECX ^ (_ECX - 1)) & _EAX;
      if ( (_DWORD)v39 )
      {
        _BitScanReverse((unsigned int *)&v39, v39);
        result = _RDI + v39 - 32;
        __asm { vzeroupper }
        return result;
      }
      break;
    }
    v14 = _EAX;
    a2 = _RDI;
  }
  if ( !v14 )
    goto LABEL_26;
  _BitScanReverse((unsigned int *)&v36, v14);
  result = a2 + v36 - 32;
  __asm { vzeroupper }
  return result;
}
// 6C8A4: variable 'v36' is possibly undefined
// 6C8E4: variable 'v39' is possibly undefined
// 6C909: variable 'v40' is possibly undefined

//----- (000000000006C930) ----------------------------------------------------
char *__fastcall sub_6C930(__int64 a1, __int64 a2)
{
  char *result; // rax
  __int64 v3; // rsi
  unsigned __int64 v4; // r10
  __int64 v5; // r11
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  __m128i v8; // xmm3
  signed __int64 v9; // rdx
  char v10; // cl
  unsigned __int64 v11; // rsi
  __m128i *v12; // rax
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // rdx

  if ( !a2 )
    return 0LL;
  v3 = a1 + a2;
  v4 = v3 & 0xFFFFFFFFFFFFFFC0LL;
  v5 = v3;
  if ( ((unsigned __int16)a1 & 0xFFFu) > 0xFCFuLL )
  {
    v9 = (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((char *)qword_20
                                                                                   + (a1 & 0xFFFFFFFFFFFFFFC0LL)))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((char *)&dword_30 + (a1 & 0xFFFFFFFFFFFFFFC0LL)))) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((char *)&word_10 + (a1 & 0xFFFFFFFFFFFFFFC0LL)))) << 16);
    v10 = a1 & 0xC0 ^ a1;
    v11 = v3 - (a1 & 0xFFFFFFFFFFFFFFC0LL);
    v12 = (__m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL);
    if ( (v11 & 0xFFFFFFFFFFFFFFC0LL) != 0 )
    {
      v13 = v9 >> v10;
      if ( v13 )
        goto LABEL_11;
      goto LABEL_12;
    }
  }
  else
  {
    v6 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((char *)&word_10 + (a1 & 0xFFFFFFFFFFFFFFF0LL)));
    v7 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((char *)qword_20 + (a1 & 0xFFFFFFFFFFFFFFF0LL)));
    v8 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((char *)&dword_30 + (a1 & 0xFFFFFFFFFFFFFFF0LL)));
    v9 = (((unsigned int)_mm_movemask_epi8(v7) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v8) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)(a1 & 0xFFFFFFFFFFFFFFF0LL))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v6) << 16);
    v10 = a1 & 0xF0 ^ a1;
    v11 = v3 - (a1 & 0xFFFFFFFFFFFFFFF0LL);
    v12 = (__m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL);
    if ( (v11 & 0xFFFFFFFFFFFFFFC0LL) != 0 )
    {
      v13 = v9 >> v10;
      if ( !v13 )
        goto LABEL_13;
      goto LABEL_11;
    }
  }
  v13 = (v9 | (1LL << v11)) >> v10;
  if ( v13 )
  {
LABEL_11:
    _BitScanForward64((unsigned __int64 *)&result, v13);
    return result;
  }
LABEL_12:
  v6 = 0LL;
  v7 = 0LL;
  v8 = 0LL;
LABEL_13:
  while ( 1 )
  {
    v12 += 4;
    if ( (__m128i *)v4 == v12 )
      break;
    v13 = (unsigned int)_mm_movemask_epi8(
                          _mm_cmpeq_epi8(
                            _mm_min_epu8(_mm_min_epu8(_mm_min_epu8(_mm_load_si128(v12), v12[1]), v12[2]), v12[3]),
                            v8));
    if ( (_DWORD)v13 )
    {
      _BitScanForward64(
        &v14,
        (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v7, v12[2])) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v8, v12[3])) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *v12)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v6, v12[1])) << 16));
      return (char *)v12 + v14 - a1;
    }
  }
  if ( (__m128i *)v5 != v12 )
    v13 = (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v7, v12[2])) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v8, v12[3])) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *v12)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v6, v12[1])) << 16);
  _BitScanForward64(&v13, v13 | (1LL << v5));
  return (char *)v12 + v13 - a1;
}
// 10: using guessed type __int16 word_10;
// 20: using guessed type __int64 qword_20[];
// 30: using guessed type int dword_30;

//----- (000000000006CB50) ----------------------------------------------------
unsigned __int64 __fastcall sub_6CB50(unsigned __int64 _RDI, unsigned __int64 a2, __m128 _XMM0)
{
  unsigned __int64 v5; // r8
  unsigned __int64 v6; // rdx
  unsigned int v8; // ecx
  char v10; // cc
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rdi
  unsigned __int64 result; // rax
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // rsi
  unsigned __int64 v25; // rcx
  unsigned __int64 v35; // rsi
  unsigned __int64 v39; // rsi
  unsigned __int64 v42; // rsi

  if ( !a2 )
    return 0LL;
  v5 = a2;
  v6 = _RDI;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v8 = _RDI & 0x3F;
  if ( v8 > 0x20 )
  {
    v14 = _RDI & 0x1F;
    v15 = _RDI & 0xFFFFFFFFFFFFFFE0LL;
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    _RAX = (unsigned int)(_EAX >> v14);
    if ( (_DWORD)_RAX )
    {
      __asm { tzcnt   eax, eax }
      if ( a2 > _RAX )
      {
        result = v14 + v15 + _RAX - v6;
        __asm { vzeroupper }
        return result;
      }
      goto LABEL_39;
    }
    v19 = 32 - v14;
    v10 = a2 <= v19;
    v20 = a2 - v19;
    if ( v10 )
    {
LABEL_39:
      result = v5;
      __asm { vzeroupper }
      return result;
    }
    _RDI = v15 + 32;
    v10 = v20 <= 0x80;
    v13 = v20 - 128;
    if ( v10 )
      goto LABEL_20;
  }
  else
  {
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
      goto LABEL_31;
    v10 = a2 <= 0x20;
    v11 = a2 - 32;
    if ( v10 )
      goto LABEL_39;
    _RDI = (_RDI + 32) & 0xFFFFFFFFFFFFFFE0LL;
    v12 = (v8 & 0x1F) + v11;
    v10 = v12 <= 0x80;
    v13 = v12 - 128;
    if ( v10 )
    {
LABEL_20:
      v10 = ((int)v13 + 64 < 0) ^ __OFADD__(64, (_DWORD)v13) | ((_DWORD)v13 == -64);
      v35 = (unsigned int)(v13 + 64);
      if ( !v10 )
      {
        __asm
        {
          vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
          vpmovmskb eax, ymm1
        }
        if ( (_DWORD)_RAX )
          goto LABEL_41;
        __asm
        {
          vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
          vpmovmskb eax, ymm1
        }
        if ( (_DWORD)_RAX )
          goto LABEL_42;
        __asm
        {
          vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+40h]
          vpmovmskb eax, ymm1
        }
        if ( (_DWORD)_RAX )
        {
          __asm { tzcnt   eax, eax }
          if ( v35 > _RAX )
          {
            result = _RDI + _RAX + 64 - v6;
            __asm { vzeroupper }
            return result;
          }
        }
        else
        {
          v10 = (int)v35 <= 32;
          v39 = (unsigned int)(v35 - 32);
          if ( !v10 )
          {
            __asm
            {
              vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+60h]
              vpmovmskb eax, ymm1
            }
            if ( !(_DWORD)_RAX )
            {
              result = v5;
              __asm { vzeroupper }
              return result;
            }
            __asm { tzcnt   eax, eax }
            if ( v39 > _RAX )
            {
              result = _RDI + _RAX + 96 - v6;
              __asm { vzeroupper }
              return result;
            }
          }
        }
        goto LABEL_39;
      }
      a2 = (unsigned int)(v35 + 64);
      __asm
      {
        vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
        vpmovmskb eax, ymm1
      }
      if ( !(_DWORD)_RAX )
      {
        v10 = (int)a2 <= 32;
        v42 = (unsigned int)(a2 - 32);
        if ( !v10 )
        {
          __asm
          {
            vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
            vpmovmskb eax, ymm1
          }
          if ( !(_DWORD)_RAX )
          {
            result = v5;
            __asm { vzeroupper }
            return result;
          }
          __asm { tzcnt   eax, eax }
          if ( v42 > _RAX )
          {
            result = _RDI + _RAX + 32 - v6;
            __asm { vzeroupper }
            return result;
          }
        }
        goto LABEL_39;
      }
LABEL_31:
      __asm { tzcnt   eax, eax }
      if ( a2 > _RAX )
      {
        result = _RDI + _RAX - v6;
        __asm { vzeroupper }
        return result;
      }
      goto LABEL_39;
    }
  }
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_41;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_42;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+40h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_43;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+60h]
    vpmovmskb eax, ymm1
  }
  if ( !(_DWORD)_RAX )
  {
    _RDI += 128LL;
    v10 = v13 <= 0x80;
    v13 -= 128LL;
    if ( !v10 )
    {
      v25 = _RDI & 0x7F;
      _RDI &= 0xFFFFFFFFFFFFFF80LL;
      v13 += v25;
      while ( 1 )
      {
        __asm
        {
          vmovdqa ymm1, ymmword ptr [rdi]
          vmovdqa ymm2, ymmword ptr [rdi+20h]
          vmovdqa ymm3, ymmword ptr [rdi+40h]
          vmovdqa ymm4, ymmword ptr [rdi+60h]
          vpminub ymm5, ymm2, ymm1
          vpminub ymm6, ymm4, ymm3
          vpminub ymm5, ymm6, ymm5
          vpcmpeqb ymm5, ymm0, ymm5
          vpmovmskb eax, ymm5
        }
        if ( _EAX )
          break;
        _RDI += 128LL;
        v10 = v13 <= 0x80;
        v13 -= 128LL;
        if ( v10 )
          goto LABEL_20;
      }
      __asm
      {
        vpcmpeqb ymm1, ymm0, ymm1
        vpmovmskb eax, ymm1
      }
      if ( !(_DWORD)_RAX )
      {
        __asm
        {
          vpcmpeqb ymm2, ymm0, ymm2
          vpmovmskb eax, ymm2
        }
        if ( !(_DWORD)_RAX )
        {
          __asm
          {
            vpcmpeqb ymm3, ymm0, ymm3
            vpmovmskb eax, ymm3
          }
          if ( !(_DWORD)_RAX )
          {
            __asm
            {
              vpcmpeqb ymm4, ymm0, ymm4
              vpmovmskb eax, ymm4
            }
            goto LABEL_48;
          }
LABEL_43:
          __asm { tzcnt   eax, eax }
          result = _RDI + _RAX + 64 - v6;
          __asm { vzeroupper }
          return result;
        }
LABEL_42:
        __asm { tzcnt   eax, eax }
        result = _RDI + _RAX + 32 - v6;
        __asm { vzeroupper }
        return result;
      }
LABEL_41:
      __asm { tzcnt   eax, eax }
      result = _RDI + _RAX - v6;
      __asm { vzeroupper }
      return result;
    }
    goto LABEL_20;
  }
LABEL_48:
  __asm { tzcnt   eax, eax }
  result = _RDI + _RAX + 96 - v6;
  __asm { vzeroupper }
  return result;
}
// 6CD47: variable '_RAX' is possibly undefined

//----- (000000000006CE70) ----------------------------------------------------
void *sub_6CE70()
{
  void *result; // rax

  result = sub_6D850;
  if ( (dword_C1434 & 0x800) == 0 && (BYTE4(xmmword_C1384) & 0x20) != 0 && (dword_C1434 & 0x100) != 0 )
    result = sub_6DAF0;
  return result;
}
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (000000000006CEA0) ----------------------------------------------------
void *__fastcall sub_6CEA0(void *a1, const void *a2, __int64 a3)
{
  return memcpy(a1, a2, 4 * a3);
}

//----- (000000000006CEB0) ----------------------------------------------------
__int64 __fastcall sub_6CEB0(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_9050(a1, a2, 4 * a3);
}
// 9050: using guessed type __int64 __fastcall sub_9050(_QWORD, _QWORD, _QWORD);

//----- (000000000006CEC0) ----------------------------------------------------
__int64 __fastcall sub_6CEC0(unsigned int a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14)
{
  __int64 v14; // rdx
  __int64 result; // rax
  __int64 v16; // rbp
  void **v17; // r12
  __int64 (__fastcall *v18)(void *, _QWORD); // rbp
  _QWORD *v19; // rax
  bool v20; // zf
  __int64 (__fastcall *v21)(void *, __int64 *, char **, char *, _QWORD, char *, _QWORD); // rbx
  int v22; // edx
  unsigned int v23; // [rsp+Ch] [rbp-7Ch] BYREF
  char *v24; // [rsp+10h] [rbp-78h] BYREF
  char v25[8]; // [rsp+18h] [rbp-70h] BYREF
  __int64 v26[3]; // [rsp+20h] [rbp-68h] BYREF
  int v27; // [rsp+38h] [rbp-50h]
  __int64 *v28; // [rsp+40h] [rbp-48h]
  __int64 v29; // [rsp+48h] [rbp-40h] BYREF
  char v30; // [rsp+57h] [rbp-31h] BYREF
  unsigned __int64 v31; // [rsp+58h] [rbp-30h]

  v14 = a1 + 128;
  v31 = __readfsqword(0x28u);
  if ( (unsigned int)v14 > 0x17F || a1 == -1 )
    return 0xFFFFFFFFLL;
  result = a1;
  if ( (a1 & 0xFFFFFF80) != 0 )
  {
    v16 = *(_QWORD *)__readfsqword(0xFFFFFFA0);
    v17 = *(void ***)(v16 + 40);
    if ( !v17 )
    {
      v17 = &off_BAD80;
      if ( (void **)v16 != &off_BAE20 )
      {
        sub_49110(v16, a3, a4, a5, a6, a7, a8, a9, a10, a2, v14, a12, a13, a14);
        v17 = *(void ***)(v16 + 40);
      }
    }
    v18 = (__int64 (__fastcall *)(void *, _QWORD))*((_QWORD *)*v17 + 6);
    if ( *(_QWORD *)*v17 )
      v18 = (__int64 (__fastcall *)(void *, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v18, 17));
    if ( v17[1] == (char *)&dword_0 + 1 && v18 )
    {
      sub_4F2B0((__int64)v18);
      result = v18(*v17, (unsigned __int8)a1);
    }
    else
    {
      v30 = a1;
      v24 = &v30;
      v26[0] = (__int64)&v23;
      v29 = 0LL;
      v28 = &v29;
      v19 = *v17;
      v26[1] = (__int64)&v24;
      v20 = *v19 == 0LL;
      v21 = (__int64 (__fastcall *)(void *, __int64 *, char **, char *, _QWORD, char *, _QWORD))v19[5];
      v27 = 1;
      v26[2] = 1LL;
      if ( !v20 )
        v21 = (__int64 (__fastcall *)(void *, __int64 *, char **, char *, _QWORD, char *, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v21, 17));
      sub_4F2B0((__int64)v21);
      v22 = v21(*v17, v26, &v24, v24 + 1, 0LL, v25, 0LL);
      if ( (unsigned int)(v22 - 4) <= 1 || (result = 0xFFFFFFFFLL, !v22) )
        result = v23;
    }
  }
  return result;
}
// 0: using guessed type __int64 (*dword_0)(void);
// BAD80: using guessed type void *off_BAD80;
// BAE20: using guessed type void *off_BAE20;

//----- (000000000006D090) ----------------------------------------------------
__int64 __fastcall sub_6D090(char *a1, __int64 a2, void *a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  char *v14; // rbp
  unsigned __int64 v15; // rax
  __int64 v16; // rbx
  void **v17; // r12
  _QWORD *v18; // rax
  __int64 (__fastcall *v19)(void *, __int64 *, int **, int *, _QWORD, char *, __int64, __int64); // rbx
  int v20; // eax
  _BYTE *v21; // rax
  int v23; // [rsp+Ch] [rbp-7Ch] BYREF
  char v24[8]; // [rsp+10h] [rbp-78h] BYREF
  int *v25; // [rsp+18h] [rbp-70h] BYREF
  __int64 v26[3]; // [rsp+20h] [rbp-68h] BYREF
  int v27; // [rsp+38h] [rbp-50h]
  void *v28; // [rsp+40h] [rbp-48h]
  char v29; // [rsp+50h] [rbp-38h] BYREF
  unsigned __int64 v30; // [rsp+68h] [rbp-20h]

  v14 = a1;
  v23 = a2;
  v30 = __readfsqword(0x28u);
  v26[2] = 1LL;
  if ( !a3 )
    a3 = &unk_C1708;
  v27 = 1;
  v28 = a3;
  if ( !a1 )
  {
    v23 = 0;
    v14 = &v29;
  }
  v26[0] = (__int64)v14;
  v15 = __readfsqword(0xFFFFFFA0);
  v16 = *(_QWORD *)v15;
  v17 = *(void ***)(*(_QWORD *)v15 + 40LL);
  v26[1] = (__int64)&v14[*(unsigned int *)(*(_QWORD *)v15 + 168LL)];
  if ( !v17 )
  {
    v17 = &off_BAD80;
    if ( (void **)v16 != &off_BAE20 )
    {
      sub_49110(v16, a7, a8, a9, a10, a11, a12, a13, a14, a2, (__int64)a3, a4, a5, a6);
      v17 = *(void ***)(v16 + 40);
    }
  }
  v18 = v17[2];
  v19 = (__int64 (__fastcall *)(void *, __int64 *, int **, int *, _QWORD, char *, __int64, __int64))v18[5];
  if ( *v18 )
    v19 = (__int64 (__fastcall *)(void *, __int64 *, int **, int *, _QWORD, char *, __int64, __int64))(__readfsqword(0x30u) ^ __ROR8__(v19, 17));
  if ( v23 )
  {
    v25 = &v23;
    sub_4F2B0((__int64)v19);
    v20 = v19(v17[2], v26, &v25, v25 + 1, 0LL, v24, 0LL, 1LL);
    if ( (v20 & 0xFFFFFFFB) == 0 )
      return v26[0] - (_QWORD)v14;
  }
  else
  {
    sub_4F2B0((__int64)v19);
    v20 = v19(v17[2], v26, 0LL, 0LL, 0LL, v24, 1LL, 1LL);
    if ( (v20 & 0xFFFFFFFB) == 0 )
    {
      v21 = (_BYTE *)v26[0]++;
      *v21 = 0;
      return v26[0] - (_QWORD)v14;
    }
  }
  if ( (unsigned int)(v20 - 5) > 2 )
    sub_CF00(
      "status == __GCONV_OK || status == __GCONV_EMPTY_INPUT || status == __GCONV_ILLEGAL_INPUT || status == __GCONV_INCO"
      "MPLETE_INPUT || status == __GCONV_FULL_OUTPUT",
      "wcrtomb.c",
      98LL,
      "__wcrtomb");
  if ( v20 == 5 )
    return v26[0] - (_QWORD)v14;
  __writefsdword(0xFFFFFFC0, 0x54u);
  return -1LL;
}
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// BAD80: using guessed type void *off_BAD80;
// BAE20: using guessed type void *off_BAE20;

//----- (000000000006D280) ----------------------------------------------------
__int64 __fastcall sub_6D280(__int64 a1, __int64 *a2, __int64 a3, __int64 *a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  unsigned __int64 v15; // rax
  __int64 v16; // rbx
  void **v17; // rax
  _QWORD *v18; // rbp
  __int64 (__fastcall *v19)(_QWORD *, char **, __int64 *, __int64, _QWORD, char *, _QWORD); // rbx
  __int64 v20; // rax
  __int64 v21; // r15
  int v22; // eax
  __int64 v23; // r14
  unsigned int v24; // edx
  __int64 v26; // r15
  __int64 v27; // [rsp+0h] [rbp-1A8h]
  __int64 v28; // [rsp+0h] [rbp-1A8h]
  __int64 v29; // [rsp+18h] [rbp-190h] BYREF
  char v30[8]; // [rsp+20h] [rbp-188h] BYREF
  __int64 v31; // [rsp+28h] [rbp-180h] BYREF
  char *v32; // [rsp+30h] [rbp-178h] BYREF
  char *v33; // [rsp+38h] [rbp-170h]
  __int64 v34; // [rsp+40h] [rbp-168h]
  int v35; // [rsp+48h] [rbp-160h]
  __int64 *v36; // [rsp+50h] [rbp-158h]
  char v37[256]; // [rsp+60h] [rbp-148h] BYREF
  char v38; // [rsp+160h] [rbp-48h] BYREF
  unsigned __int64 v39; // [rsp+168h] [rbp-40h]

  v39 = __readfsqword(0x28u);
  v34 = 1LL;
  if ( !a4 )
    a4 = (__int64 *)&unk_C1710;
  v35 = 1;
  v36 = a4;
  v15 = __readfsqword(0xFFFFFFA0);
  v16 = *(_QWORD *)v15;
  v17 = *(void ***)(*(_QWORD *)v15 + 40LL);
  if ( !v17 )
  {
    v17 = &off_BAD80;
    if ( (void **)v16 != &off_BAE20 )
    {
      sub_49110(v16, a7, a8, a9, a10, a11, a12, a13, a14, (__int64)a2, (__int64)&off_BAE20, (__int64)a4, a5, a6);
      v17 = *(void ***)(v16 + 40);
    }
  }
  v18 = v17[2];
  v19 = (__int64 (__fastcall *)(_QWORD *, char **, __int64 *, __int64, _QWORD, char *, _QWORD))v18[5];
  if ( *v18 )
    v19 = (__int64 (__fastcall *)(_QWORD *, char **, __int64 *, __int64, _QWORD, char *, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v19, 17));
  if ( a1 )
  {
    v27 = *a2;
    v20 = sub_91A0(*a2, a3);
    v33 = (char *)(a1 + a3);
    v32 = (char *)a1;
    v21 = v27 + 4 * v20 + 4;
    sub_4F2B0((__int64)v19);
    v22 = v19(v18, &v32, a2, v21, 0LL, v30, 0LL);
    v23 = (__int64)&v32[-a1];
    if ( (v22 & 0xFFFFFFFB) == 0 && !*(v32 - 1) )
    {
      if ( v32 == (char *)a1 )
        sub_CF00("data.__outbuf != (unsigned char *) dst", "wcsrtombs.c", 122LL, "__wcsrtombs");
      if ( *(_DWORD *)v36 )
        sub_CF00("__mbsinit (data.__statep)", "wcsrtombs.c", 123LL, "__wcsrtombs");
      *a2 = 0LL;
LABEL_22:
      --v23;
      goto LABEL_8;
    }
  }
  else
  {
    v28 = *a2;
    v23 = 0LL;
    v26 = v28 + 4 * sub_90D0(*a2) + 4;
    v29 = v28;
    v31 = *v36;
    v36 = &v31;
    v33 = &v38;
    do
    {
      v32 = v37;
      sub_4F2B0((__int64)v19);
      v22 = ((__int64 (__fastcall *)(_QWORD *, char **, __int64 *, __int64, _QWORD, char *, _QWORD, __int64))v19)(
              v18,
              &v32,
              &v29,
              v26,
              0LL,
              v30,
              0LL,
              1LL);
      v23 += v32 - v37;
    }
    while ( v22 == 5 );
    if ( (v22 & 0xFFFFFFFB) == 0 )
    {
      if ( *(v32 - 1) )
        sub_CF00("data.__outbuf[-1] == '\\0'", "wcsrtombs.c", 94LL, "__wcsrtombs");
      goto LABEL_22;
    }
  }
LABEL_8:
  v24 = v22 - 4;
  if ( v22 )
  {
    if ( v24 > 3 )
      sub_CF00(
        "status == __GCONV_OK || status == __GCONV_EMPTY_INPUT || status == __GCONV_ILLEGAL_INPUT || status == __GCONV_IN"
        "COMPLETE_INPUT || status == __GCONV_FULL_OUTPUT",
        "wcsrtombs.c",
        131LL,
        "__wcsrtombs");
    if ( v24 > 1 )
    {
      v23 = -1LL;
      __writefsdword(0xFFFFFFC0, 0x54u);
    }
  }
  return v23;
}
// 6D3AA: conditional instruction was optimized away because of 'eax.4!=0'
// 90D0: using guessed type __int64 __fastcall sub_90D0(_QWORD);
// 91A0: using guessed type __int64 __fastcall sub_91A0(_QWORD, _QWORD);
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// BAD80: using guessed type void *off_BAD80;
// BAE20: using guessed type void *off_BAE20;

//----- (000000000006D580) ----------------------------------------------------
void *sub_6D580()
{
  void *result; // rax

  if ( (dword_C1434 & 0x800) != 0
    || (BYTE4(xmmword_C1384) & 0x20) == 0
    || (result = sub_6DCB0, (dword_C1434 & 0x100) == 0) )
  {
    result = sub_6D810;
    if ( (BYTE10(xmmword_C1364) & 8) != 0 )
      result = sub_6D5F0;
  }
  return result;
}
// C1364: using guessed type __int128 xmmword_C1364;
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (000000000006D5D0) ----------------------------------------------------
_DWORD *__fastcall sub_6D5D0(_DWORD *a1, int a2)
{
  int v2; // edx
  _DWORD *result; // rax

  v2 = *a1;
  for ( result = a1; v2 != a2; ++result )
  {
    if ( !v2 )
      break;
    v2 = result[1];
  }
  return result;
}

//----- (000000000006D5F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_6D5F0(__int64 a1, __int64 a2)
{
  __int64 v3; // rsi
  unsigned __int64 v4; // r10
  __int64 v5; // r11
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  __m128i v8; // xmm3
  signed __int64 v9; // rdx
  char v10; // cl
  unsigned __int64 v11; // rsi
  __m128i *v12; // rax
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // rdx

  if ( !a2 )
    return 0LL;
  v3 = a1 + 4 * a2;
  v4 = v3 & 0xFFFFFFFFFFFFFFC0LL;
  v5 = v3;
  if ( ((unsigned __int16)a1 & 0xFFFu) > 0xFCFuLL )
  {
    v9 = (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)((char *)qword_20
                                                                                    + (a1 & 0xFFFFFFFFFFFFFFC0LL)))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)((char *)&dword_30 + (a1 & 0xFFFFFFFFFFFFFFC0LL)))) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)((char *)&word_10 + (a1 & 0xFFFFFFFFFFFFFFC0LL)))) << 16);
    v10 = a1 & 0xC0 ^ a1;
    v11 = v3 - (a1 & 0xFFFFFFFFFFFFFFC0LL);
    v12 = (__m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL);
    if ( (v11 & 0xFFFFFFFFFFFFFFC0LL) != 0 )
    {
      v13 = v9 >> v10;
      if ( v13 )
        goto LABEL_11;
      goto LABEL_12;
    }
  }
  else
  {
    v6 = _mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)((char *)&word_10 + (a1 & 0xFFFFFFFFFFFFFFF0LL)));
    v7 = _mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)((char *)qword_20 + (a1 & 0xFFFFFFFFFFFFFFF0LL)));
    v8 = _mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)((char *)&dword_30 + (a1 & 0xFFFFFFFFFFFFFFF0LL)));
    v9 = (((unsigned int)_mm_movemask_epi8(v7) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v8) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)(a1 & 0xFFFFFFFFFFFFFFF0LL))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v6) << 16);
    v10 = a1 & 0xF0 ^ a1;
    v11 = v3 - (a1 & 0xFFFFFFFFFFFFFFF0LL);
    v12 = (__m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL);
    if ( (v11 & 0xFFFFFFFFFFFFFFC0LL) != 0 )
    {
      v13 = v9 >> v10;
      if ( !v13 )
        goto LABEL_13;
      goto LABEL_11;
    }
  }
  v13 = (v9 | (1LL << v11)) >> v10;
  if ( v13 )
  {
LABEL_11:
    _BitScanForward64(&v14, v13);
    return v14 >> 2;
  }
LABEL_12:
  v6 = 0LL;
  v7 = 0LL;
  v8 = 0LL;
LABEL_13:
  while ( 1 )
  {
    v12 += 4;
    if ( (__m128i *)v4 == v12 )
      break;
    v13 = (unsigned int)_mm_movemask_epi8(
                          _mm_cmpeq_epi32(
                            _mm_min_epu32(_mm_min_epu32(_mm_min_epu32(_mm_load_si128(v12), v12[1]), v12[2]), v12[3]),
                            v8));
    if ( (_DWORD)v13 )
    {
      _BitScanForward64(
        &v15,
        (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32(v7, v12[2])) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32(v8, v12[3])) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *v12)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32(v6, v12[1])) << 16));
      return ((unsigned __int64)v12->m128i_u64 + v15 - a1) >> 2;
    }
  }
  if ( (__m128i *)v5 != v12 )
    v13 = (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32(v7, v12[2])) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32(v8, v12[3])) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *v12)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32(v6, v12[1])) << 16);
  _BitScanForward64(&v13, v13 | (1LL << v5));
  return ((unsigned __int64)v12->m128i_u64 + v13 - a1) >> 2;
}
// 10: using guessed type __int16 word_10;
// 20: using guessed type __int64 qword_20[];
// 30: using guessed type int dword_30;

//----- (000000000006D810) ----------------------------------------------------
__int64 __fastcall sub_6D810(__int64 a1, __int64 a2)
{
  __int64 v2; // rdx
  __int64 result; // rax

  v2 = sub_9170(a1, 0LL, a2);
  result = (v2 - a1) >> 2;
  if ( !v2 )
    result = a2;
  return result;
}
// 9170: using guessed type __int64 __fastcall sub_9170(_QWORD, _QWORD, _QWORD);

//----- (000000000006D850) ----------------------------------------------------
unsigned __int64 __fastcall sub_6D850(_DWORD *a1)
{
  char *v1; // rcx
  __m128i *v2; // rax
  __m128i v3; // xmm0
  int v4; // edx
  __m128i *v5; // rax
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  __m128i v8; // xmm3
  __m128i v9; // xmm0
  __m128i v10; // xmm1
  __m128i v11; // xmm2
  __m128i v12; // xmm3
  __m128i v13; // xmm3
  __m128i v14; // xmm1
  __m128i v15; // xmm6
  int v16; // edx
  __m128i v17; // xmm3
  __m128i v18; // xmm3
  __m128i v19; // xmm3
  unsigned __int64 result; // rax

  if ( !*a1 )
    return 0LL;
  if ( !a1[1] )
    return 1LL;
  if ( !a1[2] )
    return 2LL;
  if ( !a1[3] )
    return 3LL;
  if ( !a1[4] )
    return 4LL;
  if ( !a1[5] )
    return 5LL;
  if ( !a1[6] )
    return 6LL;
  if ( !a1[7] )
    return 7LL;
  v1 = (char *)(a1 + 4);
  v2 = (__m128i *)((unsigned __int64)(a1 + 8) & 0xFFFFFFFFFFFFFFF0LL);
  v3 = _mm_cmpeq_epi32((__m128i)0LL, *v2);
  v4 = _mm_movemask_epi8(v3);
  v5 = v2 + 1;
  if ( !v4 )
  {
    v6 = _mm_cmpeq_epi32((__m128i)0LL, *v5);
    v4 = _mm_movemask_epi8(v6);
    ++v5;
    if ( !v4 )
    {
      v7 = _mm_cmpeq_epi32((__m128i)0LL, *v5);
      v4 = _mm_movemask_epi8(v7);
      ++v5;
      if ( !v4 )
      {
        v8 = _mm_cmpeq_epi32((__m128i)0LL, *v5);
        v4 = _mm_movemask_epi8(v8);
        ++v5;
        if ( !v4 )
        {
          v9 = _mm_cmpeq_epi32(v3, *v5);
          v4 = _mm_movemask_epi8(v9);
          ++v5;
          if ( !v4 )
          {
            v10 = _mm_cmpeq_epi32(v6, *v5);
            v4 = _mm_movemask_epi8(v10);
            ++v5;
            if ( !v4 )
            {
              v11 = _mm_cmpeq_epi32(v7, *v5);
              v4 = _mm_movemask_epi8(v11);
              ++v5;
              if ( !v4 )
              {
                v12 = _mm_cmpeq_epi32(v8, *v5);
                v4 = _mm_movemask_epi8(v12);
                ++v5;
                if ( !v4 )
                {
                  v4 = _mm_movemask_epi8(_mm_cmpeq_epi32(v9, *v5++));
                  if ( !v4 )
                  {
                    v4 = _mm_movemask_epi8(_mm_cmpeq_epi32(v10, *v5++));
                    if ( !v4 )
                    {
                      v4 = _mm_movemask_epi8(_mm_cmpeq_epi32(v11, *v5++));
                      if ( !v4 )
                      {
                        v13 = _mm_cmpeq_epi32(v12, *v5);
                        v4 = _mm_movemask_epi8(v13);
                        ++v5;
                        if ( !v4 )
                        {
                          v5 = (__m128i *)((unsigned __int64)v5 & 0xFFFFFFFFFFFFFFC0LL);
                          do
                          {
                            do
                            {
                              v14 = v5[1];
                              v15 = v5[3];
                              v16 = _mm_movemask_epi8(
                                      _mm_cmpeq_epi32(
                                        _mm_min_epu8(_mm_min_epu8(v5[2], v15), _mm_min_epu8(*v5, v14)),
                                        v13));
                              v5 += 4;
                            }
                            while ( !v16 );
                            v17 = _mm_cmpeq_epi32(v13, v5[-4]);
                            v4 = _mm_movemask_epi8(v17);
                            v1 += 48;
                            if ( v4 )
                              break;
                            v18 = _mm_cmpeq_epi32(v17, v14);
                            v4 = _mm_movemask_epi8(v18);
                            v1 -= 16;
                            if ( v4 )
                              break;
                            v19 = _mm_cmpeq_epi32(v18, v5[-2]);
                            v4 = _mm_movemask_epi8(v19);
                            v1 -= 16;
                            if ( v4 )
                              break;
                            v13 = _mm_cmpeq_epi32(v19, v15);
                            v4 = _mm_movemask_epi8(v13);
                            v1 -= 16;
                          }
                          while ( !v4 );
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  result = (unsigned __int64)((char *)v5 - v1) >> 2;
  if ( (_BYTE)v4 )
  {
    if ( (v4 & 0xF) == 0 )
      ++result;
  }
  else if ( (v4 & 0xF00) != 0 )
  {
    result += 2LL;
  }
  else
  {
    result += 3LL;
  }
  return result;
}

//----- (000000000006DAF0) ----------------------------------------------------
unsigned __int64 __fastcall sub_6DAF0(unsigned __int64 _RDI, __m128 _XMM0)
{
  unsigned __int64 v4; // rdx
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rdi
  unsigned __int64 result; // rax

  v4 = _RDI;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  if ( (_RDI & 0x3F) > 0x20 )
  {
    v7 = _RDI & 0x1F;
    v8 = _RDI & 0xFFFFFFFFFFFFFFE0LL;
    __asm
    {
      vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    _RAX = (unsigned int)(_EAX >> v7);
    if ( (_DWORD)_RAX )
    {
      __asm { tzcnt   eax, eax }
      result = (v7 + v8 + _RAX - v4) >> 2;
      __asm { vzeroupper }
      return result;
    }
    _RDI = v8 + 32;
  }
  else
  {
    __asm
    {
      vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
      goto LABEL_14;
    _RDI = (_RDI + 32) & 0xFFFFFFFFFFFFFFE0LL;
  }
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_14;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+20h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_15;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+40h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_16;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+60h]
    vpmovmskb eax, ymm1
  }
  if ( !(_DWORD)_RAX )
  {
    for ( _RDI = (_RDI + 128) & 0xFFFFFFFFFFFFFF80LL; ; _RDI += 128LL )
    {
      __asm
      {
        vmovdqa ymm1, ymmword ptr [rdi]
        vmovdqa ymm2, ymmword ptr [rdi+20h]
        vmovdqa ymm3, ymmword ptr [rdi+40h]
        vmovdqa ymm4, ymmword ptr [rdi+60h]
        vpminud ymm5, ymm2, ymm1
        vpminud ymm6, ymm4, ymm3
        vpminud ymm5, ymm6, ymm5
        vpcmpeqd ymm5, ymm0, ymm5
        vpmovmskb eax, ymm5
      }
      if ( _EAX )
        break;
    }
    __asm
    {
      vpcmpeqd ymm1, ymm0, ymm1
      vpmovmskb eax, ymm1
    }
    if ( !(_DWORD)_RAX )
    {
      __asm
      {
        vpcmpeqd ymm2, ymm0, ymm2
        vpmovmskb eax, ymm2
      }
      if ( !(_DWORD)_RAX )
      {
        __asm
        {
          vpcmpeqd ymm3, ymm0, ymm3
          vpmovmskb eax, ymm3
        }
        if ( !(_DWORD)_RAX )
        {
          __asm
          {
            vpcmpeqd ymm4, ymm0, ymm4
            vpmovmskb eax, ymm4
          }
          goto LABEL_21;
        }
LABEL_16:
        __asm { tzcnt   eax, eax }
        result = (_RDI + _RAX + 64 - v4) >> 2;
        __asm { vzeroupper }
        return result;
      }
LABEL_15:
      __asm { tzcnt   eax, eax }
      result = (_RDI + _RAX + 32 - v4) >> 2;
      __asm { vzeroupper }
      return result;
    }
LABEL_14:
    __asm { tzcnt   eax, eax }
    result = (_RDI + _RAX - v4) >> 2;
    __asm { vzeroupper }
    return result;
  }
LABEL_21:
  __asm { tzcnt   eax, eax }
  result = (_RDI + _RAX + 96 - v4) >> 2;
  __asm { vzeroupper }
  return result;
}
// 6DC04: variable '_RAX' is possibly undefined

//----- (000000000006DCB0) ----------------------------------------------------
unsigned __int64 __fastcall sub_6DCB0(unsigned __int64 _RDI, __int64 a2, __m128 _XMM0)
{
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // rdx
  unsigned int v9; // ecx
  char v11; // cc
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // rsi
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // rdi
  unsigned __int64 result; // rax
  unsigned __int64 v20; // rcx
  unsigned __int64 v21; // rsi
  unsigned __int64 v26; // rcx
  unsigned __int64 v36; // rsi
  unsigned __int64 v40; // rsi
  unsigned __int64 v43; // rsi

  if ( !a2 )
    return 0LL;
  v5 = 4 * a2;
  v6 = v5;
  v7 = _RDI;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v9 = _RDI & 0x3F;
  if ( v9 > 0x20 )
  {
    v15 = _RDI & 0x1F;
    v16 = _RDI & 0xFFFFFFFFFFFFFFE0LL;
    __asm
    {
      vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    _RAX = (unsigned int)(_EAX >> v15);
    if ( (_DWORD)_RAX )
    {
      __asm { tzcnt   eax, eax }
      if ( v5 > _RAX )
      {
        result = (v15 + v16 + _RAX - v7) >> 2;
        __asm { vzeroupper }
        return result;
      }
      goto LABEL_39;
    }
    v20 = 32 - v15;
    v11 = v5 <= v20;
    v21 = v5 - v20;
    if ( v11 )
    {
LABEL_39:
      result = v6 >> 2;
      __asm { vzeroupper }
      return result;
    }
    _RDI = v16 + 32;
    v11 = v21 <= 0x80;
    v14 = v21 - 128;
    if ( v11 )
      goto LABEL_20;
  }
  else
  {
    __asm
    {
      vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
      goto LABEL_31;
    v11 = v5 <= 0x20;
    v12 = v5 - 32;
    if ( v11 )
      goto LABEL_39;
    _RDI = (_RDI + 32) & 0xFFFFFFFFFFFFFFE0LL;
    v13 = (v9 & 0x1F) + v12;
    v11 = v13 <= 0x80;
    v14 = v13 - 128;
    if ( v11 )
    {
LABEL_20:
      v11 = ((int)v14 + 64 < 0) ^ __OFADD__(64, (_DWORD)v14) | ((_DWORD)v14 == -64);
      v36 = (unsigned int)(v14 + 64);
      if ( !v11 )
      {
        __asm
        {
          vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
          vpmovmskb eax, ymm1
        }
        if ( (_DWORD)_RAX )
          goto LABEL_41;
        __asm
        {
          vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+20h]
          vpmovmskb eax, ymm1
        }
        if ( (_DWORD)_RAX )
          goto LABEL_42;
        __asm
        {
          vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+40h]
          vpmovmskb eax, ymm1
        }
        if ( (_DWORD)_RAX )
        {
          __asm { tzcnt   eax, eax }
          if ( v36 > _RAX )
          {
            result = (_RDI + _RAX + 64 - v7) >> 2;
            __asm { vzeroupper }
            return result;
          }
        }
        else
        {
          v11 = (int)v36 <= 32;
          v40 = (unsigned int)(v36 - 32);
          if ( !v11 )
          {
            __asm
            {
              vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+60h]
              vpmovmskb eax, ymm1
            }
            if ( !(_DWORD)_RAX )
            {
              result = v6 >> 2;
              __asm { vzeroupper }
              return result;
            }
            __asm { tzcnt   eax, eax }
            if ( v40 > _RAX )
            {
              result = (_RDI + _RAX + 96 - v7) >> 2;
              __asm { vzeroupper }
              return result;
            }
          }
        }
        goto LABEL_39;
      }
      v5 = (unsigned int)(v36 + 64);
      __asm
      {
        vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
        vpmovmskb eax, ymm1
      }
      if ( !(_DWORD)_RAX )
      {
        v11 = (int)v5 <= 32;
        v43 = (unsigned int)(v5 - 32);
        if ( !v11 )
        {
          __asm
          {
            vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+20h]
            vpmovmskb eax, ymm1
          }
          if ( !(_DWORD)_RAX )
          {
            result = v6 >> 2;
            __asm { vzeroupper }
            return result;
          }
          __asm { tzcnt   eax, eax }
          if ( v43 > _RAX )
          {
            result = (_RDI + _RAX + 32 - v7) >> 2;
            __asm { vzeroupper }
            return result;
          }
        }
        goto LABEL_39;
      }
LABEL_31:
      __asm { tzcnt   eax, eax }
      if ( v5 > _RAX )
      {
        result = (_RDI + _RAX - v7) >> 2;
        __asm { vzeroupper }
        return result;
      }
      goto LABEL_39;
    }
  }
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_41;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+20h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_42;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+40h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_43;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+60h]
    vpmovmskb eax, ymm1
  }
  if ( !(_DWORD)_RAX )
  {
    _RDI += 128LL;
    v11 = v14 <= 0x80;
    v14 -= 128LL;
    if ( !v11 )
    {
      v26 = _RDI & 0x7F;
      _RDI &= 0xFFFFFFFFFFFFFF80LL;
      v14 += v26;
      while ( 1 )
      {
        __asm
        {
          vmovdqa ymm1, ymmword ptr [rdi]
          vmovdqa ymm2, ymmword ptr [rdi+20h]
          vmovdqa ymm3, ymmword ptr [rdi+40h]
          vmovdqa ymm4, ymmword ptr [rdi+60h]
          vpminud ymm5, ymm2, ymm1
          vpminud ymm6, ymm4, ymm3
          vpminud ymm5, ymm6, ymm5
          vpcmpeqd ymm5, ymm0, ymm5
          vpmovmskb eax, ymm5
        }
        if ( _EAX )
          break;
        _RDI += 128LL;
        v11 = v14 <= 0x80;
        v14 -= 128LL;
        if ( v11 )
          goto LABEL_20;
      }
      __asm
      {
        vpcmpeqd ymm1, ymm0, ymm1
        vpmovmskb eax, ymm1
      }
      if ( !(_DWORD)_RAX )
      {
        __asm
        {
          vpcmpeqd ymm2, ymm0, ymm2
          vpmovmskb eax, ymm2
        }
        if ( !(_DWORD)_RAX )
        {
          __asm
          {
            vpcmpeqd ymm3, ymm0, ymm3
            vpmovmskb eax, ymm3
          }
          if ( !(_DWORD)_RAX )
          {
            __asm
            {
              vpcmpeqd ymm4, ymm0, ymm4
              vpmovmskb eax, ymm4
            }
            goto LABEL_48;
          }
LABEL_43:
          __asm { tzcnt   eax, eax }
          result = (_RDI + _RAX + 64 - v7) >> 2;
          __asm { vzeroupper }
          return result;
        }
LABEL_42:
        __asm { tzcnt   eax, eax }
        result = (_RDI + _RAX + 32 - v7) >> 2;
        __asm { vzeroupper }
        return result;
      }
LABEL_41:
      __asm { tzcnt   eax, eax }
      result = (_RDI + _RAX - v7) >> 2;
      __asm { vzeroupper }
      return result;
    }
    goto LABEL_20;
  }
LABEL_48:
  __asm { tzcnt   eax, eax }
  result = (_RDI + _RAX + 96 - v7) >> 2;
  __asm { vzeroupper }
  return result;
}
// 6DEB7: variable '_RAX' is possibly undefined

//----- (000000000006E000) ----------------------------------------------------
unsigned __int64 __fastcall sub_6E000(const clockid_t which_clock, struct timespec *tp)
{
  unsigned __int64 result; // rax
  int v3; // edx

  if ( !&dword_0 )
    goto LABEL_6;
  result = dword_0();
  v3 = result;
  if ( (unsigned __int64)(int)result <= 0xFFFFFFFFFFFFF000LL )
    return result;
  if ( (int)result == -38LL )
  {
LABEL_6:
    result = sys_clock_gettime(which_clock, tp);
    v3 = result;
    if ( result <= 0xFFFFFFFFFFFFF000LL )
      return result;
  }
  __writefsdword(0xFFFFFFC0, -v3);
  return 0xFFFFFFFFLL;
}
// 0: using guessed type __int64 (*dword_0)(void);

//----- (000000000006E070) ----------------------------------------------------
__int64 __fastcall sub_6E070(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  char v14; // r13
  u32 *v17; // rdi
  unsigned __int64 v18; // rbx
  __int64 v19; // rdx
  __int64 v20; // rcx
  u32 *v21; // r8
  u32 v22; // er9
  __int64 v23; // r12
  double v24; // xmm4_8
  double v25; // xmm5_8
  unsigned int v27; // er13
  char v28; // [rsp+0h] [rbp-28h]

  v14 = a2;
  if ( !(_BYTE)a2 )
  {
    a2 = 2LL;
    if ( (sub_4B7D0(a1, 2u, 1uLL, a4, a5, a6, v28) & 0x80000000) != 0LL )
      return 0LL;
  }
  v17 = (_DWORD *)(&stru_8020 + 16);
  v18 = 0x8000LL;
  if ( a4 )
  {
    v18 = 0x8000LL;
    if ( *(_QWORD *)(a4 + 56) >= 0x8000uLL )
      v18 = *(_QWORD *)(a4 + 56);
    if ( v18 > 0x100000 )
      v18 = 0x100000LL;
    v17 = (u32 *)(v18 + 48);
  }
  v23 = sub_21500(v17, a2, a3, a4, (u32 *)a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
  if ( !v23 )
  {
    v18 = 0x2000LL;
    v23 = sub_21500((u32 *)&stru_2020.r_addend, a2, v19, v20, v21, v22, a7, a8, a9, a10, v24, v25, a13, a14);
    if ( !v23 )
    {
      if ( v14 )
      {
        v27 = __readfsdword(0xFFFFFFC0);
        sub_4B7A0(a1);
        __writefsdword(0xFFFFFFC0, v27);
        return v23;
      }
      return 0LL;
    }
  }
  *(_DWORD *)v23 = a1;
  *(_DWORD *)(v23 + 4) = 0;
  *(_QWORD *)(v23 + 8) = v18;
  *(_QWORD *)(v23 + 16) = 0LL;
  *(_QWORD *)(v23 + 24) = 0LL;
  *(_QWORD *)(v23 + 32) = 0LL;
  *(_DWORD *)(v23 + 40) = 0;
  return v23;
}
// 6E0C6: variable 'a3' is possibly undefined
// 6E0C6: variable 'a4' is possibly undefined
// 6E0C6: variable 'a5' is possibly undefined
// 6E0C6: variable 'a6' is possibly undefined
// 6E0C6: variable 'a11' is possibly undefined
// 6E0C6: variable 'a12' is possibly undefined
// 6E12C: variable 'v28' is possibly undefined
// 6E148: variable 'v19' is possibly undefined
// 6E148: variable 'v20' is possibly undefined
// 6E148: variable 'v21' is possibly undefined
// 6E148: variable 'v22' is possibly undefined
// 6E148: variable 'v24' is possibly undefined
// 6E148: variable 'v25' is possibly undefined
// 2020: using guessed type Elf64_Rela;
// 8020: using guessed type Elf64_Rela;

//----- (000000000006E270) ----------------------------------------------------
__int64 __fastcall sub_6E270(const char *a1, __int64 a2, int a3)
{
  __int64 v3; // r8
  __int64 v4; // r9
  signed int v5; // edi
  struct stat v7; // [rsp-18h] [rbp-B8h] BYREF
  unsigned __int64 v8; // [rsp+80h] [rbp-20h]

  if ( !*a1 )
  {
    __writefsdword(0xFFFFFFC0, 2u);
    return 0LL;
  }
  v5 = sub_4B910(a1, 591872, a3);
  v8 = __readfsqword(0x28u);
  if ( v5 < 0 )
    return 0LL;
  if ( (sub_4AA80(1u, v5, &v7) & 0x80000000) == 0LL )
  {
    if ( (v7.st_mode & 0xF000) == 0x4000 )
      return sub_6E070(v5, 1, 0LL, (__int64)&v7, v3, v4);
    __writefsdword(0xFFFFFFC0, 0x14u);
  }
  sub_4B7A0(v5);
  return 0LL;
}
// 6E1D5: variable 'v3' is possibly undefined
// 6E1D5: variable 'v4' is possibly undefined

//----- (000000000006E2B0) ----------------------------------------------------
unsigned __int64 __fastcall sub_6E2B0(unsigned int *a1)
{
  unsigned int v1; // ebp
  unsigned __int64 result; // rax

  if ( a1 )
  {
    v1 = *a1;
    sub_21B70(a1);
    result = sub_4B7A0(v1);
  }
  else
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (000000000006E2E0) ----------------------------------------------------
int __fastcall sub_6E2E0(__int64 _RDI, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  volatile signed __int32 *v6; // rbp
  u32 *v8; // r8
  u32 v9; // er9
  signed __int64 v10; // rax

  v6 = (volatile signed __int32 *)(_RDI + 4);
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedCompareExchange(v6, 1, 0) )
      sub_1C7D0((volatile __int32 *)(_RDI + 4), a2, 1LL, a4, a5, a6);
  }
  else
  {
    _EDX = 1;
    __asm { cmpxchg [rdi+4], edx }
  }
  sub_4AD50(*(_DWORD *)_RDI, 0LL, 0);
  *(_QWORD *)(_RDI + 32) = 0LL;
  *(_QWORD *)(_RDI + 24) = 0LL;
  *(_QWORD *)(_RDI + 16) = 0LL;
  *(_DWORD *)(_RDI + 40) = 0;
  LODWORD(v10) = __readfsdword(0x18u);
  if ( (_DWORD)v10 )
  {
    LODWORD(v10) = _InterlockedExchange((volatile __int32 *)(_RDI + 4), 0);
    if ( (int)v10 > 1 )
      v10 = sys_futex((u32 *)v6, 129, 1u, 0LL, v8, v9);
  }
  else
  {
    --*(_DWORD *)(_RDI + 4);
  }
  return v10;
}
// 6E38F: variable 'v8' is possibly undefined
// 6E38F: variable 'v9' is possibly undefined

//----- (000000000006E3A0) ----------------------------------------------------
__int64 __fastcall sub_6E3A0(__int64 _RDI, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  unsigned int v6; // er14
  volatile signed __int32 *v7; // r13
  unsigned __int64 v9; // rax
  __int64 v10; // r8
  __int64 v11; // rdx
  bool v12; // zf
  __int64 v13; // r8
  signed __int64 v14; // rax
  signed __int64 v16; // rax

  v6 = __readfsdword(0xFFFFFFC0);
  v7 = (volatile signed __int32 *)(_RDI + 4);
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedCompareExchange(v7, 1, 0) )
      sub_1C7D0((volatile __int32 *)(_RDI + 4), a2, 1LL, a4, a5, a6);
  }
  else
  {
    _EDX = 1;
    __asm { cmpxchg [rdi+4], edx }
  }
  v9 = *(_QWORD *)(_RDI + 24);
  while ( 1 )
  {
    v13 = v9 + 48;
    if ( *(_QWORD *)(_RDI + 16) <= v9 )
      break;
LABEL_4:
    v10 = _RDI + v13;
    v9 += *(unsigned __int16 *)(v10 + 16);
    v11 = *(_QWORD *)(v10 + 8);
    v12 = *(_QWORD *)v10 == 0LL;
    *(_QWORD *)(_RDI + 24) = v9;
    *(_QWORD *)(_RDI + 32) = v11;
    if ( !v12 )
      goto LABEL_10;
  }
  v14 = sub_80680(*(_DWORD *)_RDI, (struct linux_dirent64 *)(_RDI + 48), *(_QWORD *)(_RDI + 8));
  if ( v14 > 0 )
  {
    *(_QWORD *)(_RDI + 16) = v14;
    v13 = 48LL;
    v9 = 0LL;
    goto LABEL_4;
  }
  if ( !v14 || (v10 = 0LL, __readfsdword(0xFFFFFFC0) == 2) )
  {
    __writefsdword(0xFFFFFFC0, v6);
    v10 = 0LL;
  }
LABEL_10:
  if ( __readfsdword(0x18u) )
  {
    if ( _InterlockedExchange((volatile __int32 *)(_RDI + 4), 0) > 1 )
      v16 = sys_futex((u32 *)v7, 129, 1u, 0LL, (u32 *)v10, a6);
  }
  else
  {
    --*(_DWORD *)(_RDI + 4);
  }
  return v10;
}
// 6E451: variable 'v10' is possibly undefined
// 6E488: variable 'a6' is possibly undefined

//----- (000000000006E4B0) ----------------------------------------------------
__int64 __fastcall sub_6E4B0(unsigned int a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  unsigned __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  unsigned int v13; // eax
  __int64 v14; // r8
  __int64 v15; // r9
  double v16; // xmm4_8
  double v17; // xmm5_8
  struct stat v19; // [rsp+0h] [rbp-B8h] BYREF
  unsigned __int64 v20; // [rsp+98h] [rbp-20h]

  v20 = __readfsqword(0x28u);
  if ( (sub_4AA80(1u, a1, &v19) & 0x80000000) != 0LL )
    return 0LL;
  if ( (v19.st_mode & 0xF000) != 0x4000 )
  {
    __writefsdword(0xFFFFFFC0, 0x14u);
    return 0LL;
  }
  v13 = sub_4B7D0(a1, 3u, v9, v10, v11, v12, v19.st_dev);
  if ( v13 == -1 )
    return 0LL;
  if ( (v13 & 3) != 1 )
    return sub_6E070(a1, 0LL, v13, (__int64)&v19, v14, v15, a2, a3, a4, a5, v16, v17, a8, a9);
  __writefsdword(0xFFFFFFC0, 0x16u);
  return 0LL;
}
// 6E502: variable 'v9' is possibly undefined
// 6E502: variable 'v10' is possibly undefined
// 6E502: variable 'v11' is possibly undefined
// 6E502: variable 'v12' is possibly undefined
// 6E51D: variable 'v14' is possibly undefined
// 6E51D: variable 'v15' is possibly undefined
// 6E51D: variable 'v16' is possibly undefined
// 6E51D: variable 'v17' is possibly undefined

//----- (000000000006E570) ----------------------------------------------------
unsigned __int64 __fastcall sub_6E570(struct old_utsname *a1)
{
  unsigned __int64 result; // rax

  result = sys_uname(a1);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000006E5A0) ----------------------------------------------------
unsigned __int64 __fastcall sub_6E5A0(const char *a1, const char *const *a2, const char *const *a3)
{
  unsigned __int64 result; // rax

  result = sys_execve(a1, a2, a3);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000006E5D0) ----------------------------------------------------
unsigned __int64 __fastcall sub_6E5D0(const char *a1, _QWORD *a2, const char *const *a3)
{
  __int64 v4; // rax
  __int64 v5; // rdx
  void *v6; // rsp
  unsigned __int64 v7; // rdx
  const char *v9[2]; // [rsp+0h] [rbp-40h] BYREF
  __int64 v10; // [rsp+10h] [rbp-30h] BYREF
  unsigned __int64 v11; // [rsp+18h] [rbp-28h]

  v11 = __readfsqword(0x28u);
  v4 = 0LL;
  if ( *a2 )
  {
    while ( 1 )
    {
      v5 = v4++;
      if ( !a2[v4] )
        break;
      if ( v4 == 2147483646 )
      {
        __writefsdword(0xFFFFFFC0, 7u);
        return v11 - __readfsqword(0x28u);
      }
    }
    v6 = alloca(8 * v5 + 24);
    v7 = ((unsigned __int64)v9 + 7) >> 3;
    *(_QWORD *)(8 * v7) = "/bin/sh";
    *(_QWORD *)&byte_8[8 * v7] = a1;
    if ( v4 == 1 )
      goto LABEL_6;
    memcpy(&v10, a2 + 1, 8 * v4);
  }
  else
  {
    v9[1] = a1;
    v9[0] = "/bin/sh";
LABEL_6:
    v10 = 0LL;
  }
  sub_6E5A0("/bin/sh", v9, a3);
  return v11 - __readfsqword(0x28u);
}

//----- (000000000006E6E0) ----------------------------------------------------
__int64 __fastcall sub_6E6E0(const char *a1, const char **a2, const char *const *a3, char a4)
{
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  const char *v11; // r15
  unsigned __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  unsigned __int64 v17; // r14
  __int64 v18; // rax
  __int64 v19; // r14
  void *v20; // rsp
  const char *v21; // rax
  const char *v22; // r9
  _BYTE *v23; // rax
  unsigned __int64 v24; // r9
  unsigned int v25; // ecx
  _QWORD *v26; // rax
  int v27; // ecx
  _BYTE *v28; // r9
  int v29; // eax
  int v30; // edx
  _BYTE *v31; // [rsp+0h] [rbp-60h] BYREF
  unsigned __int64 v32; // [rsp+8h] [rbp-58h]
  unsigned __int64 v33; // [rsp+10h] [rbp-50h]
  char v34; // [rsp+1Eh] [rbp-42h]
  char v35; // [rsp+1Fh] [rbp-41h]
  unsigned __int64 v36; // [rsp+28h] [rbp-38h]

  v35 = a4;
  v36 = __readfsqword(0x28u);
  if ( !*a1 )
  {
    __writefsdword(0xFFFFFFC0, 2u);
    return 0xFFFFFFFFLL;
  }
  if ( sub_9210(a1, 47LL) )
  {
    sub_6E5A0(a1, a2, a3);
    if ( __readfsdword(0xFFFFFFC0) == 8 && a4 )
      sub_6E5D0(a1, a2, a3);
    return 0xFFFFFFFFLL;
  }
  v11 = (const char *)sub_12350("PATH");
  if ( !v11 )
    v11 = "/bin:/usr/bin";
  v12 = sub_9040(a1, 255LL, v7, v8, v9, v10);
  v17 = v12;
  if ( v12 > 0xFF
    || (v32 = v12 + 1,
        v18 = sub_9040(v11, 4095LL, v13, v14, v15, v16),
        v19 = v17 + v18 + 3,
        v33 = v18 + 1,
        !sub_1C780(v19)) )
  {
    __writefsdword(0xFFFFFFC0, 0x24u);
    return 0xFFFFFFFFLL;
  }
  v34 = 0;
  v20 = alloca(v19);
  while ( 1 )
  {
    v21 = (const char *)sub_9100(v11, 58LL);
    v22 = v21;
    if ( v21 - v11 < v33 )
      break;
    if ( !*v21 )
      goto LABEL_14;
LABEL_33:
    v11 = v22;
  }
  v31 = v21;
  v23 = (_BYTE *)sub_91D0(&v31, v11, v21 - v11);
  v24 = (unsigned __int64)v31;
  v25 = v32;
  *v23 = 47;
  v26 = &v23[(unsigned __int64)v11 < v24];
  if ( v25 >= 8 )
  {
    *v26 = *(_QWORD *)a1;
    v30 = v32;
    *(_QWORD *)((char *)v26 + (unsigned int)v32 - 8) = *(_QWORD *)&a1[(unsigned int)v32 - 8];
    qmemcpy(
      (void *)((unsigned __int64)(v26 + 1) & 0xFFFFFFFFFFFFFFF8LL),
      (const void *)(a1 - ((const char *)v26 - ((unsigned __int64)(v26 + 1) & 0xFFFFFFFFFFFFFFF8LL))),
      8LL * (((unsigned int)v26 - (((_DWORD)v26 + 8) & 0xFFFFFFF8) + v30) >> 3));
  }
  else if ( (v25 & 4) != 0 )
  {
    *(_DWORD *)v26 = *(_DWORD *)a1;
    *(_DWORD *)((char *)v26 + (unsigned int)v32 - 4) = *(_DWORD *)&a1[(unsigned int)v32 - 4];
  }
  else if ( (_DWORD)v32 )
  {
    v27 = v32 & 2;
    *(_BYTE *)v26 = *a1;
    if ( v27 )
      *(_WORD *)((char *)v26 + (unsigned int)v32 - 2) = *(_WORD *)&a1[(unsigned int)v32 - 2];
  }
  v31 = (_BYTE *)v24;
  sub_6E5A0((const char *)&v31, a2, a3);
  v28 = v31;
  v29 = __readfsdword(0xFFFFFFC0);
  if ( v29 == 8 && v35 )
  {
    sub_6E5D0((const char *)&v31, a2, a3);
    v29 = __readfsdword(0xFFFFFFC0);
    v28 = v31;
  }
  if ( v29 == 13 )
  {
    v34 = 1;
  }
  else if ( v29 <= 13 )
  {
    if ( v29 != 2 )
      return 0xFFFFFFFFLL;
  }
  else if ( v29 != 110 )
  {
    if ( v29 <= 110 )
    {
      if ( (unsigned int)(v29 - 19) > 1 )
        return 0xFFFFFFFFLL;
    }
    else if ( v29 != 116 )
    {
      return 0xFFFFFFFFLL;
    }
  }
  if ( *v28 )
  {
    v22 = v28 + 1;
    goto LABEL_33;
  }
LABEL_14:
  if ( v34 )
    __writefsdword(0xFFFFFFC0, 0xDu);
  return 0xFFFFFFFFLL;
}
// 6E7A5: variable 'v7' is possibly undefined
// 6E7A5: variable 'v8' is possibly undefined
// 6E7A5: variable 'v9' is possibly undefined
// 6E7A5: variable 'v10' is possibly undefined
// 6E7C9: variable 'v13' is possibly undefined
// 6E7C9: variable 'v14' is possibly undefined
// 6E7C9: variable 'v15' is possibly undefined
// 6E7C9: variable 'v16' is possibly undefined
// 9040: using guessed type __int64 __fastcall sub_9040(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 9100: using guessed type __int64 __fastcall sub_9100(_QWORD, _QWORD);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// 9210: using guessed type __int64 __fastcall sub_9210(_QWORD, _QWORD);

//----- (000000000006EA10) ----------------------------------------------------
__int64 __fastcall sub_6EA10(const char *a1, const char **a2, const char *const *a3)
{
  return sub_6E6E0(a1, a2, a3, 0);
}

//----- (000000000006EA20) ----------------------------------------------------
signed __int64 sub_6EA20()
{
  return sys_getuid();
}

//----- (000000000006EA30) ----------------------------------------------------
signed __int64 sub_6EA30()
{
  return sys_geteuid();
}

//----- (000000000006EA40) ----------------------------------------------------
signed __int64 sub_6EA40()
{
  return sys_getgid();
}

//----- (000000000006EA50) ----------------------------------------------------
signed __int64 sub_6EA50()
{
  return sys_getegid();
}

//----- (000000000006EA60) ----------------------------------------------------
unsigned __int64 __fastcall sub_6EA60(pid_t a1, pid_t a2)
{
  unsigned __int64 result; // rax

  result = sys_setpgid(a1, a2);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000006EA90) ----------------------------------------------------
unsigned __int64 sub_6EA90()
{
  unsigned __int64 result; // rax

  result = sys_setsid();
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000006EAC0) ----------------------------------------------------
unsigned __int64 __fastcall sub_6EAC0(pid_t a1, struct sched_param *a2)
{
  unsigned __int64 result; // rax

  result = sys_sched_setparam(a1, a2);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000006EAF0) ----------------------------------------------------
unsigned __int64 __fastcall sub_6EAF0(pid_t a1, int a2, struct sched_param *a3)
{
  unsigned __int64 result; // rax

  result = sys_sched_setscheduler(a1, a2, a3);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (000000000006EB20) ----------------------------------------------------
__int64 __fastcall sub_6EB20(unsigned int a1)
{
  __int64 result; // rax

  if ( a1 > 1 )
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    result = 6LL;
    __asm { syscall; LINUX - sys_lstat }
  }
  return result;
}

//----- (000000000006EB80) ----------------------------------------------------
unsigned __int64 __fastcall sub_6EB80(unsigned int a1, int a2, const char *a3, struct stat *a4, int a5)
{
  unsigned __int64 result; // rax

  if ( a1 > 1 )
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    result = 0xFFFFFFFFLL;
  }
  else
  {
    result = sys_newfstatat(a2, a3, a4, a5);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)result);
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}

//----- (000000000006EBE0) ----------------------------------------------------
_BOOL8 __fastcall sub_6EBE0(unsigned int a1)
{
  return (unsigned int)sub_6EC30(a1) == 0;
}

//----- (000000000006EC30) ----------------------------------------------------
__int64 __fastcall sub_6EC30(unsigned int a1)
{
  unsigned __int64 v1; // rax
  __int64 v2; // r8
  unsigned int v3; // er9
  __int64 v4; // rax
  __int16 v5; // dx
  __m128i v6; // xmm0
  __int64 v7; // rax
  __int64 v9; // [rsp+0h] [rbp-38h] BYREF
  __int64 v10; // [rsp+8h] [rbp-30h]
  char v11; // [rsp+10h] [rbp-28h]
  __m128i v12; // [rsp+11h] [rbp-27h] BYREF
  __int16 v13; // [rsp+21h] [rbp-17h]
  char v14; // [rsp+23h] [rbp-15h]
  unsigned __int64 v15; // [rsp+28h] [rbp-10h]

  v15 = __readfsqword(0x28u);
  v1 = sys_ioctl(a1, 0x5401u, (unsigned __int64)&v9);
  if ( v1 > 0xFFFFFFFFFFFFF000LL )
  {
    v3 = -1;
    __writefsdword(0xFFFFFFC0, -(int)v1);
  }
  else
  {
    v3 = v1;
    if ( !(_DWORD)v1 )
    {
      v4 = v9;
      v5 = v13;
      *(_QWORD *)(v2 + 36) = 0LL;
      v6 = _mm_loadu_si128(&v12);
      *(_DWORD *)(v2 + 44) = 0;
      *(_QWORD *)v2 = v4;
      v7 = v10;
      *(_WORD *)(v2 + 33) = v5;
      LOBYTE(v5) = v14;
      *(_QWORD *)(v2 + 8) = v7;
      LOBYTE(v7) = v11;
      *(_BYTE *)(v2 + 35) = v5;
      *(_BYTE *)(v2 + 16) = v7;
      LOWORD(v7) = v10;
      *(_BYTE *)(v2 + 48) = 0;
      LODWORD(v7) = v7 & 0x100F;
      *(__m128i *)(v2 + 17) = v6;
      *(_DWORD *)(v2 + 52) = v7;
      *(_DWORD *)(v2 + 56) = v7;
    }
  }
  return v3;
}
// 6EC72: variable 'v2' is possibly undefined

//----- (000000000006ED00) ----------------------------------------------------
__int64 __fastcall sub_6ED00(unsigned __int64 a1)
{
  unsigned __int64 v1; // rax
  __int64 result; // rax

  v1 = sys_brk(a1);
  if ( v1 > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)v1);
    result = 0LL;
    qword_C1718 = -1LL;
  }
  else
  {
    qword_C1718 = v1;
    if ( a1 > v1 )
    {
      __writefsdword(0xFFFFFFC0, 0xCu);
      result = 0xFFFFFFFFLL;
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}
// C1718: using guessed type __int64 qword_C1718;

//----- (000000000006ED60) ----------------------------------------------------
__int64 __fastcall sub_6ED60(__int64 a1)
{
  unsigned __int64 v1; // rax
  __int64 v2; // r13
  _BYTE *v3; // rbx
  __int64 v4; // rbp

  v1 = __readfsqword(0xFFFFFFA0);
  v2 = *(_QWORD *)v1;
  v3 = *(_BYTE **)(*(_QWORD *)v1 + 152LL);
  if ( !*v3 )
    return 0LL;
  v4 = 0LL;
  while ( (unsigned int)sub_91B0(a1, v3) )
  {
    ++v4;
    v3 += strlen((__int64)v3) + 1;
    if ( !*v3 )
      return 0LL;
  }
  return *(_QWORD *)(v2 + 8 * (v4 + *(unsigned int *)(v2 + 208) + 8));
}
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);

//----- (000000000006EDF0) ----------------------------------------------------
__int64 __fastcall sub_6EDF0(unsigned int a1, _DWORD *a2)
{
  __int64 result; // rax
  unsigned int v3; // edx
  __int64 v4; // rdx
  __int64 v5; // rdx

  result = a1;
  if ( a2 )
  {
    v3 = a1 >> *a2;
    if ( v3 < a2[1] )
    {
      v4 = (unsigned int)a2[v3 + 5];
      if ( (_DWORD)v4 )
      {
        v5 = *(unsigned int *)((char *)&a2[a2[3] & (a1 >> a2[2])] + v4);
        if ( (_DWORD)v5 )
          result = *(_DWORD *)((char *)&a2[a2[4] & a1] + v5) + a1;
      }
    }
  }
  return result;
}

//----- (000000000006EE40) ----------------------------------------------------
__int64 __fastcall sub_6EE40(unsigned __int64 a1, unsigned __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  unsigned __int8 **v11; // rsi
  int *v12; // rax
  __int64 v13; // rcx
  u32 *v14; // r8
  u32 v15; // er9
  double v16; // xmm4_8
  double v17; // xmm5_8
  int *v18; // rbp
  unsigned int v19; // eax
  unsigned __int64 v20; // rdx
  unsigned __int64 v21; // r12
  unsigned __int8 *v22; // rax
  char *v23; // rdi
  unsigned __int8 *v24; // rax
  unsigned int v26; // eax
  unsigned __int64 v27; // [rsp+0h] [rbp-78h]
  char *v29; // [rsp+18h] [rbp-60h] BYREF
  unsigned __int64 v30; // [rsp+20h] [rbp-58h] BYREF
  unsigned __int8 *v31; // [rsp+28h] [rbp-50h] BYREF
  unsigned __int8 *v32[9]; // [rsp+30h] [rbp-48h] BYREF

  v11 = (unsigned __int8 **)"rce";
  v32[1] = (unsigned __int8 *)__readfsqword(0x28u);
  v12 = (int *)sub_140F0("/proc/self/maps", "rce", a3, a4, a5, a6, a7, a8, a9, a10);
  if ( v12 )
  {
    v18 = v12;
    v19 = *v12;
    v20 = v19;
    BYTE1(v20) = BYTE1(v19) | 0x80;
    *v18 = v20;
    v29 = 0LL;
    v30 = 0LL;
    if ( (v19 & 0x10) == 0 )
    {
      v27 = a2 + a1;
      do
      {
        v11 = (unsigned __int8 **)&v30;
        if ( sub_69FB0((const char **)&v29, &v30, 0xAu, (__int64)v18, v14, v15, a3, a4, a5, a6, v16, v17, a9, a10) <= 0 )
          break;
        v11 = &v31;
        v21 = sub_129A0(v29, &v31, 0x10u);
        v22 = v31;
        if ( v31 == (unsigned __int8 *)v29 )
          break;
        v23 = (char *)++v31;
        if ( *v22 != 45 )
          break;
        v11 = v32;
        v20 = sub_129A0(v23, v32, 0x10u);
        v24 = v32[0];
        if ( v32[0] == v31 )
          break;
        v11 = (unsigned __int8 **)++v32[0];
        if ( *v24 != 32 )
          break;
        if ( v27 > v21 )
        {
          v13 = a1;
          if ( a1 < v20 )
          {
            v11 = (unsigned __int8 **)(v24 + 2);
            v32[0] = v24 + 2;
            if ( v24[1] != 114 )
              break;
            v11 = (unsigned __int8 **)(v24 + 3);
            v32[0] = v24 + 3;
            if ( v24[2] != 45 )
              break;
            if ( a1 < v21 )
              goto LABEL_19;
            if ( v27 <= v20 )
            {
              a2 = 0LL;
              break;
            }
            if ( a1 < v21 )
            {
LABEL_19:
              if ( v27 > v20 )
                a2 = v21 + a2 - v20;
              else
                a2 = v21 + a2 - v27;
            }
            else
            {
              a2 = a1 + a2 - v20;
            }
            if ( !a2 )
              break;
          }
        }
      }
      while ( (*(_BYTE *)v18 & 0x10) == 0 );
    }
    sub_137F0(v18, (__int64)v11, v20, v13, v14, v15);
    sub_21B70(v29);
    if ( a2 )
      return 0xFFFFFFFFLL;
  }
  else
  {
    v26 = __readfsdword(0xFFFFFFC0);
    if ( v26 != 2 && v26 != 13 )
      return 0xFFFFFFFFLL;
  }
  return 1LL;
}
// 6EF09: variable 'v14' is possibly undefined
// 6EF09: variable 'v15' is possibly undefined
// 6EF09: variable 'v16' is possibly undefined
// 6EF09: variable 'v17' is possibly undefined
// 6EFDB: variable 'v20' is possibly undefined
// 6EFDB: variable 'v13' is possibly undefined
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (000000000006F050) ----------------------------------------------------
__int64 __fastcall sub_6F050(_BYTE *a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // r12
  char v5; // dl
  __int64 v6; // r13

  v2 = strlen(a2);
  v3 = v2;
  if ( *a1 != 123 )
  {
    if ( (unsigned int)sub_9130(a1, a2, v2)
      || (v5 = a1[v3], (unsigned __int8)((v5 & 0xDF) - 65) <= 0x19u)
      || (unsigned __int8)(v5 - 48) <= 9u
      || v5 == 95 )
    {
      v3 = 0LL;
    }
    return v3;
  }
  v6 = v2;
  v3 = 0LL;
  if ( (unsigned int)sub_9130(a1 + 1, a2, v2) || a1[v6 + 1] != 125 )
    return v3;
  return v6 + 2;
}
// 9130: using guessed type __int64 __fastcall sub_9130(_QWORD, _QWORD, _QWORD);

//----- (000000000006F100) ----------------------------------------------------
_BOOL8 __fastcall sub_6F100(char *a1, __int64 a2)
{
  __int64 v2; // rbp
  char v3; // al
  void *v4; // rsp
  __int64 *v5; // rdx
  char v6; // cl
  char *v7; // rax
  _BOOL8 result; // rax
  char v9; // r8
  char v10; // r8
  __int64 v11; // [rsp-8h] [rbp-8h] BYREF
  void *retaddr; // [rsp+0h] [rbp+0h]

  if ( !a2 )
    return 0LL;
  v11 = v2;
  v3 = *a1;
  v4 = alloca(a2 + 10);
  v5 = &v11;
  if ( !*a1 )
    goto LABEL_14;
  do
  {
    while ( 1 )
    {
      v6 = a1[1];
      if ( v3 != 47 )
      {
        ++a1;
        goto LABEL_5;
      }
      if ( v6 == 46 )
      {
        v9 = a1[2];
        if ( v9 == 46 )
        {
          v10 = a1[3];
          if ( v10 == 47 || !v10 )
          {
            do
            {
              if ( v5 <= &v11 )
                break;
              v5 = (__int64 *)((char *)v5 - 1);
            }
            while ( *(_BYTE *)v5 != 47 );
            a1 += 3;
            v3 = v10;
            goto LABEL_6;
          }
        }
        else if ( v9 == 47 || !v9 )
        {
          a1 += 2;
          v3 = v9;
          goto LABEL_6;
        }
      }
      ++a1;
      if ( &v11 < v5 && *((_BYTE *)v5 - 1) == 47 )
        break;
LABEL_5:
      *(_BYTE *)v5 = v3;
      v3 = v6;
      v5 = (__int64 *)((char *)v5 + 1);
LABEL_6:
      if ( !v3 )
        goto LABEL_12;
    }
    v3 = v6;
  }
  while ( v6 );
LABEL_12:
  if ( v5 == &v11 || (v7 = (char *)v5, *((_BYTE *)v5 - 1) != 47) )
  {
LABEL_14:
    *(_BYTE *)v5 = 47;
    v7 = (char *)v5 + 1;
  }
  if ( (unsigned __int64)(v7 - (char *)&v11) > 8 && v11 == 0x62696C2F7273752FLL )
    result = (_BYTE)retaddr == 47;
  else
    result = 0LL;
  return result;
}
// 6F100: could not find valid save-restore pair for rbp
// 6F109: variable 'v2' is possibly undefined

//----- (000000000006F220) ----------------------------------------------------
void __fastcall __noreturn sub_6F220(unsigned int a1, unsigned int a2, _BYTE *a3, __int64 a4, __int64 a5, const char *a6, double xmm0_8_0, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a7)
{
  __int64 v20; // rdi
  double v21; // xmm4_8
  double v22; // xmm5_8

  if ( a2 != -1 )
    sub_4B7A0(a2);
  if ( a5 )
  {
    v20 = *(_QWORD *)(a5 + 840);
    if ( v20 != -1 )
      sub_21B70(v20);
  }
  sub_21B70(a5);
  sub_21B70(a4);
  if ( a7 )
  {
    *(_DWORD *)(a7 + 24) = 0;
    sub_4D260();
  }
  sub_50110(a1, a3, 0LL, a6, xmm0_8_0, a8, a9, a10, v21, v22, a13, a14);
}
// 6F292: variable 'v21' is possibly undefined
// 6F292: variable 'v22' is possibly undefined
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (000000000006F2A0) ----------------------------------------------------
__int64 __fastcall sub_6F2A0(const char *a1, __int64 a2, _BYTE *a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  char *v12; // r13
  unsigned int v14; // er15
  __int64 v15; // rax
  signed __int64 v16; // rax
  double v17; // xmm4_8
  double v18; // xmm5_8
  unsigned __int8 v19; // dl
  __int64 v20; // r10
  unsigned int v21; // edi
  unsigned int v23; // er12
  __int64 v24; // rcx
  __int64 v25; // r10
  size_t v26; // rbx
  unsigned __int64 v27; // r9
  __int64 v28; // r8
  unsigned __int64 v29; // rbx
  const char *v30; // r13
  unsigned __int64 v31; // r14
  size_t v32; // rdx
  loff_t v33; // rcx
  void *v34; // rsp
  __int64 *i; // r12
  unsigned __int64 v36; // rax
  const char *v37; // r9
  __int64 v38; // rax
  void *v39; // rsp
  char *v40; // rbx
  unsigned __int64 v41; // rax
  loff_t v42; // rcx
  void *v43; // rsp
  unsigned __int64 v44; // rax
  __int64 v45; // rsi
  __int64 *v46; // rax
  const char *v47; // r10
  char v48; // dl
  bool v49; // al
  unsigned __int8 v50; // dl
  unsigned int v51; // eax
  __int64 v52; // [rsp+0h] [rbp-60h] BYREF
  const char *v53; // [rsp+8h] [rbp-58h]
  __int64 v54; // [rsp+10h] [rbp-50h]
  __int64 *v55; // [rsp+18h] [rbp-48h]
  int v56; // [rsp+24h] [rbp-3Ch]
  const char *v57; // [rsp+28h] [rbp-38h]

  v12 = (char *)a1;
  v56 = a4;
  v14 = sub_4B910(a1, (int)sub_80000, (int)a3);
  if ( v14 == -1 )
    return v14;
  __writefsdword(0xFFFFFFC0, 0);
  *(_QWORD *)a2 = 0LL;
  v57 = (const char *)(a2 + 8);
  v15 = 0LL;
  while ( 1 )
  {
    v16 = sub_4BA60(v14, (char *)&v57[v15], 832 - v15);
    if ( v16 <= 0 )
      break;
    v15 = *(_QWORD *)a2 + v16;
    *(_QWORD *)a2 = v15;
    if ( (unsigned __int64)v15 > 0x3F )
      goto LABEL_5;
  }
  v15 = *(_QWORD *)a2;
LABEL_5:
  if ( v15 <= 63 )
  {
    v37 = "cannot read file data";
    v23 = __readfsdword(0xFFFFFFC0);
    if ( !v23 )
      v37 = "file too short";
    goto LABEL_41;
  }
  if ( *(_QWORD *)(a2 + 8) != 0x10102464C457FLL && *(_QWORD *)(a2 + 8) != 0x3010102464C457FLL
    || (v19 = *(_BYTE *)(a2 + 16)) != 0 && (*(_BYTE *)(a2 + 15) != 3 || v19 > 3u)
    || *(_DWORD *)(a2 + 17)
    || *(_WORD *)(a2 + 21)
    || *(_BYTE *)(a2 + 23) )
  {
    if ( *(_DWORD *)(a2 + 8) == 1179403647 )
    {
      if ( *(_BYTE *)(a2 + 12) != 2 )
      {
        *a3 = 1;
        v20 = 0LL;
        goto LABEL_12;
      }
      v23 = 0;
      v37 = "ELF file data encoding not little-endian";
      if ( *(_BYTE *)(a2 + 13) == 1 )
      {
        v37 = "ELF file version ident does not match current one";
        if ( *(_BYTE *)(a2 + 14) == 1 )
        {
          v48 = *(_BYTE *)(a2 + 15);
          v49 = v48 != 3;
          if ( !v48 || (v37 = "ELF file OS ABI invalid", v48 == 3) )
          {
            v50 = *(_BYTE *)(a2 + 16);
            if ( v50 && (v50 > 3u || v49) )
            {
              v23 = 0;
              v37 = "ELF file ABI version invalid";
            }
            else
            {
              v51 = (unsigned int)memcmp(a2 + 17, (__int64)&dword_A6379, 7LL);
              v37 = "internal error";
              v23 = v51;
              if ( v51 )
              {
                v23 = 0;
                v37 = "nonzero padding in e_ident";
              }
            }
          }
        }
      }
    }
    else
    {
      v23 = 0;
      v37 = "invalid ELF header";
    }
LABEL_41:
    if ( (_BYTE)v56 )
    {
      v57 = v37;
      v38 = strlen((__int64)v12);
      v39 = alloca(v38 + 9);
      v40 = (char *)memcpy(&v52, v12, v38 + 1);
      sub_21B70(v12);
      v12 = v40;
      v37 = v57;
    }
    sub_6F220(v23, v14, v12, 0LL, 0LL, v37, a5, a6, a7, a8, v17, v18, a11, a12, 0LL);
  }
  v23 = 0;
  if ( *(_DWORD *)(a2 + 28) != 1 )
  {
    v37 = "ELF file version does not match current one";
    goto LABEL_41;
  }
  if ( *(_WORD *)(a2 + 26) != 62 )
  {
    v20 = 0LL;
    goto LABEL_12;
  }
  if ( (unsigned __int16)(*(_WORD *)(a2 + 24) - 2) > 1u )
  {
    v37 = "only ET_DYN and ET_EXEC can be loaded";
    goto LABEL_41;
  }
  if ( *(_WORD *)(a2 + 62) != 56 )
  {
    v37 = "ELF file's phentsize not the expected size";
    goto LABEL_41;
  }
  v24 = *(unsigned __int16 *)(a2 + 64);
  v25 = *(_QWORD *)(a2 + 40);
  v26 = 56 * v24;
  if ( 56 * v24 + v25 > (unsigned __int64)v15 )
  {
    v42 = *(_QWORD *)(a2 + 40);
    v43 = alloca(v26 + 8);
    v55 = &v52;
    v44 = sub_806D0(v14, (char *)&v52, v26, v42);
    v27 = (unsigned __int64)v55;
    if ( v44 != v26 )
      goto LABEL_65;
    v24 = *(unsigned __int16 *)(a2 + 64);
    v26 = 56 * v24;
  }
  else
  {
    v27 = (unsigned __int64)&v57[v25];
  }
  if ( v27 >= v27 + v26 )
  {
    v20 = 0LL;
    goto LABEL_13;
  }
  v53 = a1;
  v28 = a2;
  v29 = v27;
  v30 = 0LL;
  v31 = v27;
  while ( 1 )
  {
    if ( *(_DWORD *)v29 != 4 )
      goto LABEL_25;
    v32 = *(_QWORD *)(v29 + 32);
    if ( v32 <= 0x1F || ((*(_QWORD *)(v29 + 48) - 4LL) & 0xFFFFFFFFFFFFFFFBLL) != 0 )
      goto LABEL_25;
    v33 = *(_QWORD *)(v29 + 8);
    if ( v32 + v33 > *(_QWORD *)v28 )
    {
      if ( v32 <= 0xFFFF )
      {
        v34 = alloca(v32 + 8);
        i = &v52;
LABEL_32:
        v54 = v28;
        v55 = (__int64 *)v32;
        v36 = sub_806D0(v14, (char *)i, v32, v33);
        v32 = (size_t)v55;
        v28 = v54;
        if ( (__int64 *)v36 == v55 )
          goto LABEL_33;
        v47 = v30;
        v12 = (char *)v53;
        sub_21B70(v47);
        goto LABEL_65;
      }
      v45 = *(_QWORD *)(v29 + 32);
      v52 = v28;
      v54 = v33;
      v55 = (__int64 *)v32;
      v46 = sub_21DF0(v30, v45, v32, v33, (u32 *)v28, v27, a5, a6, a7, a8, v17, v18, a11, a12);
      i = v46;
      if ( v46 )
      {
        v28 = v52;
        v33 = v54;
        v30 = (const char *)v46;
        v32 = (size_t)v55;
        goto LABEL_32;
      }
      v12 = (char *)v53;
LABEL_65:
      v37 = "cannot read file data";
      v23 = __readfsdword(0xFFFFFFC0);
      goto LABEL_41;
    }
LABEL_33:
    for ( i = (__int64 *)&v57[v33]; unk_A6360 ^ *i | i[1] ^ 0x554E4700000001LL; i = (__int64 *)((char *)i + v41) )
    {
      v27 = *((unsigned int *)i + 1);
      v41 = -*(_QWORD *)(v29 + 48) & (*(_QWORD *)(v29 + 48)
                                    + v27
                                    - 1
                                    + (-*(_QWORD *)(v29 + 48) & (*(_QWORD *)(v29 + 48) + *(unsigned int *)i + 11LL)));
      if ( v41 > v32 - 32 )
        goto LABEL_55;
      v32 -= v41;
    }
    if ( v32 )
      break;
LABEL_55:
    v24 = *(unsigned __int16 *)(v28 + 64);
LABEL_25:
    v29 += 56LL;
    if ( v29 >= v31 + 56 * v24 )
    {
      v20 = (__int64)v30;
      goto LABEL_13;
    }
  }
  v20 = (__int64)v30;
  if ( *((_DWORD *)i + 4)
    || *((unsigned __int8 *)i + 28) + ((*((unsigned __int8 *)i + 24) + (*((unsigned __int8 *)i + 20) << 8)) << 8) > (unsigned int)dword_C1328
    && dword_C1328 )
  {
LABEL_12:
    v21 = v14;
    v57 = (const char *)v20;
    v14 = -1;
    sub_4B7A0(v21);
    __writefsdword(0xFFFFFFC0, 2u);
    v20 = (__int64)v57;
  }
LABEL_13:
  sub_21B70(v20);
  return v14;
}
// 6F5A8: variable 'v17' is possibly undefined
// 6F5A8: variable 'v18' is possibly undefined
// 6F702: variable 'v27' is possibly undefined
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// A6379: using guessed type int dword_A6379;
// C1328: using guessed type int dword_C1328;

//----- (000000000006F850) ----------------------------------------------------
void __fastcall sub_6F850(__int64 a1, __int64 *a2)
{
  __int64 *v2; // r12
  __int64 v4; // rsi
  unsigned __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // rax
  _BYTE *v8; // rdi
  __int64 v9; // rbp
  _BYTE *v10; // rax

  if ( a2 != (__int64 *)-1LL )
  {
    v2 = a2;
    v4 = *a2;
    do
    {
      while ( 1 )
      {
        ++v2;
        v6 = *(_QWORD *)(a1 + 8);
        v5 = *(_QWORD *)(v4 + 32);
        if ( *(_BYTE *)a1 )
          break;
        v7 = *(unsigned int *)(a1 + 4);
        *(_DWORD *)(a1 + 4) = v7 + 1;
        v8 = *(_BYTE **)(a1 + 16);
        v9 = v6 + 16 * v7;
        *(_QWORD *)(v9 + 16) = v8;
        if ( v5 > 1 )
        {
          v10 = (_BYTE *)sub_91D0(v8, *(_QWORD *)(v4 + 24), v5 - 1);
        }
        else
        {
          *(_QWORD *)(a1 + 16) = v8 + 1;
          *v8 = 46 - ((v5 == 0) - 1);
          v10 = *(_BYTE **)(a1 + 16);
        }
        *(_QWORD *)(a1 + 16) = v10 + 1;
        *v10 = 0;
        v4 = *v2;
        *(_DWORD *)(v9 + 24) = 0;
        if ( !v4 )
          return;
      }
      v4 = *v2;
      ++*(_DWORD *)(v6 + 8);
      if ( v5 < 2 )
        v5 = 2LL;
      *(_QWORD *)v6 += v5;
    }
    while ( v4 );
  }
}
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);

//----- (000000000006F920) ----------------------------------------------------
__int64 __fastcall sub_6F920(__int64 a1, __int64 a2, int a3, __int64 *a4, _QWORD *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, _BYTE *a16)
{
  _QWORD *v16; // rax
  void *v17; // rsp
  const char *v18; // r14
  _QWORD *v19; // r15
  int v20; // ebx
  unsigned __int64 v21; // r12
  __int64 v22; // r13
  __int64 v23; // rax
  const char *v24; // r13
  __int64 v25; // r14
  bool v26; // zf
  __int64 v27; // rax
  double v28; // xmm4_8
  double v29; // xmm5_8
  __int64 v30; // rsi
  __int64 v31; // rdx
  __int64 v32; // rcx
  u32 *v33; // r8
  unsigned int v34; // er9
  int v35; // eax
  __int64 v36; // rax
  unsigned int v37; // eax
  int v40; // eax
  __int64 v41; // rax
  __int64 v42; // rax
  void *v43; // rax
  unsigned int v44; // er9
  int v45; // er9
  int v46; // eax
  int v47; // edx
  size_t v48; // rax
  const char *v49; // rax
  void *v50; // rsp
  _QWORD *v51; // r13
  _QWORD *v52; // rax
  int v53; // er12
  __int64 v54; // r14
  unsigned __int64 v55; // r15
  char *v56; // rdi
  char *v57; // rax
  const char *v58; // rax
  char v59; // [rsp+0h] [rbp-130h] BYREF
  _BYTE v60[7]; // [rsp+1h] [rbp-12Fh] BYREF
  const char *v61; // [rsp+8h] [rbp-128h]
  __int64 *v62; // [rsp+10h] [rbp-120h]
  size_t v63; // [rsp+18h] [rbp-118h]
  _QWORD *v64; // [rsp+20h] [rbp-110h]
  int v65; // [rsp+28h] [rbp-108h]
  int v66; // [rsp+2Ch] [rbp-104h]
  struct stat *v67; // [rsp+30h] [rbp-100h]
  _QWORD *v68; // [rsp+38h] [rbp-F8h]
  const char *v69; // [rsp+40h] [rbp-F0h]
  __int64 v70; // [rsp+48h] [rbp-E8h]
  __int64 v71; // [rsp+50h] [rbp-E0h]
  __int64 v72; // [rsp+58h] [rbp-D8h]
  size_t v73; // [rsp+60h] [rbp-D0h]
  char *v74; // [rsp+68h] [rbp-C8h]
  char v75; // [rsp+70h] [rbp-C0h] BYREF
  __int16 v76; // [rsp+88h] [rbp-A8h]

  v16 = (_QWORD *)*a4;
  v71 = a1;
  v72 = a2;
  v66 = a3;
  v62 = a4;
  v64 = a5;
  v70 = a6;
  v68 = v16;
  if ( !v16 )
    return (unsigned int)-1;
  v65 = 0;
  v63 = 0LL;
  v17 = alloca((signed __int64)&dword_0 + qword_C1720 + v72 + 8);
  v18 = &v59;
  v19 = (_QWORD *)*v68;
  do
  {
    if ( (dword_C14B4 & 1) != 0 )
    {
      v48 = v19[1];
      LODWORD(v74) = dword_C14B4 & 1;
      v73 = v48;
      if ( v48 != v63 )
      {
        v49 = (const char *)v19[2];
        v67 = (struct stat *)&v59;
        v69 = v49;
        v50 = alloca((signed __int64)&dword_0 + qword_C1720);
        sub_76EA0(" search path=", a7, a8, a9, a10, a11, a12, a13, a14);
        v51 = v68;
        v52 = (_QWORD *)*v68;
        if ( *v68 )
        {
          v63 = (size_t)v19;
          v53 = (int)v74;
          v61 = v18;
          do
          {
            if ( v73 != v52[1] )
              break;
            v54 = sub_91D0(&v59, v52[3], v52[4]);
            if ( &dword_0 )
            {
              v55 = 0LL;
              v74 = v60;
              do
              {
                if ( *(_DWORD *)(*v51 + 4 * v55 + 40) != 1 )
                {
                  v57 = (char *)sub_91D0(v54, *(&dword_0 + 2 * v55), *(&dword_0 + 2 * v55 + 1));
                  if ( &v59 == v57 )
                  {
                    *v57 = 0;
                  }
                  else if ( v57 == v74 && v59 == 47 )
                  {
                    *v57 = 0;
                  }
                  else
                  {
                    *(v57 - 1) = 0;
                  }
                  v56 = ":%s";
                  if ( v53 )
                    v56 = "%s";
                  v53 = 0;
                  sub_76F50(v56, &v59);
                }
                ++v55;
              }
              while ( v55 < (unsigned __int64)&dword_0 );
            }
            v52 = (_QWORD *)v51[1];
            ++v51;
          }
          while ( v52 );
          v19 = (_QWORD *)v63;
          v18 = v61;
        }
        if ( v69 )
        {
          if ( !*v69 )
          {
            v58 = "<main program>";
            if ( off_BEFD8 )
              v58 = (const char *)off_BEFD8;
            v69 = v58;
          }
          sub_76F50("\t\t(%s from file %s)\n", (const char *)v73, v69);
        }
        else
        {
          sub_76F50("\t\t(%s)\n", (const char *)v73);
        }
        v63 = v73;
      }
    }
    v20 = 0;
    v21 = 0LL;
    v22 = sub_91D0(v18, v19[3], v19[4]);
    LODWORD(v69) = v66 & 0x4000000;
    v67 = (struct stat *)&v75;
LABEL_5:
    if ( (unsigned __int64)&dword_0 > v21 )
    {
LABEL_6:
      v23 = v22;
      ++v21;
      v24 = v18;
      v25 = v23;
      while ( 1 )
      {
        v26 = *((_DWORD *)v19 + v21 + 9) == 1;
        v74 = (char *)(v21 - 1);
        if ( !v26 )
        {
          v27 = sub_91D0(v25, *(&dword_0 + 2 * v21 - 2), *(&dword_0 + 2 * v21 - 1));
          v73 = sub_91D0(v27, v71, v72) - (_QWORD)v24;
          if ( (dword_C14B4 & 1) != 0 )
            sub_76EA0("  trying file=%s\n", v24);
          v30 = v70;
          v34 = sub_6F2A0(v24, v70, a16, 0, a7, a8, a9, a10, v28, v29, a13, a14);
          v35 = *((_DWORD *)v19 + v21 + 9);
          if ( v35 )
          {
            v20 |= v35 != 1;
            if ( v34 == -1 )
            {
              v41 = v25;
              v18 = v24;
              v22 = v41;
              goto LABEL_5;
            }
          }
          else
          {
            if ( v34 == -1 )
            {
              v42 = v25;
              v18 = v24;
              v22 = v42;
              if ( a15 && (*((_BYTE *)*(&off_BF0E0 + 19 * *(_QWORD *)(a15 + 48)) + 797) & 8) != 0 )
              {
                v20 = 1;
              }
              else
              {
                v18[v73 + ~v72] = 0;
                v45 = sub_4AA20(1u, v18, v67);
                v46 = 1;
                if ( !v45 )
                {
                  v47 = v76 & 0xF000;
                  v46 = (v47 == 0x4000) + 1;
                  if ( v47 == 0x4000 )
                    v20 = 1;
                }
                *((_DWORD *)v19 + (_QWORD)v74 + 10) = v46;
              }
              goto LABEL_5;
            }
            *((_DWORD *)v19 + v21 + 9) = 2;
            v20 = 1;
          }
          if ( !(_DWORD)v69 )
          {
            v18 = v24;
            goto LABEL_35;
          }
          v30 = v34;
          LODWORD(v74) = v34;
          v40 = sub_4AA80(1u, v34, v67);
          v34 = (unsigned int)v74;
          if ( !v40 && (v76 & 0x800) != 0 )
          {
            v36 = v25;
            v18 = v24;
            v22 = v36;
            if ( (_DWORD)v74 == -1 )
            {
              if ( (unsigned __int64)&dword_0 > v21 )
                goto LABEL_6;
              break;
            }
LABEL_35:
            LODWORD(v74) = v34;
            v43 = (void *)sub_21500((u32 *)v73, v30, v31, v32, v33, v34, a7, a8, a9, a10, a11, a12, a13, a14);
            v44 = (unsigned int)v74;
            *v64 = v43;
            if ( v43 )
            {
              LODWORD(v74) = v44;
              memcpy(v43, v18, v73);
              return (unsigned int)v74;
            }
            sub_4B7A0(v44);
            return (unsigned int)-1;
          }
          sub_4B7A0((unsigned int)v74);
          __writefsdword(0xFFFFFFC0, 2u);
        }
        if ( (unsigned __int64)&dword_0 <= v21 )
        {
          v18 = v24;
          break;
        }
        ++v21;
      }
    }
    if ( v20 )
    {
      v37 = __readfsdword(0xFFFFFFC0);
      if ( v37 != 13 && v37 != 2 )
        return (unsigned int)-1;
    }
    ++v68;
    v65 |= v20;
    v19 = (_QWORD *)*v68;
  }
  while ( *v68 );
  if ( v65 )
    return (unsigned int)-1;
  if ( *((_DWORD *)v62 + 2) )
    sub_21B70(*v62);
  if ( v62 == &qword_BDC20 || v62 == &qword_BDBF0 )
    return (unsigned int)-1;
  *v62 = -1LL;
  return (unsigned int)-1;
}
// 6FA97: variable 'v28' is possibly undefined
// 6FA97: variable 'v29' is possibly undefined
// 6FC51: variable 'v31' is possibly undefined
// 6FC51: variable 'v32' is possibly undefined
// 6FC51: variable 'v33' is possibly undefined
// 6FC51: variable 'a11' is possibly undefined
// 6FC51: variable 'a12' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// BD7E0: using guessed type int dword_BD7E0;
// BDBF0: using guessed type __int64 qword_BDBF0;
// BDC20: using guessed type __int64 qword_BDC20;
// BEFD8: using guessed type void *off_BEFD8;
// BF0E0: using guessed type void *off_BF0E0;
// C14B4: using guessed type int dword_C14B4;
// C1720: using guessed type __int64 qword_C1720;

//----- (000000000006FF90) ----------------------------------------------------
void *__fastcall sub_6FF90(_QWORD *a1, _BYTE *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  __int64 *v11; // rbx
  __int64 v12; // rsi
  void *result; // rax
  __int64 v14; // rax
  size_t v15; // r13
  __int64 v16; // rdx
  __int64 v17; // rcx
  u32 *v18; // r8
  u32 v19; // er9
  double v20; // xmm4_8
  double v21; // xmm5_8
  __int64 v22; // rax
  __int64 v23; // r12
  __int64 v24; // rax
  __int64 v25; // rdx
  __int64 v26; // rcx
  u32 *v27; // r8
  u32 v28; // er9
  double v29; // xmm4_8
  double v30; // xmm5_8
  double v32; // xmm4_8
  double v33; // xmm5_8

  v11 = a1;
  if ( !a1 )
  {
    v24 = strlen((__int64)a2);
    if ( sub_21500((u32 *)(v24 + 25), (__int64)a2, v25, v26, v27, v28, a3, a4, a5, a6, v29, v30, a9, a10) )
      sub_CF00(
        (__int64)"lastp != NULL",
        (__int64)"dl-load.c",
        0x1B0u,
        "add_name_to_object",
        a3,
        a4,
        a5,
        a6,
        v32,
        v33,
        a9,
        a10);
    goto LABEL_10;
  }
  while ( 1 )
  {
    v12 = *v11;
    result = (void *)sub_91B0(a2, *v11);
    if ( !(_DWORD)result )
      return result;
    if ( !v11[1] )
      break;
    v11 = (__int64 *)v11[1];
  }
  v14 = strlen((__int64)a2);
  v15 = v14 + 1;
  v22 = sub_21500((u32 *)(v14 + 25), v12, v16, v17, v18, v19, a3, a4, a5, a6, v20, v21, a9, a10);
  v23 = v22;
  if ( !v22 )
LABEL_10:
    sub_50110(12LL, a2, 0LL, "cannot allocate name record", a3, a4, a5, a6, v32, v33, a9, a10);
  result = memcpy((void *)(v22 + 24), a2, v15);
  *(_QWORD *)(v23 + 8) = 0LL;
  *(_QWORD *)v23 = result;
  *(_DWORD *)(v23 + 16) = 0;
  v11[1] = v23;
  return result;
}
// 7003E: variable 'v25' is possibly undefined
// 7003E: variable 'v26' is possibly undefined
// 7003E: variable 'v27' is possibly undefined
// 7003E: variable 'v28' is possibly undefined
// 7003E: variable 'v29' is possibly undefined
// 7003E: variable 'v30' is possibly undefined
// 6FFF0: variable 'v16' is possibly undefined
// 6FFF0: variable 'v17' is possibly undefined
// 6FFF0: variable 'v18' is possibly undefined
// 6FFF0: variable 'v19' is possibly undefined
// 6FFF0: variable 'v20' is possibly undefined
// 6FFF0: variable 'v21' is possibly undefined
// 70059: variable 'v32' is possibly undefined
// 70059: variable 'v33' is possibly undefined
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);

//----- (0000000000070080) ----------------------------------------------------
__int64 __fastcall sub_70080(__int64 a1)
{
  __int64 v1; // r12
  __int64 v2; // rax
  _BYTE *v4; // rbp
  __int64 v5; // rax

  v1 = 0LL;
  v2 = sub_9210(a1, 36LL);
  if ( !v2 )
    return 0LL;
  do
  {
    v4 = (_BYTE *)(v2 + 1);
    v5 = sub_6F050((_BYTE *)(v2 + 1), (__int64)"ORIGIN");
    if ( v5 || (v5 = sub_6F050(v4, (__int64)"PLATFORM")) != 0 || (v5 = sub_6F050(v4, (__int64)"LIB")) != 0 )
    {
      ++v1;
      v4 += v5;
    }
    v2 = sub_9210(v4, 36LL);
  }
  while ( v2 );
  return v1;
}
// 9210: using guessed type __int64 __fastcall sub_9210(_QWORD, _QWORD);

//----- (0000000000070130) ----------------------------------------------------
char *__fastcall sub_70130(__int64 a1, char *a2, char *a3)
{
  char *v3; // r15
  char *v4; // r13
  bool v6; // bp
  char v7; // al
  __int64 v8; // rcx
  char *v10; // rax
  char v11; // al
  __int64 v12; // [rsp+0h] [rbp-48h]

  v3 = a3;
  v4 = a2;
  v6 = 0;
  v7 = *a2;
  do
  {
    while ( 1 )
    {
      ++v4;
      if ( v7 != 36 )
      {
        *v3++ = v7;
        goto LABEL_3;
      }
      v8 = sub_6F050(v4, (__int64)"ORIGIN");
      if ( v8 )
        break;
      v8 = sub_6F050(v4, (__int64)"PLATFORM");
      if ( v8 )
      {
        v10 = (char *)(qword_C14C0 - 1);
        goto LABEL_7;
      }
      v8 = sub_6F050(v4, (__int64)"LIB");
      if ( v8 )
      {
        v10 = "";
        goto LABEL_7;
      }
      *v3++ = 36;
LABEL_3:
      v7 = *v4;
      if ( !*v4 )
        goto LABEL_9;
    }
    if ( v4 != a2 + 1 )
      goto LABEL_18;
    v11 = v4[v8];
    if ( v11 )
    {
      if ( v11 != 47 )
        goto LABEL_18;
    }
    v6 = (*(_BYTE *)(a1 + 796) & 3) == 0;
    v10 = (char *)(*(_QWORD *)(a1 + 840) - 1LL);
LABEL_7:
    if ( (unsigned __int64)v10 > 0xFFFFFFFFFFFFFFFDLL )
      goto LABEL_18;
    v12 = v8;
    v3 = (char *)sub_90F0(v3);
    v4 += v12;
    v7 = *v4;
  }
  while ( *v4 );
LABEL_9:
  if ( !v6 || sub_6F100(a3, v3 - a3) )
  {
    *v3 = 0;
    return a3;
  }
LABEL_18:
  *a3 = 0;
  return a3;
}
// 90F0: using guessed type __int64 __fastcall sub_90F0(_QWORD);
// BD7E0: using guessed type int dword_BD7E0;
// C14C0: using guessed type __int64 qword_C14C0;

//----- (00000000000702B0) ----------------------------------------------------
char *__fastcall sub_702B0(__int64 a1, void *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  __int64 v11; // rax
  double v12; // xmm4_8
  double v13; // xmm5_8
  char *result; // rax
  __int64 v15; // rbx
  __int64 v16; // rax
  __int64 v17; // rdx
  __int64 v18; // rcx
  u32 *v19; // r8
  u32 v20; // er9
  double v21; // xmm4_8
  double v22; // xmm5_8
  __int64 v23; // rdi
  __int64 v24; // r14
  __int64 v25; // r13
  unsigned __int64 v26; // rax
  char *v27; // rdx
  __int64 v28; // rax

  v11 = sub_70080((__int64)a2);
  if ( !v11 )
    return (char *)sub_23100(a2, (__int64)a2, a3, a4, a5, a6, v12, v13, a9, a10);
  v15 = v11;
  v16 = strlen((__int64)a2);
  v23 = *(_QWORD *)(a1 + 840);
  v24 = v16;
  v25 = v16;
  if ( !v23 )
  {
    if ( **(_BYTE **)(a1 + 8) )
      sub_CF00(
        (__int64)"(l)->l_name[0] == '\\0' || IS_RTLD (l)",
        (__int64)"dl-load.c",
        0x18Cu,
        "expand_dynamic_string_token",
        a3,
        a4,
        a5,
        a6,
        v21,
        v22,
        a9,
        a10);
    v28 = sub_77EB0(a3, a4, a5, a6, v21, v22, a9, a10);
    *(_QWORD *)(a1 + 840) = v28;
    v23 = v28;
    if ( (unsigned __int64)(v28 - 1) <= 0xFFFFFFFFFFFFFFFDLL )
      goto LABEL_5;
LABEL_14:
    v26 = 0LL;
    goto LABEL_6;
  }
  if ( v23 == -1 )
    goto LABEL_14;
LABEL_5:
  v26 = strlen(v23);
LABEL_6:
  if ( qword_C14B8 >= v26 )
    v26 = qword_C14B8;
  if ( v26 > 4 )
    v25 = v24 + (v26 - 4) * v15;
  v27 = (char *)sub_21500((u32 *)(v25 + 1), (__int64)a2, v17, v18, v19, v20, a3, a4, a5, a6, v21, v22, a9, a10);
  if ( v27 )
    result = sub_70130(a1, (char *)a2, v27);
  else
    result = 0LL;
  return result;
}
// 702D6: variable 'v12' is possibly undefined
// 702D6: variable 'v13' is possibly undefined
// 7032E: variable 'v17' is possibly undefined
// 7032E: variable 'v18' is possibly undefined
// 7032E: variable 'v19' is possibly undefined
// 7032E: variable 'v20' is possibly undefined
// 7032E: variable 'v21' is possibly undefined
// 7032E: variable 'v22' is possibly undefined
// C14B8: using guessed type __int64 qword_C14B8;

//----- (00000000000703B0) ----------------------------------------------------
char *__fastcall sub_703B0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, const void *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v15; // rbx
  char *result; // rax
  __int64 v17; // rdx
  __int64 v18; // rcx
  u32 *v19; // r8
  double v20; // xmm4_8
  double v21; // xmm5_8
  char *v22; // r15
  char *v23; // rax
  unsigned __int64 v24; // r13
  __int64 v25; // r12
  _QWORD *v26; // r14
  __int64 v27; // rax
  __int64 v28; // rsi
  __int64 v29; // rax
  double v30; // xmm4_8
  double v31; // xmm5_8
  _BYTE *v32; // rax
  bool v33; // cc
  __int64 (**v34)(void); // rax
  int v35; // edx
  char *v36; // [rsp+8h] [rbp-90h]
  __int64 v40; // [rsp+30h] [rbp-68h]
  __int64 v42[8]; // [rsp+58h] [rbp-40h] BYREF

  v15 = 0LL;
  v42[0] = a1;
  while ( 1 )
  {
    result = (char *)sub_7FCC0(v42, a3);
    v22 = result;
    if ( !result )
      break;
    if ( !*result )
    {
      v25 = qword_C1320;
      v24 = 0LL;
      v36 = 0LL;
      if ( !qword_C1320 )
        goto LABEL_23;
      goto LABEL_13;
    }
    v23 = sub_702B0(a6, result, a7, a8, a9, a10, v20, v21, a13, a14);
    v22 = v23;
    if ( v23 )
    {
      v24 = strlen((__int64)v23);
      if ( v24 )
      {
        while ( v24 != 1 )
        {
          if ( v22[v24 - 1] != 47 )
            goto LABEL_33;
          --v24;
        }
        if ( *v22 == 47 )
        {
          v36 = v22;
          goto LABEL_12;
        }
LABEL_33:
        v22[v24++] = 47;
        v36 = v22;
LABEL_12:
        v25 = qword_C1320;
        if ( !qword_C1320 )
        {
LABEL_23:
          if ( a5 )
            v40 = strlen((__int64)a5) + 1;
          else
            v40 = 0LL;
          v28 = 4LL * (_QWORD)&dword_0 + 40;
          v29 = sub_21500(
                  (u32 *)(v24 + v28 + 1 + v40),
                  v28,
                  v17,
                  v18,
                  v19,
                  (u32)&dword_0,
                  a7,
                  a8,
                  a9,
                  a10,
                  v20,
                  v21,
                  a13,
                  a14);
          v26 = (_QWORD *)v29;
          if ( !v29 )
            sub_50110(12LL, 0LL, 0LL, "cannot create cache for search path", a7, a8, a9, a10, v30, v31, a13, a14);
          *(_QWORD *)(v29 + 24) = v29 + v28;
          v32 = (_BYTE *)sub_91D0(v29 + v28, v22, v24);
          v33 = v24 <= qword_C1720;
          *v32 = 0;
          v26[4] = v24;
          if ( !v33 )
            qword_C1720 = v24;
          v34 = 0LL;
          v35 = 2 * (*v22 != 47);
          if ( &dword_0 )
          {
            do
            {
              *((_DWORD *)v26 + (_QWORD)v34 + 10) = v35;
              v34 = (__int64 (**)(void))((char *)v34 + 1);
            }
            while ( &dword_0 != v34 );
          }
          v26[1] = a4;
          if ( a5 )
            v26[2] = memcpy((char *)v26 + v24 + v28 + 1, a5, v40);
          else
            v26[2] = 0LL;
          *v26 = v25;
          qword_C1320 = (__int64)v26;
LABEL_20:
          *(_QWORD *)(a2 + 8 * v15++) = v26;
          goto LABEL_21;
        }
LABEL_13:
        v26 = (_QWORD *)v25;
        while ( v26[4] != v24 || (unsigned int)memcmp((__int64)v22, v26[3], v24) )
        {
          v26 = (_QWORD *)*v26;
          if ( !v26 )
            goto LABEL_23;
        }
        v27 = 0LL;
        if ( !v15 )
          goto LABEL_20;
        while ( *(_QWORD **)(a2 + 8 * v27) != v26 )
        {
          if ( ++v27 == v15 )
            goto LABEL_20;
        }
LABEL_21:
        sub_21B70(v36);
      }
      else
      {
        sub_21B70(v22);
      }
    }
  }
  *(_QWORD *)(a2 + 8 * v15) = 0LL;
  return result;
}
// 7041D: variable 'v20' is possibly undefined
// 7041D: variable 'v21' is possibly undefined
// 7054A: variable 'v17' is possibly undefined
// 7054A: variable 'v18' is possibly undefined
// 7054A: variable 'v19' is possibly undefined
// 70663: variable 'v30' is possibly undefined
// 70663: variable 'v31' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// C1320: using guessed type __int64 qword_C1320;
// C1720: using guessed type __int64 qword_C1720;

//----- (0000000000070670) ----------------------------------------------------
__int64 __fastcall sub_70670(__int64 a1, _BYTE *a2, __int64 a3, __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  const void *v15; // r13
  __int64 result; // rax
  char *v17; // rax
  char *v18; // rdx
  __int64 v19; // rcx
  u32 *v20; // r8
  u32 v21; // er9
  double v22; // xmm4_8
  double v23; // xmm5_8
  __int64 v24; // r14
  char v25; // al
  u32 *v26; // rdi
  __int64 v27; // rax
  double v28; // xmm4_8
  double v29; // xmm5_8
  _QWORD *v30; // r15
  const char *v31; // rcx

  v15 = *(const void **)(a3 + 8);
  if ( !*a2 )
    goto LABEL_2;
  v17 = (char *)sub_23100(a2, (__int64)a2, a5, a6, a7, a8, a9, a10, a11, a12);
  v24 = (__int64)v17;
  if ( !v17 )
  {
    v31 = "cannot create RUNPATH/RPATH copy";
LABEL_14:
    sub_50110(12LL, 0LL, 0LL, v31, a5, a6, a7, a8, v22, v23, a11, a12);
  }
  v25 = *v17;
  if ( v25 )
  {
    v18 = (char *)v24;
    v19 = 0LL;
    do
    {
      ++v18;
      v19 += v25 == 58;
      v25 = *v18;
    }
    while ( *v18 );
    v26 = (u32 *)(8 * v19 + 16);
  }
  else
  {
    v26 = (_DWORD *)&word_10;
  }
  v27 = sub_21500(v26, (__int64)a2, (__int64)v18, v19, v20, v21, a5, a6, a7, a8, v22, v23, a11, a12);
  v30 = (_QWORD *)v27;
  if ( !v27 )
  {
    sub_21B70(v24);
    v31 = "cannot create cache for search path";
    goto LABEL_14;
  }
  sub_703B0(v24, v27, (__int64)":", a4, v15, a3, a5, a6, a7, a8, v28, v29, a11, a12);
  sub_21B70(v24);
  if ( !*v30 )
  {
    sub_21B70(v30);
LABEL_2:
    *(_QWORD *)a1 = -1LL;
    return 0LL;
  }
  *(_QWORD *)a1 = v30;
  result = 1LL;
  *(_DWORD *)(a1 + 8) = 1;
  return result;
}
// 70706: variable 'v18' is possibly undefined
// 70706: variable 'v19' is possibly undefined
// 70706: variable 'v20' is possibly undefined
// 70706: variable 'v21' is possibly undefined
// 70706: variable 'v22' is possibly undefined
// 70706: variable 'v23' is possibly undefined
// 7072D: variable 'v28' is possibly undefined
// 7072D: variable 'v29' is possibly undefined
// 10: using guessed type __int16 word_10;
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// BD7E0: using guessed type int dword_BD7E0;

//----- (0000000000070840) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
const char *__fastcall sub_70840(_BYTE *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 v10; // rsi
  __int64 v11; // rdx
  __int64 v12; // rcx
  u32 *v13; // r8
  u32 v14; // er9
  double v15; // xmm4_8
  double v16; // xmm5_8
  __int64 v17; // rax
  u32 *v18; // r8
  u32 v19; // er9
  double v20; // xmm4_8
  double v21; // xmm5_8
  _QWORD *v22; // r12
  __int64 v23; // rax
  _QWORD *v24; // rbx
  const char *result; // rax
  __int64 v26; // rax
  void *v27; // rsp
  __int64 v28; // rdx
  __int64 v29; // rcx
  u32 *v30; // r8
  u32 v31; // er9
  char *v32; // r12
  double v33; // xmm4_8
  double v34; // xmm5_8
  char v35; // al
  __int64 v36; // rdi
  __int64 v37; // rax
  u32 *v38; // rdi
  const char *v39; // rcx
  __int64 v40; // [rsp+0h] [rbp-30h] BYREF

  v10 = qword_C14B8;
  qword_BDC10 = (__int64)sub_76190(
                           (__int64 *)qword_C14C0,
                           (_QWORD *)qword_C14B8,
                           &qword_BDC08,
                           &qword_BDC00,
                           a2,
                           a3,
                           a4,
                           a5,
                           a6,
                           a7,
                           a8,
                           a9);
  v17 = sub_21500((u32 *)&word_10, v10, v11, v12, v13, v14, a2, a3, a4, a5, v15, v16, a8, a9);
  qword_BDBF0 = v17;
  if ( !v17 )
  {
    v39 = "cannot create search path array";
LABEL_17:
    sub_50110(12LL, 0LL, 0LL, v39, a2, a3, a4, a5, v20, v21, a8, a9);
  }
  v22 = (_QWORD *)v17;
  v23 = sub_21500(
          (u32 *)(40 * ((4 * (__int64)&dword_0 + 79) / 0x28uLL)),
          v10,
          (4 * (__int64)&dword_0 + 79) / 0x28uLL,
          0xCCCCCCCCCCCCCCCDLL,
          v18,
          v19,
          a2,
          a3,
          a4,
          a5,
          v20,
          v21,
          a8,
          a9);
  *v22 = v23;
  v24 = (_QWORD *)v23;
  if ( !v23 )
  {
LABEL_16:
    v39 = "cannot create cache for search path";
    goto LABEL_17;
  }
  qword_C1320 = v23;
  *(_QWORD *)(v23 + 8) = "system search path";
  result = "/usr/lib/";
  dword_BDBF8 = 0;
  v24[2] = 0LL;
  v24[3] = "/usr/lib/";
  v24[4] = 9LL;
  if ( &dword_0 )
    result = (const char *)sub_9190((__int64)(v24 + 5), 0LL, 4LL * (_QWORD)&dword_0);
  *v24 = 0LL;
  qword_C1720 = 9LL;
  v22[1] = 0LL;
  if ( a1 && *a1 )
  {
    v26 = strlen((__int64)a1);
    v27 = alloca(v26 + 9);
    v32 = (char *)memcpy(&v40, a1, v26 + 1);
    v35 = *v32;
    if ( *v32 )
    {
      v28 = (__int64)v32;
      v29 = 1LL;
      do
      {
        v36 = v29 + 1;
        if ( (unsigned __int8)(v35 - 58) <= 1u )
        {
          v37 = v29 + 2;
          ++v29;
          v36 = v37;
        }
        v35 = *(_BYTE *)++v28;
      }
      while ( v35 );
      v38 = (u32 *)(8 * v36);
    }
    else
    {
      v38 = (_DWORD *)&word_10;
    }
    qword_BDC20 = sub_21500(v38, (__int64)a1, v28, v29, v30, v31, a2, a3, a4, a5, v33, v34, a8, a9);
    goto LABEL_16;
  }
  qword_BDC20 = -1LL;
  return result;
}
// 7087E: write access to const memory at BDC10 has been detected
// 7088A: write access to const memory at BDBF0 has been detected
// 708FA: write access to const memory at BDBF8 has been detected
// 70952: write access to const memory at BDC20 has been detected
// 709DA: write access to const memory at BDC20 has been detected
// 70A12: write access to const memory at BDC28 has been detected
// 70A30: write access to const memory at BDC20 has been detected
// 70885: variable 'v11' is possibly undefined
// 70885: variable 'v12' is possibly undefined
// 70885: variable 'v13' is possibly undefined
// 70885: variable 'v14' is possibly undefined
// 70885: variable 'v15' is possibly undefined
// 70885: variable 'v16' is possibly undefined
// 708CC: variable 'v18' is possibly undefined
// 708CC: variable 'v19' is possibly undefined
// 708CC: variable 'v20' is possibly undefined
// 708CC: variable 'v21' is possibly undefined
// 709D5: variable 'v28' is possibly undefined
// 709D5: variable 'v29' is possibly undefined
// 709D5: variable 'v30' is possibly undefined
// 709D5: variable 'v31' is possibly undefined
// 709D5: variable 'v33' is possibly undefined
// 709D5: variable 'v34' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);
// 10: using guessed type __int16 word_10;
// BDBF0: using guessed type __int64 qword_BDBF0;
// BDBF8: using guessed type int dword_BDBF8;
// BDC00: using guessed type __int64 qword_BDC00;
// BDC08: using guessed type __int64 qword_BDC08;
// BDC10: using guessed type __int64 qword_BDC10;
// BDC20: using guessed type __int64 qword_BDC20;
// BDC28: using guessed type int dword_BDC28;
// C1320: using guessed type __int64 qword_C1320;
// C14B8: using guessed type __int64 qword_C14B8;
// C14C0: using guessed type __int64 qword_C14C0;
// C1720: using guessed type __int64 qword_C1720;

//----- (0000000000070A70) ----------------------------------------------------
_QWORD *__fastcall sub_70A70(_QWORD *a1, _QWORD *a2)
{
  _QWORD *result; // rax
  unsigned __int64 v3; // rdi
  unsigned int *v4; // rdx
  __int64 v5; // rsi

  result = a1;
  if ( a2[6] == 8LL )
  {
    v3 = a2[5];
    if ( v3 > 0xC )
    {
      v4 = (unsigned int *)(a2[2] + *result);
      v5 = 12LL - (_QWORD)v4;
      do
      {
        result = (_QWORD *)*v4;
        if ( (_DWORD)result == 4 && v4[2] == 5 && v4[3] == 5590599 )
          break;
        v4 = (unsigned int *)((char *)v4
                            + (((((unsigned __int64)result + 19) & 0xFFFFFFFFFFFFFFF8LL) + v4[1] + 7) & 0xFFFFFFFFFFFFFFF8LL));
        result = (_QWORD *)((char *)v4 + v5);
      }
      while ( (unsigned __int64)v4 + v5 < v3 );
    }
  }
  return result;
}

//----- (0000000000070AE0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall sub_70AE0(_BYTE *a1, unsigned int a2, __int64 a3, char *a4, _QWORD *r8_0, char a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, int a15, __int64 a16, __int64 a17)
{
  double v19; // xmm4_8
  double v20; // xmm5_8
  int v21; // eax
  _QWORD *v22; // rax
  __int64 i; // r12
  __int64 v24; // rdi
  loff_t v25; // rcx
  __int64 v26; // rax
  size_t v27; // rbx
  __int64 v28; // rax
  void *v29; // rsp
  __int64 v30; // rdx
  unsigned int *v31; // rax
  unsigned int *v32; // r15
  unsigned __int64 v33; // r11
  __int64 v34; // rbx
  __int64 v35; // rdi
  unsigned int v36; // edx
  __int64 v37; // rdx
  __int64 v38; // r13
  unsigned int v39; // er14
  char *v40; // rax
  char *v41; // rdx
  char *v42; // rax
  bool v43; // zf
  char *v44; // r13
  unsigned __int64 v45; // rcx
  unsigned __int64 v46; // r8
  unsigned __int64 v47; // r8
  unsigned __int64 v48; // rcx
  __int64 v49; // r15
  void *v50; // r10
  unsigned __int64 v51; // rdi
  unsigned __int64 v52; // rsi
  const char *v53; // r9
  void *v54; // rsp
  __int64 v55; // rdx
  __int64 v56; // rcx
  __int64 v57; // rsi
  __int64 v58; // r14
  char *v59; // rdx
  __int64 v60; // r10
  __int64 v61; // rcx
  char v62; // si
  __int64 v63; // rdx
  __int64 v64; // rdx
  __int64 v65; // rsi
  __int64 v66; // rdx
  unsigned __int64 v68; // rdx
  unsigned __int64 v69; // rax
  int v70; // eax
  unsigned __int64 v71; // r9
  unsigned int *v72; // rdx
  unsigned int v73; // er8
  __int64 v74; // r10
  __int64 v75; // rdi
  __int64 v76; // rax
  char v77; // cl
  unsigned int *v78; // rcx
  unsigned __int64 v79; // rbx
  unsigned int v80; // esi
  unsigned int v81; // er13
  void **v82; // rax
  __int64 v83; // rax
  __int64 v84; // rdi
  unsigned __int64 *v85; // rax
  unsigned __int64 v86; // rdx
  __int64 j; // rcx
  __int64 v88; // rax
  __int64 v89; // rax
  __int64 v90; // rax
  __int64 v91; // rax
  __int64 v92; // rax
  __int64 v93; // rax
  __int64 v94; // rax
  __int64 v95; // rax
  __int64 v96; // rax
  __int64 v97; // rax
  __int64 v98; // rdx
  __int64 v99; // rax
  __int64 v100; // rdx
  int v101; // eax
  __int64 v102; // rax
  __int64 v103; // rax
  __int64 v104; // r8
  __int64 v105; // rax
  void **v106; // rax
  int v107; // eax
  _QWORD *v108; // rsi
  __int64 v109; // rax
  __int64 v110; // rcx
  unsigned __int64 v111; // rdx
  unsigned __int8 v112; // al
  __int64 v113; // rdx
  size_t v114; // r13
  void *v115; // rdi
  void *v116; // rax
  __int64 v117; // rax
  int v118; // eax
  unsigned __int64 v119; // r10
  __int64 v120; // rdi
  __int64 v121; // [rsp-8h] [rbp-148h]
  char v122[4]; // [rsp+0h] [rbp-140h] BYREF
  int v123; // [rsp+4h] [rbp-13Ch] BYREF
  unsigned __int64 v124; // [rsp+8h] [rbp-138h]
  char *v125; // [rsp+10h] [rbp-130h]
  int v126; // [rsp+18h] [rbp-128h]
  char v127; // [rsp+1Fh] [rbp-121h]
  unsigned __int64 v128; // [rsp+20h] [rbp-120h]
  __int64 v129; // [rsp+28h] [rbp-118h]
  char *v130; // [rsp+30h] [rbp-110h]
  _BYTE *v131; // [rsp+38h] [rbp-108h]
  void *v132; // [rsp+40h] [rbp-100h]
  __int64 v133; // [rsp+48h] [rbp-F8h]
  int v134; // [rsp+50h] [rbp-F0h]
  unsigned int a5[3]; // [rsp+54h] [rbp-ECh]
  void **v136; // [rsp+60h] [rbp-E0h]
  char *v137; // [rsp+68h] [rbp-D8h]
  __m128i v138; // [rsp+70h] [rbp-D0h] BYREF
  struct stat v139; // [rsp+80h] [rbp-C0h] BYREF

  a5[0] = a2;
  v131 = a1;
  v129 = a3;
  v130 = a4;
  v136 = sub_4D270(0LL, a17);
  v126 = a15 & 0x20000000;
  if ( (a15 & 0x20000000) != 0 )
  {
    if ( a17 )
      sub_CF00("nsid == LM_ID_BASE", "dl-load.c", 957LL, "_dl_map_object_from_fd");
    a7 = 0.0;
    v138 = 0LL;
  }
  else
  {
    if ( (sub_4AA80(1u, a5[0], &v139) & 0x80000000) != 0LL )
    {
      v53 = "cannot stat shared object";
      i = 0LL;
      v136 = 0LL;
      v134 = __readfsdword(0xFFFFFFC0);
      goto LABEL_107;
    }
    v138 = *(__m128i *)&v139.st_dev;
    for ( i = (__int64)*(&off_BF0E0 + 19 * a17); i; i = *(_QWORD *)(i + 24) )
    {
      if ( (*(_BYTE *)(i + 797) & 0x20) == 0 && *(_OWORD *)(i + 936) == *(_OWORD *)&v139.st_dev )
      {
        sub_4B7A0(a5[0]);
        sub_21B70(v130);
        sub_6FF90(*(_QWORD **)(i + 56), v131);
        return i;
      }
    }
  }
  v134 = a15 & 4;
  if ( (a15 & 4) != 0 )
  {
    i = 0LL;
    sub_21B70(v130);
    sub_4B7A0(a5[0]);
    return i;
  }
  if ( (dword_C14B4 & 0x40) != 0 )
    sub_76EA0("file=%s [%lu];  generating link map\n", v131, a17);
  v21 = *((_DWORD *)v136 + 6);
  if ( v21 )
  {
    if ( v21 != 1 )
      sub_CF00("r->r_state == RT_ADD", "dl-load.c", 1066LL, "_dl_map_object_from_fd");
    v127 = 0;
  }
  else
  {
    *((_DWORD *)v136 + 6) = 1;
    sub_4D260();
    v127 = 1;
  }
  v22 = sub_74330(v130, v131, a6, r8_0, a15, a17, a7, a8, a9, a10, v19, v20, a13, a14);
  i = (__int64)v22;
  if ( !v22 )
  {
    v53 = "cannot create shared object descriptor";
    goto LABEL_183;
  }
  v24 = v129;
  v25 = *(_QWORD *)(v129 + 40);
  v22[86] = *(_QWORD *)(v129 + 32);
  LOWORD(v123) = *(_WORD *)(v24 + 24);
  v26 = *(unsigned __int16 *)(v24 + 64);
  *(_WORD *)(i + 696) = v26;
  v27 = 56 * v26;
  if ( (unsigned __int64)(56 * v26 + v25) > *(_QWORD *)v24 )
  {
    v54 = alloca(v27 + 8);
    v132 = v122;
    if ( sub_806D0(a5[0], v122, v27, v25) != v27 )
    {
      v53 = "cannot read file data";
      goto LABEL_183;
    }
  }
  else
  {
    v132 = (void *)(v24 + v25 + 8);
  }
  v28 = *(unsigned __int16 *)(i + 696);
  v125 = v122;
  v29 = alloca(48 * v28);
  v30 = 7 * v28;
  v31 = (unsigned int *)v132;
  v137 = v122;
  v32 = (unsigned int *)((char *)v132 + 8 * v30);
  v124 = ((unsigned __int64)&v123 + 3) >> 3;
  if ( v32 <= v132 )
  {
LABEL_200:
    v53 = "object file has no loadable segments";
    goto LABEL_104;
  }
  v133 = 7LL;
  LOBYTE(a5[1]) = 0;
  v128 = qword_C0378;
  v33 = (unsigned __int64)&off_BF078[-1].r_addend + 7;
  v34 = 0LL;
  v35 = -(__int64)off_BF078;
  do
  {
    while ( 1 )
    {
      v36 = *v31;
      if ( *v31 == 7 )
      {
        v63 = *((_QWORD *)v31 + 5);
        if ( v63 )
        {
          *(_QWORD *)(i + 1080) = v63;
          v64 = *((_QWORD *)v31 + 6);
          *(_QWORD *)(i + 1088) = v64;
          v65 = *((_QWORD *)v31 + 2);
          if ( v64 )
            v64 = v65 & (v64 - 1);
          *(_QWORD *)(i + 1096) = v64;
          v66 = *((_QWORD *)v31 + 4);
          *(_QWORD *)(i + 1064) = v65;
          *(_QWORD *)(i + 1072) = v66;
          if ( (*(_BYTE *)(i + 796) & 3) != 1 && !v128 )
            sub_CF00(
              "false && \"TLS not initialized in static application\"",
              "dl-load.c",
              1206LL,
              "_dl_map_object_from_fd");
        }
        goto LABEL_18;
      }
      if ( v36 <= 7 )
      {
        switch ( v36 )
        {
          case 2u:
            if ( *((_QWORD *)v31 + 4) )
            {
              *(_QWORD *)(i + 16) = *((_QWORD *)v31 + 2);
              *(_WORD *)(i + 698) = *((_QWORD *)v31 + 5) >> 4;
            }
            break;
          case 6u:
            *(_QWORD *)(i + 680) = *((_QWORD *)v31 + 2);
            break;
          case 1u:
            v55 = *((_QWORD *)v31 + 6);
            if ( (v33 & v55) != 0 )
            {
              v53 = "ELF load command alignment not page-aligned";
              goto LABEL_104;
            }
            v56 = *((_QWORD *)v31 + 2);
            v57 = *((_QWORD *)v31 + 1);
            if ( ((v55 - 1) & (v56 - v57)) != 0 )
            {
              v53 = "ELF load command address/offset not properly aligned";
              goto LABEL_104;
            }
            v58 = v35 & v56;
            v59 = &v137[48 * v34];
            v60 = v56 + *((_QWORD *)v31 + 4);
            v61 = *((_QWORD *)v31 + 5) + v56;
            *(_QWORD *)v59 = v58;
            *((_QWORD *)v59 + 2) = v60;
            *((_QWORD *)v59 + 3) = v61;
            *((_QWORD *)v59 + 1) = v35 & (v33 + v60);
            *((_QWORD *)v59 + 4) = v35 & v57;
            if ( (unsigned __int64)(v34 + 1) > 1 )
            {
              v62 = a5[1];
              if ( v58 != *((_QWORD *)v59 - 5) )
                v62 = 1;
              LOBYTE(a5[1]) = v62;
            }
            *(_DWORD *)&v137[48 * v34++ + 40] = (1934713408 >> (4 * (v31[1] & 7))) & 0xF;
            break;
        }
        goto LABEL_18;
      }
      if ( v36 == 1685382481 )
      {
        v133 = v31[1];
        goto LABEL_18;
      }
      if ( v36 == 1685382482 )
        break;
LABEL_18:
      v31 += 14;
      if ( v32 <= v31 )
        goto LABEL_24;
    }
    v37 = *((_QWORD *)v31 + 2);
    v31 += 14;
    *(_QWORD *)(i + 1128) = v37;
    *(_QWORD *)(i + 1136) = *((_QWORD *)v31 - 2);
  }
  while ( v32 > v31 );
LABEL_24:
  if ( !v34 )
    goto LABEL_200;
  v123 = (unsigned __int16)v123;
  if ( (_WORD)v123 == 3 )
  {
    v38 = *(_QWORD *)(8 * v124);
    v39 = qword_28[v124];
    v128 = *(_QWORD *)&v137[48 * v34 - 24] - v38;
    v40 = (char *)mmap((void *)(v38 & qword_BF090), v128, v39, 0x802u, a5[0], qword_20[v124]);
    *(_QWORD *)(i + 848) = v40;
    if ( v40 == (char *)-1LL )
    {
LABEL_43:
      v53 = "failed to map segment from shared object";
    }
    else
    {
      v41 = &v40[v128];
      v42 = &v40[-v38];
      v43 = LOBYTE(a5[1]) == 0;
      *(_QWORD *)(i + 856) = v41;
      *(_QWORD *)i = v42;
      if ( v43
        || (sub_4BD40(
              (unsigned __int64)&v42[*(_QWORD *)&byte_8[8 * v124]],
              *(_QWORD *)&v137[48 * v34 - 48] - *(_QWORD *)&byte_8[8 * v124],
              0LL) & 0x80000000) == 0LL )
      {
        *(_BYTE *)(i + 797) |= 0x40u;
        v44 = v137;
        while ( 1 )
        {
          if ( (v39 & 4) != 0 )
            *(_QWORD *)(i + 864) = *(_QWORD *)i + *((_QWORD *)v44 + 1);
          if ( !*(_QWORD *)(i + 680) )
          {
            v68 = *((_QWORD *)v44 + 4);
            v69 = *(_QWORD *)(v129 + 40);
            if ( v68 <= v69
              && v68 + *((_QWORD *)v44 + 1) - *(_QWORD *)v44 >= v69 + 56LL * *(unsigned __int16 *)(v129 + 64) )
            {
              *(_QWORD *)(i + 680) = *(_QWORD *)v44 + v69 - v68;
            }
          }
          v45 = *((_QWORD *)v44 + 3);
          v46 = *((_QWORD *)v44 + 2);
          if ( v45 > v46 )
          {
            v47 = *(_QWORD *)i + v46;
            v48 = *(_QWORD *)i + v45;
            v49 = v47;
            v50 = (void *)(-(__int64)off_BF078 & ((unsigned __int64)off_BF078 + v47 - 1));
            if ( v48 <= (unsigned __int64)v50 )
              v50 = (void *)v48;
            if ( v47 < (unsigned __int64)v50 )
            {
              if ( (v39 & 2) != 0 )
              {
                v124 = v48;
                *(_QWORD *)&a5[1] = v50;
                sub_9190(v47, 0LL, (__int64)v50 - v47);
                v50 = *(void **)&a5[1];
                v48 = v124;
              }
              else
              {
                v124 = (unsigned __int64)v50;
                *(_QWORD *)&a5[1] = v48;
                v118 = sub_4BD40(v47 & -(__int64)off_BF078, (size_t)off_BF078, v39 | 2);
                v119 = v124;
                if ( v118 < 0 )
                  goto LABEL_73;
                v124 = *(_QWORD *)&a5[1];
                *(_QWORD *)&a5[1] = v119;
                sub_9190(v49, 0LL, v119 - v49);
                sub_4BD40(v49 & -(__int64)off_BF078, (size_t)off_BF078, v39);
                v50 = *(void **)&a5[1];
                v48 = v124;
              }
            }
            if ( v48 > (unsigned __int64)v50
              && mmap(v50, v48 - (_QWORD)v50, v39, 0x32u, 0xFFFFFFFFuLL, 0LL) == (void *)-1LL )
            {
              break;
            }
          }
          if ( v44 + 48 >= &v137[48 * v34] )
          {
            v32 = (unsigned int *)((char *)v132 + 56 * *(unsigned __int16 *)(i + 696));
            if ( v132 == v32 )
              goto LABEL_109;
            goto LABEL_82;
          }
          v51 = *((_QWORD *)v44 + 6);
          v44 += 48;
LABEL_41:
          v52 = *((_QWORD *)v44 + 1);
          v39 = *((_DWORD *)v44 + 10);
          if ( v52 > v51
            && mmap((void *)(*(_QWORD *)i + v51), v52 - v51, v39, 0x812u, a5[0], *((_QWORD *)v44 + 4)) == (void *)-1LL )
          {
            goto LABEL_43;
          }
        }
        v53 = "cannot map zero-fill pages";
      }
      else
      {
LABEL_73:
        v53 = "cannot change memory protections";
      }
    }
LABEL_104:
    v82 = 0LL;
    if ( v127 )
      v82 = v136;
    v136 = v82;
LABEL_107:
    v121 = a17;
    sub_6F220(v134, a5[0], v131, (__int64)v130, i, v53, (__int64)v136);
  }
  if ( !v126 )
  {
    v53 = "cannot dynamically load executable";
    goto LABEL_104;
  }
  v51 = *(_QWORD *)(8 * v124);
  v44 = v137;
  v110 = *(_QWORD *)&v137[48 * v34 - 24];
  v111 = v51 + *(_QWORD *)i;
  *(_QWORD *)(i + 856) = *(_QWORD *)i + v110;
  v112 = a5[1];
  v128 = v110 - v51;
  *(_QWORD *)(i + 848) = v111;
  *(_BYTE *)(i + 797) = *(_BYTE *)(i + 797) & 0xBF | (((v112 ^ 1) & 1) << 6);
  if ( v44 < &v44[48 * v34] )
    goto LABEL_41;
  do
  {
LABEL_82:
    v70 = *(v32 - 14);
    v32 -= 14;
    if ( v70 == 4 )
    {
      if ( (*(_BYTE *)(i + 801) & 7) == 0 && *((_QWORD *)v32 + 6) == 8LL )
      {
        v71 = *((_QWORD *)v32 + 5);
        if ( v71 > 0xC )
        {
          v72 = (unsigned int *)(*((_QWORD *)v32 + 2) + *(_QWORD *)i);
          v73 = 0;
          LODWORD(v137) = 0;
          v74 = 12LL - (_QWORD)v72;
          while ( 1 )
          {
            v76 = *v72;
            if ( (_DWORD)v76 == 4 && v72[2] == 5 && v72[3] == 5590599 )
              break;
            v75 = v72[1];
LABEL_88:
            v72 = (unsigned int *)((char *)v72 + ((v75 + ((v76 + 19) & 0xFFFFFFFFFFFFFFF8LL) + 7) & 0xFFFFFFFFFFFFFFF8LL));
            if ( v71 <= (unsigned __int64)v72 + v74 )
            {
              v107 = (unsigned __int8)v137 & 2;
              if ( ((unsigned __int8)v137 & 1) != 0 )
                *(_BYTE *)(i + 801) |= 2u;
              if ( v107 )
                *(_BYTE *)(i + 801) |= 4u;
              goto LABEL_81;
            }
          }
          v77 = *(_BYTE *)(i + 801);
          if ( (v77 & 7) == 0 )
          {
            *(_BYTE *)(i + 801) = v77 & 0xF8 | 1;
            v75 = v72[1];
            if ( (unsigned int)v75 > 7 && (v75 & 7) == 0 )
            {
              v78 = v72 + 4;
              v79 = (unsigned __int64)v72 + v75 + 16;
              while ( 1 )
              {
                v80 = v73;
                v73 = *v78;
                v81 = v78[1];
                if ( *v78 < v80 || v79 < (unsigned __int64)v78 + v81 + 8 )
                  break;
                if ( v73 == -1073741822 )
                {
                  if ( v81 != 4 )
                    break;
                  LODWORD(v137) = v78[2];
                  goto LABEL_88;
                }
                if ( v73 > 0xC0000002 )
                  break;
                v78 = (unsigned int *)((char *)v78 + ((v81 + 7LL) & 0xFFFFFFFFFFFFFFF8LL) + 8);
                if ( (__int64)(v79 - (_QWORD)v78) <= 7 )
                  goto LABEL_88;
              }
            }
          }
        }
      }
    }
    else if ( v70 == 1685382483 )
    {
      sub_70A70((_QWORD *)i, v32);
    }
LABEL_81:
    ;
  }
  while ( v132 != v32 );
LABEL_109:
  v83 = *(_QWORD *)(i + 16);
  if ( !v83 )
  {
    if ( v123 == 3 )
    {
      v53 = "object file has no dynamic section";
      goto LABEL_104;
    }
    goto LABEL_199;
  }
  v84 = *(_QWORD *)i;
  v43 = *(_QWORD *)i + v83 == 0;
  v85 = (unsigned __int64 *)(*(_QWORD *)i + v83);
  *(_QWORD *)(i + 16) = v85;
  if ( v43 )
  {
LABEL_199:
    v101 = *(_DWORD *)(i + 996);
    goto LABEL_158;
  }
  v86 = *v85;
  for ( j = i + 64; v86; v85 += 2 )
  {
    if ( v86 > 0x22 )
    {
      if ( 1879048191 - v86 > 0xF )
      {
        if ( (unsigned int)(2 * v86) <= 0xFFFFFFF8 )
        {
          if ( 1879047679 - v86 > 0xB )
          {
            if ( 1879047935 - v86 <= 0xA )
              *(_QWORD *)(j + 8 * (1879048001 - v86)) = v85;
          }
          else
          {
            *(_QWORD *)(j + 8 * (1879047733 - v86)) = v85;
          }
        }
        else
        {
          *(_QWORD *)(j + 8LL * (unsigned int)(50 - ((2 * (int)v86) >> 1))) = v85;
        }
      }
      else
      {
        *(_QWORD *)(j + 8 * (1879048226 - v86)) = v85;
      }
    }
    else
    {
      *(_QWORD *)(j + 8 * v86) = v85;
    }
    v86 = v85[2];
  }
  if ( v84 )
  {
    v88 = *(_QWORD *)(i + 96);
    if ( v88 )
      *(_QWORD *)(v88 + 8) += v84;
    v89 = *(_QWORD *)(i + 88);
    if ( v89 )
      *(_QWORD *)(v89 + 8) += v84;
    v90 = *(_QWORD *)(i + 104);
    if ( v90 )
      *(_QWORD *)(v90 + 8) += v84;
    v91 = *(_QWORD *)(i + 112);
    if ( v91 )
      *(_QWORD *)(v91 + 8) += v84;
    v92 = *(_QWORD *)(i + 120);
    if ( v92 )
      *(_QWORD *)(v92 + 8) += v84;
    v93 = *(_QWORD *)(i + 248);
    if ( v93 )
      *(_QWORD *)(v93 + 8) += v84;
    v94 = *(_QWORD *)(i + 464);
    if ( v94 )
      *(_QWORD *)(v94 + 8) += v84;
    v95 = *(_QWORD *)(i + 672);
    if ( v95 )
      *(_QWORD *)(v95 + 8) += v84;
  }
  v96 = *(_QWORD *)(i + 224);
  if ( v96 && *(_QWORD *)(v96 + 8) != 7LL )
    sub_CF00("info[DT_PLTREL]->d_un.d_val == DT_RELA", "get-dynamic-info.h", 123LL, "elf_get_dynamic_info");
  if ( *(_QWORD *)(i + 120) && *(_QWORD *)(*(_QWORD *)(i + 136) + 8LL) != 24LL )
    sub_CF00("info[DT_RELAENT]->d_un.d_val == sizeof (ElfW(Rela))", "get-dynamic-info.h", 131LL, "elf_get_dynamic_info");
  v97 = *(_QWORD *)(i + 304);
  if ( v97 )
  {
    v98 = *(_QWORD *)(v97 + 8);
    *(_DWORD *)(i + 1000) = v98;
    if ( (v98 & 2) != 0 )
      *(_QWORD *)(i + 192) = v97;
    if ( (v98 & 4) != 0 )
      *(_QWORD *)(i + 240) = v97;
    if ( (v98 & 8) != 0 )
      *(_QWORD *)(i + 256) = v97;
  }
  v99 = *(_QWORD *)(i + 376);
  if ( v99 )
  {
    v100 = *(_QWORD *)(v99 + 8);
    *(_DWORD *)(i + 996) = v100;
    v101 = v100;
    if ( (v100 & 8) != 0 )
      *(_BYTE *)(i + 800) = 1;
    if ( (dword_C14B4 & 0x40) != 0 && (v100 & 0xF7FFF716) != 0 )
    {
      sub_76EA0("\nWARNING: Unsupported flag value(s) of 0x%x in DT_FLAGS_1.\n", (unsigned int)v100 & 0xF7FFF716);
      v101 = *(_DWORD *)(i + 996);
    }
    if ( (v101 & 1) != 0 )
      *(_QWORD *)(i + 256) = *(_QWORD *)(i + 376);
  }
  else
  {
    v101 = *(_DWORD *)(i + 996);
  }
  if ( *(_QWORD *)(i + 296) )
    *(_QWORD *)(i + 184) = 0LL;
LABEL_158:
  if ( (v101 & 0x40) != 0 && a15 < 0 || (v101 & 0x8000000) != 0 && !v126 )
  {
    munmap(*(void **)(i + 848), *(_QWORD *)(i + 856) - *(_QWORD *)(i + 848));
    v120 = *(_QWORD *)(i + 56);
    if ( !*(_DWORD *)(v120 + 16) )
      sub_21B70(v120);
    if ( *(char *)(i + 796) < 0 )
      sub_21B70(*(_QWORD *)(i + 680));
    v53 = "cannot dynamically load position-independent executable";
    if ( (*(_BYTE *)(i + 999) & 8) == 0 )
      v53 = "shared object cannot be dlopen()ed";
    goto LABEL_104;
  }
  v102 = *(_QWORD *)(i + 680);
  if ( !v102 )
  {
    v114 = 56LL * *(unsigned __int16 *)(v129 + 64);
    v115 = (void *)sub_21500(v114);
    if ( v115 )
    {
      v116 = memcpy(v115, v132, v114);
      *(_BYTE *)(i + 796) |= 0x80u;
      *(_QWORD *)(i + 680) = v116;
      goto LABEL_164;
    }
    v53 = "cannot allocate memory for program header";
LABEL_183:
    v134 = __readfsdword(0xFFFFFFC0);
    goto LABEL_104;
  }
  *(_QWORD *)(i + 680) = *(_QWORD *)i + v102;
LABEL_164:
  if ( ((unsigned __int8)v133 & (unsigned __int8)~(_BYTE)dword_BF068 & 1) != 0 )
  {
    dword_BDC30 |= 7u;
    v134 = off_BF098(a16);
    if ( v134 )
    {
      v53 = "cannot enable executable stack as shared object requires";
      goto LABEL_104;
    }
  }
  v103 = *(_QWORD *)(i + 1064);
  if ( v103 )
    *(_QWORD *)(i + 1064) = *(_QWORD *)i + v103;
  if ( (unsigned int)sub_4B7A0(a5[0]) )
  {
    v53 = "cannot close file descriptor";
    goto LABEL_183;
  }
  if ( v123 == 2 && (*(_BYTE *)(i + 796) & 3) != 0 )
    sub_CF00("type != ET_EXEC || l->l_type == lt_executable", "dl-load.c", 1390LL, "_dl_map_object_from_fd");
  v104 = *(_QWORD *)i;
  v105 = *(_QWORD *)i + *(_QWORD *)(i + 688);
  *(_QWORD *)(i + 688) = v105;
  if ( (dword_C14B4 & 0x40) != 0 )
    sub_76EA0(
      "  dynamic: 0x%0*lx  base: 0x%0*lx   size: 0x%0*Zx\n    entry: 0x%0*lx  phdr: 0x%0*lx  phnum:   %*u\n\n",
      16LL,
      *(_QWORD *)(i + 16),
      16LL,
      v104,
      16LL,
      v128,
      16LL,
      v105,
      16LL,
      *(_QWORD *)(i + 680),
      16LL,
      *(unsigned __int16 *)(i + 696));
  sub_741B0(i);
  if ( (a15 & 8) == 0 )
  {
    if ( *(_QWORD *)(i + 192) )
    {
      v108 = *(_QWORD **)(i + 912);
      if ( *v108 != i + 704 )
      {
        **(_QWORD **)(i + 720) = i;
        v109 = *(_QWORD *)(i + 904);
        *(_DWORD *)(i + 728) = 1;
        sub_9050(v108 + 1, v108, 8 * v109 - 8);
        **(_QWORD **)(i + 912) = i + 720;
      }
    }
  }
  if ( (*(_BYTE *)(i + 996) & 0x20) != 0 )
    qword_C1310 = i;
  v43 = qword_C14A0 == 0;
  *(__m128i *)(i + 936) = _mm_loadu_si128(&v138);
  if ( v43 )
  {
LABEL_176:
    v106 = &off_BF0E0 + 19 * a17;
    if ( !v106[4] )
    {
      v113 = *(_QWORD *)(i + 176);
      if ( v113 )
      {
        if ( !strcmp((const char *)(*(_QWORD *)(*(_QWORD *)(i + 104) + 8LL) + *(_QWORD *)(v113 + 8)), "libc.so.6") )
          v106[4] = (void *)i;
      }
    }
  }
  else
  {
    v117 = *(_QWORD *)(i + 176);
    if ( v117 )
    {
      sub_6FF90(*(_QWORD **)(i + 56), (_BYTE *)(*(_QWORD *)(*(_QWORD *)(i + 104) + 8LL) + *(_QWORD *)(v117 + 8)));
      goto LABEL_176;
    }
  }
  if ( *(_QWORD *)(i + 1080) && ((*(_BYTE *)(i + 796) & 3) == 1 || qword_C0378) )
    *(_QWORD *)(i + 1112) = sub_4D380();
  sub_74270((_QWORD *)i, a17);
  return i;
}
// 71B1F: write access to const memory at BDC30 has been detected
// 70BAE: variable 'v19' is possibly undefined
// 70BAE: variable 'v20' is possibly undefined
// 20: using guessed type __int64 qword_20[];
// 28: using guessed type __int64 qword_28[];
// 9050: using guessed type __int64 __fastcall sub_9050(_QWORD, _QWORD, _QWORD);
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// BDC30: using guessed type int dword_BDC30;
// BF068: using guessed type int dword_BF068;
// BF078: using guessed type Elf64_Rela *off_BF078;
// BF090: using guessed type __int64 qword_BF090;
// BF098: using guessed type __int64 (__fastcall *off_BF098)(_QWORD);
// BF0E0: using guessed type void *off_BF0E0;
// C0378: using guessed type __int64 qword_C0378;
// C1310: using guessed type __int64 qword_C1310;
// C14A0: using guessed type __int64 qword_C14A0;
// C14B4: using guessed type int dword_C14B4;

//----- (0000000000071D90) ----------------------------------------------------
__int64 __fastcall sub_71D90(__int64 a1, _BYTE *a2, char a3, int a4, int a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v15; // r12
  _QWORD *i; // r15
  __int64 v19; // rax
  char v21; // r15
  double v22; // xmm4_8
  double v23; // xmm5_8
  const char *v24; // rdi
  __int64 v25; // rsi
  double v26; // xmm4_8
  double v27; // xmm5_8
  char *v28; // rax
  double v29; // xmm4_8
  double v30; // xmm5_8
  char *v31; // r14
  __int64 v32; // rdx
  _QWORD *v33; // rcx
  __int64 v34; // r8
  __int64 v35; // r9
  unsigned int v36; // eax
  __int64 v37; // rax
  __int64 *v38; // r11
  __int64 v39; // rax
  char v40; // al
  __int64 v41; // rax
  unsigned int v42; // eax
  __int64 v43; // rax
  __int64 *v44; // r15
  __int64 v45; // rax
  unsigned int v46; // eax
  __int64 v47; // rax
  const char *v48; // rdi
  unsigned int v49; // eax
  const char *v50; // rcx
  __int64 v51; // r8
  char *v52; // rdi
  __int64 v53; // rax
  unsigned int v54; // eax
  __int64 v55; // rax
  __int64 v56; // [rsp+48h] [rbp-3F8h]
  _QWORD *v57; // [rsp+48h] [rbp-3F8h]
  __int64 v58; // [rsp+48h] [rbp-3F8h]
  __int64 v59; // [rsp+50h] [rbp-3F0h]
  __int64 v60; // [rsp+50h] [rbp-3F0h]
  __int64 v61; // [rsp+50h] [rbp-3F0h]
  _BYTE *v63; // [rsp+60h] [rbp-3E0h]
  unsigned int v64; // [rsp+60h] [rbp-3E0h]
  __int64 v65; // [rsp+68h] [rbp-3D8h]
  _QWORD *v66; // [rsp+78h] [rbp-3C8h]
  char v68; // [rsp+87h] [rbp-3B9h]
  __int64 v69; // [rsp+88h] [rbp-3B8h]
  char v70; // [rsp+A7h] [rbp-399h] BYREF
  char *v71; // [rsp+A8h] [rbp-398h] BYREF
  __int64 (**v72)(void); // [rsp+B0h] [rbp-390h] BYREF
  char v73[816]; // [rsp+B8h] [rbp-388h] BYREF

  if ( a6 < 0 )
    sub_CF00("nsid >= 0", "dl-load.c", 2007LL, "_dl_map_object");
  if ( a6 >= (unsigned __int64)qword_BF088 )
    sub_CF00("nsid < GL(dl_nns)", "dl-load.c", 2008LL, "_dl_map_object");
  v15 = a1;
  for ( i = *(&off_BF0E0 + 19 * a6); i; i = (_QWORD *)i[3] )
  {
    if ( (((*((_BYTE *)i + 797) >> 1) | (*((_BYTE *)i + 797) >> 5)) & 1) == 0 )
    {
      if ( (unsigned int)sub_772B0((__int64)a2, (__int64)i) )
        return (__int64)i;
      if ( (*((_BYTE *)i + 797) & 1) == 0 )
      {
        v19 = i[22];
        if ( v19 )
        {
          v63 = (_BYTE *)(*(_QWORD *)(i[13] + 8LL) + *(_QWORD *)(v19 + 8));
          if ( !(unsigned int)sub_91B0(a2, v63) )
          {
            sub_6FF90((_QWORD *)i[7], v63);
            *((_BYTE *)i + 797) |= 1u;
            return (__int64)i;
          }
        }
      }
    }
  }
  v21 = dword_C14B4;
  v64 = a5 & 0x10000000;
  if ( (dword_C14B4 & 0x40) != 0 )
  {
    if ( a1 )
    {
      v50 = *(const char **)(a1 + 8);
      v51 = *(_QWORD *)(a1 + 48);
      if ( !*v50 )
      {
        v50 = (const char *)off_BEFD8;
        if ( !off_BEFD8 )
          v50 = "<main program>";
      }
      v52 = "\nfile=%s [%lu];  needed by %s [%lu]\n";
      if ( v64 )
        v52 = "\nfile=%s [%lu];  dynamically loaded by %s [%lu]\n";
      sub_76EA0(v52, a2, a6, v50, v51);
      v70 = 0;
      if ( sub_9210(a2, 47LL) )
      {
LABEL_16:
        v71 = sub_702B0(v15, a2);
        v24 = v71;
        if ( v71 )
        {
LABEL_17:
          LODWORD(v25) = sub_6F2A0(v24, (__int64)v73, &v70, 1, a7, a8, a9, a10, v22, v23, a13, a14);
          if ( (_DWORD)v25 != -1 )
          {
            if ( v64 )
              v15 = 0LL;
            goto LABEL_20;
          }
          HIDWORD(v24) = HIDWORD(v71);
          sub_21B70(v71);
        }
LABEL_22:
        if ( v64 )
          v15 = 0LL;
        goto LABEL_24;
      }
      v69 = strlen((__int64)a2) + 1;
      if ( (dword_C14B4 & 1) == 0 )
        goto LABEL_31;
    }
    else
    {
      v70 = 0;
      if ( sub_9210(a2, 47LL) )
        goto LABEL_21;
      v69 = strlen((__int64)a2) + 1;
      if ( (v21 & 1) == 0 )
      {
LABEL_100:
        v66 = off_BF0E0;
        goto LABEL_60;
      }
    }
    goto LABEL_87;
  }
  v70 = 0;
  if ( sub_9210(a2, 47LL) )
  {
    if ( a1 )
      goto LABEL_16;
LABEL_21:
    v71 = (char *)sub_23100(a2);
    v24 = v71;
    if ( v71 )
      goto LABEL_17;
    goto LABEL_22;
  }
  v69 = strlen((__int64)a2) + 1;
  if ( (v21 & 1) != 0 )
LABEL_87:
    sub_76EA0("find library=%s [%lu]; searching\n", a2, a6);
  if ( !v15 )
    goto LABEL_100;
LABEL_31:
  if ( *(_QWORD *)(v15 + 296) )
  {
    if ( &dword_0 != (__int64 (**)(void))-1LL )
      goto LABEL_33;
    goto LABEL_53;
  }
  v68 = 0;
  v66 = off_BF0E0;
  v65 = v15;
  do
  {
    v37 = *(_QWORD *)(v15 + 808);
    v38 = (__int64 *)(v15 + 808);
    if ( v37 == -1 )
      goto LABEL_45;
    if ( !v37 )
    {
      v39 = *(_QWORD *)(v15 + 184);
      if ( !v39 )
      {
        *(_QWORD *)(v15 + 808) = -1LL;
        goto LABEL_45;
      }
      v40 = sub_70670(
              v15 + 808,
              (_BYTE *)(*(_QWORD *)(*(_QWORD *)(v15 + 104) + 8LL) + *(_QWORD *)(v39 + 8)),
              v15,
              (__int64)"RPATH");
      v38 = (__int64 *)(v15 + 808);
      if ( !v40 )
        goto LABEL_45;
    }
    v36 = sub_6F920((__int64)a2, v69, a5, v38, &v71, (__int64)v73, a7, a8, a9, a10, v26, v27, a13, a14, v65, &v70);
    v34 = v56;
    v35 = v60;
    if ( v36 != -1 )
    {
      v15 = v65;
      v25 = v36;
      goto LABEL_36;
    }
    v68 |= v66 == (_QWORD *)v15;
LABEL_45:
    v15 = *(_QWORD *)(v15 + 736);
  }
  while ( v15 );
  v15 = v65;
  if ( v68 )
    goto LABEL_67;
LABEL_60:
  v33 = v66;
  if ( v66 )
  {
    if ( (*((_BYTE *)v66 + 796) & 3) != 2 )
    {
      v43 = v66[101];
      v44 = v66 + 101;
      if ( v43 != -1 )
      {
        if ( v43 )
          goto LABEL_64;
        v55 = v66[23];
        if ( !v55 )
        {
          v66[101] = -1LL;
          goto LABEL_67;
        }
        if ( !(unsigned __int8)sub_70670(
                                 (__int64)v44,
                                 (_BYTE *)(*(_QWORD *)(v66[13] + 8LL) + *(_QWORD *)(v55 + 8)),
                                 (__int64)v66,
                                 (__int64)"RPATH") )
          goto LABEL_67;
LABEL_64:
        v45 = (__int64)v66;
        if ( v15 )
          v45 = v15;
        v46 = sub_6F920((__int64)a2, v69, a5, v44, &v71, (__int64)v73, a7, a8, a9, a10, v26, v27, a13, a14, v45, &v70);
        v33 = v57;
        v25 = v46;
        if ( v46 != -1 )
          goto LABEL_36;
      }
    }
  }
LABEL_67:
  if ( &dword_0 == (__int64 (**)(void))-1LL )
  {
    if ( v15 )
      goto LABEL_53;
    goto LABEL_72;
  }
  if ( !v15 )
  {
    v42 = sub_6F920(
            (__int64)a2,
            v69,
            a5,
            &qword_BDC20,
            &v71,
            (__int64)v73,
            a7,
            a8,
            a9,
            a10,
            v26,
            v27,
            a13,
            a14,
            (__int64)off_BF0E0,
            &v70);
    goto LABEL_56;
  }
LABEL_33:
  v25 = (unsigned int)sub_6F920(
                        (__int64)a2,
                        v69,
                        a5,
                        &qword_BDC20,
                        &v71,
                        (__int64)v73,
                        a7,
                        a8,
                        a9,
                        a10,
                        v26,
                        v27,
                        a13,
                        a14,
                        v15,
                        &v70);
  v32 = v59;
  if ( (_DWORD)v25 == -1 )
  {
LABEL_53:
    v41 = *(_QWORD *)(v15 + 952);
    if ( v41 != -1 )
    {
      if ( v41 )
      {
LABEL_55:
        v42 = sub_6F920(
                (__int64)a2,
                v69,
                a5,
                (__int64 *)(v15 + 952),
                &v71,
                (__int64)v73,
                a7,
                a8,
                a9,
                a10,
                v26,
                v27,
                a13,
                a14,
                v15,
                &v70);
LABEL_56:
        v25 = v42;
        if ( v42 != -1 )
          goto LABEL_36;
      }
      else
      {
        v47 = *(_QWORD *)(v15 + 296);
        if ( v47 )
        {
          if ( (unsigned __int8)sub_70670(
                                  v15 + 952,
                                  (_BYTE *)(*(_QWORD *)(*(_QWORD *)(v15 + 104) + 8LL) + *(_QWORD *)(v47 + 8)),
                                  v15,
                                  (__int64)"RUNPATH") )
            goto LABEL_55;
        }
        else
        {
          *(_QWORD *)(v15 + 952) = -1LL;
        }
      }
    }
LABEL_72:
    v71 = 0LL;
    if ( (a5 & 0x4000000) == 0 && !dword_C132C )
    {
      v48 = (const char *)sub_79440(a2);
      if ( v48 )
      {
        if ( v15 )
        {
          if ( (*(_BYTE *)(v15 + 997) & 8) == 0 )
          {
LABEL_77:
            v49 = sub_6F2A0(v48, (__int64)v73, &v70, 0, a7, a8, a9, a10, v26, v27, a13, a14);
            v25 = v49;
            if ( v49 != -1 )
            {
              v71 = (char *)v48;
              goto LABEL_36;
            }
            goto LABEL_91;
          }
        }
        else if ( (*((_BYTE *)off_BF0E0 + 997) & 8) == 0 )
        {
          goto LABEL_77;
        }
        if ( *(_QWORD *)v48 != 0x62696C2F7273752FLL || v48[8] != 47 )
          goto LABEL_77;
LABEL_91:
        sub_21B70(v48);
      }
    }
    v53 = v15;
    if ( (v15 || (v53 = (__int64)*(&off_BF0E0 + 19 * a6)) != 0) && (*(_BYTE *)(v53 + 997) & 8) != 0 )
    {
      v25 = 0xFFFFFFFFLL;
    }
    else
    {
      v25 = 0xFFFFFFFFLL;
      if ( &dword_0 != (__int64 (**)(void))-1LL )
      {
        v54 = sub_6F920(
                (__int64)a2,
                v69,
                a5,
                &qword_BDBF0,
                &v71,
                (__int64)v73,
                a7,
                a8,
                a9,
                a10,
                v26,
                v27,
                a13,
                a14,
                v53,
                &v70);
        v34 = v58;
        v35 = v61;
        v25 = v54;
      }
    }
  }
LABEL_36:
  if ( (dword_C14B4 & 1) != 0 )
    sub_76EA0((_BYTE *)&off_8FB58 + 2, v25, v32, v33, v34, v35);
  v24 = (const char *)v64;
  if ( v64 )
    v15 = 0LL;
  if ( (_DWORD)v25 != -1 )
  {
LABEL_20:
    v72 = &dword_0;
    return sub_70AE0(
             a2,
             v25,
             (__int64)v73,
             v71,
             (_QWORD *)v15,
             a3,
             a7,
             a8,
             a9,
             a10,
             v26,
             v27,
             a13,
             a14,
             a5,
             (__int64)&v72,
             a6);
  }
LABEL_24:
  if ( !a4 || (dword_C14B4 & 0x800) != 0 )
  {
    if ( v70 )
      sub_50110(0LL, a2, 0LL, "wrong ELF class: ELFCLASS32");
    LODWORD(v24) = __readfsdword(0xFFFFFFC0);
    sub_50110((__int64)v24, a2, 0LL, "cannot open shared object file");
  }
  v28 = (char *)sub_23100(a2);
  v31 = v28;
  if ( !v28 || (i = sub_74330(v28, a2, a3, (_QWORD *)v15, a5, a6, a7, a8, a9, a10, v29, v30, a13, a14)) == 0LL )
  {
    sub_21B70(v31);
    sub_50110(12LL, a2, 0LL, "cannot create shared object descriptor");
  }
  *((_WORD *)i + 398) |= 0x204u;
  i[98] = &dword_A6380;
  *((_DWORD *)i + 189) = 1;
  sub_74270(i, a6);
  return (__int64)i;
}
// 7206A: conditional instruction was optimized away because of 'r12.8!=0'
// 71EEE: variable 'v22' is possibly undefined
// 71EEE: variable 'v23' is possibly undefined
// 71F38: variable 'v26' is possibly undefined
// 71F38: variable 'v27' is possibly undefined
// 71FB1: variable 'v29' is possibly undefined
// 71FB1: variable 'v30' is possibly undefined
// 72061: variable 'v59' is possibly undefined
// 724EC: variable 'v32' is possibly undefined
// 724EC: variable 'v33' is possibly undefined
// 724EC: variable 'v34' is possibly undefined
// 724EC: variable 'v35' is possibly undefined
// 720FA: variable 'v56' is possibly undefined
// 720FC: variable 'v60' is possibly undefined
// 72280: variable 'v57' is possibly undefined
// 724B4: variable 'v58' is possibly undefined
// 724B6: variable 'v61' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// 9210: using guessed type __int64 __fastcall sub_9210(_QWORD, _QWORD);
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// 8FB58: using guessed type void *off_8FB58;
// A6380: using guessed type int dword_A6380;
// BD7E0: using guessed type int dword_BD7E0;
// BDBF0: using guessed type __int64 qword_BDBF0;
// BDC20: using guessed type __int64 qword_BDC20;
// BEFD8: using guessed type void *off_BEFD8;
// BF088: using guessed type __int64 qword_BF088;
// BF0E0: using guessed type void *off_BF0E0;
// C132C: using guessed type int dword_C132C;
// C14B4: using guessed type int dword_C14B4;

//----- (00000000000728F0) ----------------------------------------------------
unsigned int *__fastcall sub_728F0(__int64 a1, unsigned int *a2, __int64 a3, char a4, unsigned __int8 a5, unsigned int *a6, double xmm0_8_0, double xmm1_8_0, double xmm2_8_0, double xmm3_8_0, double xmm4_8_0, double a12, double a13, double a14, unsigned int a7, __int64 a8, __int64 a9, unsigned int **a10, _DWORD *a11)
{
  __int16 v20; // dx
  char v23; // cl
  __int64 v24; // rax
  __int16 v25; // r14
  __int64 v26; // rax
  int v27; // ebp
  __int64 v30; // rdi
  double v31; // xmm4_8
  double v32; // xmm5_8

  v20 = *((_WORD *)a6 + 3);
  v23 = a6[1] & 0xF;
  if ( *((_QWORD *)a6 + 1) || v23 == 6 || v20 == -15 )
  {
    if ( !((v20 == 0) & a5 | (((1127 >> v23) & 1) == 0)) && (a6 == a2 || !(unsigned int)sub_91B0(a8 + *a6, a1)) )
    {
      v24 = *(_QWORD *)(a9 + 832);
      if ( a3 )
      {
        if ( !v24 )
        {
          v30 = *(_QWORD *)(a3 + 16);
          if ( v30 && (unsigned int)sub_772B0(v30, a9) )
            sub_CF00(
              (__int64)"version->filename == NULL || ! _dl_name_match_p (version->filename, map)",
              (__int64)"dl-lookup.c",
              0x69u,
              "check_match",
              xmm0_8_0,
              xmm1_8_0,
              xmm2_8_0,
              xmm3_8_0,
              v31,
              v32,
              a13,
              a14);
          return a6;
        }
        v25 = *(_WORD *)(v24 + 2LL * a7);
        v26 = *(_QWORD *)(a9 + 744) + 24LL * (v25 & 0x7FFF);
        v27 = *(_DWORD *)(v26 + 8);
        if ( v27 == *(_DWORD *)(a3 + 8) && !(unsigned int)sub_91B0(*(_QWORD *)v26, *(_QWORD *)a3)
          || !(*(_DWORD *)(a3 + 12) | v27) && v25 >= 0 )
        {
          return a6;
        }
      }
      else
      {
        if ( !v24 || __SPAIR64__(*(_WORD *)(v24 + 2LL * a7) & 0x7FFF, a4 & 2) < 0x200000001LL )
          return a6;
        if ( *(__int16 *)(v24 + 2LL * a7) >= 0 && !(*a11)++ )
          *a10 = a6;
      }
    }
    return 0LL;
  }
  return 0LL;
}
// 72A77: variable 'v31' is possibly undefined
// 72A77: variable 'v32' is possibly undefined
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);

//----- (0000000000072A80) ----------------------------------------------------
__int64 __fastcall sub_72A80(unsigned __int8 *a1, unsigned __int64 a2, unsigned __int64 *a3, unsigned int *a4, unsigned int **a5, __int64 *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, __int64 a16, char a17, __int64 a18, int a19, __int64 a20)
{
  unsigned __int64 v20; // r12
  __int64 v24; // r13
  unsigned int v25; // edx
  __int64 v26; // rax
  __int64 v27; // rax
  unsigned __int64 v28; // rax
  __int64 v29; // rbx
  const char *v30; // rdx
  unsigned __int64 v31; // rsi
  __int64 v32; // rax
  unsigned int v33; // eax
  int v34; // er15
  __int64 v35; // rbp
  unsigned int *v36; // rax
  __int64 v37; // rdx
  unsigned __int64 v38; // rcx
  unsigned int *v39; // r9
  char v40; // al
  __int64 v42; // rax
  int v43; // ebp
  _DWORD *v44; // r14
  __int64 v45; // rdx
  unsigned int *v46; // rax
  __int64 v47; // rax
  unsigned __int64 v48; // rax
  __int64 v49; // r10
  unsigned __int64 v50; // rax
  __int64 v51; // rbx
  __int64 v52; // rbp
  unsigned __int64 v53; // r14
  void **v54; // r12
  u32 *v55; // r8
  unsigned __int64 v56; // rdx
  unsigned __int64 v57; // rax
  unsigned __int64 v58; // r15
  unsigned __int64 v59; // r14
  unsigned __int64 v60; // r13
  __int64 v61; // rbx
  __int64 v62; // rbp
  unsigned int *v63; // r12
  __int64 v64; // rdi
  unsigned __int64 v65; // r8
  __int64 v66; // rbp
  unsigned __int64 v67; // rcx
  unsigned __int64 v68; // r15
  __int64 v69; // rcx
  __int64 v70; // rsi
  unsigned int *v71; // rax
  unsigned int *v72; // rax
  unsigned __int64 v73; // rdi
  __int64 v74; // rax
  __int64 v75; // rax
  __int64 v76; // rax
  __int64 v77; // rax
  unsigned __int64 v78; // rdi
  unsigned __int8 *v79; // rax
  __int64 i; // rdx
  unsigned __int64 v81; // r12
  __int64 v82; // rdx
  __int64 v83; // rcx
  u32 *v84; // r8
  __int64 v85; // r9
  double v86; // xmm4_8
  double v87; // xmm5_8
  __int64 v88; // r10
  unsigned int *v89; // r9
  unsigned int *v90; // rsi
  __int64 v91; // rdi
  __int64 v92; // r11
  __int64 v93; // rbp
  unsigned __int64 v94; // rcx
  unsigned __int64 v95; // rax
  void **v96; // r13
  __int64 v97; // rax
  int v98; // [rsp+8h] [rbp-B0h]
  unsigned int *v99; // [rsp+8h] [rbp-B0h]
  unsigned int *v100; // [rsp+8h] [rbp-B0h]
  __int64 v101; // [rsp+10h] [rbp-A8h]
  __int64 v102; // [rsp+18h] [rbp-A0h]
  unsigned int *v103; // [rsp+18h] [rbp-A0h]
  unsigned __int64 v105; // [rsp+20h] [rbp-98h]
  unsigned int *v106; // [rsp+20h] [rbp-98h]
  __int64 v108; // [rsp+28h] [rbp-90h]
  unsigned __int64 v109; // [rsp+30h] [rbp-88h]
  unsigned int *v110; // [rsp+30h] [rbp-88h]
  unsigned __int64 v111; // [rsp+30h] [rbp-88h]
  unsigned int *v112; // [rsp+30h] [rbp-88h]
  unsigned int *v113; // [rsp+38h] [rbp-80h]
  unsigned int *v114; // [rsp+38h] [rbp-80h]
  unsigned int *v115; // [rsp+38h] [rbp-80h]
  unsigned int *v116; // [rsp+38h] [rbp-80h]
  __int64 v117; // [rsp+40h] [rbp-78h]
  unsigned __int64 v118; // [rsp+40h] [rbp-78h]
  int v122; // [rsp+74h] [rbp-44h] BYREF
  unsigned int *v123[8]; // [rsp+78h] [rbp-40h] BYREF
  __int64 v124; // [rsp+C0h] [rbp+8h]
  __int64 v125; // [rsp+C0h] [rbp+8h]
  __int64 v126; // [rsp+C0h] [rbp+8h]
  __int64 v127; // [rsp+D8h] [rbp+20h]
  int v128; // [rsp+E0h] [rbp+28h]

  v20 = *((unsigned int *)a6 + 2);
  v24 = *a6;
  v109 = a2 >> 6;
  while ( 1 )
  {
    v29 = *(_QWORD *)(*(_QWORD *)(v24 + 8 * a15) + 40LL);
    if ( v29 == a18 )
      goto LABEL_5;
    v98 = a19 & 2;
    if ( (a19 & 2) != 0 && (*(_BYTE *)(v29 + 796) & 3) == 0 )
      goto LABEL_5;
    if ( (*(_BYTE *)(v29 + 797) & 0x20) != 0 )
      goto LABEL_5;
    if ( (dword_C14B4 & 8) != 0 )
    {
      v30 = *(const char **)(v29 + 8);
      if ( !*v30 )
      {
        v30 = (const char *)off_BEFD8;
        if ( !off_BEFD8 )
          v30 = "<main program>";
      }
      v128 = a19;
      sub_76EA0("symbol=%s;  lookup in file=%s [%lu]\n", (const char *)a1, v30, *(_QWORD *)(v29 + 48));
      a19 = v128;
    }
    v25 = *(_DWORD *)(v29 + 756);
    if ( !v25 )
      goto LABEL_5;
    v26 = *(_QWORD *)(v29 + 112);
    v122 = 0;
    v123[0] = 0LL;
    v102 = *(_QWORD *)(v26 + 8);
    v101 = *(_QWORD *)(*(_QWORD *)(v29 + 104) + 8LL);
    v27 = *(_QWORD *)(v29 + 768);
    if ( v27 )
    {
      v28 = *(_QWORD *)(v27 + 8LL * (*(_DWORD *)(v29 + 760) & (unsigned int)v109));
      if ( ((unsigned __int8)(v28 >> (a2 >> *(_DWORD *)(v29 + 764))) & (unsigned __int8)(v28 >> a2) & 1) != 0 )
      {
        v38 = v25;
        v42 = *(unsigned int *)(*(_QWORD *)(v29 + 776) + 4 * (a2 % v25));
        if ( (_DWORD)v42 )
        {
          v125 = a15;
          v43 = a19;
          v44 = (_DWORD *)(*(_QWORD *)(v29 + 784) + 4 * v42);
          while ( 1 )
          {
            v45 = (unsigned int)*v44;
            if ( !((a2 ^ v45) >> 1) )
            {
              v46 = sub_728F0(
                      (__int64)a1,
                      a4,
                      a16,
                      a17,
                      v43,
                      (unsigned int *)(v102 + 24LL * (unsigned int)(((__int64)v44 - *(_QWORD *)(v29 + 784)) >> 2)),
                      a7,
                      a8,
                      a9,
                      a10,
                      a11,
                      a12,
                      a13,
                      a14,
                      ((__int64)v44 - *(_QWORD *)(v29 + 784)) >> 2,
                      v101,
                      v29,
                      v123,
                      &v122);
              if ( v46 )
              {
                a19 = v43;
                a15 = v125;
                v39 = v46;
                goto LABEL_23;
              }
              LODWORD(v45) = *v44;
            }
            ++v44;
            v37 = v45 & 1;
            if ( (_DWORD)v37 )
            {
              a19 = v43;
              a15 = v125;
              goto LABEL_63;
            }
          }
        }
      }
      goto LABEL_5;
    }
    v31 = v25;
    if ( *a3 == 0xFFFFFFFF )
    {
      v32 = 0LL;
      v73 = *a1;
      if ( *a1 )
      {
        v74 = a1[1];
        if ( (_BYTE)v74 )
        {
          v73 = v74 + 16 * v73;
          v75 = a1[2];
          if ( (_BYTE)v75 )
          {
            v73 = v75 + 16 * v73;
            v76 = a1[3];
            if ( (_BYTE)v76 )
            {
              v73 = v76 + 16 * v73;
              v77 = a1[4];
              if ( (_BYTE)v77 )
              {
                v78 = v77 + 16 * v73;
                v79 = a1 + 5;
                for ( i = a1[5]; (_BYTE)i; i = *v79 )
                {
                  ++v79;
                  v78 = (16 * v78 + i) ^ ((16 * v78 + i) >> 24) & 0xF0;
                }
                v73 = v78 & 0xFFFFFFF;
              }
            }
          }
        }
        v32 = 4 * (v73 % v31);
      }
      *a3 = v73;
    }
    else
    {
      v32 = 4 * (*a3 % v25);
    }
    v33 = *(_DWORD *)(*(_QWORD *)(v29 + 784) + v32);
    if ( v33 )
    {
      v127 = a18;
      v34 = a19;
      v124 = a15;
      do
      {
        v35 = v33;
        v36 = sub_728F0(
                (__int64)a1,
                a4,
                a16,
                a17,
                v34,
                (unsigned int *)(v102 + 24LL * v33),
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14,
                v33,
                v101,
                v29,
                v123,
                &v122);
        if ( v36 )
        {
          a19 = v34;
          v39 = v36;
          a15 = v124;
          a18 = v127;
          goto LABEL_23;
        }
        v33 = *(_DWORD *)(*(_QWORD *)(v29 + 776) + 4 * v35);
      }
      while ( v33 );
      a19 = v34;
      a15 = v124;
      a18 = v127;
LABEL_63:
      if ( v122 == 1 )
      {
        v39 = v123[0];
        if ( v123[0] )
          break;
      }
    }
LABEL_5:
    if ( v20 <= ++a15 )
      return 0LL;
  }
LABEL_23:
  if ( !a20 && (*(_BYTE *)(v29 + 796) & 3) == 0 && a19 == 4 )
  {
    v37 = *(_QWORD *)(v29 + 120);
    if ( v37 )
    {
      v47 = *(_QWORD *)(v29 + 128);
      if ( v47 )
      {
        v48 = *(_QWORD *)(v47 + 8);
        if ( v48 )
        {
          v49 = *(_QWORD *)(v37 + 8);
          v37 = (0xAAAAAAAAAAAAAAABLL * (unsigned __int128)v48) >> 64;
          v50 = v48 / 0x18;
          if ( (_DWORD)v50 )
          {
            v117 = v29;
            v51 = v49;
            v126 = a15;
            v113 = v39;
            v52 = v49 + 24LL * (unsigned int)(v50 - 1) + 24;
            do
            {
              v38 = *(_QWORD *)(v51 + 8);
              if ( (unsigned int)v38 <= 0x24
                && (unsigned int)v38 == 5LL
                && ((0x1000070080uLL >> v38) & 1) == 0
                && !(unsigned int)sub_91B0(v101 + *(unsigned int *)(v102 + 24 * HIDWORD(v38)), a1) )
              {
                a19 = 4;
                a15 = v126;
                goto LABEL_5;
              }
              v51 += 24LL;
            }
            while ( v51 != v52 );
            a19 = 4;
            v39 = v113;
            v29 = v117;
            a15 = v126;
          }
        }
      }
    }
  }
  if ( (*((_BYTE *)v39 + 5) & 3u) - 1 <= 1 )
    goto LABEL_5;
  v40 = *((_BYTE *)v39 + 4) >> 4;
  if ( v40 == 2 )
  {
    if ( !dword_C14AC )
      goto LABEL_28;
    if ( !*a5 )
    {
      *a5 = v39;
      a5[1] = (unsigned int *)v29;
    }
    goto LABEL_5;
  }
  if ( v40 != 10 )
  {
    if ( v40 == 1 )
      goto LABEL_28;
    goto LABEL_5;
  }
  v53 = a2;
  v108 = *(_QWORD *)(v29 + 48);
  v54 = &off_BF0E0 + 19 * v108;
  v55 = (u32 *)v54[11];
  v103 = (unsigned int *)v54[10];
  if ( !v103 )
  {
    v106 = v39;
    v97 = sub_22260(0x20uLL, 0x1FuLL, a7, a8, a9, a10, a11, a12, a13, a14, v37, v38, v55, (__int64)v39);
    v103 = (unsigned int *)v97;
    if ( v97 )
    {
      v54[10] = (void *)v97;
      v54[11] = &off_18 + 7;
      v39 = v106;
      v65 = 31LL;
      v54[13] = sub_21B70;
      v68 = v53 % 0x1F;
      v66 = (__int64)v53 % 29 + 1;
      goto LABEL_67;
    }
LABEL_117:
    sub_77200("out of memory\n");
  }
  v110 = v39;
  v114 = (unsigned int *)v29;
  v56 = v53 % ((unsigned __int64)v55 - 2);
  v118 = v53 % (unsigned __int64)v55;
  v57 = v53;
  v58 = (unsigned __int64)v54[11];
  v59 = v53 % (unsigned __int64)v55;
  v60 = v57;
  v61 = v56 + 1;
  v62 = 32 * (v56 + 1);
LABEL_55:
  v63 = &v103[8 * v59];
  while ( 1 )
  {
    v64 = *((_QWORD *)v63 + 1);
    if ( v60 != *v63 )
    {
      if ( v64 )
        goto LABEL_57;
      v65 = v58;
      v66 = v61;
      v39 = v110;
      v67 = 3 * v58;
      v29 = (__int64)v114;
      v68 = v118;
      v53 = v60;
      if ( v67 > 4 * (__int64)*(&off_BF0E0 + 19 * v108 + 12) )
      {
LABEL_67:
        v69 = v101 + *v39;
        v70 = 32 * v66;
        if ( v98 )
        {
LABEL_68:
          v71 = &v103[8 * v68];
          while ( *((_QWORD *)v71 + 1) )
          {
            v68 += v66;
            v71 = (unsigned int *)((char *)v71 + v70);
            if ( v65 <= v68 )
            {
              v68 -= v65;
              goto LABEL_68;
            }
          }
          *v71 = v53;
          *((_QWORD *)v71 + 1) = v69;
          *((_QWORD *)v71 + 2) = a4;
          *((_QWORD *)v71 + 3) = a20;
        }
        else
        {
LABEL_74:
          v72 = &v103[8 * v68];
          while ( *((_QWORD *)v72 + 1) )
          {
            v68 += v66;
            v72 = (unsigned int *)((char *)v72 + v70);
            if ( v65 <= v68 )
            {
              v68 -= v65;
              goto LABEL_74;
            }
          }
          *v72 = v53;
          *((_QWORD *)v72 + 1) = v69;
          *((_QWORD *)v72 + 2) = v39;
          *((_QWORD *)v72 + 3) = v29;
          if ( (*(_BYTE *)(v29 + 796) & 3) == 2 && !*(_BYTE *)(v29 + 799) )
          {
            if ( (a17 & 8) != 0 )
            {
              if ( !*(_BYTE *)(v29 + 800) )
              {
                if ( (dword_C14B4 & 4) != 0 )
                {
                  v100 = v39;
                  sub_76EA0(
                    "marking %s [%lu] as NODELETE due to unique symbol\n",
                    *(const char **)(v29 + 8),
                    *(_QWORD *)(v29 + 48));
                  v39 = v100;
                }
                *(_BYTE *)(v29 + 800) = 1;
              }
            }
            else
            {
              if ( (dword_C14B4 & 4) != 0 )
              {
                v99 = v39;
                sub_76EA0(
                  "marking %s [%lu] as NODELETE due to unique symbol\n",
                  *(const char **)(v29 + 8),
                  *(_QWORD *)(v29 + 48));
                v39 = v99;
              }
              *(_BYTE *)(v29 + 799) = 1;
            }
          }
        }
        *(&off_BF0E0 + 19 * v108 + 12) = (char *)*(&off_BF0E0 + 19 * v108 + 12) + 1;
LABEL_28:
        *a5 = v39;
        a5[1] = (unsigned int *)v29;
        return 1LL;
      }
      v115 = v110;
      v111 = v65;
      v81 = sub_77320(v65 + 1);
      v88 = sub_22260(0x20uLL, v81, a7, a8, a9, a10, v86, v87, a13, a14, v82, v83, v84, v85);
      if ( v88 )
      {
        v89 = v115;
        v105 = v81 - 2;
        v90 = v103;
        if ( v111 )
        {
          do
          {
            v91 = *((_QWORD *)v90 + 1);
            if ( v91 )
            {
              v92 = *((_QWORD *)v90 + 3);
              v93 = *((_QWORD *)v90 + 2);
              v94 = *v90 % v81;
LABEL_101:
              v95 = v88 + 32 * v94;
              while ( *(_QWORD *)(v95 + 8) )
              {
                v94 += *v90 % v105 + 1;
                v95 += 32 * (*v90 % v105 + 1);
                if ( v81 <= v94 )
                {
                  v94 -= v81;
                  goto LABEL_101;
                }
              }
              *(_DWORD *)v95 = *v90;
              *(_QWORD *)(v95 + 8) = v91;
              *(_QWORD *)(v95 + 16) = v93;
              *(_QWORD *)(v95 + 24) = v92;
            }
            v90 += 8;
          }
          while ( &v103[8 * v111] != v90 );
          v89 = v115;
        }
        v116 = (unsigned int *)v88;
        v112 = v89;
        v96 = &off_BF0E0 + 19 * v108;
        ((void (__fastcall *)(unsigned int *, unsigned int *))v96[13])(v103, v90);
        v65 = v81;
        v39 = v112;
        v96[11] = (void *)v81;
        v96[13] = sub_21B70;
        v96[10] = v116;
        v103 = v116;
        v68 = v53 % v81;
        v66 = v53 % v105 + 1;
        goto LABEL_67;
      }
      goto LABEL_117;
    }
    if ( !(unsigned int)sub_91B0(v64, a1) )
      break;
LABEL_57:
    v59 += v61;
    v63 = (unsigned int *)((char *)v63 + v62);
    if ( v58 <= v59 )
    {
      v59 -= v58;
      goto LABEL_55;
    }
  }
  if ( v98 )
  {
    *a5 = v110;
    a5[1] = v114;
  }
  else
  {
    *a5 = (unsigned int *)*((_QWORD *)v63 + 2);
    a5[1] = (unsigned int *)*((_QWORD *)v63 + 3);
  }
  return 1LL;
}
// 72CC5: variable 'a11' is possibly undefined
// 72CC5: variable 'a12' is possibly undefined
// 7339F: variable 'v86' is possibly undefined
// 7339F: variable 'v87' is possibly undefined
// 7339F: variable 'v82' is possibly undefined
// 7339F: variable 'v83' is possibly undefined
// 7339F: variable 'v84' is possibly undefined
// 7339F: variable 'v85' is possibly undefined
// 734F7: variable 'v37' is possibly undefined
// 734F7: variable 'v38' is possibly undefined
// 18: using guessed type void (__fastcall __noreturn *off_18)();
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// 9228: using guessed type __int64 __fastcall sub_9228(_QWORD);
// 9248: using guessed type __int64 __fastcall sub_9248(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// BEFD8: using guessed type void *off_BEFD8;
// BF0E0: using guessed type void *off_BF0E0;
// C14AC: using guessed type int dword_C14AC;
// C14B4: using guessed type int dword_C14B4;

//----- (0000000000073690) ----------------------------------------------------
__int64 __fastcall sub_73690(unsigned __int8 *a1, __int64 a2, unsigned int **a3, __int64 **a4, const char **a5, int a6, __m128 a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, int a15, __int64 a16)
{
  unsigned __int8 *v16; // r13
  int v18; // edx
  unsigned __int8 *v19; // rcx
  unsigned int v20; // eax
  unsigned __int64 v21; // rbx
  __int64 v22; // rcx
  __int64 *v23; // r9
  __int64 v24; // rax
  __int64 **v25; // rbp
  __int64 v26; // rsi
  __int64 v27; // r14
  int v28; // ebp
  __int64 *v30; // r9
  __int64 v31; // rdx
  __int64 **v32; // r15
  int v33; // eax
  __int64 v34; // rdx
  const char *v35; // rcx
  const char *v36; // r9
  const char *v37; // rsi
  u32 *v38; // r8
  __int64 *v39; // rax
  __int64 *v40; // rbx
  __int64 v41; // rax
  __int64 v42; // rdx
  unsigned int *v43; // rax
  u32 v44; // er9
  _QWORD *v45; // rax
  u32 *v46; // r8
  __int64 v47; // rax
  u32 v49; // eax
  const char *v50; // rcx
  const char *v51; // rsi
  volatile __int32 *v52; // rax
  signed __int64 v53; // rax
  __int64 *v54; // rdx
  __int64 v55; // rcx
  int v56; // ebx
  unsigned int v57; // edx
  unsigned int v58; // ebx
  __int64 v59; // rax
  __int64 v60; // rdx
  double v61; // xmm4_8
  double v62; // xmm5_8
  u32 v63; // er9
  _DWORD *v64; // rcx
  u32 *v65; // r8
  u32 v66; // er9
  __int64 v67; // rdi
  const char *v68; // r8
  const char *v69; // rsi
  const char *v70; // r9
  double v71; // xmm4_8
  double v72; // xmm5_8
  __int64 v73; // rdx
  const char *v74; // rsi
  const char *v75; // rcx
  __int64 v76; // [rsp-8h] [rbp-C0h]
  u32 v80; // [rsp+10h] [rbp-A8h]
  __int64 v82; // [rsp+20h] [rbp-98h]
  _DWORD *v83; // [rsp+20h] [rbp-98h]
  __int64 v84; // [rsp+28h] [rbp-90h]
  unsigned __int64 v85; // [rsp+48h] [rbp-70h] BYREF
  unsigned int *v86; // [rsp+50h] [rbp-68h] BYREF
  __int64 v87; // [rsp+58h] [rbp-60h]
  __m128i v88[5]; // [rsp+60h] [rbp-58h] BYREF

  v16 = a1;
  v18 = *a1;
  if ( (_BYTE)v18 )
  {
    v19 = a1;
    v20 = 5381;
    do
    {
      ++v19;
      v20 = v18 + 33 * v20;
      v18 = *v19;
    }
    while ( (_BYTE)v18 );
    v21 = v20;
  }
  else
  {
    v21 = 5381LL;
  }
  v86 = 0LL;
  v85 = 0xFFFFFFFFLL;
  v87 = 0LL;
  if ( a5 && (a15 & 2) != 0 )
    sub_CF00(
      (__int64)"version == NULL || !(flags & DL_LOOKUP_RETURN_NEWEST)",
      (__int64)"dl-lookup.c",
      0x34Du,
      "_dl_lookup_symbol_x",
      *(double *)a7.m128_u64,
      a8,
      a9,
      a10,
      a11,
      a12,
      a13,
      a14);
  v22 = (__int64)*a3;
  v23 = *a4;
  if ( a16 )
  {
    if ( a16 != *(_QWORD *)*v23 )
    {
      v34 = 0LL;
      do
        ++v34;
      while ( *(_QWORD *)(*v23 + 8 * v34) != a16 );
      v82 = v34;
      goto LABEL_10;
    }
  }
  else if ( !v23 )
  {
    goto LABEL_34;
  }
  v82 = 0LL;
LABEL_10:
  v24 = v82;
  v25 = a4;
  while ( 1 )
  {
    v26 = v21;
    if ( (unsigned int)sub_72A80(
                         a1,
                         v21,
                         &v85,
                         (unsigned int *)v22,
                         &v86,
                         v23,
                         *(double *)a7.m128_u64,
                         a8,
                         a9,
                         a10,
                         a11,
                         a12,
                         a13,
                         a14,
                         v24,
                         (__int64)a5,
                         a15,
                         a16,
                         a6,
                         a2) )
      break;
    v23 = v25[1];
    ++v25;
    v22 = (__int64)*a3;
    v24 = 0LL;
    if ( !v23 )
      goto LABEL_14;
  }
  v22 = (__int64)*a3;
LABEL_14:
  if ( !v86 )
  {
LABEL_34:
    if ( v22 && *(_BYTE *)(v22 + 4) >> 4 == 2 || (dword_C14B4 & 0x100) != 0 )
    {
      *a3 = 0LL;
      return 0LL;
    }
    if ( a2 )
    {
      v68 = (const char *)&unk_A6E65;
      v69 = *(const char **)(a2 + 8);
      v70 = (const char *)&unk_A6E65;
      if ( a5 )
      {
        v68 = ", version ";
        v70 = *a5;
        if ( !*a5 )
          v70 = (const char *)&unk_A6E65;
      }
      if ( *v69 )
      {
LABEL_153:
        sub_78F10(
          v88,
          (__int64)v69,
          "undefined symbol: %s%s%s",
          (__int64)a1,
          (__int64)v68,
          (__int64)v70,
          *(double *)a7.m128_u64,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14,
          (char)a5);
        sub_500B0(0, v88, "symbol lookup error", a7, a8, a9, a10, v71, v72, a13, a14);
      }
    }
    else
    {
      v68 = (const char *)&unk_A6E65;
      v70 = (const char *)&unk_A6E65;
      if ( a5 )
      {
        v68 = ", version ";
        v70 = *a5;
        if ( !*a5 )
          v70 = (const char *)&unk_A6E65;
      }
    }
    v69 = (const char *)off_BEFD8;
    if ( !off_BEFD8 )
      v69 = "<main program>";
    goto LABEL_153;
  }
  if ( v22 && (*(_BYTE *)(v22 + 5) & 3) == 3 )
  {
    if ( a6 == 1 )
    {
      if ( v87 != a2 )
      {
        v86 = (unsigned int *)v22;
        v87 = a2;
      }
      v27 = a2;
      v28 = 1;
      goto LABEL_19;
    }
    v88[0] = 0uLL;
    v30 = *a4;
    if ( !*a4 )
      goto LABEL_69;
    v31 = v82;
    v32 = a4;
    while ( 1 )
    {
      if ( (*(_BYTE *)(v22 + 4) & 0xF) != 1 || (v33 = 4, a6 != 4) )
        v33 = 1;
      v26 = v21;
      if ( (unsigned int)sub_72A80(
                           a1,
                           v21,
                           &v85,
                           (unsigned int *)v22,
                           (unsigned int **)v88,
                           v30,
                           *(double *)a7.m128_u64,
                           a8,
                           a9,
                           a10,
                           a11,
                           a12,
                           a13,
                           a14,
                           v31,
                           (__int64)a5,
                           a15,
                           a16,
                           v33,
                           0LL) )
        break;
      v30 = v32[1];
      ++v32;
      if ( !v30 )
        break;
      v22 = (__int64)*a3;
      v31 = 0LL;
    }
    if ( v88[0].m128i_i64[0] && v88[0].m128i_i64[1] != a2 )
    {
      v43 = *a3;
      v87 = a2;
      v27 = a2;
      v86 = v43;
    }
    else
    {
LABEL_69:
      v27 = v87;
    }
    v28 = 1;
  }
  else
  {
    v27 = v87;
    v28 = 0;
  }
  if ( (*(_BYTE *)(v27 + 796) & 3) == 2
    && a2 != v27
    && (a15 & 1) != 0
    && !*(_BYTE *)(v27 + 799)
    && ((a15 & 8) == 0 || !*(_BYTE *)(v27 + 800)) )
  {
    v38 = *(u32 **)(a2 + 976);
    v39 = *(__int64 **)(a2 + 968);
    v40 = v39;
    if ( v39 )
    {
      v41 = *v39;
      LODWORD(v42) = 0;
      if ( *v40 )
      {
        while ( v41 != v27 )
        {
          v42 = (unsigned int)(v42 + 1);
          v41 = v40[v42];
          if ( !v41 )
            goto LABEL_74;
        }
        goto LABEL_64;
      }
    }
LABEL_74:
    if ( v38 )
    {
      v44 = *v38;
      if ( *v38 )
      {
        v45 = v38 + 2;
        while ( *v45 != v27 )
        {
          if ( &v38[2 * v44 + 2] == (u32 *)++v45 )
            goto LABEL_81;
        }
        goto LABEL_64;
      }
    }
    else
    {
      v44 = 0;
    }
LABEL_81:
    v84 = *(_QWORD *)(v27 + 1144);
    if ( (a15 & 4) == 0 )
      goto LABEL_82;
    LODWORD(v52) = _InterlockedExchange(MK_FP(0, 28LL), 0);
    if ( (_DWORD)v52 == 2 )
    {
      v26 = 129LL;
      v53 = sys_futex((u32 *)(__readfsqword(0x10u) + 28), 129, 1u, 0LL, v38, v44);
    }
    v54 = *(__int64 **)(a2 + 968);
    if ( v54 != v40 )
    {
      if ( v54 )
      {
        v55 = *v54;
        if ( *v54 )
        {
          LODWORD(v26) = 0;
          while ( v27 != v55 )
          {
            v26 = (unsigned int)(v26 + 1);
            v55 = v54[v26];
            if ( !v55 )
              goto LABEL_124;
          }
          goto LABEL_120;
        }
      }
    }
LABEL_124:
    v22 = *(_QWORD *)(a2 + 976);
    if ( v22 )
    {
      v57 = *(_DWORD *)v22;
      if ( v38 == (u32 *)v22 )
      {
        if ( v44 < v57 )
        {
          v26 = (__int64)&v38[2 * v44];
          v22 = 0LL;
          while ( *(_QWORD *)(v26 + 8 * v22 + 8) != v27 )
          {
            if ( v57 <= v44 + (unsigned int)++v22 )
            {
LABEL_135:
              v44 = v57;
              goto LABEL_82;
            }
          }
          goto LABEL_120;
        }
      }
      else
      {
        if ( v57 )
        {
          v26 = v22 + 8;
          v22 += 8LL * (v57 - 1) + 16;
          while ( *(_QWORD *)v26 != v27 )
          {
            v26 += 8LL;
            if ( v26 == v22 )
              goto LABEL_135;
          }
LABEL_120:
          v56 = -(*(_QWORD *)(v27 + 1144) != v84);
          goto LABEL_121;
        }
        v44 = 0;
      }
    }
LABEL_82:
    v46 = *(u32 **)(a2 + 48);
    v47 = (__int64)*(&off_BF0E0 + 19 * (_QWORD)v46);
    if ( v47 )
    {
      while ( v47 != v27 )
      {
        v47 = *(_QWORD *)(v47 + 24);
        if ( !v47 )
          goto LABEL_95;
      }
      if ( v84 == *(_QWORD *)(v27 + 1144) )
      {
        if ( *(_BYTE *)(v27 + 799) || (a15 & 8) != 0 && *(_BYTE *)(v27 + 800) )
        {
LABEL_110:
          if ( (a15 & 4) != 0 )
            __writefsdword(0x1Cu, 1u);
          goto LABEL_64;
        }
        if ( (*(_BYTE *)(a2 + 796) & 3) != 2 )
        {
          if ( (dword_C14B4 & 4) == 0 )
            goto LABEL_92;
          if ( (a15 & 8) == 0 || !*(_BYTE *)(v27 + 800) )
          {
            v73 = *(_QWORD *)(v27 + 48);
            v74 = *(const char **)(v27 + 8);
            v75 = *(const char **)(a2 + 8);
            if ( *v75 )
              sub_76EA0("marking %s [%lu] as NODELETE due to reference to %s [%lu]\n", v74, v73, v75, v46);
            else
              sub_76EA0("marking %s [%lu] as NODELETE due to reference to main program\n", v74, v73);
LABEL_92:
            if ( (a15 & 8) == 0 )
            {
              *(_BYTE *)(v27 + 799) = 1;
              goto LABEL_110;
            }
            goto LABEL_123;
          }
          goto LABEL_123;
        }
        v49 = *(_DWORD *)(a2 + 984);
        if ( v49 <= v44 )
        {
          v58 = 10;
          if ( v49 )
            v58 = 2 * v49;
          v80 = v44;
          v59 = sub_21500(
                  (u32 *)(8LL * v58 + 8),
                  v26,
                  19LL * (_QWORD)v46,
                  v22,
                  v46,
                  v44,
                  *(double *)a7.m128_u64,
                  a8,
                  a9,
                  a10,
                  a11,
                  a12,
                  a13,
                  a14);
          v63 = v80;
          v64 = (_DWORD *)v59;
          if ( !v59 )
          {
            if ( (dword_C14B4 & 4) == 0 )
              goto LABEL_92;
            if ( (a15 & 8) == 0 || !*(_BYTE *)(v27 + 800) )
            {
              sub_76EA0(
                "marking %s [%lu] as NODELETE due to memory allocation failure\n",
                *(const char **)(v27 + 8),
                *(_QWORD *)(v27 + 48));
              goto LABEL_92;
            }
LABEL_123:
            *(_BYTE *)(v27 + 800) = 1;
            goto LABEL_110;
          }
          v65 = (u32 *)v80;
          if ( v80 )
          {
            v83 = (_DWORD *)v59;
            v26 = *(_QWORD *)(a2 + 976) + 8LL;
            memcpy((void *)(v59 + 8), (const void *)v26, 8LL * v80);
            v63 = v80;
            v64 = v83;
            v65 = (u32 *)v80;
          }
          v66 = v63 + 1;
          *(_QWORD *)&v64[2 * (_QWORD)v65 + 2] = v27;
          *v64 = v66;
          v67 = *(_QWORD *)(a2 + 976);
          *(_DWORD *)(a2 + 984) = v58;
          *(_QWORD *)(a2 + 976) = v64;
          if ( v67 )
            sub_78000(v67, v26, v60, (__int64)v64, v65, v66, *(double *)a7.m128_u64, a8, a9, a10, v61, v62, a13, a14);
        }
        else
        {
          *(_QWORD *)(*(_QWORD *)(a2 + 976) + 8LL * v44 + 8) = v27;
          **(_DWORD **)(a2 + 976) = v44 + 1;
        }
        if ( (dword_C14B4 & 0x40) != 0 )
        {
          v50 = *(const char **)(a2 + 8);
          if ( !*v50 )
          {
            v50 = (const char *)off_BEFD8;
            if ( !off_BEFD8 )
              v50 = "<main program>";
          }
          v51 = *(const char **)(v27 + 8);
          if ( !*v51 )
          {
            v51 = (const char *)off_BEFD8;
            if ( !off_BEFD8 )
              v51 = "<main program>";
          }
          sub_76EA0(
            "\nfile=%s [%lu];  needed by %s [%lu] (relocation dependency)\n\n",
            v51,
            *(_QWORD *)(v27 + 48),
            v50,
            *(_QWORD *)(a2 + 48));
        }
        goto LABEL_110;
      }
    }
LABEL_95:
    if ( (a15 & 4) == 0 )
      return sub_73690(a1, a2, a3, a4, a5, a6, *(double *)a7.m128_u64, a8, a9, a10, a11, a12, a13, a14, a15, a16);
    v56 = -1;
LABEL_121:
    __writefsdword(0x1Cu, 1u);
    if ( v56 != -1 )
    {
LABEL_64:
      v27 = v87;
      goto LABEL_19;
    }
    return sub_73690(
             a1,
             a2,
             a3,
             *(__int64 ***)(a2 + 912),
             a5,
             a6,
             *(double *)a7.m128_u64,
             a8,
             a9,
             a10,
             a11,
             a12,
             a13,
             a14,
             a15,
             a16);
  }
LABEL_19:
  if ( !*(_DWORD *)(v27 + 988) )
    *(_DWORD *)(v27 + 988) = 1;
  if ( (dword_C14B4 & 0x804) != 0 && (dword_C14B4 & 4) != 0 )
  {
    v35 = *(const char **)(v27 + 8);
    v36 = "protected";
    if ( !v28 )
      v36 = "normal";
    if ( !*v35 )
    {
      v35 = (const char *)off_BEFD8;
      if ( !off_BEFD8 )
        v35 = "<main program>";
    }
    v37 = *(const char **)(a2 + 8);
    if ( !*v37 )
    {
      v37 = (const char *)off_BEFD8;
      if ( !off_BEFD8 )
        v37 = "<main program>";
    }
    sub_76EA0(
      "binding file %s [%lu] to %s [%lu]: %s symbol `%s'",
      v37,
      *(_QWORD *)(a2 + 48),
      v35,
      *(_QWORD *)(v27 + 48),
      v36,
      (const char *)v16);
    if ( a5 )
      sub_76F50(" [%s]\n", *a5);
    else
      sub_76F50((_BYTE *)&off_8FB58 + 2, v37, v76);
    v27 = v87;
  }
  *a3 = v86;
  return v27;
}
// 73BF5: conditional instruction was optimized away because of 'rax.8!=0'
// 737AC: variable 'a11' is possibly undefined
// 737AC: variable 'a12' is possibly undefined
// 73B36: variable 'v76' is possibly undefined
// 73D39: variable 'v44' is possibly undefined
// 73F0E: variable 'v38' is possibly undefined
// 73F89: variable 'v22' is possibly undefined
// 73FD5: variable 'v60' is possibly undefined
// 73FD5: variable 'v61' is possibly undefined
// 73FD5: variable 'v62' is possibly undefined
// 740DD: variable 'v71' is possibly undefined
// 740DD: variable 'v72' is possibly undefined
// 9228: using guessed type __int64 __fastcall sub_9228(_QWORD);
// 9248: using guessed type __int64 __fastcall sub_9248(_QWORD);
// 8FB58: using guessed type void *off_8FB58;
// BEFD8: using guessed type void *off_BEFD8;
// BF0E0: using guessed type void *off_BF0E0;
// C14B4: using guessed type int dword_C14B4;

//----- (00000000000741B0) ----------------------------------------------------
unsigned int *__fastcall sub_741B0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 v9; // rax
  unsigned int *v10; // rcx
  __int64 v11; // rdx
  unsigned int v12; // eax
  __int64 v13; // rsi
  unsigned int *v14; // r8
  unsigned int v15; // ecx
  unsigned int *v16; // rax
  unsigned int *result; // rax
  unsigned int *v18; // rax
  __int64 v19; // rdx

  v9 = *(_QWORD *)(a1 + 672);
  if ( v9 )
  {
    v10 = *(unsigned int **)(v9 + 8);
    v11 = *v10;
    *(_DWORD *)(a1 + 756) = v11;
    v12 = v10[2];
    v13 = v10[1];
    if ( (v12 & (v12 - 1)) != 0 )
      sub_CF00(
        (__int64)"(bitmask_nwords & (bitmask_nwords - 1)) == 0",
        (__int64)"dl-lookup.c",
        0x3C6u,
        "_dl_setup_hash",
        a2,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9);
    *(_DWORD *)(a1 + 760) = v12 - 1;
    v14 = v10 + 4;
    v15 = v10[3];
    v16 = &v14[2 * v12];
    *(_QWORD *)(a1 + 768) = v14;
    *(_QWORD *)(a1 + 776) = v16;
    result = &v16[v11 - v13];
    *(_DWORD *)(a1 + 764) = v15;
    *(_QWORD *)(a1 + 784) = result;
  }
  else
  {
    result = *(unsigned int **)(a1 + 96);
    if ( result )
    {
      v18 = (unsigned int *)*((_QWORD *)result + 1);
      v19 = *v18;
      v18 += 2;
      *(_QWORD *)(a1 + 784) = v18;
      result = &v18[v19];
      *(_DWORD *)(a1 + 756) = v19;
      *(_QWORD *)(a1 + 776) = result;
    }
  }
  return result;
}

//----- (0000000000074270) ----------------------------------------------------
__int64 __fastcall sub_74270(_QWORD *a1, __int64 a2)
{
  void **v2; // rdx
  _QWORD *v3; // rax
  _QWORD *v4; // rdx
  __int64 v5; // rax
  __int64 result; // rax

  v2 = &off_BF0E0 + 19 * a2;
  v3 = *v2;
  if ( *v2 )
  {
    do
    {
      v4 = v3;
      v3 = (_QWORD *)v3[3];
    }
    while ( v3 );
    a1[4] = v4;
    v4[3] = a1;
  }
  else
  {
    *v2 = a1;
  }
  ++*((_DWORD *)&off_BF0E0 + 38 * a2 + 2);
  v5 = qword_BF080;
  a1[143] = qword_BF080;
  result = v5 + 1;
  qword_BF080 = result;
  return result;
}
// 9228: using guessed type __int64 __fastcall sub_9228(_QWORD);
// 9248: using guessed type __int64 __fastcall sub_9248(_QWORD);
// BF080: using guessed type __int64 qword_BF080;
// BF0E0: using guessed type void *off_BF0E0;

//----- (0000000000074330) ----------------------------------------------------
_QWORD *__fastcall sub_74330(char *a1, const void *a2, char a3, _QWORD *a4, char a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v17; // r15
  __int64 v18; // rcx
  u32 *v19; // r8
  __int64 v20; // r9
  double v21; // xmm4_8
  double v22; // xmm5_8
  _QWORD *v23; // rax
  _QWORD *v24; // r12
  char *v25; // rax
  char *v26; // rax
  char v27; // cl
  _QWORD *v28; // rsi
  __int64 v29; // rax
  _QWORD *v30; // rdx
  int v31; // edx
  _QWORD *v32; // rax
  _QWORD *v33; // rax
  __int64 v34; // rbp
  __int64 v35; // rax
  __int64 v36; // rdx
  u32 *v37; // r8
  __int64 v38; // r9
  double v39; // xmm4_8
  double v40; // xmm5_8
  __int64 v41; // rcx
  __int64 v42; // r13
  u32 *v43; // rax
  __int64 v44; // r14
  __int64 v45; // rbx
  __int64 v46; // r15
  _QWORD *v47; // rax
  __int64 v48; // rdx
  __int64 v49; // rcx
  u32 *v50; // r8
  u32 v51; // er9
  double v52; // xmm4_8
  double v53; // xmm5_8
  _BYTE *v54; // rdi
  _BYTE *v55; // rax
  _BYTE *v56; // rdx
  __int64 v58; // rax
  __int64 v59; // rdi
  unsigned __int8 v61; // [rsp+10h] [rbp-48h]
  u32 *v63; // [rsp+18h] [rbp-40h]

  v17 = strlen((__int64)a2);
  v23 = (_QWORD *)sub_22260(v17 + 1185, 1uLL, a7, a8, a9, a10, v21, v22, a13, a14, v17 + 1, v18, v19, v20);
  v24 = v23;
  if ( !v23 )
    return v24;
  v23[5] = v23;
  v23[90] = v23 + 144;
  v23[7] = v23 + 145;
  v25 = (char *)memcpy(v23 + 148, a2, v17 + 1);
  *((_DWORD *)v24 + 294) = 1;
  v24[145] = v25;
  v26 = &v25[v17];
  v27 = *a1;
  if ( *a1 )
    v26 = a1;
  v24[1] = v26;
  *((_BYTE *)v24 + 796) = *((_BYTE *)v24 + 796) & 0xFC | a3 & 3;
  if ( (dword_C14B4 & 0x100) == 0 )
    *((_DWORD *)v24 + 247) = 1;
  v28 = v24 + 109;
  v24[6] = a6;
  v24[92] = a4;
  v29 = (__int64)*(&off_BF0E0 + 19 * a6);
  v24[114] = v24 + 109;
  v24[113] = 4LL;
  if ( v29 )
  {
    v30 = (_QWORD *)(v29 + 704);
    v24[109] = v29 + 704;
    if ( !a4 )
    {
      v32 = v24;
      goto LABEL_29;
    }
    v31 = 1;
  }
  else
  {
    v31 = 0;
    if ( !a4 )
    {
      v32 = v24;
LABEL_11:
      v33 = v32 + 88;
LABEL_12:
      *v28 = v33;
      goto LABEL_13;
    }
  }
  do
  {
    v32 = a4;
    a4 = (_QWORD *)a4[92];
  }
  while ( a4 );
  if ( !v31 )
    goto LABEL_11;
  v30 = (_QWORD *)v24[109];
LABEL_29:
  v33 = v32 + 88;
  if ( v33 != v30 )
  {
    if ( (a5 & 8) != 0 )
      v24[110] = v30;
    else
      v28 = v24 + 110;
    goto LABEL_12;
  }
LABEL_13:
  v61 = v27;
  v24[115] = v24 + 88;
  if ( v27 )
  {
    v34 = 0LL;
    v35 = strlen((__int64)a1);
    v41 = v61;
    v42 = v35;
    v43 = (u32 *)(v35 + 1);
    v63 = v43;
    v44 = (__int64)v43;
    if ( v61 == 47 )
    {
      v58 = sub_21500(v43, (__int64)v28, v36, 47LL, v37, v38, a7, a8, a9, a10, v39, v40, a13, a14);
      v34 = v58;
      if ( !v58 )
      {
        v34 = -1LL;
LABEL_26:
        v24[105] = v34;
        return v24;
      }
      v54 = (_BYTE *)v58;
    }
    else
    {
      while ( 1 )
      {
        v45 = v44;
        v44 += 128LL;
        v46 = v34;
        v47 = sub_21DF0((const char *)v34, v44, v36, v41, v37, v38, a7, a8, a9, a10, v39, v40, a13, a14);
        v34 = (__int64)v47;
        if ( !v47 )
        {
          v34 = v46;
LABEL_39:
          v59 = v34;
          v34 = -1LL;
          sub_21B70(v59);
          goto LABEL_26;
        }
        if ( sub_4B000((__int64)v47, v45 + 127 - v42, a7, a8, a9, a10, v52, v53, a13, a14, v48, v49, v50, v51) )
          break;
        if ( __readfsdword(0xFFFFFFC0) != 34 )
          goto LABEL_39;
      }
      v54 = (_BYTE *)(v34 + strlen(v34));
      if ( *(v54 - 1) != 47 )
        *v54++ = 47;
    }
    v55 = (_BYTE *)sub_91D0(v54, a1, v63);
    do
      v56 = v55--;
    while ( *v55 != 47 );
    if ( (_BYTE *)v34 == v55 )
      v55 = v56;
    *v55 = 0;
    goto LABEL_26;
  }
  return v24;
}
// 74378: variable 'v21' is possibly undefined
// 74378: variable 'v22' is possibly undefined
// 74378: variable 'v18' is possibly undefined
// 74378: variable 'v19' is possibly undefined
// 74378: variable 'v20' is possibly undefined
// 745FB: variable 'v36' is possibly undefined
// 745FB: variable 'v37' is possibly undefined
// 745FB: variable 'v38' is possibly undefined
// 745FB: variable 'v39' is possibly undefined
// 745FB: variable 'v40' is possibly undefined
// 74501: variable 'v41' is possibly undefined
// 7451C: variable 'v52' is possibly undefined
// 7451C: variable 'v53' is possibly undefined
// 7451C: variable 'v48' is possibly undefined
// 7451C: variable 'v49' is possibly undefined
// 7451C: variable 'v50' is possibly undefined
// 7451C: variable 'v51' is possibly undefined
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// BF0E0: using guessed type void *off_BF0E0;
// C14B4: using guessed type int dword_C14B4;

//----- (0000000000074640) ----------------------------------------------------
__int64 __fastcall sub_74640(__int64 a1, char a2)
{
  unsigned __int64 v2; // r8
  __int64 v4; // rsi
  __int64 v5; // r9
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rdx

  if ( *(_QWORD *)(a1 + 1104) == -1LL )
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 1088);
  if ( v2 > qword_C0358 )
    return 0xFFFFFFFFLL;
  v4 = qword_C0360;
  if ( (unsigned __int64)(qword_C0368 - qword_C0360) <= 0x9BF )
    return 0xFFFFFFFFLL;
  v5 = *(_QWORD *)(a1 + 1096);
  v6 = qword_C0368 - qword_C0360 - 2496;
  v7 = v5 + *(_QWORD *)(a1 + 1080);
  if ( v6 < v7 )
    return 0xFFFFFFFFLL;
  v8 = v2 * ((v6 - v7) / v2);
  v9 = v6 - v5 - v8;
  if ( a2 )
  {
    if ( qword_C0348 >= v9 )
    {
      qword_C0348 = v5 + qword_C0348 - v6 + v8;
      goto LABEL_8;
    }
    return 0xFFFFFFFFLL;
  }
LABEL_8:
  qword_C0360 += v9;
  *(_QWORD *)(a1 + 1104) = v4 + v9;
  if ( (*(_BYTE *)(*(_QWORD *)(a1 + 40) + 796LL) & 4) != 0 )
    off_BF0A0();
  else
    *(_BYTE *)(a1 + 797) |= 4u;
  return 0LL;
}
// BF0A0: using guessed type __int64 (*off_BF0A0)(void);
// C0348: using guessed type __int64 qword_C0348;
// C0358: using guessed type __int64 qword_C0358;
// C0360: using guessed type __int64 qword_C0360;
// C0368: using guessed type __int64 qword_C0368;

//----- (0000000000074730) ----------------------------------------------------
__int64 __fastcall sub_74730(__int64 a1)
{
  __int64 result; // rax

  if ( *(_QWORD *)(a1 + 1104) == -1LL || (result = sub_74640(a1, 0), (_DWORD)result) )
    sub_50110(0LL, *(_BYTE **)(a1 + 8), 0LL, "cannot allocate memory in static TLS block");
  return result;
}

//----- (0000000000074770) ----------------------------------------------------
__int64 __fastcall sub_74770(_QWORD *a1)
{
  __int64 v1; // rdx
  __int64 v2; // r12
  __int64 v3; // rax

  v1 = a1[134];
  v2 = a1[135] - v1;
  v3 = sub_91D0(__readfsqword(0x10u) - a1[138], a1[133], v1);
  return sub_9190(v3, 0LL, v2);
}
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);

//----- (00000000000747C0) ----------------------------------------------------
unsigned __int64 __fastcall sub_747C0(__int64 a1)
{
  unsigned __int64 result; // rax
  __int64 v3; // rdi
  __int64 v4; // rsi
  __int64 v5; // rdi
  __int64 v6; // rsi

  result = -(__int64)off_BF078;
  v3 = *(_QWORD *)a1 + *(_QWORD *)(a1 + 1128);
  v4 = *(_QWORD *)(a1 + 1136) + v3;
  v5 = -(__int64)off_BF078 & v3;
  v6 = -(__int64)off_BF078 & v4;
  if ( v5 != v6 )
  {
    result = sub_4BD40(v5, v6 - v5, 1uLL);
    if ( (result & 0x80000000) != 0LL )
    {
      LODWORD(v5) = __readfsdword(0xFFFFFFC0);
      sub_50110(v5, *(_BYTE **)(a1 + 8), 0LL, "cannot apply additional memory protection after relocation");
    }
  }
  return result;
}
// BF078: using guessed type Elf64_Rela *off_BF078;

//----- (0000000000074830) ----------------------------------------------------
void __fastcall __noreturn sub_74830(__int64 a1, unsigned int a2)
{
  unsigned __int8 v2; // bl
  _BYTE *v3; // rax
  _BYTE *v4; // rsi
  char v5[72]; // [rsp+0h] [rbp-48h] BYREF

  v2 = a2;
  v3 = (_BYTE *)sub_90F0(v5);
  if ( a2 > 0xFF )
  {
    v3 += 6;
    *(v3 - 6) = a0123456789abcd[a2 >> 28];
    *(v3 - 5) = a0123456789abcd[HIBYTE(a2) & 0xF];
    *(v3 - 4) = a0123456789abcd[(a2 >> 20) & 0xF];
    *(v3 - 3) = a0123456789abcd[HIWORD(a2) & 0xF];
    *(v3 - 2) = a0123456789abcd[(unsigned __int16)a2 >> 12];
    *(v3 - 1) = a0123456789abcd[(a2 >> 8) & 0xF];
  }
  v3[2] = 0;
  v4 = *(_BYTE **)(a1 + 8);
  *v3 = a0123456789abcd[v2 >> 4];
  v3[1] = a0123456789abcd[v2 & 0xF];
  sub_50110(0LL, v4, 0LL, v5);
}
// 90F0: using guessed type __int64 __fastcall sub_90F0(_QWORD);

//----- (0000000000074900) ----------------------------------------------------
void __fastcall sub_74900(__int64 a1, __int64 **a2, int a3, int a4, u32 *a5, void (*a6)(void), double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v14; // r11
  int v15; // er12
  int v16; // er13
  bool v17; // zf
  __int64 v18; // rax
  __int64 v19; // rdx
  int v20; // edi
  __int64 v21; // rax
  __int64 v22; // rax
  unsigned __int64 v23; // rdx
  __int64 v24; // rsi
  __int64 v25; // r15
  __int64 v26; // rax
  __int64 v27; // rdi
  __int64 v28; // rcx
  __int64 v29; // rax
  int v30; // ecx
  __int64 v31; // r12
  __int64 v32; // r11
  unsigned __int64 v33; // rax
  unsigned __int64 v34; // r13
  unsigned __int64 v35; // rbx
  unsigned __int64 v36; // rdi
  _QWORD *v37; // rdx
  __int64 v38; // rcx
  __int64 v39; // rsi
  __int64 v40; // r15
  __int64 (*v41)(void); // rax
  __int64 (**v42)(void); // r14
  __int64 v43; // r11
  const char *v44; // rdx
  __int64 v45; // rsi
  __int64 v46; // rcx
  const char *v47; // rdi
  _QWORD *v48; // rbx
  unsigned __int64 v49; // r10
  unsigned __int64 v50; // r14
  _QWORD *v51; // r10
  __int16 v52; // si
  unsigned __int8 *v53; // rdi
  unsigned int *v54; // r15
  unsigned __int8 v55; // dl
  int v56; // er9
  unsigned __int8 *v57; // r8
  __int64 v58; // rax
  unsigned int *v59; // rcx
  __int64 v60; // r11
  _QWORD *v61; // rbx
  unsigned __int64 v62; // r13
  __int64 v63; // r15
  unsigned __int64 v64; // rax
  unsigned __int64 v65; // rax
  __int64 v66; // rsi
  __int16 v67; // cx
  _QWORD *v68; // r14
  unsigned int *v69; // r10
  unsigned __int8 v70; // al
  unsigned __int64 v71; // rdi
  __int64 v72; // r8
  __int64 v73; // rdi
  __int64 v74; // rax
  unsigned int *v75; // rdx
  __int64 v76; // rcx
  __int64 (__fastcall *v77)(unsigned __int64, __int64, unsigned int *, _QWORD, u32 *); // rax
  __int64 v78; // rdx
  _QWORD *v79; // rcx
  __int64 v80; // rdx
  unsigned int *v81; // r15
  unsigned __int8 v82; // dl
  int v83; // er9
  __int64 v84; // rdi
  __int64 **v85; // rcx
  unsigned __int8 *v86; // rdi
  __int64 v87; // rax
  unsigned int *v88; // rcx
  __int64 v89; // r11
  __int16 v90; // si
  __int64 v91; // r9
  void (__fastcall *v92)(_QWORD); // r9
  char v93; // al
  __int64 v94; // rax
  const char *v95; // rcx
  const char *v96; // rdx
  const char *v97; // rsi
  __int64 v98; // r8
  unsigned __int64 v99; // rax
  char v100; // al
  const char *v101; // rsi
  char v102; // al
  __int64 v103; // rax
  const char *v104; // rcx
  __int64 v105; // rdx
  __int64 v106; // rcx
  __int64 v107; // r8
  void *v108; // rdx
  unsigned __int64 v109; // rax
  int v110; // edx
  unsigned __int64 v111; // r13
  __int64 v112; // r15
  _QWORD *v113; // rbx
  unsigned __int64 v114; // rax
  unsigned int *v115; // r10
  _QWORD *v116; // r14
  unsigned __int8 v117; // al
  __int64 v118; // rsi
  __int64 v119; // rdi
  __int64 **v120; // rcx
  unsigned __int8 *v121; // rdi
  __int64 v122; // rax
  unsigned int *v123; // rdx
  __int64 v124; // rcx
  __int64 (__fastcall *v125)(const char *, __int64, _QWORD, __int64, u32 *); // rax
  __int16 v126; // si
  __int64 v127; // r9
  void (*v128)(void); // r9
  char v129; // al
  __int64 v130; // rax
  const char *v131; // rcx
  const char *v132; // rdx
  const char *v133; // rsi
  __int64 v134; // r8
  char v135; // al
  const char *v136; // rsi
  char v137; // al
  __int64 v138; // rax
  const char *v139; // rcx
  __int64 v140; // rdx
  __int64 v141; // rcx
  __int64 v142; // r8
  unsigned __int64 v143; // rax
  int v144; // edx
  __int64 v145; // rdx
  unsigned __int64 v146; // rcx
  unsigned __int64 v147; // rbx
  _QWORD *v148; // r15
  __int64 v149; // r12
  __int64 v150; // rdi
  unsigned __int64 v151; // rsi
  __int64 v152; // rdi
  int v153; // eax
  size_t v154; // rsi
  unsigned __int64 v155; // rdi
  int v156; // edx
  const char *v157; // rsi
  __int64 v158; // rbx
  __int64 v159; // r12
  __int64 v160; // rax
  __int64 v161; // rdx
  unsigned __int64 v162; // rax
  unsigned __int64 v163; // rcx
  __int64 v164; // rax
  const char *v165; // rsi
  int v166; // eax
  __int64 (__fastcall *v167)(unsigned __int64, unsigned __int64, __int64, __int64, __int64, __int64, __m128, __m128, __m128, __m128, __m128, __m128, __m128, __m128, unsigned int, __int64, __int64); // rdx
  __int64 v168; // r11
  const char *v169; // rcx
  _QWORD v170[2]; // [rsp-Eh] [rbp-130h] BYREF
  int v171; // [rsp+2h] [rbp-120h]
  _QWORD *v172; // [rsp+Ah] [rbp-118h]
  const char *v173; // [rsp+12h] [rbp-110h]
  u32 *v174; // [rsp+1Ah] [rbp-108h]
  void (__fastcall *v175)(_QWORD); // [rsp+2Ah] [rbp-F8h]
  _QWORD *v176; // [rsp+32h] [rbp-F0h]
  _QWORD *v177; // [rsp+3Ah] [rbp-E8h]
  char *v178; // [rsp+42h] [rbp-E0h]
  unsigned __int64 v179; // [rsp+4Ah] [rbp-D8h]
  __int64 v180; // [rsp+52h] [rbp-D0h]
  _QWORD *v181; // [rsp+5Ah] [rbp-C8h]
  int v182; // [rsp+62h] [rbp-C0h]
  unsigned int v183; // [rsp+66h] [rbp-BCh]
  unsigned __int64 v184; // [rsp+6Ah] [rbp-B8h]
  __int64 **v185; // [rsp+72h] [rbp-B0h]
  __int128 *v186; // [rsp+7Ah] [rbp-A8h]
  __int64 v187; // [rsp+82h] [rbp-A0h]
  void *v188; // [rsp+8Ah] [rbp-98h]
  const char *v189; // [rsp+92h] [rbp-90h]
  unsigned __int64 v190; // [rsp+9Ah] [rbp-88h]
  unsigned int *v191; // [rsp+AAh] [rbp-78h] BYREF
  __int128 v192[2]; // [rsp+B2h] [rbp-70h] BYREF
  __int128 v193; // [rsp+D2h] [rbp-50h]
  __int128 v194; // [rsp+E2h] [rbp-40h]
  char v195; // [rsp+F2h] [rbp-30h] BYREF

  v185 = a2;
  v182 = a4;
  if ( (*(_BYTE *)(a1 + 796) & 4) != 0 )
    return;
  v14 = a1;
  v15 = a3;
  if ( a4 || !*(_QWORD *)(a1 + 256) )
  {
    v16 = a3 & 1;
    if ( (dword_C14B4 & 0x20) == 0 )
      goto LABEL_4;
    v44 = " (lazy)";
    if ( (v15 & 1) == 0 )
      v44 = (const char *)&unk_A6E65;
  }
  else
  {
    v16 = 0;
    if ( (dword_C14B4 & 0x20) == 0 )
      goto LABEL_4;
    v44 = (const char *)&unk_A6E65;
  }
  v157 = *(const char **)(a1 + 8);
  if ( !*v157 )
  {
    v157 = (const char *)off_BEFD8;
    if ( !off_BEFD8 )
      v157 = "<main program>";
  }
  v190 = a1;
  sub_76EA0("\nrelocation processing: %s%s\n", v157, v44);
  v14 = a1;
LABEL_4:
  v177 = *(_QWORD **)(v14 + 240);
  if ( v177 )
  {
    v145 = *(unsigned __int16 *)(v14 + 696);
    v146 = *(_QWORD *)(v14 + 680);
    v147 = v146;
    if ( v146 >= v146 + 56 * v145 )
    {
      v177 = 0LL;
    }
    else
    {
      LODWORD(v189) = v15;
      v148 = 0LL;
      v149 = v14;
      LODWORD(v190) = v16;
      do
      {
        if ( (*(_QWORD *)v147 & 0x2FFFFFFFFLL) == 1 )
        {
          v150 = *(_QWORD *)(v147 + 16);
          v151 = (unsigned __int64)off_BF078 + v150 + *(_QWORD *)(v147 + 40) - 1;
          v152 = -(__int64)off_BF078 & v150;
          v171 = 0;
          v153 = *(_DWORD *)(v147 + 4);
          v154 = (-(__int64)off_BF078 & v151) - v152;
          v155 = *(_QWORD *)v149 + v152;
          v156 = 0;
          v170[1] = v154;
          v170[0] = v155;
          if ( (v153 & 4) != 0 )
          {
            v171 = 1;
            v156 = 1;
          }
          if ( (v153 & 2) != 0 )
          {
            v156 |= 2u;
            v171 = v156;
          }
          if ( (v153 & 1) != 0 )
          {
            v156 |= 4u;
            v171 = v156;
          }
          if ( (sub_4BD40(v155, v154, v156 | 2u) & 0x80000000) != 0LL )
          {
            v168 = v149;
            v169 = "cannot make segment writable for relocation";
            goto LABEL_283;
          }
          v172 = v148;
          v148 = v170;
          v146 = *(_QWORD *)(v149 + 680);
          v145 = *(unsigned __int16 *)(v149 + 696);
        }
        v147 += 56LL;
      }
      while ( v147 < v146 + 56 * v145 );
      v14 = v149;
      v177 = v148;
      v16 = v190;
      v15 = (int)v189;
    }
  }
  v17 = *(_QWORD *)(v14 + 248) == 0LL;
  v180 = *(_QWORD *)(*(_QWORD *)(v14 + 104) + 8LL);
  if ( v17 )
  {
    v21 = *(_QWORD *)(v14 + 656);
    if ( !v21 || !v16 )
      goto LABEL_13;
  }
  else
  {
    if ( !v16 )
      goto LABEL_13;
    v18 = *(_QWORD *)(*(_QWORD *)(v14 + 88) + 8LL);
    v19 = *(_QWORD *)(v18 + 8);
    if ( v19 )
    {
      *(_QWORD *)(v14 + 1008) = *(_QWORD *)v14 + v19;
      *(_QWORD *)(v14 + 1016) = v18 + 24;
    }
    v20 = v182;
    *(_QWORD *)(v18 + 8) = v14;
    if ( v20 )
    {
      if ( (BYTE6(xmmword_C1384) & 1) != 0 )
      {
        *(_QWORD *)(v18 + 16) = &sub_78130;
      }
      else
      {
        v167 = (__int64 (__fastcall *)(unsigned __int64, unsigned __int64, __int64, __int64, __int64, __int64, __m128, __m128, __m128, __m128, __m128, __m128, __m128, __m128, unsigned int, __int64, __int64))&sub_785B0;
        if ( (BYTE11(xmmword_C1364) & 0x10) == 0 )
          v167 = sub_78A30;
        *(_QWORD *)(v18 + 16) = v167;
      }
      if ( qword_C14A0 )
      {
        v190 = v14;
        v166 = sub_772B0(qword_C14A0, v14);
        v14 = v190;
        if ( v166 )
          qword_C1488 = v190;
      }
    }
    else if ( qword_C1438 )
    {
      v108 = sub_78CB0;
      if ( (dword_C13C4 & 2) != 0 )
        v108 = sub_78D80;
      *(_QWORD *)(v18 + 16) = v108;
    }
    else
    {
      *(_QWORD *)(v18 + 16) = sub_78C30;
    }
    v21 = *(_QWORD *)(v14 + 656);
    if ( !v21 )
      goto LABEL_13;
  }
  *(_QWORD *)(*(_QWORD *)(v21 + 8) + *(_QWORD *)v14) = sub_79AC0;
LABEL_13:
  v22 = *(_QWORD *)(v14 + 120);
  v192[0] = 0LL;
  v192[1] = 0LL;
  v193 = 0LL;
  v194 = 0LL;
  if ( v22 )
  {
    v23 = *(_QWORD *)(v22 + 8);
    v24 = 0LL;
    v25 = *(_QWORD *)(*(_QWORD *)(v14 + 128) + 8LL);
    v26 = *(_QWORD *)(v14 + 392);
    v27 = v23 + v25;
    if ( v26 )
      v24 = *(_QWORD *)(v26 + 8);
  }
  else
  {
    v24 = 0LL;
    v27 = 0LL;
    v25 = 0LL;
    v23 = 0LL;
  }
  if ( *(_QWORD *)(v14 + 224) )
  {
    v28 = *(_QWORD *)(*(_QWORD *)(v14 + 248) + 8LL);
    v29 = *(_QWORD *)(*(_QWORD *)(v14 + 80) + 8LL);
    a5 = (u32 *)(v28 + v29);
    if ( v28 + v29 == v27 )
    {
      v25 -= v29;
      v27 = v25 + v23;
    }
    if ( !v16 && v28 == v27 )
    {
      v25 += v29;
    }
    else
    {
      *(_QWORD *)&v193 = *(_QWORD *)(*(_QWORD *)(v14 + 248) + 8LL);
      *((_QWORD *)&v193 + 1) = v29;
      DWORD2(v194) = v16;
    }
  }
  v30 = 0;
  v186 = v192;
  v178 = &v195;
  v183 = v15 & 0x2000000;
  v31 = v14;
  while ( 1 )
  {
    v32 = *(_QWORD *)v31;
    v33 = v23;
    v190 = v23 + v25;
    if ( !v30 )
    {
      v47 = *(const char **)(*(_QWORD *)(v31 + 112) + 8LL);
      v48 = (_QWORD *)(v23 + 24 * v24);
      v189 = v47;
      if ( v31 && (v32 || !*(_QWORD *)(v31 + 576)) && v23 < (unsigned __int64)v48 )
      {
        do
        {
          v78 = *(unsigned int *)(v33 + 8);
          v79 = (_QWORD *)(v32 + *(_QWORD *)v33);
          if ( v78 != 38 && v78 != 8 )
            sub_CF00(
              "ELFW(R_TYPE) (reloc->r_info) == R_X86_64_RELATIVE",
              "../sysdeps/x86_64/dl-machine.h",
              541LL,
              "elf_machine_rela_relative");
          v80 = *(_QWORD *)(v33 + 16);
          v33 += 24LL;
          *v79 = v32 + v80;
        }
        while ( (unsigned __int64)v48 > v33 );
        v49 = *(_QWORD *)(v31 + 464);
        if ( v49 )
        {
LABEL_56:
          v188 = *(void **)(v49 + 8);
          if ( v190 <= (unsigned __int64)v48 )
            goto LABEL_42;
          v179 = 0LL;
          v184 = 0LL;
          v187 = v32;
          while ( 1 )
          {
            v50 = v48[1];
            if ( (_DWORD)v50 == 37 )
            {
              v99 = v184;
              v179 = (unsigned __int64)v48;
              if ( !v184 )
                v99 = (unsigned __int64)v48;
              v184 = v99;
            }
            else
            {
              v51 = (_QWORD *)(*v48 + v187);
              v52 = *((_WORD *)v188 + HIDWORD(v50));
              v53 = *(unsigned __int8 **)(v31 + 744);
              v54 = (unsigned int *)&v189[24 * HIDWORD(v50)];
              v191 = v54;
              if ( (unsigned int)v50 == 8LL || (unsigned int)v50 == 38LL )
              {
                *v51 = *(_QWORD *)v31 + v48[2];
              }
              else if ( (_DWORD)v50 )
              {
                v55 = *((_BYTE *)v54 + 4);
                if ( v55 >> 4 && (*((_BYTE *)v54 + 5) & 3u) - 1 > 1 )
                {
                  if ( v54 == *(unsigned int **)(v31 + 1032) )
                  {
                    LODWORD(v109) = 0;
                    if ( (unsigned int)v50 <= 0x24uLL )
                      v109 = (0x1000070080uLL >> v50) & 1;
                    v110 = *(_DWORD *)(v31 + 1040);
                    if ( (unsigned int)v50 == 5LL )
                    {
                      if ( 3 - ((_DWORD)v109 == 0) != v110 )
                        goto LABEL_67;
                    }
                    else if ( (unsigned int)v50 == 6LL )
                    {
                      if ( 5 - ((_DWORD)v109 == 0) != v110 )
                        goto LABEL_67;
                    }
                    else if ( v110 != (_DWORD)v109 )
                    {
                      goto LABEL_65;
                    }
                    v59 = *(unsigned int **)(v31 + 1056);
                    v60 = *(_QWORD *)(v31 + 1048);
                    v191 = v59;
                    goto LABEL_74;
                  }
LABEL_65:
                  if ( (unsigned int)v50 == 7LL || (unsigned int)v50 == 16LL )
                  {
                    v56 = 1;
                    if ( (unsigned int)v50 != 5LL )
                      goto LABEL_68;
                  }
                  else
                  {
LABEL_67:
                    v56 = (unsigned int)v50 == 36LL || (unsigned __int64)(unsigned int)v50 - 17 <= 1;
                    if ( (unsigned int)v50 != 5LL )
                    {
LABEL_68:
                      if ( (unsigned int)v50 == 6LL )
                        v56 |= 4u;
LABEL_70:
                      *(_DWORD *)(v31 + 1040) = v56;
                      *(_QWORD *)(v31 + 1032) = v54;
                      v57 = &v53[24 * (v52 & 0x7FFF)];
                      if ( v57 && !*((_DWORD *)v57 + 2) )
                        v57 = 0LL;
                      v53 = (unsigned __int8 *)(v180 + *v54);
                      v181 = v51;
                      v58 = sub_73690(
                              v53,
                              v31,
                              &v191,
                              v185,
                              (const char **)v57,
                              v56,
                              0.0,
                              a8,
                              a9,
                              a10,
                              a11,
                              a12,
                              a13,
                              a14,
                              9,
                              0LL);
                      v59 = v191;
                      v51 = v181;
                      *(_QWORD *)(v31 + 1048) = v58;
                      v60 = v58;
                      *(_QWORD *)(v31 + 1056) = v59;
LABEL_74:
                      if ( !v59 )
                      {
LABEL_75:
                        if ( (unsigned int)v50 <= 0x25uLL )
                          goto LABEL_76;
                        goto LABEL_129;
                      }
                      v90 = *((_WORD *)v59 + 3);
                      v55 = *((_BYTE *)v59 + 4);
                      if ( v90 == -15 )
                      {
LABEL_137:
                        v91 = 0LL;
                        goto LABEL_119;
                      }
LABEL_118:
                      v91 = *(_QWORD *)v60;
LABEL_119:
                      v92 = (void (__fastcall *)(_QWORD))(*((_QWORD *)v59 + 1) + v91);
                      if ( (v55 & 0xF) != 10 || v183 || !v90 )
                        goto LABEL_75;
                      if ( v31 != v60 )
                      {
                        v93 = *(_BYTE *)(v60 + 796);
                        if ( (v93 & 3) != 0 && (v93 & 4) == 0 )
                        {
                          v94 = *(_QWORD *)(v31 + 104);
                          v175 = v92;
                          v95 = *(const char **)(v60 + 8);
                          v96 = *(const char **)(v31 + 8);
                          v176 = v51;
                          v97 = (const char *)off_BEFD8;
                          v98 = *v54;
                          v181 = (_QWORD *)v60;
                          if ( !off_BEFD8 )
                            v97 = "<program name unknown>";
                          v53 = "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n";
                          sub_77150(
                            "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n",
                            v97,
                            v96,
                            v95,
                            (const char *)(*(_QWORD *)(v94 + 8) + v98));
                          v92 = v175;
                          v51 = v176;
                          v60 = (__int64)v181;
                        }
                      }
                      v176 = (_QWORD *)v60;
                      v181 = v51;
                      v92(v53);
                      if ( (unsigned int)v50 <= 0x25uLL )
LABEL_76:
                        __asm { jmp     rax }
LABEL_129:
                      sub_74830(v31, v50);
                    }
                  }
                  v56 |= 2u;
                  goto LABEL_70;
                }
                v59 = (unsigned int *)&v189[24 * HIDWORD(v50)];
                v60 = v31;
                v90 = *((_WORD *)v54 + 3);
                if ( v90 == -15 )
                  goto LABEL_137;
                goto LABEL_118;
              }
            }
            v48 += 3;
            if ( v190 <= (unsigned __int64)v48 )
            {
              v61 = (_QWORD *)v184;
              if ( !v184 )
                goto LABEL_42;
              v62 = v179;
              if ( v184 > v179 )
                goto LABEL_42;
              v63 = v187;
              while ( 2 )
              {
                v64 = v61[1];
                if ( (_DWORD)v64 == 37 )
                {
                  v65 = HIDWORD(v64);
                  v66 = *(_QWORD *)(v31 + 744);
                  v67 = *((_WORD *)v188 + v65);
                  v68 = (_QWORD *)(v63 + *v61);
                  v69 = (unsigned int *)&v189[24 * v65];
                  v191 = v69;
                  v70 = *((_BYTE *)v69 + 4);
                  v71 = v70;
                  LOBYTE(v71) = v70 >> 4;
                  if ( v70 >> 4 && (*((_BYTE *)v69 + 5) & 3u) - 1 > 1 )
                  {
                    if ( v69 != *(unsigned int **)(v31 + 1032) || *(_DWORD *)(v31 + 1040) )
                    {
                      *(_QWORD *)(v31 + 1032) = v69;
                      *(_DWORD *)(v31 + 1040) = 0;
                      v72 = v66 + 24LL * (v67 & 0x7FFF);
                      if ( v72 && !*(_DWORD *)(v72 + 8) )
                        v72 = 0LL;
                      v73 = *v69;
                      v66 = v31;
                      v190 = (unsigned __int64)v69;
                      v74 = sub_73690(
                              (unsigned __int8 *)(v180 + v73),
                              v31,
                              &v191,
                              v185,
                              (const char **)v72,
                              0,
                              0.0,
                              a8,
                              a9,
                              a10,
                              a11,
                              a12,
                              a13,
                              a14,
                              9,
                              0LL);
                      v75 = v191;
                      v69 = (unsigned int *)v190;
                      *(_QWORD *)(v31 + 1048) = v74;
                      v76 = v74;
                      *(_QWORD *)(v31 + 1056) = v75;
                      v71 = (unsigned __int64)v173;
                      a5 = v174;
                    }
                    else
                    {
                      v75 = *(unsigned int **)(v31 + 1056);
                      v76 = *(_QWORD *)(v31 + 1048);
                      v191 = v75;
                    }
                    if ( !v75 )
                    {
LABEL_91:
                      v77 = (__int64 (__fastcall *)(unsigned __int64, __int64, unsigned int *, _QWORD, u32 *))(*(_QWORD *)v31 + v61[2]);
                      if ( !v183 )
                        v77 = (__int64 (__fastcall *)(unsigned __int64, __int64, unsigned int *, _QWORD, u32 *))v77(v71, v66, v75, 0LL, a5);
                      goto LABEL_93;
                    }
                    v70 = *((_BYTE *)v75 + 4);
                  }
                  else
                  {
                    v76 = v31;
                    v75 = v69;
                  }
                  v66 = *((unsigned __int16 *)v75 + 3);
                  a6 = (void (*)(void))*((_QWORD *)v75 + 1);
                  v100 = v70 & 0xF;
                  if ( (_WORD)v66 == 0xFFF1 )
                  {
                    if ( v100 != 10 )
                      goto LABEL_91;
                  }
                  else
                  {
                    if ( v100 != 10 || !(_WORD)v66 )
                      goto LABEL_91;
                    a6 = (void (*)(void))((char *)a6 + *(_QWORD *)v76);
                  }
                  v101 = (const char *)v183;
                  if ( v183 )
                  {
                    v77 = (__int64 (__fastcall *)(unsigned __int64, __int64, unsigned int *, _QWORD, u32 *))(*(_QWORD *)v31 + v61[2]);
                  }
                  else
                  {
                    if ( v31 != v76 )
                    {
                      v102 = *(_BYTE *)(v76 + 796);
                      if ( (v102 & 3) != 0 && (v102 & 4) == 0 )
                      {
                        v103 = *(_QWORD *)(v31 + 104);
                        v190 = (unsigned __int64)a6;
                        v104 = *(const char **)(v76 + 8);
                        v101 = (const char *)off_BEFD8;
                        if ( !off_BEFD8 )
                          v101 = "<program name unknown>";
                        v71 = (unsigned __int64)"%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n";
                        sub_77150(
                          "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n",
                          v101,
                          *(const char **)(v31 + 8),
                          v104,
                          (const char *)(*(_QWORD *)(v103 + 8) + *v69));
                        a6 = (void (*)(void))v190;
                      }
                    }
                    a6();
                    v77 = (__int64 (__fastcall *)(unsigned __int64, __int64, unsigned int *, _QWORD, u32 *))((__int64 (__fastcall *)(unsigned __int64, const char *, __int64, __int64, __int64))(*(_QWORD *)v31 + v61[2]))(v71, v101, v105, v106, v107);
                  }
LABEL_93:
                  *v68 = v77;
                }
                v61 += 3;
                if ( (unsigned __int64)v61 > v62 )
                  goto LABEL_42;
                continue;
              }
            }
          }
        }
      }
      else
      {
        v49 = *(_QWORD *)(v31 + 464);
        if ( v49 )
          goto LABEL_56;
      }
      v184 = 0LL;
      if ( v190 <= (unsigned __int64)v48 )
        goto LABEL_42;
      v187 = v32;
      while ( 1 )
      {
        v50 = v48[1];
        if ( (_DWORD)v50 == 37 )
        {
          v184 = (unsigned __int64)v48;
          if ( !v49 )
            v49 = (unsigned __int64)v48;
        }
        else
        {
          v188 = (void *)(*v48 + v187);
          v81 = (unsigned int *)&v189[24 * HIDWORD(v50)];
          v191 = v81;
          if ( (unsigned int)v50 == 8LL )
          {
            v47 = (const char *)v188;
            *(_QWORD *)v188 = *(_QWORD *)v31 + v48[2];
          }
          else if ( (unsigned int)v50 == 38LL )
          {
            *(_QWORD *)v188 = *(_QWORD *)v31 + v48[2];
          }
          else if ( (_DWORD)v50 )
          {
            v82 = *((_BYTE *)v81 + 4);
            if ( v82 >> 4 && (*((_BYTE *)v81 + 5) & 3u) - 1 > 1 )
            {
              if ( v81 == *(unsigned int **)(v31 + 1032) )
              {
                LODWORD(v143) = 0;
                if ( (unsigned int)v50 <= 0x24uLL )
                  v143 = (0x1000070080uLL >> v50) & 1;
                v144 = *(_DWORD *)(v31 + 1040);
                if ( (unsigned int)v50 == 5LL )
                {
                  if ( 3 - ((_DWORD)v143 == 0) != v144 )
                    goto LABEL_110;
                }
                else if ( (unsigned int)v50 == 6LL )
                {
                  if ( 5 - ((_DWORD)v143 == 0) != v144 )
                    goto LABEL_110;
                }
                else if ( v144 != (_DWORD)v143 )
                {
                  goto LABEL_108;
                }
                v88 = *(unsigned int **)(v31 + 1056);
                v89 = *(_QWORD *)(v31 + 1048);
                v191 = v88;
                goto LABEL_114;
              }
LABEL_108:
              if ( (unsigned int)v50 == 7LL || (unsigned int)v50 == 16LL )
              {
                v83 = 1;
                if ( (unsigned int)v50 != 5LL )
                  goto LABEL_111;
              }
              else
              {
LABEL_110:
                v83 = (unsigned int)v50 == 36LL || (unsigned __int64)(unsigned int)v50 - 17 <= 1;
                if ( (unsigned int)v50 != 5LL )
                {
LABEL_111:
                  if ( (unsigned int)v50 == 6LL )
                    v83 |= 4u;
LABEL_113:
                  v84 = *v81;
                  v85 = v185;
                  *(_DWORD *)(v31 + 1040) = v83;
                  v86 = (unsigned __int8 *)(v180 + v84);
                  *(_QWORD *)(v31 + 1032) = v81;
                  v181 = (_QWORD *)v49;
                  v87 = sub_73690(v86, v31, &v191, v85, 0LL, v83, 0.0, a8, a9, a10, a11, a12, a13, a14, 9, 0LL);
                  v88 = v191;
                  v49 = (unsigned __int64)v181;
                  *(_QWORD *)(v31 + 1048) = v87;
                  v89 = v87;
                  *(_QWORD *)(v31 + 1056) = v88;
LABEL_114:
                  if ( !v88 )
                  {
LABEL_115:
                    if ( (unsigned int)v50 <= 0x25uLL )
                      __asm { jmp     rax }
                    goto LABEL_129;
                  }
                  v126 = *((_WORD *)v88 + 3);
                  v82 = *((_BYTE *)v88 + 4);
                  if ( v126 == -15 )
                  {
LABEL_200:
                    v127 = 0LL;
                    goto LABEL_187;
                  }
LABEL_186:
                  v127 = *(_QWORD *)v89;
LABEL_187:
                  v128 = (void (*)(void))(*((_QWORD *)v88 + 1) + v127);
                  if ( (v82 & 0xF) == 10 && !v183 && v126 )
                  {
                    if ( v31 != v89 )
                    {
                      v129 = *(_BYTE *)(v89 + 796);
                      if ( (v129 & 3) != 0 && (v129 & 4) == 0 )
                      {
                        v130 = *(_QWORD *)(v31 + 104);
                        v176 = (_QWORD *)v49;
                        v131 = *(const char **)(v89 + 8);
                        v132 = *(const char **)(v31 + 8);
                        v179 = (unsigned __int64)v128;
                        v133 = (const char *)off_BEFD8;
                        v134 = *v81;
                        v181 = (_QWORD *)v89;
                        if ( !off_BEFD8 )
                          v133 = "<program name unknown>";
                        sub_77150(
                          "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n",
                          v133,
                          v132,
                          v131,
                          (const char *)(*(_QWORD *)(v130 + 8) + v134));
                        v49 = (unsigned __int64)v176;
                        v128 = (void (*)(void))v179;
                        v89 = (__int64)v181;
                      }
                    }
                    v179 = v49;
                    v181 = (_QWORD *)v89;
                    v128();
                  }
                  goto LABEL_115;
                }
              }
              v83 |= 2u;
              goto LABEL_113;
            }
            v88 = (unsigned int *)&v189[24 * HIDWORD(v50)];
            v89 = v31;
            v126 = *((_WORD *)v81 + 3);
            if ( v126 == -15 )
              goto LABEL_200;
            goto LABEL_186;
          }
        }
        v48 += 3;
        if ( v190 <= (unsigned __int64)v48 )
        {
          if ( !v49 )
            goto LABEL_42;
          v111 = v184;
          if ( v49 > v184 )
            goto LABEL_42;
          v112 = v187;
          v113 = (_QWORD *)v49;
          while ( 2 )
          {
            v114 = v113[1];
            if ( (_DWORD)v114 != 37 )
              goto LABEL_172;
            v115 = (unsigned int *)&v189[24 * HIDWORD(v114)];
            v116 = (_QWORD *)(v112 + *v113);
            v191 = v115;
            v117 = *((_BYTE *)v115 + 4);
            v118 = v117;
            LOBYTE(v118) = v117 >> 4;
            if ( v117 >> 4 && (*((_BYTE *)v115 + 5) & 3u) - 1 > 1 )
            {
              if ( v115 != *(unsigned int **)(v31 + 1032) || (LODWORD(a6) = *(_DWORD *)(v31 + 1040), (_DWORD)a6) )
              {
                v119 = *v115;
                v120 = v185;
                *(_QWORD *)(v31 + 1032) = v115;
                v118 = v31;
                v121 = (unsigned __int8 *)(v180 + v119);
                *(_DWORD *)(v31 + 1040) = 0;
                v190 = (unsigned __int64)v115;
                v122 = sub_73690(v121, v31, &v191, v120, 0LL, 0, 0.0, a8, a9, a10, a11, a12, a13, a14, 9, 0LL);
                v123 = v191;
                v115 = (unsigned int *)v190;
                *(_QWORD *)(v31 + 1048) = v122;
                v124 = v122;
                *(_QWORD *)(v31 + 1056) = v123;
                v47 = v173;
                a5 = v174;
              }
              else
              {
                v123 = *(unsigned int **)(v31 + 1056);
                v124 = *(_QWORD *)(v31 + 1048);
                v191 = v123;
              }
              if ( !v123 )
                break;
              v117 = *((_BYTE *)v123 + 4);
            }
            else
            {
              v124 = v31;
              v123 = v115;
            }
            v118 = *((unsigned __int16 *)v123 + 3);
            a6 = (void (*)(void))*((_QWORD *)v123 + 1);
            v135 = v117 & 0xF;
            if ( (_WORD)v118 == 0xFFF1 )
            {
              if ( v135 == 10 )
                goto LABEL_207;
            }
            else if ( v135 == 10 && (_WORD)v118 )
            {
              a6 = (void (*)(void))((char *)a6 + *(_QWORD *)v124);
LABEL_207:
              v136 = (const char *)v183;
              if ( v183 )
              {
                v125 = (__int64 (__fastcall *)(const char *, __int64, _QWORD, __int64, u32 *))(*(_QWORD *)v31 + v113[2]);
              }
              else
              {
                if ( v31 != v124 )
                {
                  v137 = *(_BYTE *)(v124 + 796);
                  if ( (v137 & 3) != 0 && (v137 & 4) == 0 )
                  {
                    v138 = *(_QWORD *)(v31 + 104);
                    v190 = (unsigned __int64)a6;
                    v139 = *(const char **)(v124 + 8);
                    v136 = (const char *)off_BEFD8;
                    if ( !off_BEFD8 )
                      v136 = "<program name unknown>";
                    v47 = "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n";
                    sub_77150(
                      "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n",
                      v136,
                      *(const char **)(v31 + 8),
                      v139,
                      (const char *)(*(_QWORD *)(v138 + 8) + *v115));
                    a6 = (void (*)(void))v190;
                  }
                }
                a6();
                v125 = (__int64 (__fastcall *)(const char *, __int64, _QWORD, __int64, u32 *))((__int64 (__fastcall *)(const char *, const char *, __int64, __int64, __int64))(*(_QWORD *)v31 + v113[2]))(
                                                                                                v47,
                                                                                                v136,
                                                                                                v140,
                                                                                                v141,
                                                                                                v142);
              }
LABEL_181:
              *v116 = v125;
LABEL_172:
              v113 += 3;
              if ( (unsigned __int64)v113 > v111 )
                goto LABEL_42;
              continue;
            }
            break;
          }
          v125 = (__int64 (__fastcall *)(const char *, __int64, _QWORD, __int64, u32 *))(*(_QWORD *)v31 + v113[2]);
          if ( !v183 )
            v125 = (__int64 (__fastcall *)(const char *, __int64, _QWORD, __int64, u32 *))v125(v47, v118, 0LL, v124, a5);
          goto LABEL_181;
        }
      }
    }
    v34 = 0LL;
    v35 = 0LL;
    if ( v23 < v23 + v25 )
    {
      v36 = v190;
      do
      {
        while ( 1 )
        {
          v39 = *(_QWORD *)(v33 + 8);
          if ( (_DWORD)v39 != 37 )
            break;
          v34 = v33;
          if ( !v35 )
            v35 = v33;
          v33 += 24LL;
          if ( v36 <= v33 )
            goto LABEL_34;
        }
        v37 = (_QWORD *)(v32 + *(_QWORD *)v33);
        if ( (unsigned int)v39 == 7LL )
        {
          v38 = *(_QWORD *)(v31 + 1008);
          if ( v38 )
            *v37 = v38 + 2LL * ((_QWORD)v37 - *(_QWORD *)(v31 + 1016));
          else
            *v37 += v32;
        }
        else
        {
          if ( (unsigned int)v39 != 36LL )
            sub_74830(v31, v39);
          v45 = *(_QWORD *)(v31 + 664);
          v46 = *(_QWORD *)v31;
          v37[1] = v33;
          *v37 = *(_QWORD *)(v45 + 8) + v46;
        }
        v33 += 24LL;
      }
      while ( v36 > v33 );
LABEL_34:
      if ( v35 && v35 <= v34 )
      {
        v40 = v32;
        do
        {
          while ( *(_DWORD *)(v35 + 8) != 37 )
          {
            v35 += 24LL;
            if ( v35 > v34 )
              goto LABEL_42;
          }
          v41 = (__int64 (*)(void))(*(_QWORD *)v31 + *(_QWORD *)(v35 + 16));
          v42 = (__int64 (**)(void))(v40 + *(_QWORD *)v35);
          if ( !v183 )
            v41 = (__int64 (*)(void))v41();
          v35 += 24LL;
          *v42 = v41;
        }
        while ( v35 <= v34 );
      }
    }
LABEL_42:
    v186 += 2;
    if ( v186 == (__int128 *)v178 )
      break;
    v30 = *((_DWORD *)v186 + 6);
    v24 = *((_QWORD *)v186 + 2);
    v25 = *((_QWORD *)v186 + 1);
    v23 = *(_QWORD *)v186;
  }
  v43 = v31;
  if ( v182 )
  {
    v160 = *(_QWORD *)(v31 + 80);
    if ( v160 )
    {
      v161 = *(_QWORD *)(v31 + 224);
      v162 = *(_QWORD *)(v160 + 8);
      v190 = v31;
      v163 = 8LL * (*(_QWORD *)(v161 + 8) == 7LL) + 16;
      v164 = sub_22260(0x20uLL, v162 / v163, 0.0, a8, a9, a10, a11, a12, a13, a14, v162 % v163, v163, a5, (u32)a6);
      v43 = v190;
      *(_QWORD *)(v190 + 824) = v164;
      if ( !v164 )
      {
        v165 = (const char *)off_BEFD8;
        if ( !off_BEFD8 )
          v165 = "<program name unknown>";
        sub_77200("%s: out of memory to store relocation results for %s\n", v165, *(const char **)(v43 + 8));
      }
    }
  }
  *(_BYTE *)(v43 + 796) |= 4u;
  if ( v177 )
  {
    v158 = (__int64)v177;
    v159 = v43;
    while ( 1 )
    {
      v155 = *(_QWORD *)v158;
      if ( (sub_4BD40(*(_QWORD *)v158, *(_QWORD *)(v158 + 8), *(unsigned int *)(v158 + 16)) & 0x80000000) != 0LL )
        break;
      v158 = *(_QWORD *)(v158 + 24);
      if ( !v158 )
      {
        v43 = v159;
        goto LABEL_45;
      }
    }
    v168 = v159;
    v169 = "cannot restore segment prot after reloc";
LABEL_283:
    LODWORD(v155) = __readfsdword(0xFFFFFFC0);
    sub_50110(v155, *(_BYTE **)(v168 + 8), 0LL, v169);
  }
LABEL_45:
  if ( *(_QWORD *)(v43 + 1136) )
    sub_747C0(v43);
}
// 74DD2: variable 'a11' is possibly undefined
// 74DD2: variable 'a12' is possibly undefined
// 74F87: variable 'a5' is possibly undefined
// 75578: variable 'v105' is possibly undefined
// 75578: variable 'v106' is possibly undefined
// 75578: variable 'v107' is possibly undefined
// 75BD8: variable 'v140' is possibly undefined
// 75BD8: variable 'v141' is possibly undefined
// 75BD8: variable 'v142' is possibly undefined
// 75EA1: variable 'a6' is possibly undefined
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// 79AC0: using guessed type __int64 __fastcall sub_79AC0();
// BEFD8: using guessed type void *off_BEFD8;
// BF078: using guessed type Elf64_Rela *off_BF078;
// C1364: using guessed type __int128 xmmword_C1364;
// C1384: using guessed type __int128 xmmword_C1384;
// C13C4: using guessed type int dword_C13C4;
// C1438: using guessed type __int64 qword_C1438;
// C1488: using guessed type __int64 qword_C1488;
// C14A0: using guessed type __int64 qword_C14A0;
// C14B4: using guessed type int dword_C14B4;

//----- (0000000000076190) ----------------------------------------------------
_QWORD *__fastcall sub_76190(__int64 *a1, _QWORD *a2, __int64 *a3, _QWORD *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  __int64 v12; // rdx
  __int64 v13; // rcx
  u32 v14; // er9
  double v15; // xmm4_8
  double v16; // xmm5_8
  __int64 v17; // rbx
  unsigned __int64 v18; // r8
  unsigned __int64 v19; // r13
  unsigned __int64 v20; // rcx
  __int64 v21; // r12
  __int64 v22; // rdx
  __int64 v23; // r14
  __int64 v24; // rax
  __int64 v25; // r15
  __int64 v26; // r12
  unsigned __int64 v27; // rbx
  void *v28; // rsp
  char *v29; // rdi
  __int64 v30; // rax
  char **v31; // r13
  __int64 v32; // rax
  char v33; // cl
  __int64 v34; // rax
  unsigned __int64 v35; // r12
  __int64 v36; // rax
  __int64 *v37; // rax
  __int64 *v38; // rax
  __int64 v39; // rdx
  __int64 v40; // rax
  __int64 v41; // r13
  _QWORD *v42; // rax
  _QWORD *v43; // rdi
  __int64 v44; // r13
  __int64 v45; // r15
  _BYTE *v46; // rax
  __int64 *v47; // r14
  __int64 v48; // r12
  _BYTE *v49; // rdi
  __int64 v50; // rdx
  __int64 v51; // rsi
  _BYTE *v52; // rax
  _BYTE *v53; // rax
  unsigned __int64 v54; // rcx
  _QWORD *v55; // rsi
  unsigned __int64 v56; // rax
  unsigned __int64 v57; // rdx
  _QWORD *v58; // rbx
  unsigned __int64 v59; // rcx
  __int64 v60; // r11
  __int64 *v61; // rdi
  __int64 v62; // rsi
  _QWORD *v63; // rdx
  __int64 v64; // rax
  __int64 v65; // r10
  __int64 v66; // rdx
  __int64 v67; // r8
  _QWORD *v68; // rsi
  _QWORD *v69; // rax
  __int64 v70; // rcx
  __int64 v71; // rdi
  __int64 v72; // rdi
  __int64 v73; // rcx
  __int64 v74; // rax
  __int64 v76; // rsi
  __int64 v77; // rdx
  __int64 v78; // rax
  __int64 v79; // rcx
  unsigned __int64 v80; // r8
  __int64 *v81; // rdi
  __int64 v82; // rax
  __int64 v83; // r14
  _QWORD *v84; // rax
  int v85; // er8
  _QWORD *v86; // rax
  __int64 *v87; // rbx
  _BYTE *v88; // rax
  __int64 v89; // rdx
  __int64 v90; // rsi
  __int64 v91; // rdx
  _QWORD *v92; // rbx
  char *v93; // rax
  _QWORD *v94; // rdi
  __int64 *v95; // rax
  void *v96; // rsp
  unsigned __int64 v97; // [rsp+0h] [rbp-A0h] BYREF
  int v98; // [rsp+Ch] [rbp-94h]
  __int64 v99; // [rsp+10h] [rbp-90h]
  unsigned __int64 v100; // [rsp+18h] [rbp-88h]
  _QWORD *v101; // [rsp+20h] [rbp-80h]
  int v102; // [rsp+28h] [rbp-78h]
  int v103; // [rsp+2Ch] [rbp-74h]
  __int64 *v104; // [rsp+30h] [rbp-70h]
  _QWORD *v105; // [rsp+38h] [rbp-68h]
  __int64 v106; // [rsp+40h] [rbp-60h]
  __int64 *v107; // [rsp+48h] [rbp-58h]
  __int64 *v108; // [rsp+50h] [rbp-50h]
  __int64 *v109; // [rsp+58h] [rbp-48h]
  unsigned __int64 v110; // [rsp+68h] [rbp-38h] BYREF

  v108 = a1;
  v105 = a2;
  v107 = a3;
  v101 = a4;
  sub_4E120(0xEu, (char **)&v110, 0LL);
  v17 = a1 != 0LL;
  v18 = qword_C12F0 & v110;
  if ( (qword_C12F0 & v110) != 0 )
  {
    v20 = 0LL;
    do
    {
      v21 = v17 + 1;
      v19 = qword_C12F0 & v110;
      if ( _bittest64((const __int64 *)&v19, v20) )
      {
        v22 = v17 + 2;
        ++v17;
        v21 = v22;
      }
      v23 = v18 & -(1LL << ++v20);
    }
    while ( v23 );
    v24 = v21;
    v106 = v21;
    v25 = 0LL;
    v26 = v17;
    v27 = qword_C12F0 & v110;
    v28 = alloca(16 * v24);
    v109 = (__int64 *)&v97;
    v104 = (__int64 *)&v97;
    while ( !_bittest64((const __int64 *)&v27, v23) )
LABEL_10:
      ++v23;
    while ( 1 )
    {
      v29 = &aSse2[9 * (int)v23];
      v30 = v25++;
      v31 = (char **)&v109[2 * v30];
      *v31 = v29;
      v32 = strlen((__int64)v29);
      v33 = v23++;
      v31[1] = (char *)v32;
      v34 = 1LL << v33;
      v13 = v27 ^ (1LL << v33);
      if ( v34 == v27 )
        break;
      v27 = v13;
      if ( !_bittest64((const __int64 *)&v27, v23) )
        goto LABEL_10;
    }
    v17 = v26;
    v35 = v106;
  }
  else
  {
    v35 = v17 + 1;
    v25 = 0LL;
    v96 = alloca(16 * (v17 + 1));
    v104 = (__int64 *)&v97;
  }
  if ( v108 )
  {
    v36 = v25++;
    v37 = &v104[2 * v36];
    *v37 = (__int64)v108;
    v37[1] = (__int64)v105;
  }
  v38 = &v104[2 * v25];
  v108 = v38;
  *v38 = (__int64)"tls";
  v38[1] = 3LL;
  if ( v25 != v17 )
    sub_CF00(
      (__int64)"m == cnt",
      (__int64)"dl-hwcaps.c",
      0x4Au,
      "_dl_important_hwcaps",
      a5,
      a6,
      a7,
      a8,
      v15,
      v16,
      a11,
      a12);
  v109 = (__int64 *)v104[1];
  if ( v35 == 1 )
  {
    *v107 = 2LL;
    v105 = (_QWORD *)sub_21500(
                       (u32 *)((char *)v109 + 33),
                       (__int64)"tls",
                       v12,
                       v13,
                       (u32 *)v18,
                       v14,
                       a5,
                       a6,
                       a7,
                       a8,
                       v15,
                       v16,
                       a11,
                       a12);
    if ( v105 )
    {
      v91 = (__int64)v109;
      v92 = v105;
      v93 = (char *)v109 + 1;
      v94 = v105 + 4;
      v105[3] = 0LL;
      v92[1] = v93;
      v95 = v104;
      *v92 = v94;
      v92[2] = v94;
      *(_BYTE *)sub_91D0(v94, *v95, v91) = 47;
      *v101 = v92[1];
      return v105;
    }
    goto LABEL_52;
  }
  v39 = (__int64)v109 + 5;
  if ( v35 > 2 )
  {
    v76 = (__int64)v104;
    v77 = 2 * v39;
    v78 = 0LL;
    do
    {
      v79 = v78++;
      v77 += v104[2 * v79 + 3] + 1;
    }
    while ( v35 - 2 != v78 );
    if ( v35 == 3 )
    {
      v80 = 3LL;
    }
    else
    {
      if ( v35 > 0x3F )
        goto LABEL_52;
      v80 = (unsigned int)v35;
      if ( (unsigned __int64)(v77 + 128) >> (67 - (unsigned __int8)v35) )
        goto LABEL_52;
    }
    v81 = v107;
    LODWORD(v107) = v80;
    v98 = 1 << v80;
    v82 = 1 << v80;
    *v81 = v82;
    v99 = v82;
    v83 = 2 * v82;
    v84 = (_QWORD *)sub_21500(
                      (u32 *)((v77 << ((unsigned __int8)v80 - 3)) + 16 * v82),
                      v76,
                      v77 << ((unsigned __int8)v80 - 3),
                      (unsigned int)(v80 - 3),
                      (u32 *)v80,
                      v14,
                      a5,
                      a6,
                      a7,
                      a8,
                      v15,
                      v16,
                      a11,
                      a12);
    v85 = (int)v107;
    v105 = v84;
    if ( v84 )
    {
      v86 = v105;
      v43 = &v105[v83];
      *v105 = &v105[v83];
      v86[2] = v43;
      v100 = 1LL << v85;
      v102 = v85 - 1;
      v103 = 1 << (v85 - 1);
LABEL_19:
      v44 = v103;
      v97 = v35;
      v107 = (__int64 *)*v104;
      v45 = *v108;
      v106 = v17 - 1;
      do
      {
        v44 -= 2LL;
        v46 = (_BYTE *)sub_91D0(v43, v45, 3LL);
        v47 = v108;
        v48 = v106;
        *v46 = 47;
        v49 = v46 + 1;
        do
        {
          while ( (v44 & (1 << v48)) == 0 )
          {
            v47 -= 2;
            if ( !--v48 )
              goto LABEL_24;
          }
          v50 = *(v47 - 1);
          v51 = *(v47 - 2);
          v47 -= 2;
          v52 = (_BYTE *)sub_91D0(v49, v51, v50);
          *v52 = 47;
          v49 = v52 + 1;
          --v48;
        }
        while ( v48 );
LABEL_24:
        v53 = (_BYTE *)sub_91D0(v49, v107, v109);
        *v53 = 47;
        v43 = v53 + 1;
      }
      while ( v44 );
      v35 = v97;
      goto LABEL_26;
    }
LABEL_52:
    sub_50110(12LL, 0LL, 0LL, "cannot create capability list", a5, a6, a7, a8, v15, v16, a11, a12);
  }
  v98 = 1 << v35;
  v40 = 1 << v35;
  *v107 = v40;
  v99 = v40;
  v41 = 2 * v40;
  v105 = (_QWORD *)sub_21500(
                     (u32 *)(v39 + 16 * v40),
                     (__int64)"tls",
                     v39,
                     (unsigned int)v35,
                     (u32 *)((char *)&dword_0 + 1),
                     v14,
                     a5,
                     a6,
                     a7,
                     a8,
                     v15,
                     v16,
                     a11,
                     a12);
  if ( !v105 )
    goto LABEL_52;
  v42 = v105;
  v43 = &v105[v41];
  *v105 = &v105[v41];
  v42[2] = v43;
  v100 = 1LL << v35;
  v102 = v35 - 1;
  v103 = 1 << (v35 - 1);
  if ( v35 != 2 )
    goto LABEL_19;
  v87 = v104;
  v88 = (_BYTE *)sub_91D0(v43, v104[2], v104[3]);
  v89 = (__int64)v109;
  v90 = *v87;
  *v88 = 47;
  *(_BYTE *)sub_91D0(v88 + 1, v90, v89) = 47;
LABEL_26:
  v54 = v100;
  v55 = v105;
  v56 = 0LL;
  do
  {
    v57 = v56++;
    v55[2 * v57 + 1] = 0LL;
  }
  while ( v56 < v54 );
  v58 = v105;
  v59 = v35;
  v60 = v99;
  v61 = &v104[2 * v35];
  do
  {
    v62 = 1 << --v59;
    if ( v60 )
    {
      v63 = v58;
      v64 = v60;
      do
      {
        --v64;
        for ( v63 += 2; (v64 & v62) != 0; *(v63 - 3) = v65 + *(v61 - 1) + 1 )
        {
          v65 = *(v63 - 1);
          --v64;
          v63 += 2;
        }
      }
      while ( v64 );
    }
    v61 -= 2;
  }
  while ( v59 );
  v66 = 1LL << v102;
  v67 = v98 - 2;
  v68 = v105 + 4;
  if ( 1LL << v102 != v67 )
  {
    v69 = v105 + 4;
    v70 = v98 - 2;
    do
    {
      while ( (--v70 & 1) != 0 )
      {
        v71 = *(v69 - 4) + *(v69 - 3);
        v69 += 2;
        *(v69 - 2) = v71;
        if ( v66 == v70 )
          goto LABEL_40;
      }
      v72 = *(v69 - 2);
      v69 += 2;
      *(v69 - 2) = v72;
    }
    while ( v66 != v70 );
LABEL_40:
    v68 += 2 * (v67 - v66);
  }
  v73 = 2LL * -v103;
  do
  {
    v74 = v68[v73];
    v68 += 2;
    *(v68 - 2) = v74 + 4;
    --v66;
  }
  while ( v66 );
  *v101 = v105[1];
  return v105;
}
// 7634B: variable 'v14' is possibly undefined
// 7634B: variable 'v15' is possibly undefined
// 7634B: variable 'v16' is possibly undefined
// 7666F: variable 'v12' is possibly undefined
// 7666F: variable 'v13' is possibly undefined
// 7666F: variable 'v18' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// C12F0: using guessed type __int64 qword_C12F0;

//----- (0000000000076770) ----------------------------------------------------
signed __int64 __fastcall sub_76770(int a1, int a2, _BYTE *a3, int *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  bool v12; // zf
  _BYTE *v14; // r12
  int v16; // er9
  int v17; // ebx
  char v18; // al
  _BYTE *v19; // rdx
  unsigned __int64 v20; // rdx
  __int64 v22; // rax
  char *v23; // rdi
  char v24; // al
  char *v25; // rcx
  char v26; // r10
  __int64 v27; // r14
  int v28; // edx
  char v29; // al
  char *v30; // r12
  __int64 v31; // rax
  unsigned int v32; // eax
  unsigned int *v33; // rdx
  unsigned __int64 v34; // rdi
  char v35; // al
  unsigned int v36; // er11
  unsigned int v37; // edx
  __int64 v38; // rax
  __int64 v39; // rsi
  void *v40; // rdx
  __int64 v41; // rax
  unsigned int *v42; // rdx
  unsigned __int64 v43; // r11
  unsigned int v44; // eax
  unsigned __int64 *v45; // rdx
  __int64 v46; // rax
  char v47; // r11
  unsigned int v48; // eax
  int *v49; // rdx
  unsigned int v50; // eax
  void **v51; // rcx
  void *v52; // rdi
  unsigned __int64 v53; // rax
  size_t v54; // rdx
  int v55; // eax
  double v56; // xmm4_8
  double v57; // xmm5_8
  unsigned __int64 v58; // rax
  __int64 v59; // rax
  unsigned int v60; // eax
  int *v61; // rdx
  char v62; // r10
  _BYTE v63[27]; // [rsp+Bh] [rbp-477h] BYREF
  unsigned __int64 fd; // [rsp+26h] [rbp-45Ch]
  int v65; // [rsp+2Eh] [rbp-454h]
  _BYTE *v66; // [rsp+32h] [rbp-450h]
  char *v67; // [rsp+3Ah] [rbp-448h]
  char v68; // [rsp+46h] [rbp-43Ch] BYREF
  __int16 v69; // [rsp+50h] [rbp-432h] BYREF
  iovec vec[67]; // [rsp+52h] [rbp-430h] BYREF

  v12 = *a3 == 0;
  LODWORD(fd) = a1;
  if ( v12 )
  {
    v20 = 0LL;
    return sys_writev((unsigned int)fd, vec, v20);
  }
  v14 = a3;
  v67 = &v68;
  v16 = 0;
  v17 = 0;
LABEL_3:
  if ( a2 != 1 )
  {
    v18 = *v14;
    if ( !*v14 )
      goto LABEL_26;
LABEL_5:
    if ( v18 == 37 )
      goto LABEL_26;
    v19 = v14;
    do
    {
      if ( v18 == 10 && a2 )
        break;
      v18 = *++v19;
      if ( !v18 )
        break;
    }
    while ( v18 != 37 );
    if ( v17 > 63 )
LABEL_102:
      sub_CF00(
        (__int64)"niov < NIOVMAX",
        (__int64)"dl-misc.c",
        0x78u,
        "_dl_debug_vdprintf",
        a5,
        a6,
        a7,
        a8,
        a9,
        a10,
        a11,
        a12);
    vec[v17].iov_len = v19 - v14;
    if ( v19 != v14 )
      vec[v17++].iov_base = v14;
    if ( v18 != 37 )
      goto LABEL_15;
LABEL_28:
    v24 = v19[1];
    if ( v24 == 48 )
    {
      v24 = v19[2];
      v25 = v19 + 2;
      v26 = 48;
    }
    else
    {
      v25 = v19 + 1;
      v26 = 32;
    }
    v27 = -1LL;
    if ( v24 == 42 )
    {
      v48 = *a4;
      if ( (unsigned int)*a4 > 0x2F )
      {
        v49 = (int *)*((_QWORD *)a4 + 1);
        *((_QWORD *)a4 + 1) = v49 + 2;
      }
      else
      {
        v49 = (int *)(*((_QWORD *)a4 + 2) + v48);
        *a4 = v48 + 8;
      }
      v24 = v25[1];
      v27 = *v49;
      ++v25;
    }
    v28 = -1;
    if ( v24 == 46 )
    {
      if ( v25[1] != 42 )
LABEL_70:
        sub_CF00(
          (__int64)"! \"invalid format specifier\"",
          (__int64)"dl-misc.c",
          0xF3u,
          "_dl_debug_vdprintf",
          a5,
          a6,
          a7,
          a8,
          a9,
          a10,
          a11,
          a12);
      v60 = *a4;
      if ( (unsigned int)*a4 > 0x2F )
      {
        v61 = (int *)*((_QWORD *)a4 + 1);
        *((_QWORD *)a4 + 1) = v61 + 2;
      }
      else
      {
        v61 = (int *)(*((_QWORD *)a4 + 2) + v60);
        *a4 = v60 + 8;
      }
      v24 = v25[2];
      v28 = *v61;
      v25 += 2;
    }
    if ( v24 == 108 || v24 == 90 )
    {
      v29 = v25[1];
      v30 = v25 + 1;
      if ( v29 != 115 )
      {
        if ( v29 > 115 )
        {
          if ( v29 != 117 )
          {
            if ( v29 != 120 )
              goto LABEL_70;
            v44 = *a4;
            if ( (unsigned int)*a4 <= 0x2F )
              goto LABEL_58;
            goto LABEL_66;
          }
        }
        else
        {
          if ( v29 == 37 )
          {
LABEL_37:
            v31 = v17;
            vec[v31].iov_base = v30;
            vec[v31].iov_len = 1LL;
LABEL_38:
            ++v17;
LABEL_39:
            v14 = v30 + 1;
            goto LABEL_17;
          }
          if ( v29 != 100 )
            goto LABEL_70;
        }
        v44 = *a4;
        if ( (unsigned int)*a4 <= 0x2F )
        {
LABEL_58:
          v45 = (unsigned __int64 *)(*((_QWORD *)a4 + 2) + v44);
          *a4 = v44 + 8;
          goto LABEL_59;
        }
LABEL_66:
        v45 = (unsigned __int64 *)*((_QWORD *)a4 + 1);
        *((_QWORD *)a4 + 1) = v45 + 1;
LABEL_59:
        v35 = v25[1];
        v34 = *v45;
        if ( v35 == 100 )
        {
          v43 = v34 >> 63;
LABEL_61:
          HIBYTE(fd) = v43;
          v65 = v16;
          BYTE6(fd) = v26;
          v66 = v63;
          v46 = sub_7A1B0(v34, (__int64)v63, 0xAu, 0);
          v39 = (__int64)v66;
          v16 = v65;
          v47 = HIBYTE(fd);
          if ( (_DWORD)v27 == -1 || (v62 = BYTE6(fd), (__int64)&v66[-v46] >= v27) )
          {
            if ( !HIBYTE(fd) )
            {
LABEL_97:
              v40 = (void *)v46;
              goto LABEL_50;
            }
LABEL_63:
            *(_BYTE *)(v46 - 1) = 45;
            v40 = (void *)(v46 - 1);
LABEL_50:
            v41 = v17++;
            v41 *= 16LL;
            *(void **)((char *)&vec[0].iov_base + v41) = v40;
            *(size_t *)((char *)&vec[0].iov_len + v41) = v39 - (_QWORD)v40;
            goto LABEL_39;
          }
          v40 = (void *)v46;
LABEL_94:
          v46 = (__int64)v40;
          do
            *(_BYTE *)--v46 = v62;
          while ( v39 - v46 < v27 );
          if ( !v47 )
            goto LABEL_97;
          goto LABEL_63;
        }
LABEL_47:
        v37 = 16;
        v65 = v16;
        HIBYTE(fd) = v26;
        if ( v35 != 120 )
          v37 = 10;
        v66 = v63;
        v38 = sub_7A1B0(v34, (__int64)v63, v37, 0);
        v39 = (__int64)v66;
        v16 = v65;
        v40 = (void *)v38;
        if ( (_DWORD)v27 == -1 )
          goto LABEL_50;
        v62 = HIBYTE(fd);
        v47 = 0;
        if ( v27 <= (__int64)&v66[-v38] )
          goto LABEL_50;
        goto LABEL_94;
      }
LABEL_76:
      v50 = *a4;
      if ( (unsigned int)*a4 > 0x2F )
      {
        v51 = (void **)*((_QWORD *)a4 + 1);
        *((_QWORD *)a4 + 1) = v51 + 1;
      }
      else
      {
        v51 = (void **)(*((_QWORD *)a4 + 2) + v50);
        *a4 = v50 + 8;
      }
      v52 = *v51;
      v65 = v28;
      LODWORD(v66) = v16;
      vec[v17].iov_base = v52;
      v53 = strlen((__int64)v52);
      v54 = v65;
      v16 = (int)v66;
      if ( v65 == -1 )
      {
        vec[v17].iov_len = v53;
      }
      else
      {
        if ( v65 > v53 )
          v54 = v53;
        vec[v17].iov_len = v54;
      }
      goto LABEL_38;
    }
    if ( v24 == 115 )
    {
      v30 = v25;
      goto LABEL_76;
    }
    if ( v24 > 115 )
    {
      if ( v24 != 117 )
      {
        if ( v24 != 120 )
          goto LABEL_70;
        v32 = *a4;
        if ( (unsigned int)*a4 <= 0x2F )
        {
LABEL_45:
          v33 = (unsigned int *)(*((_QWORD *)a4 + 2) + v32);
          *a4 = v32 + 8;
          v34 = *v33;
          v35 = *v25;
          v36 = *v33;
          if ( *v25 != 100 )
          {
LABEL_46:
            v30 = v25;
            goto LABEL_47;
          }
LABEL_55:
          LODWORD(v43) = v36 >> 31;
          v30 = v25;
          goto LABEL_61;
        }
LABEL_54:
        v42 = (unsigned int *)*((_QWORD *)a4 + 1);
        *((_QWORD *)a4 + 1) = v42 + 2;
        v34 = *v42;
        v35 = *v25;
        v36 = *v42;
        if ( *v25 != 100 )
          goto LABEL_46;
        goto LABEL_55;
      }
    }
    else
    {
      v30 = v25;
      if ( v24 == 37 )
        goto LABEL_37;
      if ( v24 != 100 )
        goto LABEL_70;
    }
    v32 = *a4;
    if ( (unsigned int)*a4 <= 0x2F )
      goto LABEL_45;
    goto LABEL_54;
  }
  do
  {
    if ( !v16 )
    {
      v55 = sub_806C0();
      if ( v55 < 0 )
        sub_CF00(
          (__int64)"pid >= 0 && sizeof (pid_t) <= 4",
          (__int64)"dl-misc.c",
          0x62u,
          "_dl_debug_vdprintf",
          a5,
          a6,
          a7,
          a8,
          v56,
          v57,
          a11,
          a12);
      LODWORD(v66) = v55;
      v58 = sub_7A1B0(v55, (__int64)&v69, 0xAu, 0);
      v16 = (int)v66;
      if ( v58 > (unsigned __int64)v67 )
      {
        sub_9190((__int64)v67, 32LL, v58 - (_QWORD)v67);
        v16 = (int)v66;
      }
      v69 = 2362;
    }
    if ( v17 > 63 )
      sub_CF00(
        (__int64)"niov < NIOVMAX",
        (__int64)"dl-misc.c",
        0x6Bu,
        "_dl_debug_vdprintf",
        a5,
        a6,
        a7,
        a8,
        a9,
        a10,
        a11,
        a12);
    v22 = v17;
    v23 = v67;
    ++v17;
    a2 = -1;
    v22 *= 16LL;
    *(size_t *)((char *)&vec[0].iov_len + v22) = 12LL;
    *(void **)((char *)&vec[0].iov_base + v22) = v23;
    v18 = *v14;
    if ( *v14 )
      goto LABEL_5;
LABEL_26:
    if ( v17 > 63 )
      goto LABEL_102;
    vec[v17].iov_len = 0LL;
    v19 = v14;
    if ( v18 == 37 )
      goto LABEL_28;
LABEL_15:
    if ( v18 != 10 )
    {
      v14 = v19;
LABEL_17:
      if ( !*v14 )
        break;
      goto LABEL_3;
    }
    if ( v14 == v19 )
    {
      v59 = v17++;
      v59 *= 16LL;
      *(void **)((char *)&vec[0].iov_base + v59) = v19;
      *(size_t *)((char *)&vec[0].iov_len + v59) = 1LL;
    }
    else
    {
      ++vec[v17 - 1].iov_len;
    }
    v14 = v19 + 1;
  }
  while ( v19[1] );
  v20 = v17;
  return sys_writev((unsigned int)fd, vec, v20);
}
// 76B8C: variable 'a9' is possibly undefined
// 76B8C: variable 'a10' is possibly undefined
// 76DEC: variable 'v56' is possibly undefined
// 76DEC: variable 'v57' is possibly undefined
// 76770: using guessed type struct iovec vec[67];

//----- (0000000000076E00) ----------------------------------------------------
__int64 __fastcall sub_76E00(const char *a1, __off_t *a2, unsigned int a3)
{
  __int64 v4; // r12
  signed int v6; // eax
  unsigned int v8; // ebp
  unsigned __int64 v9; // rsi
  struct stat v10; // [rsp+0h] [rbp-B8h] BYREF

  v4 = -1LL;
  v6 = sub_4B910(a1, (int)sub_80000, a3);
  if ( v6 >= 0 )
  {
    v8 = v6;
    if ( (sub_4AA80(1u, v6, &v10) & 0x80000000) == 0LL && (v9 = v10.st_size, *a2 = v10.st_size, v9) )
      v4 = (__int64)mmap(0LL, v9, a3, 2u, v8, 0LL);
    else
      v4 = -1LL;
    sub_4B7A0(v8);
  }
  return v4;
}

//----- (0000000000076EA0) ----------------------------------------------------
signed __int64 sub_76EA0(_BYTE *a1, ...)
{
  __va_list_tag va[1]; // [rsp+8h] [rbp-D0h] BYREF
  __int128 v3; // [rsp+50h] [rbp-88h]
  __int128 v4; // [rsp+60h] [rbp-78h]
  __int128 v5; // [rsp+70h] [rbp-68h]
  __int128 v6; // [rsp+80h] [rbp-58h]
  __int128 v7; // [rsp+90h] [rbp-48h]
  __int128 v8; // [rsp+A0h] [rbp-38h]
  __int128 v9; // [rsp+B0h] [rbp-28h]
  __int128 v10; // [rsp+C0h] [rbp-18h]

  va_start(va, a1);
  *(double *)&v3 = va_arg(va, double);
  *(double *)&v4 = va_arg(va, double);
  *(double *)&v5 = va_arg(va, double);
  *(double *)&v6 = va_arg(va, double);
  *(double *)&v7 = va_arg(va, double);
  *(double *)&v8 = va_arg(va, double);
  *(double *)&v9 = va_arg(va, double);
  *(double *)&v10 = va_arg(va, double);
  va_end(va);
  va_start(va, a1);
  return sub_76770(
           dword_BF074,
           1,
           a1,
           (int *)va,
           *(double *)&v3,
           *(double *)&v4,
           *(double *)&v5,
           *(double *)&v6,
           *(double *)&v7,
           *(double *)&v8,
           *(double *)&v9,
           *(double *)&v10);
}
// BF074: using guessed type int dword_BF074;

//----- (0000000000076F50) ----------------------------------------------------
signed __int64 sub_76F50(_BYTE *a1, ...)
{
  __va_list_tag va[1]; // [rsp+8h] [rbp-D0h] BYREF
  __int128 v3; // [rsp+50h] [rbp-88h]
  __int128 v4; // [rsp+60h] [rbp-78h]
  __int128 v5; // [rsp+70h] [rbp-68h]
  __int128 v6; // [rsp+80h] [rbp-58h]
  __int128 v7; // [rsp+90h] [rbp-48h]
  __int128 v8; // [rsp+A0h] [rbp-38h]
  __int128 v9; // [rsp+B0h] [rbp-28h]
  __int128 v10; // [rsp+C0h] [rbp-18h]

  va_start(va, a1);
  *(double *)&v3 = va_arg(va, double);
  *(double *)&v4 = va_arg(va, double);
  *(double *)&v5 = va_arg(va, double);
  *(double *)&v6 = va_arg(va, double);
  *(double *)&v7 = va_arg(va, double);
  *(double *)&v8 = va_arg(va, double);
  *(double *)&v9 = va_arg(va, double);
  *(double *)&v10 = va_arg(va, double);
  va_end(va);
  va_start(va, a1);
  return sub_76770(
           dword_BF074,
           -1,
           a1,
           (int *)va,
           *(double *)&v3,
           *(double *)&v4,
           *(double *)&v5,
           *(double *)&v6,
           *(double *)&v7,
           *(double *)&v8,
           *(double *)&v9,
           *(double *)&v10);
}
// BF074: using guessed type int dword_BF074;

//----- (0000000000077150) ----------------------------------------------------
signed __int64 sub_77150(_BYTE *a1, ...)
{
  __va_list_tag va[1]; // [rsp+8h] [rbp-D0h] BYREF

  va_start(va, a1);
  return sub_76770(2, 0, a1, (int *)va);
}

//----- (0000000000077200) ----------------------------------------------------
void __noreturn sub_77200(_BYTE *a1, ...)
{
  __va_list_tag va[1]; // [rsp+8h] [rbp-D0h] BYREF
  __int128 v2; // [rsp+50h] [rbp-88h]
  __int128 v3; // [rsp+60h] [rbp-78h]
  __int128 v4; // [rsp+70h] [rbp-68h]
  __int128 v5; // [rsp+80h] [rbp-58h]
  __int128 v6; // [rsp+90h] [rbp-48h]
  __int128 v7; // [rsp+A0h] [rbp-38h]
  __int128 v8; // [rsp+B0h] [rbp-28h]
  __int128 v9; // [rsp+C0h] [rbp-18h]

  va_start(va, a1);
  *(double *)&v2 = va_arg(va, double);
  *(double *)&v3 = va_arg(va, double);
  *(double *)&v4 = va_arg(va, double);
  *(double *)&v5 = va_arg(va, double);
  *(double *)&v6 = va_arg(va, double);
  *(double *)&v7 = va_arg(va, double);
  *(double *)&v8 = va_arg(va, double);
  *(double *)&v9 = va_arg(va, double);
  va_end(va);
  va_start(va, a1);
  sub_76770(
    2,
    0,
    a1,
    (int *)va,
    *(double *)&v2,
    *(double *)&v3,
    *(double *)&v4,
    *(double *)&v5,
    *(double *)&v6,
    *(double *)&v7,
    *(double *)&v8,
    *(double *)&v9);
  sub_49B40(127);
}

//----- (00000000000772B0) ----------------------------------------------------
__int64 __fastcall sub_772B0(__int64 a1, __int64 a2)
{
  int v2; // er8
  __int64 result; // rax
  _QWORD *v4; // rbx

  v2 = sub_91B0(a1, *(_QWORD *)(a2 + 8));
  result = 1LL;
  if ( v2 )
  {
    v4 = *(_QWORD **)(a2 + 56);
    if ( v4 )
    {
      while ( (unsigned int)sub_91B0(a1, *v4) )
      {
        v4 = (_QWORD *)v4[1];
        if ( !v4 )
          goto LABEL_8;
      }
      result = 1LL;
    }
    else
    {
LABEL_8:
      result = 0LL;
    }
  }
  return result;
}
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);

//----- (0000000000077320) ----------------------------------------------------
__int64 __fastcall sub_77320(unsigned __int64 a1)
{
  char *v1; // rcx
  char *v2; // rdx
  char *v3; // rax

  v1 = (char *)&unk_A6AF8;
  v2 = (char *)&unk_A6AF8 - 120;
  while ( v1 != v2 )
  {
    v3 = &v2[4 * ((__int64)(((v1 - v2) >> 2) + ((unsigned __int64)(v1 - v2) >> 63)) >> 1)];
    if ( *(unsigned int *)v3 < a1 )
      v2 = v3 + 4;
    else
      v1 = &v2[4 * ((__int64)(((v1 - v2) >> 2) + ((unsigned __int64)(v1 - v2) >> 63)) >> 1)];
  }
  return *(unsigned int *)v1;
}

//----- (0000000000077370) ----------------------------------------------------
unsigned __int64 __fastcall sub_77370(char *a1, char **a2)
{
  char v2; // al
  char v3; // bl
  char *v4; // rdi
  char v5; // al
  int v6; // er9
  int v7; // er10
  unsigned __int64 v8; // r8
  unsigned int v9; // er10
  __int64 v10; // rcx
  unsigned __int64 result; // rax

  v2 = *a1;
  if ( *a1 != 32 )
    goto LABEL_3;
  do
  {
    do
      v2 = *++a1;
    while ( v2 == 32 );
LABEL_3:
    ;
  }
  while ( v2 == 9 );
  if ( v2 == 45 )
  {
    v4 = a1 + 1;
    v3 = 0;
  }
  else
  {
    v3 = 1;
    v4 = &a1[v2 == 43];
  }
  v5 = *v4;
  if ( (unsigned __int8)(*v4 - 48) <= 9u )
  {
    v6 = 10;
    v7 = 9;
    if ( v5 == 48 )
    {
      if ( (v4[1] & 0xDF) == 88 )
      {
        v5 = v4[2];
        v6 = 16;
        v4 += 2;
      }
      else
      {
        v6 = 8;
        v7 = 7;
      }
    }
    v8 = 0LL;
    v9 = v7 + 48;
    while ( v5 <= 47 || v5 > v9 )
    {
      if ( v6 != 16 )
        goto LABEL_23;
      if ( (unsigned __int8)(v5 - 97) > 5u )
      {
        if ( (unsigned __int8)(v5 - 65) > 5u )
        {
LABEL_23:
          if ( a2 )
            *a2 = v4;
          if ( !v3 )
            v8 = -(__int64)v8;
          return v8;
        }
        v10 = (char)(v5 - 55);
        goto LABEL_11;
      }
      v10 = (char)(v5 - 87);
      if ( ~v10 / 0x10uLL <= v8 )
      {
LABEL_17:
        v8 = -1LL;
        if ( a2 )
          goto LABEL_29;
        return v8;
      }
LABEL_12:
      v5 = *++v4;
      v8 = v10 + v6 * v8;
    }
    v10 = (char)(v5 - 48);
LABEL_11:
    if ( ~v10 / (unsigned __int64)v6 <= v8 )
      goto LABEL_17;
    goto LABEL_12;
  }
  v8 = 0LL;
  if ( !a2 )
    return v8;
LABEL_29:
  result = v8;
  *a2 = v4;
  return result;
}

//----- (00000000000774E0) ----------------------------------------------------
__int64 __fastcall sub_774E0(__m128 a1, __m128 a2, __m128 a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14)
{
  _QWORD *v14; // rax
  _QWORD *v15; // rdi
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // rcx
  __int64 v18; // r11
  __int64 v19; // r8
  __int64 v20; // rdi
  __int64 v21; // rax
  unsigned __int64 v22; // r13
  unsigned __int64 v23; // rbx
  unsigned __int64 v24; // rdx
  __int64 v25; // r12
  void *v26; // rsp
  _BYTE *v27; // rax
  unsigned int v28; // eax
  double v29; // xmm4_8
  double v30; // xmm5_8
  unsigned int v31; // er15
  unsigned __int64 v32; // r14
  __int64 v33; // rcx
  double v34; // xmm4_8
  double v35; // xmm5_8
  char *v36; // r9
  char *v37; // r8
  char *v38; // r15
  char *v39; // r13
  unsigned int v40; // er14
  __int64 v41; // rax
  __int64 result; // rax
  int v43; // eax
  __int64 v44; // rdx
  __int64 v45; // rax
  __int64 v46; // rdi
  unsigned int v47; // edx
  __int64 v48; // r9
  __int64 v49; // rax
  char *v50; // rdx
  char *v51; // r8
  unsigned int v52; // ecx
  __int64 v53; // rsi
  __int16 *v54; // rsi
  __int16 v55; // r10
  __int64 v56; // rax
  unsigned __int64 v57; // rcx
  unsigned __int64 v58; // r13
  void *v59; // rsp
  signed __int64 v60; // rax
  unsigned __int64 v61; // rax
  __int64 v62; // r14
  char v63[8]; // [rsp+0h] [rbp-2D0h] BYREF
  __int64 v64; // [rsp+8h] [rbp-2C8h]
  char *v65; // [rsp+10h] [rbp-2C0h]
  unsigned __int64 v66; // [rsp+18h] [rbp-2B8h]
  unsigned __int64 v67; // [rsp+20h] [rbp-2B0h]
  __int64 v68; // [rsp+28h] [rbp-2A8h]
  __m128i v69; // [rsp+30h] [rbp-2A0h] BYREF
  int v70; // [rsp+40h] [rbp-290h]
  __m128i v71; // [rsp+50h] [rbp-280h] BYREF
  __m128i v72; // [rsp+60h] [rbp-270h] BYREF
  __int64 v73; // [rsp+70h] [rbp-260h]
  struct stat v74; // [rsp+80h] [rbp-250h] BYREF
  char v75[448]; // [rsp+110h] [rbp-1C0h] BYREF

  v14 = *(_QWORD **)(qword_C1488 + 680);
  v15 = &v14[7 * *(unsigned __int16 *)(qword_C1488 + 696)];
  if ( v15 <= v14 )
  {
    v20 = 0LL;
    v19 = -1LL;
    v17 = -1LL;
    v16 = 0LL;
  }
  else
  {
    v16 = 0LL;
    v17 = -1LL;
    a14 = 0x1FFFFFFFFLL;
    v18 = -(__int64)off_BF078;
    do
    {
      if ( (*v14 & 0x1FFFFFFFFLL) == 0x100000001LL )
      {
        if ( v17 > ((unsigned __int64)v18 & v14[2]) )
          v17 = v18 & v14[2];
        if ( v16 < (v18 & ((unsigned __int64)&off_BF078[-1].r_addend + v14[5] + v14[2] + 7)) )
          v16 = v18 & ((unsigned __int64)&off_BF078[-1].r_addend + v14[5] + v14[2] + 7);
      }
      v14 += 7;
    }
    while ( v15 > v14 );
    v19 = v17;
    v20 = v16;
  }
  dword_C1764 = 0;
  v21 = *(_QWORD *)qword_C1488;
  dword_C1728 = 5;
  v22 = (v21 + v16 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  qword_C1738 = (v21 + v17) & 0xFFFFFFFFFFFFFFFCLL;
  v23 = v22 - qword_C1738;
  qword_C1730 = v22 - qword_C1738;
  v24 = 3 * (v22 - qword_C1738) / 0x64;
  if ( (unsigned int)v24 > 0x31 )
  {
    if ( (unsigned int)v24 <= 0x100000 )
    {
      dword_C1744 = 3 * (v22 - qword_C1738) / 0x64;
      v62 = 320LL * (unsigned int)v24;
      v24 = 16LL * (unsigned int)v24;
      v67 = v24;
      v68 = v62 + 72;
    }
    else
    {
      dword_C1744 = 0x100000;
      v67 = 0x1000000LL;
      v68 = 335544392LL;
    }
  }
  else
  {
    dword_C1744 = 50;
    v67 = 800LL;
    v68 = 16072LL;
  }
  v71.m128i_i64[0] = v19;
  v71.m128i_i64[1] = v20;
  v69 = (__m128i)0x1FFFF6E6F6D67uLL;
  v70 = 0;
  v72.m128i_i32[0] = v23 >> 2;
  v73 = 0x7300000000000000LL;
  v72.m128i_i32[1] = sub_80920(v20, v16, v24, 0x28F5C28F5C28F5C3LL, v19, a14);
  v72.m128i_i64[1] = 0x73646E6F636573LL;
  v25 = strlen(qword_C1498);
  v26 = alloca(v25 + strlen(qword_C14A0) + 18);
  v27 = (_BYTE *)sub_90F0(v63);
  *v27 = 47;
  strcpy((char *)sub_90F0(v27 + 1), ".profile");
  v28 = sub_4B910(v63, (int)&loc_20042, 438);
  v31 = v28;
  if ( v28 == -1 )
  {
    v39 = "%s: cannot open file: %s\n";
    v40 = __readfsdword(0xFFFFFFC0);
    goto LABEL_26;
  }
  if ( (sub_4AA80(1u, v28, &v74) & 0x80000000) != 0LL || (v74.st_mode & 0xF000) != 0x8000 )
  {
    v39 = "%s: cannot stat file: %s\n";
    goto LABEL_25;
  }
  v66 = v23 >> 1;
  v32 = (v23 >> 1) + v68;
  if ( !v74.st_size )
  {
    v65 = v63;
    v64 = (__int64)off_BF078;
    v59 = alloca((signed __int64)off_BF078);
    v68 = (__int64)v63;
    sub_9190((__int64)v63, 0LL, (__int64)off_BF078);
    if ( sub_4AD50(v31, v32 & -v64, 0) != -1LL )
    {
      while ( 1 )
      {
        v60 = sub_4BA90(v31, (const char *)v68, v32 & ((unsigned __int64)&off_BF078[-1].r_addend + 7));
        if ( v60 != -1 )
          break;
        if ( __readfsdword(0xFFFFFFC0) != 4 )
          goto LABEL_49;
      }
      if ( v60 >= 0 )
        goto LABEL_17;
    }
LABEL_49:
    v39 = (char *)&unk_A6B47;
LABEL_25:
    v40 = __readfsdword(0xFFFFFFC0);
    sub_4B7A0(v31);
LABEL_26:
    v41 = sub_23140(
            v40,
            v75,
            400LL,
            *(double *)a1.m128_u64,
            *(double *)a2.m128_u64,
            *(double *)a3.m128_u64,
            a4,
            v29,
            v30,
            a7,
            a8);
    return sub_77150(v39, v63, v41);
  }
  if ( v74.st_size != v32 )
  {
    sub_4B7A0(v31);
    return sub_77150("%s: file is no correct profile data file for `%s'\n", v63, (const char *)qword_C14A0);
  }
LABEL_17:
  v68 = (__int64)mmap(0LL, v32, 3uLL, 1u, v31, 0LL);
  if ( v68 == -1 )
  {
    v39 = "%s: cannot map file: %s\n";
    goto LABEL_25;
  }
  sub_4B7A0(v31);
  v36 = (char *)v68;
  v37 = (char *)(v68 + v66 + 68);
  v38 = (char *)(v68 + 64);
  qword_C1758 = (__int64)v37;
  qword_C1768 = v68 + v66 + 72;
  if ( v74.st_size )
  {
    if ( *(_OWORD *)&v69 != *(_OWORD *)v68
      || *(_DWORD *)(v68 + 16) != v70
      || *(_DWORD *)(v68 + 20)
      || *(_OWORD *)&v71 != *(_OWORD *)(v68 + 24)
      || (v44 = v72.m128i_i64[0] ^ *(_QWORD *)(v68 + 40) | v72.m128i_i64[1] ^ *(_QWORD *)(v68 + 48),
          *(_OWORD *)&v72 != *(_OWORD *)(v68 + 40))
      || *(_QWORD *)(v68 + 56) != v73
      || *(_DWORD *)(v68 + v66 + 64) != 1 )
    {
      munmap((void *)v68, v32);
      return sub_77150("%s: file is no correct profile data file for `%s'\n", v63, (const char *)qword_C14A0);
    }
  }
  else
  {
    a1 = (__m128)_mm_loadu_si128(&v69);
    v43 = v70;
    *(_DWORD *)(v68 + 20) = 0;
    a2 = (__m128)_mm_loadu_si128(&v71);
    a3 = (__m128)_mm_loadu_si128(&v72);
    v44 = v73;
    *((_DWORD *)v36 + 4) = v43;
    *(__m128 *)v36 = a1;
    *((_QWORD *)v36 + 7) = v44;
    *(__m128 *)(v36 + 24) = a2;
    *(__m128 *)(v36 + 40) = a3;
    *((_DWORD *)v37 - 1) = 1;
  }
  v65 = v36;
  v68 = (__int64)v37;
  v45 = sub_22260(
          v66 + v67,
          1uLL,
          *(double *)a1.m128_u64,
          *(double *)a2.m128_u64,
          *(double *)a3.m128_u64,
          a4,
          v34,
          v35,
          a7,
          a8,
          v44,
          v33,
          (u32 *)v37,
          (__int64)v36);
  qword_C1750 = v45;
  v46 = v45;
  if ( !v45 )
  {
    munmap(v65, v32);
    sub_77200("Out of memory while initializing profiler\n");
  }
  dword_C1740 = 0;
  v47 = *(_DWORD *)v68;
  v48 = v45 + v66;
  v49 = (unsigned int)dword_C1744;
  qword_C1748 = v46 + v66;
  if ( v47 < dword_C1744 )
    v49 = *(unsigned int *)v68;
  dword_C1760 = v49;
  if ( v49 )
  {
    v50 = (char *)(v68 + 20 * v49 - 16);
    v51 = (char *)(v68 - 16);
    do
    {
      v52 = dword_C1740;
      v53 = *((_QWORD *)v50 + 1) >> 2;
      ++dword_C1740;
      v54 = (__int16 *)(v46 + 2 * v53);
      v55 = *v54;
      v56 = v48 + 16LL * v52;
      *(_QWORD *)v56 = v50;
      v50 -= 20;
      *(_WORD *)(v56 + 8) = v55;
      *v54 = v52;
    }
    while ( v51 != v50 );
  }
  LODWORD(v57) = 0x10000;
  v58 = v22 - qword_C1738;
  if ( v58 > v66 )
  {
    LODWORD(v57) = 1;
    if ( v58 / v66 <= 0xFFFF )
    {
      if ( v58 / v66 <= 0xFF )
      {
        if ( v58 <= 0xFFFFFFFFFFFFFFLL )
          v61 = (v58 << 8) / v66;
        else
          v61 = v58 / (v23 >> 9);
        v57 = 0x1000000 / v61;
      }
      else
      {
        v57 = 0x10000 / (v58 / v66);
      }
    }
  }
  result = sub_80760((__int64)v38, v66, qword_C1738, v57);
  dword_C1764 = 1;
  return result;
}
// 77881: variable 'v29' is possibly undefined
// 77881: variable 'v30' is possibly undefined
// 77957: variable 'v34' is possibly undefined
// 77957: variable 'v35' is possibly undefined
// 77957: variable 'v33' is possibly undefined
// 90F0: using guessed type __int64 __fastcall sub_90F0(_QWORD);
// 80920: using guessed type __int64 __fastcall sub_80920(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// BF078: using guessed type Elf64_Rela *off_BF078;
// C1488: using guessed type __int64 qword_C1488;
// C1498: using guessed type __int64 qword_C1498;
// C14A0: using guessed type __int64 qword_C14A0;
// C1728: using guessed type int dword_C1728;
// C1730: using guessed type __int64 qword_C1730;
// C1738: using guessed type __int64 qword_C1738;
// C1740: using guessed type int dword_C1740;
// C1744: using guessed type int dword_C1744;
// C1748: using guessed type __int64 qword_C1748;
// C1750: using guessed type __int64 qword_C1750;
// C1758: using guessed type __int64 qword_C1758;
// C1760: using guessed type int dword_C1760;
// C1764: using guessed type int dword_C1764;
// C1768: using guessed type __int64 qword_C1768;

//----- (0000000000077C60) ----------------------------------------------------
void __fastcall sub_77C60(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rdi
  unsigned __int64 v3; // rsi
  __int64 v4; // rcx
  _WORD *v5; // rdx
  __int64 v6; // rax
  __int64 v7; // rdx
  _QWORD *v8; // r8
  __int64 v9; // rax
  _DWORD *v10; // r10
  __int64 i; // rax
  __int64 v12; // r9
  int v13; // er8
  _WORD *v14; // r9
  __int64 v15; // r8
  __int64 v16; // rax
  unsigned int v17; // ecx
  __int16 v18; // ax
  __int64 v19; // rax
  __int64 v20; // rdx

  if ( dword_C1764 )
  {
    v2 = a1 - qword_C1738;
    if ( qword_C1730 <= v2 )
      v2 = 0LL;
    v3 = a2 - qword_C1738;
    if ( qword_C1730 > v3 )
    {
      v4 = qword_C1750;
      v5 = (_WORD *)(qword_C1750 + 2 * (v3 >> dword_C1728));
      v6 = (unsigned __int16)*v5;
      if ( !*v5 )
        goto LABEL_10;
      while ( 1 )
      {
        v7 = qword_C1748 + 16 * v6;
        v8 = *(_QWORD **)v7;
        if ( **(_QWORD **)v7 == v2 )
          goto LABEL_27;
        v9 = *(unsigned __int16 *)(v7 + 8);
        if ( (_WORD)v9 )
        {
          do
          {
            v7 = qword_C1748 + 16 * v9;
            v9 = *(unsigned __int16 *)(v7 + 8);
            v8 = *(_QWORD **)v7;
          }
          while ( (_WORD)v9 && *v8 != v2 );
        }
        if ( *v8 == v2 )
          goto LABEL_27;
        v5 = (_WORD *)(v7 + 8);
LABEL_10:
        v10 = (_DWORD *)qword_C1758;
        for ( i = (unsigned int)dword_C1760; *v10 != dword_C1760; i = (unsigned int)++dword_C1760 )
        {
          if ( dword_C1744 <= (unsigned int)i )
            break;
          v12 = *(_QWORD *)(qword_C1768 + 20 * i + 8) >> 2;
          if ( __readfsdword(0x18u) )
            __asm { lock }
          v13 = dword_C1740++;
          v14 = (_WORD *)(v4 + 2 * v12);
          v15 = (unsigned int)(v13 + 1);
          v16 = qword_C1748 + 16 * v15;
          *(_QWORD *)v16 = qword_C1768 + 20LL * (unsigned int)dword_C1760;
          *(_WORD *)(v16 + 8) = *v14;
          *v14 = v15;
          if ( __readfsdword(0x18u) )
            __asm { lock }
        }
        if ( !*v5 )
          break;
        v6 = (unsigned __int16)*v5;
      }
      if ( __readfsdword(0x18u) )
        __asm { lock }
      v17 = (*v10)++;
      if ( dword_C1744 > v17 )
      {
        if ( __readfsdword(0x18u) )
          __asm { lock }
        v18 = dword_C1740++;
        *v5 = v18 + 1;
        v19 = qword_C1748 + 16LL * (unsigned __int16)*v5;
        v20 = qword_C1768 + 20LL * v17;
        *(_QWORD *)v19 = v20;
        *(_QWORD *)v20 = v2;
        *(_QWORD *)(v20 + 8) = v3;
        *(_DWORD *)(v20 + 16) = 0;
        *(_WORD *)(v19 + 8) = 0;
        if ( __readfsdword(0x18u) )
          __asm { lock }
        ++dword_C1760;
        v8 = *(_QWORD **)v19;
LABEL_27:
        if ( __readfsdword(0x18u) )
          __asm { lock }
        ++*((_DWORD *)v8 + 4);
        return;
      }
    }
  }
}
// C1728: using guessed type int dword_C1728;
// C1730: using guessed type __int64 qword_C1730;
// C1738: using guessed type __int64 qword_C1738;
// C1740: using guessed type int dword_C1740;
// C1744: using guessed type int dword_C1744;
// C1748: using guessed type __int64 qword_C1748;
// C1750: using guessed type __int64 qword_C1750;
// C1758: using guessed type __int64 qword_C1758;
// C1760: using guessed type int dword_C1760;
// C1764: using guessed type int dword_C1764;
// C1768: using guessed type __int64 qword_C1768;

//----- (0000000000077EB0) ----------------------------------------------------
__int64 __fastcall sub_77EB0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  signed __int64 v8; // rax
  u32 *v9; // r8
  u32 v10; // er9
  double v11; // xmm4_8
  double v12; // xmm5_8
  __int64 v13; // rdx
  char *v14; // rax
  unsigned int v15; // ebx
  __int64 v16; // r12
  __int64 v17; // rbp
  __int64 v18; // r13
  __int64 v19; // rdx
  __int64 v20; // rcx
  u32 *v21; // r8
  u32 v22; // er9
  double v23; // xmm4_8
  double v24; // xmm5_8
  __int64 v25; // rax
  _BYTE *v26; // rax
  __int64 v28; // rax
  char vars0[4136]; // [rsp+0h] [rbp+0h] BYREF

  v8 = sys_readlink("/proc/self/exe", vars0, 4096);
  if ( (unsigned int)v8 > 0xFFFFF000 || (int)v8 <= 0 || vars0[0] == 91 )
  {
    v17 = qword_C1480;
    if ( qword_C1480
      && (v18 = strlen(qword_C1480),
          v25 = sub_21500((u32 *)(v18 + 1), (__int64)vars0, v19, v20, v21, v22, a1, a2, a3, a4, v23, v24, a7, a8),
          (v16 = v25) != 0) )
    {
      v26 = (_BYTE *)sub_91D0(v25, v17, v18);
      if ( (unsigned __int64)v26 > v16 + 1 )
      {
        do
        {
          if ( *(v26 - 1) != 47 )
            break;
          --v26;
        }
        while ( v26 != (_BYTE *)(v16 + 1) );
      }
      *v26 = 0;
    }
    else
    {
LABEL_18:
      v16 = -1LL;
    }
  }
  else
  {
    if ( vars0[0] != 47 )
      sub_CF00(
        (__int64)"linkval[0] == '/'",
        (__int64)"../sysdeps/unix/sysv/linux/dl-origin.c",
        0x2Eu,
        "_dl_get_origin",
        a1,
        a2,
        a3,
        a4,
        v11,
        v12,
        a7,
        a8);
    v13 = (unsigned int)v8;
    v14 = &vars0[(int)v8];
    while ( 1 )
    {
      if ( (_DWORD)v13 == 1 )
      {
        v16 = sub_21500(
                (u32 *)((char *)&dword_0 + 2),
                (__int64)vars0,
                v13,
                (unsigned __int8)vars0[0],
                v9,
                v10,
                a1,
                a2,
                a3,
                a4,
                v11,
                v12,
                a7,
                a8);
        if ( !v16 )
          goto LABEL_18;
        *(_WORD *)v16 = 47;
        return v16;
      }
      --v14;
      v15 = v13 - 1;
      if ( *v14 == 47 )
        break;
      v13 = v15;
    }
    v28 = sub_21500(
            (u32 *)((int)v13 + 1),
            (__int64)vars0,
            (unsigned int)(v13 + 1),
            (unsigned __int8)vars0[0],
            v9,
            v10,
            a1,
            a2,
            a3,
            a4,
            v11,
            v12,
            a7,
            a8);
    v16 = v28;
    if ( !v28 )
      goto LABEL_18;
    *(_BYTE *)sub_91D0(v28, vars0, (int)v15) = 0;
  }
  return v16;
}
// 77F1C: variable 'v9' is possibly undefined
// 77F1C: variable 'v10' is possibly undefined
// 77F1C: variable 'v11' is possibly undefined
// 77F1C: variable 'v12' is possibly undefined
// 77F53: variable 'v19' is possibly undefined
// 77F53: variable 'v20' is possibly undefined
// 77F53: variable 'v21' is possibly undefined
// 77F53: variable 'v22' is possibly undefined
// 77F53: variable 'v23' is possibly undefined
// 77F53: variable 'v24' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// C1480: using guessed type __int64 qword_C1480;

//----- (0000000000078000) ----------------------------------------------------
__int64 __fastcall sub_78000(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  unsigned int v14; // er12
  __int64 *v16; // r12
  __int64 v17; // rax
  __int64 i; // rax
  __int64 v19; // rax
  _QWORD *v20; // rax
  __int64 v21; // rdx
  __int64 v22; // rcx
  __int64 v23; // r8

  v14 = __readfsdword(0x18u);
  if ( v14 )
  {
    v16 = (__int64 *)qword_C12D8;
    if ( qword_C12D8 )
    {
      v17 = *(_QWORD *)qword_C12D8;
      if ( *(_QWORD *)qword_C12D8 > 0x31uLL )
      {
        qword_C12E0(a1, a2, a3, a4, a5);
        for ( i = *v16; *v16; i = *v16 )
        {
          v19 = i - 1;
          *v16 = v19;
          sub_21B70(v16[v19 + 1]);
        }
        v14 = 1;
      }
      else
      {
        *(_QWORD *)qword_C12D8 = v17 + 1;
        v16[v17 + 1] = a1;
        v14 = 0;
      }
    }
    else
    {
      v20 = (_QWORD *)sub_21500((u32 *)&qword_198, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
      qword_C12D8 = (__int64)v20;
      if ( v20 )
      {
        v20[1] = a1;
        v14 = 0;
        *v20 = 1LL;
      }
      else
      {
        qword_C12E0(408LL, a2, v21, v22, v23);
        v14 = 1;
        sub_21B70(a1);
      }
    }
  }
  else
  {
    sub_21B70(a1);
  }
  return v14;
}
// 780C1: variable 'v21' is possibly undefined
// 780C1: variable 'v22' is possibly undefined
// 780C1: variable 'v23' is possibly undefined
// 198: using guessed type __int64;
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// C12D8: using guessed type __int64 qword_C12D8;
// C12E0: using guessed type __int64 (__fastcall *qword_C12E0)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000000780E0) ----------------------------------------------------
unsigned int __fastcall sub_780E0(_QWORD *a1)
{
  unsigned int result; // eax

  result = sub_4BD40(*a1 & -(__int64)off_BF078, (size_t)off_BF078, (unsigned int)dword_BDC30);
  if ( result )
    return __readfsdword(0xFFFFFFC0);
  *a1 = 0LL;
  dword_BF068 |= 1u;
  return result;
}
// BDC30: using guessed type int dword_BDC30;
// BF068: using guessed type int dword_BF068;
// BF078: using guessed type Elf64_Rela *off_BF078;

//----- (0000000000078130) ----------------------------------------------------
#error "78130: function frame is wrong (funcsize=0)"

//----- (00000000000785B0) ----------------------------------------------------
#error "785B0: function frame is wrong (funcsize=0)"

//----- (0000000000078A30) ----------------------------------------------------
__int64 __fastcall sub_78A30(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __m128 a7, __m128 a8, __m128 a9, __m128 a10, __m128 a11, __m128 a12, __m128 a13, __m128 a14, unsigned int a15, __int64 a16, __int64 a17)
{
  __int64 v17; // rax
  __int64 v18; // rbx
  __int64 v19; // rbp
  long double v20; // fst6
  long double v21; // fst7
  __int64 (__fastcall *v26)(unsigned __int8 *, __int64 *, __int64); // r11
  __int64 v27; // rdx
  __int64 v28; // r8
  __int64 v29; // r9
  long double v30; // xmm0
  __m128 v31; // xmm1
  double v32; // xmm2_8
  double v33; // xmm3_8
  double v34; // xmm4_8
  double v35; // xmm5_8
  double v36; // xmm6_8
  double v37; // xmm7_8
  __int64 result; // rax
  unsigned __int64 v43; // r10
  void *v44; // rsp
  __int64 v45; // rax
  __int64 v47; // rdx
  __int64 v50; // [rsp+F0h] [rbp-3A0h] BYREF
  __int64 v51; // [rsp+F8h] [rbp-398h]
  long double v52; // [rsp+100h] [rbp-390h]
  __m128 v53; // [rsp+110h] [rbp-380h]
  long double v54; // [rsp+120h] [rbp-370h]
  long double v55; // [rsp+130h] [rbp-360h]
  __m128 v56; // [rsp+140h] [rbp-350h]
  __m128 v57; // [rsp+150h] [rbp-340h]
  __m128 v58; // [rsp+160h] [rbp-330h]
  __m128 v59; // [rsp+170h] [rbp-320h]
  __m128 v60; // [rsp+180h] [rbp-310h]
  __m128 v61; // [rsp+190h] [rbp-300h]
  __m128 v62; // [rsp+1A0h] [rbp-2F0h]
  __int64 v69; // [rsp+470h] [rbp-20h]
  __int64 v70; // [rsp+478h] [rbp-18h]
  _QWORD v71[2]; // [rsp+480h] [rbp-10h] BYREF
  __int64 retaddr; // [rsp+490h] [rbp+0h]

  v69 = v18;
  v70 = v17;
  v71[1] = &v50;
  v50 = a3;
  v51 = a5;
  *(_QWORD *)&v52 = a6;
  *((_QWORD *)&v52 + 1) = a4;
  v53.m128_u64[0] = a2;
  v53.m128_u64[1] = a1;
  *(_QWORD *)&v54 = v19;
  *((_QWORD *)&v54 + 1) = &a16;
  v55 = *(long double *)&a7;
  v56 = a8;
  v57 = a9;
  v58 = a10;
  v59 = a11;
  v60 = a12;
  v61 = a13;
  v62 = a14;
  __asm
  {
    bndmov  [rsp+3A0h+var_E0], bnd0
    bndmov  [rsp+3A0h+var_D0], bnd1
    bndmov  [rsp+3A0h+var_C0], bnd2
    bndmov  [rsp+3A0h+var_B0], bnd3
  }
  v26 = sub_80AF0(
          retaddr,
          a15,
          a16,
          *(double *)a7.m128_u64,
          *(double *)a8.m128_u64,
          *(double *)a9.m128_u64,
          *(double *)a10.m128_u64,
          *(double *)a11.m128_u64,
          *(double *)a12.m128_u64,
          *(double *)a13.m128_u64,
          *(double *)a14.m128_u64,
          (__int64)&v50,
          v71);
  v27 = v50;
  v28 = v51;
  v29 = *(_QWORD *)&v52;
  v30 = v55;
  v31 = v56;
  v32 = *(double *)v57.m128_u64;
  v33 = *(double *)v58.m128_u64;
  v34 = *(double *)v59.m128_u64;
  v35 = *(double *)v60.m128_u64;
  v36 = *(double *)v61.m128_u64;
  v37 = *(double *)v62.m128_u64;
  __asm
  {
    bndmov  bnd0, [rsp+3A0h+var_E0]
    bndmov  bnd1, [rsp+3A0h+var_D0]
    bndmov  bnd2, [rsp+3A0h+var_C0]
    bndmov  bnd3, [rsp+3A0h+var_B0]
  }
  if ( v71[0] < 0LL )
    return ((__int64 (__fastcall *)(unsigned __int64, unsigned __int64, __int64, _QWORD, __int64, _QWORD, double, double, double, double, double, double, double, double))v26)(
             v53.m128_u64[1],
             v53.m128_u64[0],
             v50,
             *((_QWORD *)&v52 + 1),
             v51,
             *(_QWORD *)&v52,
             *(double *)&v55,
             *(double *)v56.m128_u64,
             *(double *)v57.m128_u64,
             *(double *)v58.m128_u64,
             *(double *)v59.m128_u64,
             *(double *)v60.m128_u64,
             *(double *)v61.m128_u64,
             *(double *)v62.m128_u64);
  v43 = (v71[0] + 8LL) & 0xFFFFFFFFFFFFFFF0LL;
  v44 = alloca(v71[0] + 8LL);
  qmemcpy(&v50, &a17, 8 * (v43 >> 3));
  v45 = ((__int64 (__fastcall *)(_QWORD, unsigned __int64, __int64, _QWORD, __int64, __int64, double, double, double, double, double, double, double, double))v26)(
          *(&v50 + (v43 >> 3) + 5),
          v53.m128_u64[v43 >> 3],
          v27,
          *(&v50 + (v43 >> 3) + 3),
          v28,
          v29,
          *(double *)&v30,
          *(double *)v31.m128_u64,
          v32,
          v33,
          v34,
          v35,
          v36,
          v37);
  _RCX = &v50;
  v50 = v45;
  v51 = v47;
  v52 = v30;
  v53 = v31;
  __asm
  {
    bndmov  [rcx+0D0h], bnd0
    bndmov  [rcx+0E0h], bnd1
  }
  v54 = v20;
  v55 = v21;
  sub_80D40();
  result = v50;
  __asm
  {
    bndmov  bnd0, [rsp+3A0h+var_2D0]
    bndmov  bnd1, [rsp+3A0h+var_2C0]
  }
  return result;
}
// 78A30: could not find valid save-restore pair for rbx
// 78A30: unsupported processor register 'bnd0'
// 78A38: variable 'v18' is possibly undefined
// 78A3C: variable 'v17' is possibly undefined
// 78A70: variable 'v19' is possibly undefined
// 78BC0: variable 'v47' is possibly undefined
// 78BDC: variable 'v20' is possibly undefined
// 78BDF: variable 'v21' is possibly undefined

//----- (0000000000078C30) ----------------------------------------------------
__int64 __fastcall sub_78C30(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, unsigned int a15)
{
  __int64 (__fastcall *v15)(unsigned __int8 *, __int64 *, __int64); // rax
  int v23[124]; // [rsp+40h] [rbp-208h] BYREF
  __int64 retaddr; // [rsp+248h] [rbp+0h]

  _fxsave(v23);
  v15 = sub_80930(retaddr, a15, a7, a8, a9, a10, a11, a12, a13, a14);
  _fxrstor(v23);
  return ((__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, __int64))v15)(a1, a2, a3, a4, a5, a6);
}

//----- (0000000000078CB0) ----------------------------------------------------
__int64 __fastcall sub_78CB0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, __int64 a16, __int64 a17, __int64 a18, __int64 a19, int a20, char a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63)
{
  __int64 (__fastcall *v92)(unsigned __int8 *, __int64 *, __int64); // rax

  STACK[0x250] = 0LL;
  STACK[0x258] = 0LL;
  STACK[0x260] = 0LL;
  STACK[0x268] = 0LL;
  STACK[0x270] = 0LL;
  STACK[0x278] = 0LL;
  STACK[0x280] = 0LL;
  STACK[0x288] = 0LL;
  _xsave(&a21, 0xEEuLL);
  v92 = sub_80930(a4, a3, a7, a8, a9, a10, a11, a12, a13, a14);
  _xrstor(&a21, 0xEEuLL);
  return ((__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64))v92)(
           a1,
           a2,
           a3,
           a4,
           a5,
           a6,
           a3,
           a2,
           a1,
           a5,
           a6);
}
// 78CB0: too many input arguments, some ignored
// C1438: using guessed type __int64 qword_C1438;

//----- (0000000000078D80) ----------------------------------------------------
__int64 __fastcall sub_78D80(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, __int64 a16, __int64 a17, __int64 a18, __int64 a19, __int64 a20, char a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63)
{
  __int64 (__fastcall *v92)(unsigned __int8 *, __int64 *, __int64); // rax

  STACK[0x260] = 0LL;
  STACK[0x268] = 0LL;
  STACK[0x270] = 0LL;
  STACK[0x278] = 0LL;
  STACK[0x280] = 0LL;
  STACK[0x288] = 0LL;
  __asm { xsavec  [rsp+8+arg_30] }
  v92 = sub_80930(a4, a3, a7, a8, a9, a10, a11, a12, a13, a14);
  _xrstor(&a21, 0xEEuLL);
  return ((__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64))v92)(
           a1,
           a2,
           a3,
           a4,
           a5,
           a6,
           a3,
           a2,
           a1,
           a5,
           a6,
           a20);
}
// 78D80: too many input arguments, some ignored
// C1438: using guessed type __int64 qword_C1438;

//----- (0000000000078E40) ----------------------------------------------------
void __noreturn sub_78E40()
{
  sub_77200("Fatal error: length accounting in _dl_exception_create_format\n");
}

//----- (0000000000078E60) ----------------------------------------------------
const char *__fastcall sub_78E60(const char **a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  size_t v11; // r14
  const void *v13; // r12
  __int64 v14; // r15
  __int64 v15; // rdx
  __int64 v16; // rcx
  u32 *v17; // r8
  u32 v18; // er9
  double v19; // xmm4_8
  double v20; // xmm5_8
  __int64 v21; // rax
  const char *v22; // rbx
  void *v23; // rax
  const char *result; // rax

  v11 = 1LL;
  v13 = &unk_A6E65;
  if ( a2 )
  {
    v13 = (const void *)a2;
    v11 = strlen(a2) + 1;
  }
  v14 = strlen(a3) + 1;
  v21 = sub_21500((u32 *)(v14 + v11), a2, v15, v16, v17, v18, a4, a5, a6, a7, v19, v20, a10, a11);
  v22 = (const char *)v21;
  if ( v21 )
  {
    v23 = (void *)sub_91D0(v21, a3, v14);
    result = (const char *)memcpy(v23, v13, v11);
    a1[1] = v22;
    *a1 = result;
    a1[2] = v22;
  }
  else
  {
    a1[2] = 0LL;
    *a1 = (const char *)&unk_A6E65;
    result = "out of memory";
    a1[1] = "out of memory";
  }
  return result;
}
// 78EA9: variable 'v15' is possibly undefined
// 78EA9: variable 'v16' is possibly undefined
// 78EA9: variable 'v17' is possibly undefined
// 78EA9: variable 'v18' is possibly undefined
// 78EA9: variable 'v19' is possibly undefined
// 78EA9: variable 'v20' is possibly undefined
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);

//----- (0000000000078F10) ----------------------------------------------------
void *__fastcall sub_78F10(_QWORD *a1, __int64 a2, char *a3, __int64 a4, __int64 a5, __int64 a6, double xmm0_8_0, double a8, double a9, double a10, double a11, double a12, double a13, double a14, char a7)
{
  char *v15; // r14
  const void *v16; // r13
  __int64 v17; // rax
  u32 *v18; // rbx
  char v19; // al
  char *v20; // rbp
  unsigned int v21; // eax
  __int64 *v22; // rdx
  _BYTE *v23; // rbp
  _BYTE *v24; // rbx
  char v25; // al
  char *v26; // r12
  char v27; // al
  void *result; // rax
  char *v29; // rdx
  __int64 v30; // rax
  __int64 v31; // rax
  __int64 v32; // rdi
  unsigned __int64 *v33; // rdi
  __int64 v34; // rax
  __int64 *v35; // rdx
  __int64 v36; // r15
  unsigned __int64 v37; // rdx
  size_t v39; // [rsp+8h] [rbp-90h]
  unsigned int v40; // [rsp+18h] [rbp-80h]
  unsigned int v41; // [rsp+18h] [rbp-80h]
  char *v42; // [rsp+20h] [rbp-78h]
  char *v43; // [rsp+20h] [rbp-78h]
  char v44[24]; // [rsp+30h] [rbp-68h] BYREF
  __int64 v45; // [rsp+48h] [rbp-50h]
  __int64 v46; // [rsp+50h] [rbp-48h]
  __int64 v47; // [rsp+58h] [rbp-40h]

  v15 = a3;
  v45 = a4;
  v46 = a5;
  v47 = a6;
  if ( a2 )
  {
    v16 = (const void *)a2;
    v17 = strlen(a2);
    v39 = v17 + 1;
    v18 = (u32 *)(v17 + 2);
  }
  else
  {
    v39 = 1LL;
    v18 = (_DWORD *)(&dword_0 + 2);
    v16 = &unk_A6E65;
  }
  v40 = 24;
  v42 = &a7;
  v19 = *v15;
  if ( !*v15 )
  {
LABEL_16:
    v23 = (_BYTE *)sub_21500(v18, a2, (__int64)a3, a4, (u32 *)a5, a6, xmm0_8_0, a8, a9, a10, a11, a12, a13, a14);
    if ( !v23 )
      goto LABEL_56;
    v41 = 24;
    v24 = (char *)v18 + (_QWORD)v23;
    a1[1] = v23;
    a1[2] = v23;
    v43 = &a7;
    v25 = *v15;
    if ( !*v15 )
    {
LABEL_28:
      if ( v24 == v23 || (*v23 = 0, v24 - (v23 + 1) != v39) )
LABEL_61:
        sub_78E40();
      result = memcpy(v23 + 1, v16, v39);
      *a1 = result;
      return result;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        if ( v25 != 37 )
        {
          if ( v24 == v23 )
            goto LABEL_61;
          *v23 = v25;
          v26 = v15;
          ++v23;
          goto LABEL_21;
        }
        v27 = v15[1];
        v26 = v15 + 1;
        if ( v27 != 115 )
          break;
        if ( v41 > 0x2F )
        {
          v35 = (__int64 *)v43;
          v43 += 8;
        }
        else
        {
          v35 = (__int64 *)&v44[v41];
          v41 += 8;
        }
        v36 = *v35;
        v37 = strlen(*v35);
        if ( v24 - v23 < v37 )
          goto LABEL_61;
        v23 = (_BYTE *)sub_91D0(v23, v36, v37);
LABEL_21:
        v25 = v26[1];
        v15 = v26 + 1;
        if ( !v25 )
          goto LABEL_28;
      }
      if ( v27 > 115 )
        break;
      if ( v27 != 37 )
      {
        if ( v27 != 108 )
          goto LABEL_48;
LABEL_41:
        if ( v15[2] != 120 )
          goto LABEL_48;
        if ( v41 > 0x2F )
        {
          v33 = (unsigned __int64 *)v43;
          v43 += 8;
        }
        else
        {
          v33 = (unsigned __int64 *)&v44[v41];
          v41 += 8;
        }
        v34 = sub_7A1B0(*v33, (__int64)(v23 + 16), 0x10u, 0);
        if ( (_BYTE *)v34 != v23 )
          sub_9190((__int64)v23, 48LL, v34 - (_QWORD)v23);
        v26 = v15 + 2;
        v23 += 16;
        goto LABEL_21;
      }
      if ( v24 == v23 )
        goto LABEL_61;
      v25 = v15[2];
      *v23 = 37;
      v15 += 2;
      ++v23;
      if ( !v25 )
        goto LABEL_28;
    }
    if ( v27 == 120 )
    {
      if ( v41 > 0x2F )
      {
        v29 = v43;
        v43 += 8;
      }
      else
      {
        v29 = &v44[v41];
        v41 += 8;
      }
      v30 = sub_7A1B0(*(unsigned int *)v29, (__int64)(v23 + 8), 0x10u, 0);
      if ( (_BYTE *)v30 == v23 )
      {
        v23 += 8;
      }
      else
      {
        v31 = v30 - (_QWORD)v23;
        v32 = (__int64)v23;
        v23 += 8;
        sub_9190(v32, 48LL, v31);
      }
      goto LABEL_21;
    }
    if ( v27 != 122 )
LABEL_48:
      sub_77200("Fatal error: invalid format in exception string\n");
    goto LABEL_41;
  }
  v20 = v15;
  do
  {
    while ( 1 )
    {
      a3 = (char *)(unsigned __int8)v20[1];
      a4 = (__int64)(v20 + 1);
      if ( v19 == 37 )
        break;
      v18 = (u32 *)((char *)v18 + 1);
      ++v20;
      v19 = (char)a3;
LABEL_6:
      if ( !v19 )
        goto LABEL_15;
    }
    if ( (_BYTE)a3 == 120 )
      goto LABEL_34;
    if ( (char)a3 > 120 )
    {
      if ( (_BYTE)a3 == 122 )
      {
LABEL_33:
        if ( v20[2] == 120 )
        {
          v19 = v20[3];
          v18 += 4;
          v20 += 3;
          goto LABEL_6;
        }
LABEL_34:
        v19 = v20[2];
        v18 += 2;
        v20 += 2;
        goto LABEL_6;
      }
LABEL_32:
      v19 = v20[2];
      v18 = (u32 *)((char *)v18 + 1);
      v20 += 2;
      goto LABEL_6;
    }
    if ( (_BYTE)a3 == 108 )
      goto LABEL_33;
    if ( (_BYTE)a3 != 115 )
      goto LABEL_32;
    v21 = v40;
    if ( v40 > 0x2F )
    {
      v22 = (__int64 *)v42;
      v42 += 8;
    }
    else
    {
      v40 += 8;
      v22 = (__int64 *)&v44[v21];
    }
    v20 += 2;
    v18 = (u32 *)((char *)v18 + strlen(*v22));
    v19 = *v20;
  }
  while ( *v20 );
LABEL_15:
  if ( (__int64)v18 >= 0 )
    goto LABEL_16;
LABEL_56:
  result = a1;
  *a1 = &unk_A6E65;
  a1[1] = "out of memory";
  a1[2] = 0LL;
  return result;
}
// 79014: variable 'a3' is possibly undefined
// 79014: variable 'a4' is possibly undefined
// 79014: variable 'a5' is possibly undefined
// 79014: variable 'a6' is possibly undefined
// 79014: variable 'a11' is possibly undefined
// 79014: variable 'a12' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);

//----- (0000000000079330) ----------------------------------------------------
__int64 __fastcall sub_79330(_QWORD *a1)
{
  __int64 result; // rax

  result = sub_21B70(a1[2]);
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  return result;
}
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (0000000000079360) ----------------------------------------------------
__int64 __fastcall sub_79360(char *a1, char *a2)
{
  int v2; // eax
  int v3; // er8
  int v4; // edx
  int v5; // ecx
  int v7; // eax
  bool v8; // cc
  int v9; // eax

  while ( 1 )
  {
    v2 = *a1;
    if ( !*a1 )
      return (unsigned int)-*a2;
    while ( 1 )
    {
      v3 = *a2;
      LOBYTE(v4) = v2 - 48;
      LOBYTE(v5) = v3 - 48;
      if ( (unsigned __int8)(v2 - 48) <= 9u )
        break;
      if ( (unsigned __int8)v5 <= 9u )
        return 0xFFFFFFFFLL;
      if ( (_BYTE)v2 != (_BYTE)v3 )
        return (unsigned int)(v2 - v3);
      v2 = *++a1;
      ++a2;
      if ( !(_BYTE)v2 )
        return (unsigned int)-*a2;
    }
    if ( (unsigned __int8)v5 > 9u )
      break;
    v7 = a1[1];
    v4 = (char)v4;
    v5 = (char)v5;
    v8 = (unsigned __int8)(*++a1 - 48) <= 9u;
    if ( v8 )
    {
      do
      {
        ++a1;
        v4 = v7 + 10 * v4 - 48;
        v7 = *a1;
      }
      while ( (unsigned __int8)(*a1 - 48) <= 9u );
    }
    v9 = a2[1];
    v8 = (unsigned __int8)(*++a2 - 48) <= 9u;
    if ( v8 )
    {
      do
      {
        ++a2;
        v5 = v9 + 10 * v5 - 48;
        v9 = *a2;
      }
      while ( (unsigned __int8)(*a2 - 48) <= 9u );
    }
    if ( v5 != v4 )
      return (unsigned int)(v4 - v5);
  }
  return 1LL;
}

//----- (0000000000079440) ----------------------------------------------------
void *__fastcall sub_79440(char *a1)
{
  _DWORD *v1; // r8
  int v2; // esi
  __int64 v3; // r13
  __int64 v4; // r14
  unsigned int v5; // er12
  bool v6; // zf
  __int64 v7; // rax
  int v8; // er11
  int v9; // er15
  __int64 v10; // r14
  __int64 v11; // rsi
  int v12; // eax
  int v13; // er10
  unsigned int *v15; // rcx
  int j; // er14
  __int64 v17; // rsi
  int v18; // eax
  void *v19; // rdx
  __int64 v20; // r15
  __int64 v21; // rsi
  __int64 v22; // rax
  __int64 v23; // rsi
  __int64 v24; // rsi
  __int64 v25; // rax
  void *v26; // rsp
  void *v27; // rax
  unsigned int v28; // er12
  __int64 v29; // rax
  char *v30; // r13
  int v31; // er12
  int v32; // er15
  __int64 v33; // r14
  __int64 v34; // rsi
  int v35; // eax
  int v36; // er10
  _QWORD *v37; // rax
  unsigned int *v38; // r15
  int i; // er11
  __int64 v40; // rsi
  int v41; // er14
  int v42; // eax
  int v43; // er14
  _DWORD *v44; // r15
  __int64 v45; // rsi
  __int64 v46; // rax
  unsigned __int64 v47; // rcx
  unsigned __int64 v48; // rax
  char *v49; // rdx
  __int64 v50; // [rsp+0h] [rbp-70h] BYREF
  unsigned __int64 v51; // [rsp+8h] [rbp-68h]
  unsigned __int64 v52; // [rsp+10h] [rbp-60h]
  __int64 v53; // [rsp+18h] [rbp-58h]
  void *v54; // [rsp+20h] [rbp-50h]
  unsigned int *v55; // [rsp+28h] [rbp-48h]
  char *v56; // [rsp+38h] [rbp-38h] BYREF

  if ( (dword_C14B4 & 1) != 0 )
    sub_76EA0(" search cache=%s\n", "/etc/ld.so.cache");
  v1 = (_DWORD *)qword_C1780;
  if ( !qword_C1780 )
  {
    v37 = (_QWORD *)sub_76E00("/etc/ld.so.cache", &qword_C1770, 1u);
    v1 = v37;
    if ( v37 == (_QWORD *)-1LL )
    {
LABEL_60:
      qword_C1780 = -1LL;
      return 0LL;
    }
    v2 = qword_C1770;
    if ( (unsigned __int64)qword_C1770 <= 0x30 )
    {
      if ( (unsigned __int64)qword_C1770 <= 0x10 )
      {
LABEL_59:
        munmap(v37, qword_C1770);
        goto LABEL_60;
      }
    }
    else if ( !(*v37 ^ 0x646C2D6362696C67LL | v37[1] ^ 0x686361632E6F732ELL)
           && *((_DWORD *)v37 + 4) == 825110885
           && (qword_C1770 - 48) / 0x18uLL >= *((unsigned int *)v37 + 5) )
    {
      qword_C1778 = (__int64)v37;
      qword_C1780 = (__int64)v37;
      goto LABEL_6;
    }
    if ( *v37 == 0x2E312D6F732E646CLL && *((_WORD *)v37 + 4) == 11831 && *((_BYTE *)v37 + 10) == 48 )
    {
      v47 = *((unsigned int *)v37 + 3);
      if ( (qword_C1770 - 16) / 0xCuLL >= v47 )
      {
        qword_C1780 = (__int64)v37;
        v48 = (12 * v47 + 23) & 0xFFFFFFFFFFFFFFF8LL;
        v49 = (char *)v1 + v48;
        qword_C1778 = (__int64)v1 + v48;
        if ( qword_C1770 < v48 + 48
          || *(_QWORD *)v49 ^ 0x646C2D6362696C67LL | *((_QWORD *)v49 + 1) ^ 0x686361632E6F732ELL
          || *((_DWORD *)v49 + 4) != 825110885 )
        {
          qword_C1778 = -1LL;
        }
        goto LABEL_6;
      }
    }
    goto LABEL_59;
  }
  if ( qword_C1780 == -1 )
    return 0LL;
  v2 = qword_C1770;
LABEL_6:
  v3 = qword_C1778;
  if ( qword_C1778 == -1 )
  {
    v28 = v1[3];
    v29 = 12LL * v28 + 16;
    v30 = (char *)v1 + v29;
    LODWORD(v55) = v2 - v29;
    v31 = v28 - 1;
    if ( v31 >= 0 )
    {
      v32 = 0;
      do
      {
        v54 = v1;
        v33 = 3LL * ((v31 + v32) >> 1);
        v34 = (unsigned int)v1[v33 + 5];
        if ( (unsigned int)v55 <= (unsigned int)v34 )
          break;
        v35 = sub_79360(a1, &v30[v34]);
        v1 = v54;
        if ( !v35 )
        {
          v38 = (unsigned int *)((char *)v54 + v33 * 4 + 8);
          for ( i = v36; i; i = v41 )
          {
            v40 = *v38;
            v41 = i - 1;
            if ( (unsigned int)v55 <= (unsigned int)v40 )
              break;
            v54 = v1;
            v38 -= 3;
            v42 = sub_79360(a1, &v30[v40]);
            v1 = v54;
            if ( v42 )
              break;
          }
          v54 = 0LL;
          v43 = dword_BF070;
          v44 = &v1[3 * i + 4];
          do
          {
            if ( i > v36 )
            {
              v45 = (unsigned int)v44[1];
              if ( (unsigned int)v45 >= (unsigned int)v55 || (unsigned int)sub_79360(a1, &v30[v45]) )
                break;
            }
            if ( *v44 == 771 )
            {
              v46 = (unsigned int)v44[2];
              if ( (unsigned int)v46 < (unsigned int)v55 )
              {
                if ( v54 )
                {
                  if ( v43 == 771 )
                  {
                    v54 = &v30[v46];
LABEL_76:
                    if ( (dword_C14B4 & 1) != 0 )
LABEL_77:
                      sub_76EA0("  trying file=%s\n", (const char *)v54);
LABEL_42:
                    v25 = strlen((__int64)v54);
                    v26 = alloca(v25 + 9);
                    v27 = memcpy(&v50, v54, v25 + 1);
                    return sub_23100(v27);
                  }
                }
                else
                {
                  v54 = &v30[v46];
                  if ( v43 == 771 )
                    goto LABEL_76;
                }
              }
            }
            ++i;
            v44 += 3;
          }
          while ( v31 >= i );
LABEL_40:
          if ( (dword_C14B4 & 1) == 0 )
          {
            if ( !v54 )
              return 0LL;
            goto LABEL_42;
          }
          if ( v54 )
            goto LABEL_77;
          return 0LL;
        }
        if ( v35 >= 0 )
          v31 = v36 - 1;
        else
          v32 = v36 + 1;
      }
      while ( v32 <= v31 );
    }
  }
  else
  {
    v4 = qword_C14C0;
    v5 = (_DWORD)v1 + v2 - qword_C1778;
    if ( qword_C14C0 )
    {
      v53 = 0x4000000000000LL;
      if ( (unsigned int)sub_91B0(qword_C14C0, "haswell") )
      {
        v6 = (unsigned int)sub_91B0(v4, "xeon_phi") == 0;
        v7 = 0x8000000000000LL;
        if ( !v6 )
          v7 = -1LL;
        v53 = v7;
      }
    }
    else
    {
      v53 = -1LL;
    }
    sub_4E120(0xEu, &v56, 0LL);
    v51 = (unsigned __int64)v56;
    v52 = qword_C12F0;
    v54 = (void *)qword_C1778;
    LODWORD(v55) = *(_DWORD *)(qword_C1778 + 20);
    v8 = (_DWORD)v55 - 1;
    if ( (int)v55 - 1 >= 0 )
    {
      v9 = 0;
      while ( 1 )
      {
        v10 = 24LL * ((v8 + v9) >> 1);
        v11 = *(unsigned int *)((char *)v54 + v10 + 52);
        if ( v5 <= (unsigned int)v11 )
          break;
        v12 = sub_79360(a1, (char *)(v3 + v11));
        if ( !v12 )
        {
          v15 = (unsigned int *)((char *)v54 + v10 + 28);
          for ( j = v13; j; --j )
          {
            v17 = *v15;
            v55 = v15;
            if ( v5 <= (unsigned int)v17 )
              break;
            v18 = sub_79360(a1, (char *)(v3 + v17));
            v15 = v55 - 6;
            if ( v18 )
              break;
          }
          v19 = v54;
          v54 = 0LL;
          v52 = ~(v51 & v52 | 0x800F000000000000LL);
          LODWORD(v55) = dword_BF070;
          LODWORD(v51) = dword_C1328;
          v20 = (__int64)v19 + 24 * j + 48;
          do
          {
            if ( j > v13 )
            {
              v21 = *(unsigned int *)(v20 + 4);
              if ( (unsigned int)v21 >= v5 || (unsigned int)sub_79360(a1, (char *)(v3 + v21)) )
                break;
            }
            if ( *(_DWORD *)v20 == 771 )
            {
              v22 = *(unsigned int *)(v20 + 8);
              if ( (unsigned int)v22 < v5 && (!v54 || (_DWORD)v55 == 771) )
              {
                v23 = *(_QWORD *)(v20 + 16);
                if ( (v23 & v52) == 0 && (!(_DWORD)v51 || (unsigned int)v51 >= *(_DWORD *)(v20 + 12)) )
                {
                  v24 = v23 & 0xF000000000000LL;
                  if ( !v24 || v24 == v53 )
                  {
                    v54 = (void *)(v3 + v22);
                    if ( (_DWORD)v55 == 771 )
                      break;
                  }
                }
              }
            }
            ++j;
            v20 += 24LL;
          }
          while ( j <= v8 );
          goto LABEL_40;
        }
        if ( v12 >= 0 )
        {
          v8 = v13 - 1;
          if ( v13 - 1 < v9 )
            return 0LL;
        }
        else
        {
          v9 = v13 + 1;
          if ( v8 < v13 + 1 )
            return 0LL;
        }
      }
    }
  }
  return 0LL;
}
// 79540: variable 'v13' is possibly undefined
// 79549: variable 'v8' is possibly undefined
// 79750: variable 'v36' is possibly undefined
// 798AF: variable 'i' is possibly undefined
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// BF070: using guessed type int dword_BF070;
// C12F0: using guessed type __int64 qword_C12F0;
// C1328: using guessed type int dword_C1328;
// C14B4: using guessed type int dword_C14B4;
// C14C0: using guessed type __int64 qword_C14C0;
// C1770: using guessed type __int64 qword_C1770;
// C1778: using guessed type __int64 qword_C1778;
// C1780: using guessed type __int64 qword_C1780;

//----- (0000000000079A50) ----------------------------------------------------
__int64 sub_79A50()
{
  __int64 result; // rax

  result = qword_C1780 - 1;
  if ( (unsigned __int64)(qword_C1780 - 1) <= 0xFFFFFFFFFFFFFFFDLL )
  {
    result = munmap((void *)qword_C1780, qword_C1770);
    qword_C1780 = 0LL;
  }
  return result;
}
// C1770: using guessed type __int64 qword_C1770;
// C1780: using guessed type __int64 qword_C1780;

//----- (0000000000079A90) ----------------------------------------------------
__int64 __fastcall sub_79A90()
{
  __int64 v0; // rax

  return *(_QWORD *)(v0 + 8);
}
// 79A94: variable 'v0' is possibly undefined
// 79A90: using guessed type __int64 __fastcall sub_79A90();

//----- (0000000000079AA0) ----------------------------------------------------
unsigned __int64 __fastcall sub_79AA0()
{
  __int64 v0; // rax

  return *(_QWORD *)(v0 + 8) - __readfsqword(0);
}
// 79AA4: variable 'v0' is possibly undefined

//----- (0000000000079AC0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall sub_79AC0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __m128 a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v14; // rax
  __int64 (__fastcall **v16)(__int64, __int64, __int64, __int64, __int64, __int64); // [rsp-8h] [rbp-58h]
  __int64 v21; // [rsp+48h] [rbp-8h]

  v16 = (__int64 (__fastcall **)(__int64, __int64, __int64, __int64, __int64, __int64))v14;
  sub_83340(v14, v21, a7, a8, a9, a10, a11, a12, a13, a14);
  return (*v16)(a1, a2, a3, a4, a5, a6);
}
// 79B31: positive sp value 8 has been found
// 79AC8: variable 'v14' is possibly undefined
// 79AFC: variable 'v21' is possibly undefined

//----- (0000000000079BC0) ----------------------------------------------------
__int64 __fastcall sub_79BC0(__int64 a1)
{
  __int64 v2; // [rsp-8h] [rbp-18h]

  *(_QWORD *)(a1 + 24) = sub_81120(
                           *(_BYTE **)a1,
                           *(_DWORD *)(a1 + 8),
                           *(_QWORD *)(a1 + 16),
                           -2LL,
                           (unsigned int)dword_C14E0,
                           qword_C14D8,
                           (__int64)qword_C1270);
  return v2;
}
// 79BFA: variable 'v2' is possibly undefined
// C14D8: using guessed type __int64 qword_C14D8;
// C14E0: using guessed type int dword_C14E0;

//----- (0000000000079C00) ----------------------------------------------------
__int64 __fastcall sub_79C00(void (__fastcall *a1)(__int64), __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  unsigned int v7; // [rsp+Ch] [rbp-2Ch]
  bool v8; // [rsp+17h] [rbp-21h] BYREF
  __int64 v9; // [rsp+18h] [rbp-20h] BYREF
  __int64 v10[3]; // [rsp+20h] [rbp-18h] BYREF

  v10[1] = __readfsqword(0x28u);
  v10[0] = 0LL;
  result = sub_50290(&v9, v10, &v8, a1, a2, a6);
  if ( !(_DWORD)result )
  {
    if ( !v10[0] )
      return result;
    result = 1LL;
  }
  if ( v8 )
  {
    v7 = result;
    sub_21B70(v10[0]);
    result = v7;
  }
  return result;
}
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (0000000000079C80) ----------------------------------------------------
__int64 __fastcall sub_79C80(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v6; // er8
  __int64 result; // rax
  __int64 v8; // rdx
  __int64 v9[2]; // [rsp+0h] [rbp-38h] BYREF
  __int64 *v10; // [rsp+10h] [rbp-28h]
  __int64 v11; // [rsp+18h] [rbp-20h]
  unsigned __int64 v12; // [rsp+28h] [rbp-10h]

  v12 = __readfsqword(0x28u);
  v9[0] = a1;
  v9[1] = a2;
  v6 = sub_79C00((void (__fastcall *)(__int64))sub_79F00, (__int64)v9, a3, a4, a5, a6);
  result = 0LL;
  if ( !v6 )
  {
    result = v11;
    if ( v11 )
    {
      if ( *(_WORD *)(v11 + 6) == 0xFFF1 )
      {
        v8 = 0LL;
      }
      else
      {
        v8 = 0LL;
        if ( v10 )
          v8 = *v10;
      }
      result = *(_QWORD *)(v11 + 8) + v8;
    }
  }
  return result;
}

//----- (0000000000079D10) ----------------------------------------------------
__int64 __fastcall sub_79D10(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 *a4, __int64 a5, __int64 a6)
{
  unsigned __int64 v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rax
  int v9; // er8
  __int64 result; // rax
  __int64 v11; // rdx
  unsigned __int8 *v12; // rsi
  __int64 v13[2]; // [rsp+0h] [rbp-48h] BYREF
  __int64 *v14; // [rsp+10h] [rbp-38h]
  __int64 v15; // [rsp+18h] [rbp-30h]
  __int64 v16; // [rsp+20h] [rbp-28h]
  int v17; // [rsp+28h] [rbp-20h]
  int v18; // [rsp+2Ch] [rbp-1Ch]
  __int64 v19; // [rsp+30h] [rbp-18h]
  unsigned __int64 v20; // [rsp+38h] [rbp-10h]

  v20 = __readfsqword(0x28u);
  LODWORD(v6) = 0;
  v13[1] = a2;
  v7 = *(unsigned __int8 *)a3;
  v13[0] = a1;
  v16 = a3;
  v18 = 1;
  if ( v7 )
  {
    a4 = (unsigned __int8 *)a3;
    a3 = *(unsigned __int8 *)(a3 + 1);
    if ( (_BYTE)a3 )
    {
      v8 = (unsigned __int8)a3;
      a3 = a4[2];
      v6 = 16 * v7 + v8;
      if ( (_BYTE)a3 )
      {
        v6 = a3 + 16 * v6;
        a3 = a4[3];
        if ( (_BYTE)a3 )
        {
          v6 = a3 + 16 * v6;
          a3 = a4[4];
          if ( (_BYTE)a3 )
          {
            v12 = a4 + 5;
            v6 = a3 + 16 * v6;
            a3 = a4[5];
            if ( (_BYTE)a3 )
            {
              do
              {
                ++v12;
                v6 = ((a3 + 16 * v6) >> 24) & 0xF0 ^ (a3 + 16 * v6);
                a3 = *v12;
              }
              while ( (_BYTE)a3 );
              LODWORD(v6) = v6 & 0xFFFFFFF;
            }
          }
        }
      }
    }
    else
    {
      LODWORD(v6) = (unsigned __int8)v7;
    }
  }
  v17 = v6;
  v19 = 0LL;
  v9 = sub_79C00((void (__fastcall *)(__int64))sub_79F40, (__int64)v13, a3, (__int64)a4, a5, a6);
  result = 0LL;
  if ( !v9 )
  {
    result = v15;
    if ( v15 )
    {
      if ( *(_WORD *)(v15 + 6) == 0xFFF1 )
      {
        v11 = 0LL;
      }
      else
      {
        v11 = 0LL;
        if ( v14 )
          v11 = *v14;
      }
      result = *(_QWORD *)(v15 + 8) + v11;
    }
  }
  return result;
}

//----- (0000000000079E70) ----------------------------------------------------
unsigned __int64 __fastcall sub_79E70(__int64 *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  unsigned int **v9; // rdx
  __int64 v11; // rsi
  unsigned __int8 *v12; // rdi
  __int64 **v13; // rcx
  const char *v15[3]; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v16; // [rsp+18h] [rbp-10h]

  v9 = (unsigned int **)(a1 + 3);
  v11 = *a1;
  v16 = __readfsqword(0x28u);
  a1[3] = 0LL;
  v12 = (unsigned __int8 *)a1[1];
  v15[2] = 0LL;
  v13 = *(__int64 ***)(v11 + 912);
  v15[0] = "GLIBC_PRIVATE";
  v15[1] = (const char *)0x10963CF85LL;
  a1[2] = sub_73690(v12, v11, v9, v13, v15, 0, a2, a3, a4, a5, a6, a7, a8, a9, 0, 0LL);
  return v16 - __readfsqword(0x28u);
}

//----- (0000000000079F00) ----------------------------------------------------
__int64 __fastcall sub_79F00(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 v9; // rsi
  __int64 v11; // [rsp-10h] [rbp-18h]

  v9 = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 16) = sub_73690(
                           *(unsigned __int8 **)(a1 + 8),
                           v9,
                           (unsigned int **)(a1 + 24),
                           (__int64 **)(v9 + 920),
                           0LL,
                           0,
                           a2,
                           a3,
                           a4,
                           a5,
                           a6,
                           a7,
                           a8,
                           a9,
                           2,
                           0LL);
  return v11;
}
// 79F35: variable 'v11' is possibly undefined

//----- (0000000000079F40) ----------------------------------------------------
__int64 __fastcall sub_79F40(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 v9; // rsi
  __int64 v11; // [rsp-10h] [rbp-18h]

  v9 = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 16) = sub_73690(
                           *(unsigned __int8 **)(a1 + 8),
                           v9,
                           (unsigned int **)(a1 + 24),
                           (__int64 **)(v9 + 920),
                           (const char **)(a1 + 32),
                           0,
                           a2,
                           a3,
                           a4,
                           a5,
                           a6,
                           a7,
                           a8,
                           a9,
                           0,
                           0LL);
  return v11;
}
// 79F76: variable 'v11' is possibly undefined

//----- (0000000000079F80) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall sub_79F80(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  return sub_82F70(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

//----- (0000000000079F90) ----------------------------------------------------
__int64 __fastcall sub_79F90(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 result; // rax
  unsigned int v7; // [rsp+Ch] [rbp-2Ch]
  bool v8; // [rsp+17h] [rbp-21h] BYREF
  __int64 v9; // [rsp+18h] [rbp-20h] BYREF
  __int64 v10[3]; // [rsp+20h] [rbp-18h] BYREF

  v10[1] = __readfsqword(0x28u);
  v10[0] = 0LL;
  result = sub_50290(&v9, v10, &v8, (void (__fastcall *)(__int64))sub_79F80, a1, a6);
  if ( !(_DWORD)result )
  {
    if ( !v10[0] )
      return result;
    result = 1LL;
  }
  if ( v8 )
  {
    v7 = result;
    sub_21B70(v10[0]);
    result = v7;
  }
  return result;
}
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (000000000007A020) ----------------------------------------------------
__int64 __fastcall sub_7A020(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v6; // er8
  __int64 result; // rax
  __int64 v8; // rdx
  __int64 v9[2]; // [rsp+0h] [rbp-38h] BYREF
  __int64 *v10; // [rsp+10h] [rbp-28h]
  __int64 v11; // [rsp+18h] [rbp-20h]
  unsigned __int64 v12; // [rsp+28h] [rbp-10h]

  v12 = __readfsqword(0x28u);
  v9[0] = a1;
  v9[1] = a2;
  v6 = sub_79C00((void (__fastcall *)(__int64))sub_79E70, (__int64)v9, a3, a4, a5, a6);
  result = 0LL;
  if ( !v6 )
  {
    result = v11;
    if ( v11 )
    {
      if ( *(_WORD *)(v11 + 6) == 0xFFF1 )
      {
        v8 = 0LL;
      }
      else
      {
        v8 = 0LL;
        if ( v10 )
          v8 = *v10;
      }
      result = *(_QWORD *)(v11 + 8) + v8;
    }
  }
  return result;
}

//----- (000000000007A0B0) ----------------------------------------------------
__int64 __fastcall sub_7A0B0(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 result; // rax
  __int64 v11; // rbp
  _QWORD *v12; // rax
  __int64 v13; // rdx
  __int64 (__fastcall **v14)(); // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  _QWORD *v17; // rax
  __int64 v18; // rdx
  __int64 (__fastcall **v19)(); // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  __int64 v22; // [rsp+0h] [rbp-38h] BYREF
  int v23; // [rsp+8h] [rbp-30h]
  __int64 v24; // [rsp+10h] [rbp-28h]
  __int64 v25; // [rsp+18h] [rbp-20h]
  unsigned __int64 v26; // [rsp+28h] [rbp-10h]
  __int64 retaddr; // [rsp+38h] [rbp+0h]

  v26 = __readfsqword(0x28u);
  v22 = a1;
  v23 = a2;
  v24 = retaddr;
  v8 = (unsigned int)sub_79C00((void (__fastcall *)(__int64))sub_79BC0, (__int64)&v22, a3, a4, a5, a6);
  result = 0LL;
  if ( !(_DWORD)v8 )
  {
    v11 = v25;
    v12 = (_QWORD *)sub_7A020(v25, (__int64)"_dl_open_hook", v6, v7, v8, v9);
    if ( v12 )
    {
      v14 = off_BF9E0;
      *v12 = off_BF9E0;
    }
    v17 = (_QWORD *)sub_7A020(v11, (__int64)"_dl_open_hook2", v13, (__int64)v14, v15, v16);
    if ( v17 )
    {
      v19 = off_BF9E0;
      *v17 = off_BF9E0;
    }
    sub_7F9E0(v25, (__int64)"_dl_open_hook2", v18, (__int64)v19, v20, v21);
    result = v25;
  }
  return result;
}
// 7A103: variable 'v6' is possibly undefined
// 7A103: variable 'v7' is possibly undefined
// 7A103: variable 'v9' is possibly undefined
// 7A121: variable 'v13' is possibly undefined
// 7A121: variable 'v14' is possibly undefined
// 7A121: variable 'v15' is possibly undefined
// 7A121: variable 'v16' is possibly undefined
// 7A13A: variable 'v18' is possibly undefined
// 7A13A: variable 'v19' is possibly undefined
// 7A13A: variable 'v20' is possibly undefined
// 7A13A: variable 'v21' is possibly undefined
// BF9E0: using guessed type __int64 (__fastcall *off_BF9E0[4])();

//----- (000000000007A160) ----------------------------------------------------
_QWORD *__fastcall sub_7A160(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // rax
  __int64 (__fastcall **v7)(); // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  _QWORD *result; // rax

  v6 = (_QWORD *)sub_7A020(a1, (__int64)"_dl_open_hook", a3, a4, a5, a6);
  if ( v6 )
  {
    v7 = off_BF9E0;
    *v6 = off_BF9E0;
  }
  result = (_QWORD *)sub_7A020(a1, (__int64)"_dl_open_hook2", (__int64)v7, v8, v9, v10);
  if ( result )
    *result = off_BF9E0;
  return result;
}
// 7A18D: variable 'v7' is possibly undefined
// 7A18D: variable 'v8' is possibly undefined
// 7A18D: variable 'v9' is possibly undefined
// 7A18D: variable 'v10' is possibly undefined
// BF9E0: using guessed type __int64 (__fastcall *off_BF9E0[4])();

//----- (000000000007A1B0) ----------------------------------------------------
__int64 __fastcall sub_7A1B0(unsigned __int64 a1, __int64 a2, unsigned int a3, int a4)
{
  const char *v5; // rsi
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rdx
  __int64 result; // rax
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // rax

  v5 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  if ( !a4 )
    v5 = "0123456789abcdefghijklmnopqrstuvwxyz";
  if ( a3 == 10 )
  {
    do
    {
      *(_BYTE *)--a2 = v5[a1 % 0xA];
      v11 = a1;
      a1 /= 0xAuLL;
    }
    while ( v11 > 9 );
    result = a2;
  }
  else
  {
    if ( a3 == 16 )
    {
      do
      {
        *(_BYTE *)--a2 = v5[a1 & 0xF];
        v9 = a1;
        a1 >>= 4;
      }
      while ( v9 > 0xF );
    }
    else
    {
      v6 = a3;
      if ( a3 == 8 )
      {
        do
        {
          *(_BYTE *)--a2 = v5[a1 & 7];
          v10 = a1;
          a1 >>= 3;
        }
        while ( v10 > 7 );
      }
      else
      {
        do
        {
          *(_BYTE *)--a2 = v5[a1 % v6];
          v7 = a1;
          a1 /= v6;
        }
        while ( v7 >= v6 );
      }
    }
    result = a2;
  }
  return result;
}

//----- (000000000007A300) ----------------------------------------------------
__int64 __fastcall sub_7A300(__int64 a1)
{
  __int64 v2; // r9
  __int64 v3; // rdx
  _QWORD *v4; // rdi
  unsigned int v5; // er12
  __int64 v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v10; // rax
  __int64 *v11; // rdx
  __int64 v12; // rax
  __int64 v13; // r12
  __int64 *v14; // rbx
  __int64 v15; // r12
  int v16; // eax

  if ( *(_DWORD *)a1 )
  {
    if ( *(_DWORD *)(a1 + 4) == 102 )
    {
      v16 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = v16 - 1;
      if ( v16 > 0 )
        return 48LL;
    }
  }
  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 24);
  v4 = *(_QWORD **)(a1 + 16);
  if ( !v2 )
  {
    v14 = &v4[v3 - 1];
    v15 = *v14;
    *v14 = sub_847C0(v4, v4, v3 - 1, 0xAuLL);
    return (unsigned int)(v15 + 48);
  }
  if ( v2 <= v3 )
  {
    v10 = sub_83DC0(
            *(_QWORD *)(a1 + 48),
            0LL,
            *(unsigned __int64 **)(a1 + 16),
            *(_QWORD *)(a1 + 24),
            *(__int64 **)(a1 + 32),
            v2);
    v11 = *(__int64 **)(a1 + 48);
    v11[*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 40)] = v10;
    v12 = *(_QWORD *)(a1 + 40);
    v13 = *v11;
    *(_QWORD *)(a1 + 24) = v12;
    if ( !v12 )
    {
LABEL_17:
      *(_QWORD *)(a1 + 24) = 1LL;
      return (unsigned int)(v13 + 48);
    }
    v4 = *(_QWORD **)(a1 + 16);
    while ( !v4[v12 - 1] )
    {
      *(_QWORD *)(a1 + 24) = --v12;
      if ( !v12 )
        goto LABEL_17;
    }
    v3 = *(_QWORD *)(a1 + 24);
    v5 = v13 + 48;
  }
  else
  {
    v5 = 48;
  }
  v6 = sub_847C0(v4, v4, v3, 0xAuLL);
  if ( v6 )
  {
    v7 = *(_QWORD *)(a1 + 24);
    v8 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 24) = v7 + 1;
    *(_QWORD *)(v8 + 8 * v7) = v6;
  }
  return v5;
}

//----- (000000000007A450) ----------------------------------------------------
_QWORD *__fastcall sub_7A450(__int64 a1, __int64 a2, _QWORD *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  _DWORD *v12; // rbx
  unsigned int v13; // ebp
  unsigned int v14; // eax
  __int64 v15; // rcx
  u32 v16; // er9
  double v17; // xmm4_8
  double v18; // xmm5_8
  char *v19; // r15
  char *v20; // r13
  char v21; // al
  __int64 v22; // r14
  __int64 v23; // rdx
  __int64 v24; // rax
  __int16 *v27; // rdi
  __int64 v28; // rax
  unsigned int v29; // er15
  __int64 v30; // rax
  __int64 v31; // rcx
  u32 v32; // er9
  double v33; // xmm4_8
  double v34; // xmm5_8
  __int64 v35; // rax
  unsigned __int64 v36; // r8
  unsigned int v37; // eax
  unsigned int v38; // eax
  unsigned int v39; // edx
  __int64 v40; // rcx
  unsigned __int64 v41; // [rsp+8h] [rbp-4A0h]
  __int64 v42[2]; // [rsp+20h] [rbp-488h] BYREF
  char v43[1024]; // [rsp+30h] [rbp-478h] BYREF
  __int16 v44[16]; // [rsp+430h] [rbp-78h] BYREF
  __int16 v45[12]; // [rsp+450h] [rbp-58h] BYREF
  unsigned __int64 v46; // [rsp+468h] [rbp-40h]

  v46 = __readfsqword(0x28u);
  v12 = (_DWORD *)sub_6ED60((__int64)"to_outpunct");
  v13 = sub_6EDF0(0x2Eu, v12);
  v14 = sub_6EDF0(0x2Cu, v12);
  if ( v12 )
  {
    v29 = v14;
    v42[0] = 0LL;
    v30 = sub_6D090((char *)v44, v13, v42, v15, (u32 *)v42, v16, a4, a5, a6, a7, v17, v18, a10, a11);
    if ( v30 == -1 )
      v44[0] = 46;
    else
      *((_BYTE *)v44 + v30) = 0;
    v42[0] = 0LL;
    v35 = sub_6D090((char *)v45, v29, v42, v31, (u32 *)v42, v32, a4, a5, a6, a7, v33, v34, a10, a11);
    if ( v35 == -1 )
      v45[0] = 44;
    else
      *((_BYTE *)v45 + v35) = 0;
  }
  v42[0] = (__int64)v43;
  v42[1] = 1024LL;
  if ( !(unsigned __int8)sub_6BAD0(v42, a2 - a1, 1LL) )
    return (_QWORD *)a1;
  v41 = v42[0];
  v19 = (char *)(sub_91D0(v42[0], a1, a2 - a1) - 1);
  if ( v41 <= (unsigned __int64)v19 )
  {
    v20 = (char *)(v41 - 1);
    while ( 1 )
    {
      v21 = *v19;
      if ( (unsigned __int8)(*v19 - 48) > 9u )
        break;
      v22 = *(_QWORD *)(*(_QWORD *)__readfsqword(0xFFFFFFA0) + 8LL * (char)(v21 - 7) + 64);
      v23 = strlen(v22);
      a3 = (_QWORD *)((char *)a3 - v23);
      v24 = v23 - 1;
      if ( v23 )
      {
        do
          *((_BYTE *)a3 + v24) = *(_BYTE *)(v22 + v24);
        while ( v24-- != 0 );
        if ( --v19 == v20 )
          goto LABEL_12;
      }
      else
      {
LABEL_7:
        if ( --v19 == v20 )
          goto LABEL_12;
      }
    }
    if ( v12 && (v21 & 0xFD) == 44 )
    {
      v27 = v45;
      if ( v21 == 46 )
        v27 = v44;
      v28 = strlen((__int64)v27);
      a3 = (_QWORD *)((char *)a3 - v28);
      if ( v28 )
      {
        if ( (unsigned int)v28 >= 8 )
        {
          v36 = (unsigned __int64)(a3 + 1) & 0xFFFFFFFFFFFFFFF8LL;
          *a3 = *(_QWORD *)v27;
          *(_QWORD *)((char *)a3 + (unsigned int)v28 - 8) = *(_QWORD *)((char *)v27 + (unsigned int)v28 - 8);
          v37 = ((_DWORD)a3 - v36 + v28) & 0xFFFFFFF8;
          if ( v37 >= 8 )
          {
            v38 = v37 & 0xFFFFFFF8;
            v39 = 0;
            do
            {
              v40 = v39;
              v39 += 8;
              *(_QWORD *)(v36 + v40) = *(_QWORD *)((char *)v27 - ((char *)a3 - v36) + v40);
            }
            while ( v39 < v38 );
          }
        }
        else if ( (v28 & 4) != 0 )
        {
          *(_DWORD *)a3 = *(_DWORD *)v27;
          *(_DWORD *)((char *)a3 + (unsigned int)v28 - 4) = *(_DWORD *)((char *)v27 + (unsigned int)v28 - 4);
        }
        else if ( (_DWORD)v28 )
        {
          *(_BYTE *)a3 = *(_BYTE *)v27;
          if ( (v28 & 2) != 0 )
            *(_WORD *)((char *)a3 + (unsigned int)v28 - 2) = *(__int16 *)((char *)v27 + (unsigned int)v28 - 2);
        }
      }
    }
    else
    {
      *((_BYTE *)a3 - 1) = v21;
      a3 = (_QWORD *)((char *)a3 - 1);
    }
    goto LABEL_7;
  }
LABEL_12:
  if ( (char *)v42[0] != v43 )
    sub_21B70(v42[0]);
  return a3;
}
// 7A67E: variable 'v15' is possibly undefined
// 7A67E: variable 'v16' is possibly undefined
// 7A67E: variable 'v17' is possibly undefined
// 7A67E: variable 'v18' is possibly undefined
// 7A6B6: variable 'v31' is possibly undefined
// 7A6B6: variable 'v32' is possibly undefined
// 7A6B6: variable 'v33' is possibly undefined
// 7A6B6: variable 'v34' is possibly undefined
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);

//----- (000000000007D1B0) ----------------------------------------------------
__int64 __fastcall sub_7D1B0(_QWORD *a1, __int64 a2, const __m128i **a3, __m128i a4, __m128 a5, __m128i a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, __int64 a13, __int64 a14)
{
  _QWORD *v14; // r11
  char v16; // r14
  char v17; // al
  char v18; // si
  __int64 v19; // rdx
  int v20; // ebx
  const __m128i *v21; // rdx
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // rax
  signed __int64 v24; // rax
  unsigned int v25; // ebx
  const char *v26; // r13
  char *v27; // rcx
  __int64 v28; // rdx
  bool v29; // zf
  int v30; // er15
  char v31; // al
  int v32; // er15
  __int64 v33; // rax
  _DWORD *v34; // rsi
  __int64 v35; // rdx
  unsigned int v36; // edi
  __int8 *v37; // rdx
  __int16 v39; // fps
  __int64 v43; // rax
  __int64 v44; // rax
  _DWORD *v45; // rsi
  __int64 v46; // rax
  _DWORD *v47; // rsi
  unsigned int v48; // er14
  __int64 v49; // rax
  unsigned int v50; // esi
  bool v51; // al
  __int64 v52; // r13
  __int64 v53; // rax
  unsigned int v54; // er14
  _BYTE *v56; // rax
  __int8 *v57; // rdx
  signed __int64 v58; // r13
  int v59; // er14
  int v60; // ecx
  signed __int64 v61; // rax
  void *v62; // rsp
  void *v63; // rsp
  void *v64; // rsp
  int v65; // eax
  int v66; // edx
  int v67; // edx
  __int64 v68; // rbx
  __int64 v69; // rdx
  __int64 v70; // rdx
  char *v71; // r15
  int v72; // er12
  int v73; // er14
  char *v74; // rbx
  int v75; // er13
  __int64 v76; // rax
  __int64 v77; // rdx
  bool v78; // zf
  int v79; // eax
  __int64 v80; // rax
  __int64 v81; // rdx
  unsigned __int64 v82; // rax
  char v83; // cl
  __int64 *v84; // rdi
  unsigned __int64 v85; // rsi
  __int32 v87; // esi
  __int32 v88; // ecx
  __int64 *v89; // r9
  unsigned __int64 *v90; // rsi
  int v93; // er14
  __int64 v95; // rdx
  __int64 v96; // rcx
  __int64 v97; // rdx
  __int64 *v98; // rcx
  __int64 v99; // rax
  __int64 v100; // rcx
  int v101; // esi
  int v102; // edx
  __int32 v103; // esi
  __int32 v104; // eax
  __int8 v105; // al
  unsigned int v106; // edx
  __int8 *v107; // r8
  unsigned int i; // er9
  unsigned int v109; // ecx
  __int64 v110; // rax
  unsigned __int64 v111; // rdx
  __int64 v112; // rcx
  int v113; // esi
  u32 v114; // er9
  __int64 v115; // rax
  unsigned int v116; // esi
  int v117; // eax
  double v118; // xmm4_8
  double v119; // xmm5_8
  bool v120; // al
  __int64 v121; // r8
  char *v122; // r13
  _BYTE *v123; // rax
  unsigned int v124; // esi
  int v125; // eax
  unsigned __int64 v126; // r8
  __int64 v127; // rax
  int v128; // eax
  unsigned __int64 v129; // r15
  _BOOL4 v130; // eax
  __int32 v131; // esi
  void *v132; // rsp
  __int64 *v133; // r13
  __int64 *v134; // r15
  __int64 *v135; // rbx
  unsigned int *v136; // rax
  unsigned int *v137; // r15
  __int32 v138; // ebx
  int v139; // er14
  unsigned int v140; // eax
  __int32 v141; // edx
  int v142; // esi
  __int64 v143; // r8
  bool v144; // di
  __int64 v145; // rax
  unsigned __int16 v146; // ax
  __int32 v147; // eax
  __int8 *v148; // r9
  __int64 v149; // rbx
  __int8 v150; // al
  unsigned int v151; // edx
  unsigned int v152; // esi
  unsigned int v153; // edi
  __int64 v154; // r14
  unsigned __int64 v155; // r9
  unsigned int v156; // er10
  int v157; // edi
  __int64 v158; // rax
  unsigned __int64 v159; // rdx
  __int64 v160; // rdx
  __int64 v161; // rax
  unsigned int *v162; // rdx
  unsigned __int8 v163; // al
  int v164; // eax
  _DWORD *v165; // rsi
  int v166; // edi
  unsigned int v167; // eax
  __int64 v168; // rbx
  char v169; // r14
  int v170; // esi
  __int64 *v171; // rax
  int v172; // edx
  int v173; // edi
  int v174; // esi
  int v175; // eax
  _BYTE *v176; // rax
  char v177; // al
  __int64 v178; // rax
  __int64 v179; // rdx
  char v180; // r15
  unsigned __int64 v181; // rax
  char *v182; // rbx
  __int64 v183; // r8
  __int64 v184; // rax
  int v185; // esi
  __int64 v186; // rax
  __int64 v187; // r8
  unsigned __int64 v188; // r8
  unsigned __int64 *v189; // r10
  __int64 v190; // rdx
  int v191; // edi
  unsigned __int64 *v192; // rax
  unsigned __int64 v193; // rcx
  int v194; // ecx
  int v195; // er12
  int v196; // er13
  __int64 v197; // rdx
  __int64 v198; // rax
  unsigned __int64 v199; // rcx
  unsigned __int64 *v201; // rdx
  __int64 v202; // rax
  int v204; // er9
  __int64 v205; // rdi
  unsigned __int64 *v206; // r14
  __int64 v207; // r11
  __int64 v208; // r13
  __int64 v209; // r8
  __int64 *v210; // r9
  __int64 v211; // rax
  __int64 v212; // rax
  _BYTE *v213; // rax
  __int64 v214; // rcx
  __int64 v215; // rax
  __int64 v216; // rbx
  __int64 v217; // rax
  __int8 *v218; // r14
  __int64 v219; // rdx
  void *v220; // rsp
  __int64 *v221; // rdi
  __int64 v222; // r14
  int v223; // ebx
  unsigned int *v224; // r12
  __int64 *v225; // r15
  unsigned int v226; // er13
  int v227; // eax
  u32 *v228; // r8
  __int64 v229; // rbx
  __int64 (__fastcall *v230)(_QWORD *, __int64 *, u32 *); // rax
  __int64 v231; // rax
  __int64 v232; // rbx
  int v233; // esi
  __int64 v234; // rax
  __int64 v235; // rbx
  __int64 v236; // rdi
  int v237; // er12
  u32 v238; // er15
  bool v239; // al
  __int64 v240; // rax
  unsigned int v241; // esi
  int v242; // eax
  __int64 v243; // rbx
  __int64 *v244; // r15
  u32 v245; // er14
  unsigned __int8 *v246; // rax
  unsigned __int8 v247; // dl
  bool v248; // zf
  _BYTE *v249; // rax
  __int64 *v250; // r9
  __int64 v251; // r14
  __int64 v252; // rax
  unsigned __int64 *v253; // r13
  char v255; // al
  char v256; // cl
  __int64 v257; // r12
  unsigned __int64 *v258; // rsi
  unsigned __int64 v259; // rdx
  _BYTE *v260; // rax
  __int64 v261; // r14
  __int64 v262; // rax
  unsigned __int64 v263; // rax
  bool v264; // sf
  int v265; // er14
  int v266; // edx
  __int64 v267; // rsi
  bool v268; // cf
  int v269; // eax
  int v272; // er15
  __int64 v273; // rbx
  unsigned __int64 v274; // r13
  __int64 v275; // r14
  __int64 v276; // rax
  __int64 v277; // rax
  int v278; // ebx
  int v280; // ecx
  unsigned __int64 v282; // rax
  __int64 v283; // rdx
  unsigned int v284; // esi
  int v285; // eax
  bool v286; // al
  int v287; // er14
  unsigned int v288; // esi
  int v289; // eax
  _BYTE *v290; // rax
  __int64 v291; // rax
  __int64 v292; // rax
  __int64 *v293; // r15
  __int64 *v294; // rax
  unsigned __int64 v296; // rax
  int v297; // eax
  unsigned __int64 v298; // rax
  __int64 v299; // rdx
  unsigned int v300; // esi
  int v301; // eax
  int v302; // esi
  unsigned int v303; // eax
  __int64 v304; // rsi
  int v306; // eax
  unsigned int *v307; // rdx
  u32 *v308; // r8
  _QWORD *v311; // rsi
  _QWORD *v312; // [rsp+10h] [rbp-158h] BYREF
  int v313; // [rsp+18h] [rbp-150h]
  int v314; // [rsp+1Ch] [rbp-14Ch]
  int v315; // [rsp+20h] [rbp-148h]
  unsigned int v316; // [rsp+24h] [rbp-144h]
  int v317; // [rsp+28h] [rbp-140h]
  int v318; // [rsp+2Ch] [rbp-13Ch]
  __int64 *v319; // [rsp+30h] [rbp-138h]
  unsigned int v320; // [rsp+38h] [rbp-130h]
  unsigned int v321; // [rsp+3Ch] [rbp-12Ch]
  unsigned __int64 v322; // [rsp+40h] [rbp-128h]
  _BYTE *v323; // [rsp+48h] [rbp-120h]
  __int64 v324; // [rsp+50h] [rbp-118h]
  _QWORD *v325; // [rsp+58h] [rbp-110h]
  _QWORD *v326; // [rsp+60h] [rbp-108h]
  unsigned int v327; // [rsp+68h] [rbp-100h]
  int v328; // [rsp+6Ch] [rbp-FCh]
  u32 *v329; // [rsp+70h] [rbp-F8h]
  __int8 *v330; // [rsp+78h] [rbp-F0h]
  __m128 v331; // [rsp+80h] [rbp-E8h] BYREF
  char *v332; // [rsp+90h] [rbp-D8h]
  __int64 v333; // [rsp+98h] [rbp-D0h]
  __m128i v334; // [rsp+A0h] [rbp-C8h] BYREF
  __int16 v335; // [rsp+BAh] [rbp-AEh]
  unsigned int v336; // [rsp+BCh] [rbp-ACh] BYREF
  unsigned int v337; // [rsp+C0h] [rbp-A8h] BYREF
  unsigned int v338; // [rsp+C4h] [rbp-A4h]
  int v339; // [rsp+C8h] [rbp-A0h] BYREF
  unsigned __int64 *v340; // [rsp+D0h] [rbp-98h]
  __int64 v341; // [rsp+D8h] [rbp-90h]
  __int64 *v342; // [rsp+E0h] [rbp-88h]
  __int64 v343; // [rsp+E8h] [rbp-80h]
  __int64 *v344; // [rsp+F0h] [rbp-78h]
  __int64 v345; // [rsp+F8h] [rbp-70h]
  __int64 v346[2]; // [rsp+100h] [rbp-68h] BYREF
  unsigned __int64 v347; // [rsp+110h] [rbp-58h] BYREF
  unsigned __int64 v348; // [rsp+118h] [rbp-50h]
  unsigned __int64 v349; // [rsp+128h] [rbp-40h]

  v308 = (u32 *)a2;
  v311 = (_QWORD *)__readfsqword(0xFFFFFFA8);
  v14 = v311;
  v326 = v311;
  v16 = *(_BYTE *)(a2 + 12);
  v333 = a2;
  v349 = __readfsqword(0x28u);
  v17 = *(_BYTE *)(a2 + 13);
  v336 = 0;
  v337 = 0;
  LODWORD(v332) = (v17 & 4) != 0;
  v18 = v17 & 1;
  if ( (v17 & 1) != 0 )
  {
    v35 = v326[4];
    v29 = **(_BYTE **)(v35 + 80) == 0;
    v324 = *(_QWORD *)(v35 + 80);
    if ( v29 )
      v324 = *(_QWORD *)(v326[1] + 64LL);
    v328 = *(_DWORD *)(v35 + 408);
    if ( !v328 )
      v328 = *(_DWORD *)(v326[1] + 88LL);
    if ( v16 >= 0 )
      goto LABEL_5;
    v330 = *(__int8 **)(v35 + 96);
  }
  else
  {
    v19 = v14[1];
    v20 = *(_DWORD *)(v19 + 88);
    v324 = *(_QWORD *)(v19 + 64);
    v328 = v20;
    if ( v16 >= 0 )
    {
LABEL_5:
      v330 = 0LL;
      v327 = 0;
      v323 = 0LL;
      goto LABEL_6;
    }
    v330 = *(__int8 **)(v19 + 80);
  }
  v334.m128i_i8[0] = *v330;
  if ( (unsigned __int8)(v334.m128i_i8[0] - 1) > 0x7Du )
    goto LABEL_5;
  if ( (_DWORD)v332 )
  {
    if ( v18 )
      v36 = *(_DWORD *)(v326[4] + 416LL);
    else
      v36 = *(_DWORD *)(v326[1] + 96LL);
    v327 = v36;
    v323 = 0LL;
    v37 = 0LL;
    if ( v36 )
      v37 = v330;
    v330 = v37;
    v21 = *a3;
    if ( (v17 & 0x10) != 0 )
      goto LABEL_7;
    goto LABEL_36;
  }
  if ( v18 )
    v323 = *(_BYTE **)(v326[4] + 88LL);
  else
    v323 = *(_BYTE **)(v326[1] + 72LL);
  v57 = 0LL;
  if ( *v323 )
    v57 = v330;
  v327 = *v323 != 0 ? 0xFFFFFFFE : 0;
  v330 = v57;
LABEL_6:
  v21 = *a3;
  if ( (v17 & 0x10) != 0 )
  {
LABEL_7:
    a5 = (__m128)_mm_load_si128(v21);
    a4.m128i_i64[0] = a5.m128_u64[0];
    v334 = (__m128i)a5;
    v22 = sub_87E90(a5, a5);
    a6 = _mm_load_si128(&v334);
    if ( v22 )
    {
      v25 = _mm_movemask_ps((__m128)a6) & 8;
      v336 = v25;
      v26 = "N";
      v27 = "NAN";
      v28 = *(int *)(v333 + 8);
      v248 = (*(_BYTE *)(__readfsqword(0xFFFFFFF8) + 2 * v28 + 1) & 1) == 0;
      if ( v248 )
        v26 = "n";
      if ( v248 )
        v27 = "nan";
LABEL_15:
      v30 = *(_DWORD *)(v333 + 4);
      v31 = (((unsigned __int8)v16 >> 5) ^ 1) & 1;
      if ( v25 )
      {
        v32 = v30 - 4;
        LOBYTE(v28) = v32 > 0;
        if ( v32 <= 0 || !v31 )
        {
          v25 = 0;
LABEL_19:
          if ( (_DWORD)v332 )
          {
            v33 = a1[20];
            if ( v33 )
            {
              v34 = *(_DWORD **)(v33 + 32);
              if ( (unsigned __int64)v34 < *(_QWORD *)(v33 + 40) )
              {
                *(_QWORD *)(v33 + 32) = v34 + 1;
                *v34 = 45;
                goto LABEL_60;
              }
            }
            v331.m128_u64[0] = (unsigned __int64)v27;
            v284 = 45;
            v334.m128i_i8[0] = v28;
            goto LABEL_471;
          }
          v56 = (_BYTE *)a1[5];
          if ( (unsigned __int64)v56 < a1[6] )
          {
            a1[5] = v56 + 1;
            *v56 = 45;
            goto LABEL_60;
          }
          v331.m128_u64[0] = (unsigned __int64)v27;
          v288 = 45;
          v334.m128i_i8[0] = v28;
          goto LABEL_499;
        }
LABEL_42:
        v334.m128i_i64[0] = (__int64)v27;
        if ( (_DWORD)v332 )
          v43 = sub_6A3E0(
                  (__int64)a1,
                  32,
                  v32,
                  *(double *)a4.m128i_i64,
                  *(double *)a5.m128_u64,
                  *(double *)a6.m128i_i64,
                  a7,
                  a8,
                  a9,
                  a10,
                  a11);
        else
          v43 = sub_6A2A0(
                  (__int64)a1,
                  32,
                  v32,
                  *(double *)a4.m128i_i64,
                  *(double *)a5.m128_u64,
                  *(double *)a6.m128i_i64,
                  a7,
                  a8,
                  a9,
                  a10,
                  a11);
        v27 = (char *)v334.m128i_i64[0];
        if ( v43 != v32 )
          return (unsigned int)-1;
        v25 = v32;
        v28 = 1LL;
        if ( v336 )
          goto LABEL_19;
        v16 = *(_BYTE *)(v333 + 12);
        if ( (v16 & 0x40) == 0 )
        {
LABEL_47:
          if ( (v16 & 0x10) == 0 )
            goto LABEL_61;
          if ( (_DWORD)v332 )
          {
            v44 = a1[20];
            if ( v44 && (v45 = *(_DWORD **)(v44 + 32), (unsigned __int64)v45 < *(_QWORD *)(v44 + 40)) )
            {
              *(_QWORD *)(v44 + 32) = v45 + 1;
              *v45 = 32;
            }
            else
            {
              v331.m128_u64[0] = (unsigned __int64)v27;
              v334.m128i_i8[0] = v28;
              v297 = sub_6AB50(
                       (__int64)a1,
                       0x20u,
                       v28,
                       (__int64)v27,
                       v308,
                       a14,
                       *(double *)a4.m128i_i64,
                       *(double *)a5.m128_u64,
                       *(double *)a6.m128i_i64,
                       a7,
                       a8,
                       a9,
                       a10,
                       a11);
              v28 = v334.m128i_u8[0];
              v27 = (char *)v331.m128_u64[0];
              if ( v297 == -1 )
                return (unsigned int)-1;
            }
          }
          else
          {
            v249 = (_BYTE *)a1[5];
            if ( (unsigned __int64)v249 >= a1[6] )
            {
              v331.m128_u64[0] = (unsigned __int64)v27;
              v334.m128i_i8[0] = v28;
              v306 = sub_1A150(
                       (__int64)a1,
                       0x20u,
                       *(double *)a4.m128i_i64,
                       *(double *)a5.m128_u64,
                       *(double *)a6.m128i_i64,
                       a7,
                       a8,
                       a9,
                       a10,
                       a11);
              v28 = v334.m128i_u8[0];
              v27 = (char *)v331.m128_u64[0];
              if ( v306 == -1 )
                return (unsigned int)-1;
            }
            else
            {
              a1[5] = v249 + 1;
              *v249 = 32;
            }
          }
LABEL_60:
          ++v25;
LABEL_61:
          if ( (_DWORD)v332 )
          {
            v48 = v25 + 3;
            while ( 1 )
            {
              v49 = a1[20];
              v26 += 4;
              v50 = *((_DWORD *)v26 - 1);
              if ( v49 && (v27 = *(char **)(v49 + 32), (unsigned __int64)v27 < *(_QWORD *)(v49 + 40)) )
              {
                *(_QWORD *)(v49 + 32) = v27 + 4;
                v51 = v50 == -1;
                *(_DWORD *)v27 = v50;
              }
              else
              {
                v334.m128i_i8[0] = v28;
                v125 = sub_6AB50(
                         (__int64)a1,
                         v50,
                         v28,
                         (__int64)v27,
                         v308,
                         a14,
                         *(double *)a4.m128i_i64,
                         *(double *)a5.m128_u64,
                         *(double *)a6.m128i_i64,
                         a7,
                         a8,
                         a9,
                         a10,
                         a11);
                v28 = v334.m128i_u8[0];
                v51 = v125 == -1;
              }
              if ( v51 )
                break;
              if ( v48 == ++v25 )
              {
                if ( (*(_BYTE *)(v333 + 12) & 0x20) != 0 && (_BYTE)v28 )
                {
                  v52 = v32;
                  v53 = sub_6A3E0(
                          (__int64)a1,
                          32,
                          v32,
                          *(double *)a4.m128i_i64,
                          *(double *)a5.m128_u64,
                          *(double *)a6.m128i_i64,
                          a7,
                          a8,
                          a9,
                          a10,
                          a11);
                  goto LABEL_71;
                }
                return v25;
              }
            }
          }
          else
          {
            v121 = (__int64)(v27 + 3);
            v122 = v27;
            do
            {
              ++v122;
              v123 = (_BYTE *)a1[5];
              v124 = (unsigned __int8)*(v122 - 1);
              if ( (unsigned __int64)v123 >= a1[6] )
              {
                v332 = v27;
                v331.m128_u64[0] = v121;
                v334.m128i_i8[0] = v28;
                v175 = sub_1A150(
                         (__int64)a1,
                         v124,
                         *(double *)a4.m128i_i64,
                         *(double *)a5.m128_u64,
                         *(double *)a6.m128i_i64,
                         a7,
                         a8,
                         a9,
                         a10,
                         a11);
                LOBYTE(v28) = v334.m128i_i8[0];
                v121 = v331.m128_u64[0];
                v27 = v332;
                if ( v175 == -1 )
                  return (unsigned int)-1;
              }
              else
              {
                a1[5] = v123 + 1;
                *v123 = v124;
              }
              v54 = v25 + (_DWORD)v122 - (_DWORD)v27;
            }
            while ( v122 != (char *)v121 );
            if ( (*(_BYTE *)(v333 + 12) & 0x20) == 0 || !(_BYTE)v28 )
              return v54;
            v52 = v32;
            v25 = v54;
            v53 = sub_6A2A0(
                    (__int64)a1,
                    32,
                    v32,
                    *(double *)a4.m128i_i64,
                    *(double *)a5.m128_u64,
                    *(double *)a6.m128i_i64,
                    a7,
                    a8,
                    a9,
                    a10,
                    a11);
LABEL_71:
            if ( v53 == v52 )
              return v32 + v25;
          }
          return (unsigned int)-1;
        }
LABEL_56:
        if ( (_DWORD)v332 )
        {
          v46 = a1[20];
          if ( v46 )
          {
            v47 = *(_DWORD **)(v46 + 32);
            if ( (unsigned __int64)v47 < *(_QWORD *)(v46 + 40) )
            {
              *(_QWORD *)(v46 + 32) = v47 + 1;
              *v47 = 43;
              goto LABEL_60;
            }
          }
          v331.m128_u64[0] = (unsigned __int64)v27;
          v284 = 43;
          v334.m128i_i8[0] = v28;
LABEL_471:
          v285 = sub_6AB50(
                   (__int64)a1,
                   v284,
                   v28,
                   (__int64)v27,
                   v308,
                   a14,
                   *(double *)a4.m128i_i64,
                   *(double *)a5.m128_u64,
                   *(double *)a6.m128i_i64,
                   a7,
                   a8,
                   a9,
                   a10,
                   a11);
          v28 = v334.m128i_u8[0];
          v27 = (char *)v331.m128_u64[0];
          v286 = v285 == -1;
          goto LABEL_472;
        }
        v176 = (_BYTE *)a1[5];
        if ( (unsigned __int64)v176 < a1[6] )
        {
          a1[5] = v176 + 1;
          *v176 = 43;
          goto LABEL_60;
        }
        v331.m128_u64[0] = (unsigned __int64)v27;
        v288 = 43;
        v334.m128i_i8[0] = v28;
LABEL_499:
        v289 = sub_1A150(
                 (__int64)a1,
                 v288,
                 *(double *)a4.m128i_i64,
                 *(double *)a5.m128_u64,
                 *(double *)a6.m128i_i64,
                 a7,
                 a8,
                 a9,
                 a10,
                 a11);
        v28 = v334.m128i_u8[0];
        v27 = (char *)v331.m128_u64[0];
        v286 = v289 == -1;
LABEL_472:
        if ( v286 )
          return (unsigned int)-1;
        goto LABEL_60;
      }
      if ( (v16 & 0x50) != 0 )
      {
        v32 = v30 - 4;
        LOBYTE(v28) = v32 > 0;
        if ( v32 <= 0 )
          goto LABEL_55;
      }
      else
      {
        v32 = v30 - 3;
        LOBYTE(v28) = v32 > 0;
        if ( v32 <= 0 )
          goto LABEL_55;
      }
      if ( v31 )
        goto LABEL_42;
LABEL_55:
      if ( (v16 & 0x40) == 0 )
        goto LABEL_47;
      goto LABEL_56;
    }
    a5 = (__m128)_mm_load_si128((const __m128i *)&xmmword_A7C70);
    v334 = a6;
    v331 = (__m128)_mm_and_si128(a6, (__m128i)xmmword_A7C60);
    v23 = sub_87E90(v331, a5);
    a6 = _mm_load_si128(&v334);
    if ( !v23 )
    {
      a5 = (__m128)_mm_load_si128((const __m128i *)&xmmword_A7C70);
      a4 = _mm_load_si128((const __m128i *)&v331);
      v24 = sub_880A0((__m128)a4, a5);
      a6 = _mm_load_si128(&v334);
      if ( v24 > 0 )
      {
        v25 = _mm_movemask_ps((__m128)a6) & 8;
LABEL_11:
        v336 = v25;
        v26 = "I";
        v27 = "INF";
        v28 = *(int *)(v333 + 8);
        v29 = (*(_BYTE *)(__readfsqword(0xFFFFFFF8) + 2 * v28 + 1) & 1) == 0;
        if ( v29 )
          v26 = "i";
        if ( v29 )
          v27 = "inf";
        goto LABEL_15;
      }
    }
    a4.m128i_i64[0] = a6.m128i_i64[0];
    v341 = sub_85730(v346, a6, 2LL, &v339, &v336);
    v58 = v341;
    v59 = ((_DWORD)v341 << 6) - 112;
    goto LABEL_85;
  }
LABEL_36:
  if ( (v16 & 1) != 0 )
  {
    _FST7 = *v21;
    if ( fabs(*(long double *)&_FST7) > 1.189731495357231765e4932 )
    {
      __asm { fxam }
      v25 = v39 & 0x200;
      goto LABEL_11;
    }
    v341 = sub_85670(
             v346,
             2LL,
             &v339,
             (int *)&v336,
             (__int64)v308,
             a14,
             COERCE_UNSIGNED_INT128(*(long double *)v21),
             WORD4(COERCE_UNSIGNED_INT128(*(long double *)v21)));
    v58 = v341;
    v59 = ((_DWORD)v341 << 6) - 63;
  }
  else
  {
    a4 = (__m128i)v21->m128i_u64[0];
    a5.m128_u64[0] = fabs(*(double *)a4.m128i_i64);
    if ( *(double *)a5.m128_u64 > 1.797693134862316e308 )
    {
      v25 = _mm_movemask_pd((__m128d)a4) & 1;
      goto LABEL_11;
    }
    v341 = sub_855E0(v346, *(double *)a4.m128i_i64, 2LL, &v339, &v336);
    v58 = v341;
    v59 = ((_DWORD)v341 << 6) - 52;
  }
LABEL_85:
  v60 = v339;
  v343 = 0LL;
  v61 = 16 * ((unsigned __int64)(8LL * (((int)(abs32(v339) + 63) >> 6) + 4) + 23) >> 4);
  v62 = alloca(v61);
  v63 = alloca(v61);
  v64 = alloca(v61);
  v340 = (unsigned __int64 *)&v312;
  v344 = (__int64 *)&v312;
  v342 = (__int64 *)&v312;
  if ( v339 <= 2 )
  {
    if ( v339 >= 0 )
    {
      v126 = sub_841E0((__int64)&v312, (__int64)v346, v58, (unsigned __int8)v59 + (unsigned __int8)v339);
      v127 = v341++;
      v340[v127] = v126;
      v339 = 0;
      goto LABEL_121;
    }
    v180 = 12;
    v181 = sub_841E0((__int64)&v312, (__int64)v346, v58, v59);
    v334.m128i_i32[0] = 0;
    v182 = (char *)&unk_A85B8;
    v183 = v181;
    v184 = v341;
    v331.m128_u64[0] = (unsigned __int64)a1;
    v185 = -v339;
    ++v341;
    v340[v184] = v183;
    v337 = 1;
    v339 = v185;
    while ( 1 )
    {
      v182 -= 24;
      if ( *((_DWORD *)v182 + 5) > v185 )
        goto LABEL_295;
      v197 = *((_QWORD *)v182 + 1) - 1LL;
      v198 = *(_QWORD *)v182;
      if ( v341 < v197 )
        v186 = sub_84410(v344, (__int64 *)&qword_A8600[v198 + 1], v197, v340, v341);
      else
        v186 = sub_84410(v344, (__int64 *)v340, v341, &qword_A8600[v198 + 1], *((_QWORD *)v182 + 1) - 1LL);
      v187 = v341 + *((_QWORD *)v182 + 1);
      if ( v186 )
        v188 = v187 - 1;
      else
        v188 = v187 - 2;
      v345 = v188;
      v189 = (unsigned __int64 *)v344;
      v190 = v188;
      v191 = v339;
      v192 = (unsigned __int64 *)&v344[v188 - 1];
      _BitScanReverse64(&v193, *v192);
      v194 = v193 ^ 0x3F;
      v195 = v194;
      v196 = ~v194 + (((_DWORD)v188 - (_DWORD)v341 + 1) << 6);
      v185 = v339;
      if ( v339 + 3 == v196 )
      {
        if ( v194 > 60 )
        {
          v347 = 0xA000000000000000LL;
          v348 = 0LL;
          sub_841E0((__int64)&v347, (__int64)&v347, 2uLL, 64 - v194);
          v191 = v339;
          v185 = v339;
          if ( v339 + 2 >= v196 )
          {
            v189 = (unsigned __int64 *)v344;
            v188 = v345;
            goto LABEL_304;
          }
          if ( v339 + 3 != v196 )
            goto LABEL_295;
          v188 = v345;
          v189 = (unsigned __int64 *)v344;
          v199 = v348;
          v190 = v345;
          v192 = (unsigned __int64 *)&v344[v345 - 1];
        }
        else
        {
          v347 = 0LL;
          v348 = 10LL << (60 - (unsigned __int8)v194);
          v199 = v348;
          if ( v196 <= v339 + 2 )
            goto LABEL_304;
        }
        if ( *v192 >= v199 )
        {
          if ( *v192 != v199 )
          {
            v185 = v191;
            goto LABEL_295;
          }
          if ( v189[v190 - 2] >= v347 )
          {
            v185 = v191;
            goto LABEL_295;
          }
        }
      }
      else if ( v196 > v339 + 2 )
      {
        goto LABEL_295;
      }
LABEL_304:
      v185 = v191 - v196;
      v334.m128i_i32[0] |= 1 << v180;
      v339 = v191 - v196;
      if ( v191 - v196 < 0 )
        v195 -= v191 - v196;
      _RAX = *v189;
      if ( !*v189 )
      {
        v201 = v189 + 1;
        v202 = 1LL;
        do
        {
          _RCX = *v201;
          v204 = v202 - 1;
          v205 = (int)v202;
          v206 = v201;
          v207 = v202;
          v208 = v202;
          ++v201;
          ++v202;
        }
        while ( !_RCX );
        if ( v195 != 63 )
        {
          v253 = v340;
          __asm { tzcnt   rdx, rcx }
          v255 = 63 - v195;
          v256 = 63 - v195;
          if ( (int)_RDX < 63 - v195 )
          {
            v257 = v204;
            v258 = &v189[v207 - 1];
            v256 = v255;
            v259 = v188 - v204;
LABEL_418:
            sub_84300(v253, v258, v259, v256);
            v185 = v339;
            v341 = v345 - v257;
            goto LABEL_295;
          }
          v257 = (int)v205;
          v189 = v206;
          v188 -= (int)v205;
LABEL_521:
          v259 = v188;
          v258 = v189;
          goto LABEL_418;
        }
        goto LABEL_310;
      }
      if ( v195 == 63 )
      {
        v205 = 0LL;
        v208 = 0LL;
LABEL_310:
        v209 = v188 - v205;
        if ( v209 > 0 )
        {
          v210 = (__int64 *)v340;
          v211 = 0LL;
          do
          {
            v210[v211] = v189[v208 + v211];
            ++v211;
            v209 = v345 - v205;
          }
          while ( v345 - v205 > v211 );
        }
        v341 = v209;
        goto LABEL_295;
      }
      __asm { tzcnt   rax, rax }
      v253 = v340;
      v256 = 63 - v195;
      if ( 63 - v195 <= (int)_RAX )
      {
        v257 = 0LL;
        goto LABEL_521;
      }
      v296 = sub_841E0((__int64)v340, (__int64)v189, v188, (unsigned __int8)v195 + 1);
      v185 = v339;
      v341 = v345 + 1;
      v340[v345] = v296;
LABEL_295:
      --v180;
      if ( v182 == (char *)&unk_A8498 )
      {
        a1 = (_QWORD *)v331.m128_u64[0];
        if ( v185 > 0 )
        {
          sub_847C0(v344, v340, v341, 0xAuLL);
          _RSI = v344;
          v280 = 4;
          v345 = v341;
          __asm { tzcnt   rax, [rsi] }
          if ( v339 <= 4 )
            v280 = v339;
          if ( v280 <= (int)_RAX )
          {
            sub_84300(v340, (unsigned __int64 *)v344, v341, v280);
          }
          else
          {
            v282 = sub_841E0((__int64)v340, (__int64)v344, v341, 64 - (unsigned __int8)v280);
            if ( v282 )
            {
              v283 = v345++;
              v340[v283] = v282;
            }
          }
          v334.m128i_i32[0] |= 1u;
          v341 = v345;
        }
        goto LABEL_466;
      }
      if ( v185 <= 0 )
      {
        a1 = (_QWORD *)v331.m128_u64[0];
LABEL_466:
        v339 = v334.m128i_i32[0];
        goto LABEL_121;
      }
    }
  }
  v65 = v339 + v59;
  v66 = v339 + v59 + 63;
  if ( v339 + v59 >= 0 )
    v66 = v339 + v59;
  v67 = v66 >> 6;
  if ( (v65 & 0x3F) != 0 )
  {
    v263 = sub_841E0((__int64)&(&v312)[v67], (__int64)v346, v58, v65 % 64);
    v60 = v339;
    v264 = v339 + v59 < 0;
    v265 = v339 + v59;
    v266 = v265 + 63;
    if ( !v264 )
      v266 = v265;
    v69 = v266 >> 6;
    v267 = v69 + v341;
    v341 += v69;
    if ( v263 )
    {
      v341 = v267 + 1;
      v340[v267] = v263;
    }
  }
  else
  {
    v68 = v67;
    if ( v58 > 0 )
    {
      v334.m128i_i32[0] = v339;
      memcpy(&(&v312)[v67], v346, 8 * v58);
      v60 = v334.m128i_i32[0];
    }
    v69 = v68;
    v341 = v68 + v58;
  }
  if ( v69 > 0 )
  {
    v334.m128i_i32[0] = v60;
    sub_9190((__int64)v340, 0LL, 8 * v69);
    v60 = v334.m128i_i32[0];
  }
  v70 = v343;
  v71 = (char *)&unk_A85B8;
  v334.m128i_i64[0] = (__int64)a1;
  v72 = 0;
  v73 = 12;
  v74 = (char *)&unk_A85B8 - 312;
  v75 = 0;
  while ( 1 )
  {
    v79 = *((_DWORD *)v71 - 2);
    v71 -= 24;
    if ( v72 + v79 - 1 <= v60 )
      break;
LABEL_100:
    --v73;
    if ( v71 == v74 )
      goto LABEL_107;
LABEL_101:
    v60 = v339;
  }
  if ( !v70 )
  {
    v76 = *(_QWORD *)v71;
    if ( (*(_BYTE *)(v333 + 13) & 0x10) != 0 )
    {
      v345 = *((_QWORD *)v71 + 1) + 1LL;
      memcpy(v344 + 1, &qword_A8600[v76], 8 * v345);
      *v344 = 0LL;
      v77 = v345;
      v339 += 64;
    }
    else
    {
      v345 = *((_QWORD *)v71 + 1);
      memcpy(v344, &qword_A8600[v76], 8 * v345);
      v77 = v345;
    }
LABEL_97:
    v78 = v341 == v77;
    if ( v341 > v77 )
      goto LABEL_106;
    goto LABEL_98;
  }
  v80 = sub_84410(v344, v342, v70, &qword_A8600[*(_QWORD *)v71 + 1], *((_QWORD *)v71 + 1) - 1LL);
  v81 = v343 + *((_QWORD *)v71 + 1);
  if ( !v80 )
  {
    v77 = v81 - 2;
    v345 = v77;
    goto LABEL_97;
  }
  v77 = v81 - 1;
  v345 = v77;
  v78 = v341 == v77;
  if ( v341 > v77 )
    goto LABEL_106;
LABEL_98:
  if ( !v78 || (v128 = sub_83D80((__int64)v340, (__int64)v344, v77), v77 = v345, v128 < 0) )
  {
    v70 = v343;
    goto LABEL_100;
  }
LABEL_106:
  v343 = v77;
  memcpy(v342, v344, 8 * v77);
  v70 = v343;
  _BitScanReverse64(&v82, v342[v343 - 1]);
  v83 = v73--;
  v72 = ((_DWORD)v343 << 6) - 129 - (v82 ^ 0x3F);
  v75 |= 1 << v83;
  if ( v71 != v74 )
    goto LABEL_101;
LABEL_107:
  v339 = v75;
  a1 = (_QWORD *)v334.m128i_i64[0];
  if ( v70 > 0 )
  {
    v84 = v342;
    _BitScanReverse64(&v85, v342[v70 - 1]);
    _RAX = *v342;
    v87 = v85 ^ 0x3F;
    v88 = v87;
    if ( *v342 )
    {
      if ( v87 )
      {
        __asm { tzcnt   rax, rax }
        LODWORD(_R8) = _RAX;
        _R13 = *v340;
        if ( *v340 )
        {
          v90 = (unsigned __int64 *)v342;
          __asm { tzcnt   r8, r13 }
          if ( (int)_RAX <= (int)_R8 )
            LODWORD(_R8) = _RAX;
          v272 = 64 - v88;
          _R13 = 0LL;
        }
        else
        {
          v90 = (unsigned __int64 *)v342;
          v272 = 64 - v88;
        }
LABEL_493:
        v93 = 0;
        v273 = 0LL;
        if ( v272 <= (int)_R8 )
        {
LABEL_494:
          v287 = v93 + 1;
          sub_84300((unsigned __int64 *)v342, v90, v70 - v273, v272);
          v343 -= v287;
          sub_84300(v340, (unsigned __int64 *)((char *)v340 + _R13), v341 - v273, v272);
          v276 = v341 - v273;
          if ( !v340[v341 - v273 - 1] )
            v276 = v341 - v287;
          goto LABEL_454;
        }
        v334.m128i_i32[0] = v88;
        sub_841E0((__int64)v342, (__int64)v342, v70, v88);
        v298 = sub_841E0((__int64)v340, (__int64)v340, v341, v334.m128i_i8[0]);
        if ( v298 )
        {
          v299 = v341++;
          v340[v299] = v298;
        }
      }
    }
    else
    {
      v89 = (__int64 *)v340;
      v90 = (unsigned __int64 *)v342;
      _R13 = 0LL;
      while ( 1 )
      {
        _R8 = *(unsigned __int64 *)((char *)v340 + _R13);
        v93 = _RAX;
        if ( _R8 )
          break;
        _R8 = v90[1];
        v93 = _RAX + 1;
        ++v90;
        ++_RAX;
        _R13 += 8LL;
        if ( _R8 )
        {
          if ( v88 )
          {
            _R9 = *(unsigned __int64 *)((char *)v340 + _R13);
            __asm { tzcnt   rax, r8 }
            LODWORD(_R8) = _RAX;
            if ( _R9 )
            {
              __asm { tzcnt   r8, r9 }
              if ( (int)_RAX <= (int)_R8 )
                LODWORD(_R8) = _RAX;
              v272 = 64 - v88;
            }
            else
            {
              v272 = 64 - v88;
            }
            goto LABEL_451;
          }
LABEL_114:
          v95 = v70 - v93;
          if ( v95 > 0 )
          {
            v96 = 0LL;
            do
            {
              v84[v96] = v84[_RAX + v96];
              ++v96;
              v95 = v343 - v93;
            }
            while ( v95 > v96 );
          }
          v343 = v95;
          v97 = v341 - v93;
          if ( v97 > 0 )
          {
            v98 = &v89[_RAX];
            v99 = 0LL;
            do
            {
              v89[v99] = v98[v99];
              ++v99;
              v97 = v341 - v93;
            }
            while ( v97 > v99 );
          }
          v341 = v97;
          goto LABEL_121;
        }
      }
      if ( !v88 )
      {
        if ( !(_DWORD)_RAX )
          goto LABEL_121;
        goto LABEL_114;
      }
      __asm { tzcnt   r8, r8 }
      v272 = 64 - v88;
      if ( !(_DWORD)_RAX )
        goto LABEL_493;
LABEL_451:
      v273 = v93;
      if ( v272 <= (int)_R8 )
        goto LABEL_494;
      v274 = _R13 - 8;
      v275 = v93 - 1;
      sub_84300((unsigned __int64 *)v342, (unsigned __int64 *)((char *)v342 + v274), v70 - v275, v272);
      v343 -= v273;
      sub_84300(v340, (unsigned __int64 *)((char *)v340 + v274), v341 - v275, v272);
      v276 = v341 - v275;
      if ( !v340[v341 - v275 - 1] )
        v276 = v341 - v273;
LABEL_454:
      v341 = v276;
    }
  }
LABEL_121:
  v100 = *(int *)(v333 + 8);
  v101 = *(_DWORD *)v333;
  v315 = *(_DWORD *)(v333 + 4);
  LODWORD(v329) = v101;
  v314 = *(_DWORD *)(__readfsqword(0xFFFFFFE8) + 4 * v100);
  if ( (_BYTE)v314 == 101 )
  {
    v338 = v100;
    if ( v101 < 0 )
    {
      v322 = 14LL;
      LODWORD(v329) = 6;
    }
    else
    {
      v322 = v101 + 8LL;
    }
    goto LABEL_271;
  }
  if ( (_BYTE)v314 == 102 )
  {
    v338 = 102;
    v179 = (int)v329;
    if ( (int)v329 < 0 )
    {
      LODWORD(v329) = 6;
      v179 = 6LL;
    }
    v320 = v337;
    if ( !v337 )
    {
      v318 = 0x7FFFFFFF;
      v322 = v179 + v339 + 2;
      v321 = v339 + 1;
      v103 = 1;
      v331.m128_i32[0] = (int)v329;
      if ( v330 )
        goto LABEL_134;
LABEL_389:
      if ( v322 <= 0x3FFFFFFFFFFFFFFCLL )
        goto LABEL_172;
      goto LABEL_390;
    }
    v322 = v179 + 2;
LABEL_271:
    v103 = 1;
    v318 = 0x7FFFFFFF;
    v321 = 1;
    v331.m128_i32[0] = (int)v329;
    goto LABEL_133;
  }
  v318 = 6;
  if ( (int)v329 >= 0 )
  {
    v102 = 1;
    if ( (_DWORD)v329 )
      v102 = (int)v329;
    v318 = v102;
  }
  if ( v337 )
  {
    if ( v339 > 4 )
      goto LABEL_129;
    v338 = 102;
    v321 = 0;
    v331.m128_i32[0] = v318;
LABEL_288:
    v322 = v318 + 5LL;
  }
  else
  {
    if ( v318 > v339 )
    {
      v338 = 102;
      v321 = v339 + 1;
      v331.m128_i32[0] = v318 - (v339 + 1);
      goto LABEL_288;
    }
LABEL_129:
    v321 = 1;
    v338 = v100 - 2;
    v331.m128_i32[0] = v318 - 1;
    v322 = v318 - 1 + 8LL;
  }
  v103 = 0;
  v104 = v331.m128_i32[0];
  if ( (*(_BYTE *)(v333 + 12) & 8) == 0 )
    v104 = 0;
  LODWORD(v329) = v104;
LABEL_133:
  if ( v330 )
  {
LABEL_134:
    v105 = *v330;
    if ( (unsigned __int8)(*v330 - 1) > 0x7Du )
    {
      v320 = 0;
      v110 = 1LL;
    }
    else
    {
      v106 = v321;
      v107 = v330;
      for ( i = 0; ; ++i )
      {
        v109 = v105;
        if ( v106 <= v105 )
        {
          v320 = i;
          v110 = (int)(i + 1);
          goto LABEL_388;
        }
        v105 = *++v107;
        v106 -= v109;
        if ( (unsigned __int8)v105 > 0x7Eu )
        {
          v320 = i + 1;
          v110 = (int)(i + 2);
          goto LABEL_388;
        }
        if ( !v105 )
          break;
      }
      v320 = i + 1 + (v106 - 1) / v109;
      v110 = (int)(v320 + 1);
    }
LABEL_388:
    v322 += v110;
    goto LABEL_389;
  }
  v320 = 0;
LABEL_172:
  v334.m128i_i32[0] = v103;
  if ( v331.m128_i32[0] > v322 )
  {
LABEL_390:
    v54 = -1;
    __writefsdword(0xFFFFFFC0, 0x22u);
    return v54;
  }
  v129 = 4 * v322 + 8;
  v130 = sub_1C780(v129);
  v131 = v334.m128i_i32[0];
  if ( v129 > 0x1000 && !v130 )
  {
    v319 = (__int64 *)sub_21500(v129);
    if ( v319 )
    {
      v313 = 0;
      v131 = v334.m128i_i32[0];
      v317 = 1;
      goto LABEL_176;
    }
    return (unsigned int)-1;
  }
  v313 = 1;
  v317 = 0;
  v132 = alloca(v129 + 8);
  v319 = (__int64 *)&v312;
LABEL_176:
  v133 = v319 + 1;
  if ( v337 && v338 == 102 )
  {
    v277 = (__int64)v319;
    v278 = v328;
    v316 = 0;
    --v339;
    *((_DWORD *)v319 + 2) = 48;
    v137 = (unsigned int *)(v277 + 16);
    *(_DWORD *)(v277 + 12) = v278;
    goto LABEL_185;
  }
  if ( (int)v321 <= 0 )
  {
    v316 = 0;
    v136 = (unsigned int *)(v319 + 1);
  }
  else
  {
    v134 = v319 + 1;
    v135 = (__int64 *)((char *)v319 + 4 * v321 + 8);
    do
    {
      v134 = (__int64 *)((char *)v134 + 4);
      *((_DWORD *)v134 - 1) = sub_7A300((__int64)&v337);
    }
    while ( v134 != v135 );
    v136 = (unsigned int *)v133 + v321;
    v316 = v321;
  }
  if ( (*(_BYTE *)(v333 + 12) & 8) != 0 || (int)v329 > 0 )
  {
LABEL_184:
    v137 = v136 + 1;
    *v136 = v328;
    v131 = 1;
    goto LABEL_185;
  }
  if ( v331.m128_i32[0] <= 0 )
  {
    LODWORD(v325) = 0;
    v137 = v136;
    v138 = 0;
  }
  else
  {
    if ( v341 > 1 || *v340 )
      goto LABEL_184;
    v137 = v136;
    v131 = 1;
LABEL_185:
    v312 = a1;
    v138 = 0;
    LODWORD(v325) = 0;
    v139 = v131;
    v334.m128i_i32[0] = (int)v329;
LABEL_186:
    if ( v334.m128i_i32[0] > v138 )
      goto LABEL_189;
    if ( v331.m128_i32[0] > v138 )
    {
      while ( 2 )
      {
        if ( v341 > 1 || *v340 )
        {
          do
          {
LABEL_189:
            ++v138;
            ++v137;
            v140 = sub_7A300((__int64)&v337);
            *(v137 - 1) = v140;
            if ( !v139 && v140 == 48 )
            {
              ++v331.m128_i32[0];
              if ( (int)v329 > 0 )
              {
                LODWORD(v325) = (_DWORD)v325 + 1;
                v334.m128i_i32[0] = (_DWORD)v325 + (_DWORD)v329;
              }
              goto LABEL_186;
            }
            v139 = 1;
          }
          while ( v334.m128i_i32[0] > v138 );
          if ( v331.m128_i32[0] > v138 )
            continue;
        }
        break;
      }
    }
    a1 = v312;
  }
  v141 = *(v137 - 1);
  if ( v141 == v328 )
    v141 = *(v137 - 2);
  v334.m128i_i32[0] = v141;
  v142 = sub_7A300((__int64)&v337);
  v144 = v142 != 53 && v142 != 48;
  if ( !v144 )
  {
    v145 = v341;
    if ( v341 == 1 )
    {
      v250 = (__int64 *)v340;
      if ( *v340 )
      {
        v145 = 1LL;
        if ( !v343 )
        {
LABEL_408:
          while ( !v250[v145 - 1] )
          {
            if ( !--v145 )
              goto LABEL_200;
          }
        }
LABEL_199:
        v144 = 1;
      }
    }
    else
    {
      if ( v343 )
        goto LABEL_199;
      v250 = (__int64 *)v340;
      if ( v341 )
        goto LABEL_408;
    }
  }
LABEL_200:
  v146 = v335 & 0xC00;
  if ( (v335 & 0xC00) == 2048 )
  {
    if ( !v336 )
    {
LABEL_250:
      if ( v142 > 52 )
        goto LABEL_252;
LABEL_251:
      if ( v144 )
        goto LABEL_252;
    }
LABEL_204:
    v334.m128i_i32[0] = (_DWORD)v325 + (_DWORD)v329;
    goto LABEL_205;
  }
  if ( v146 > 0x800u )
  {
    if ( v146 == 3072 )
      goto LABEL_204;
    goto LABEL_2;
  }
  if ( v146 )
  {
    if ( v146 == 1024 )
    {
      v143 = v336;
      if ( v336 )
        goto LABEL_250;
      goto LABEL_204;
    }
LABEL_2:
    exit();
  }
  if ( v142 <= 52 )
    goto LABEL_204;
  if ( (v334.m128i_i8[0] & 1) == 0 )
    goto LABEL_251;
LABEL_252:
  v170 = *(v137 - 1);
  v171 = (__int64 *)(v137 - 1);
  if ( !v138 )
  {
    v334.m128i_i32[0] = (_DWORD)v325 + (_DWORD)v329;
LABEL_369:
    if ( v170 == v328 )
      v171 = (__int64 *)((char *)v171 - 4);
    if ( v171 < v133 )
      goto LABEL_436;
    while ( *(_DWORD *)v171 == 57 )
    {
      *(_DWORD *)v171 = 48;
      v171 = (__int64 *)((char *)v171 - 4);
      if ( v133 > v171 )
        goto LABEL_436;
    }
    if ( v133 > v171 )
    {
LABEL_436:
      if ( v338 == 102 )
      {
        v291 = (__int64)v319;
        if ( v318 == v316 )
        {
          v302 = v328;
          *(_DWORD *)v319 = 49;
          *(_DWORD *)(v291 + 4) = v302;
          if ( (*(_BYTE *)(v333 + 12) & 8) != 0 || v138 )
          {
            v303 = v316;
            *((_DWORD *)v319 + (int)v316 + 2) = 48;
            v138 += v303 + 1;
          }
          else
          {
            v138 = v318;
          }
          ++v339;
          v133 = v319;
          v304 = *(int *)(v333 + 8);
          v316 = 1;
          v338 = (*(_WORD *)(__readfsqword(0xFFFFFFF8) + 2 * v304) & 0x100) == 0 ? 101 : 69;
        }
        else
        {
          ++v316;
          v133 = (__int64 *)((char *)v319 + 4);
          *((_DWORD *)v319 + 1) = 49;
        }
      }
      else
      {
        v268 = v337 == 0;
        *((_DWORD *)v319 + 2) = 49;
        v339 += v268 ? 1 : -1;
        if ( !v339 )
          v337 = 0;
      }
      v112 = (unsigned int)v318;
      if ( (int)(v138 + v316) > v318 )
      {
        v269 = v138 + v316 - v318;
        v138 = v318 - v316;
        v137 -= v269;
      }
    }
    else
    {
      ++*(_DWORD *)v171;
    }
LABEL_205:
    v147 = v334.m128i_i32[0];
    if ( v334.m128i_i32[0] < v138 )
      goto LABEL_208;
    goto LABEL_209;
  }
  v172 = v328;
  v173 = 0;
  if ( v170 == v328 )
  {
LABEL_475:
    if ( (_DWORD)v329 == v173 )
    {
      v112 = ((int)v325 <= 0) + (unsigned int)v325 - 1;
      LODWORD(v325) = ((int)v325 <= 0) + (_DWORD)v325 - 1;
    }
    goto LABEL_477;
  }
  while ( v170 == 57 )
  {
    *(_DWORD *)v171 = 48;
    v170 = *((_DWORD *)v171 - 1);
    v171 = (__int64 *)((char *)v171 - 4);
    ++v173;
    if ( v170 == v172 )
      goto LABEL_475;
  }
  if ( (_DWORD)v329 == v173
    && (v112 = (unsigned int)v325, (int)v325 > 0)
    && (LODWORD(v325) = (_DWORD)v325 - 1, v170 == v328) )
  {
LABEL_477:
    v174 = *(_DWORD *)v171;
    if ( (_BYTE)v314 == 103
      && v338 == 102
      && (*(_BYTE *)(v333 + 12) & 8) != 0
      && v171 == (__int64 *)((char *)v319 + 12)
      && *((_DWORD *)v319 + 2) == 48 )
    {
      LODWORD(v325) = (_DWORD)v325 - 1;
    }
  }
  else
  {
    v174 = v170 + 1;
    *(_DWORD *)v171 = v174;
  }
  v334.m128i_i32[0] = (_DWORD)v325 + (_DWORD)v329;
  if ( v174 == v328 )
  {
    v170 = *((_DWORD *)v171 - 1);
    v171 = (__int64 *)((char *)v171 - 4);
    goto LABEL_369;
  }
  v147 = v334.m128i_i32[0];
  if ( v138 <= v334.m128i_i32[0] )
    goto LABEL_213;
  do
  {
LABEL_208:
    if ( *(v137 - 1) != 48 )
      break;
    --v138;
    --v137;
  }
  while ( v147 < v138 );
LABEL_209:
  if ( !v138 && (*(_BYTE *)(v333 + 12) & 8) == 0 && *(v137 - 1) == v328 )
    --v137;
LABEL_213:
  v148 = v330;
  if ( v330 )
  {
    v112 = v316;
    LODWORD(v149) = v316;
    if ( v316 == v321 )
      goto LABEL_221;
    v320 = 0;
    v150 = *v330;
    if ( (unsigned __int8)(*v330 - 1) <= 0x7Du )
    {
      v151 = v316;
      v152 = 0;
      do
      {
        v153 = v150;
        if ( v151 > v150 )
        {
          v150 = *++v148;
          ++v152;
          v151 -= v153;
          if ( (unsigned __int8)v150 <= 0x7Eu )
            continue;
        }
        v320 = v152;
        goto LABEL_221;
      }
      while ( v150 );
      v320 = v152 + (v151 - 1) / v153;
LABEL_221:
      v112 = (int)v320;
      if ( v320 )
      {
        v334.m128i_i64[0] = (int)v320;
        v154 = 4 * ((int)v320 + (__int64)(int)v316);
        sub_6CEB0(
          (__int64)v133 + v154,
          (__int64)v133 + 4 * (int)v316,
          ((char *)v137 - ((char *)v133 + 4 * (int)v316)) >> 2);
        v143 = (__int64)v330;
        v155 = (unsigned __int64)v133 + v154 - 4;
        v156 = v327;
        v112 = v334.m128i_i64[0];
        v157 = *v330;
        do
        {
          LODWORD(v158) = v149;
          v159 = v155;
          LODWORD(v149) = v149 - v157;
          do
          {
            v159 -= 4LL;
            v158 = (unsigned int)(v158 - 1);
            *(_DWORD *)(v159 + 4) = *((_DWORD *)v133 + v158);
          }
          while ( (_DWORD)v158 != (_DWORD)v149 );
          v160 = (unsigned int)(v157 - 1);
          v161 = -v160;
          v162 = (unsigned int *)(v155 + 4 * ~v160);
          v155 = v155 + 4 * v161 - 8;
          *v162 = v156;
          v163 = *(_BYTE *)(v143 + 1);
          if ( v163 > 0x7Eu )
            break;
          if ( v163 )
            ++v143;
          else
            v163 = *(_BYTE *)v143;
          v157 = (char)v163;
        }
        while ( (char)v163 < (unsigned int)v149 );
        do
        {
          v155 -= 4LL;
          v149 = (unsigned int)(v149 - 1);
          *(_DWORD *)(v155 + 4) = *((_DWORD *)v133 + v149);
        }
        while ( v155 > (unsigned __int64)v133 );
        v137 += v112;
      }
    }
  }
  v111 = v338;
  if ( v338 != 102 )
  {
    v112 = v337;
    v164 = v339;
    if ( !v337 )
    {
      *v137 = v338;
      v111 = 43LL;
      goto LABEL_234;
    }
    if ( (_BYTE)v314 == 103 && v339 == 4 )
    {
      sub_6CEA0(v133, "0", 6LL);
      *((_DWORD *)v133 + 1) = v328;
      if ( v133 + 1 <= (__int64 *)v137 )
      {
        v307 = v137;
        v137 += 4;
        sub_91C0(v133 + 3, 48LL, ((char *)v307 - (char *)(v133 + 1)) >> 2);
      }
      else
      {
        v137 += 5;
      }
    }
    else
    {
      *v137 = v338;
      v111 = 45LL;
LABEL_234:
      v137[1] = v111;
      v165 = v137 + 2;
      if ( v164 <= 9 )
      {
        v137[2] = 48;
        v165 = v137 + 3;
      }
      else
      {
        LODWORD(v112) = 10;
        do
          LODWORD(v112) = 10 * v112;
        while ( (int)v112 <= v164 );
        do
        {
          ++v165;
          v166 = v112;
          v112 = (unsigned int)((int)v112 / 10);
          v111 = (unsigned int)(v164 >> 31);
          LODWORD(v111) = v164 % (int)v112;
          *(v165 - 1) = v164 / (int)v112 + 48;
          v164 %= (int)v112;
        }
        while ( v166 > 109 );
        v339 = v111;
      }
      v137 = v165 + 1;
      *v165 = v164 + 48;
    }
  }
  v167 = v336;
  v168 = (char *)v137 - (char *)v133;
  v169 = *(_BYTE *)(v333 + 12);
  if ( v336 || (v169 & 0x50) != 0 )
  {
    v111 = v168 >> 2;
    v112 = v315 - 1 - (unsigned int)(v168 >> 2);
    v334.m128i_i32[0] = v315 - 1 - (v168 >> 2);
    if ( (v169 & 0x20) == 0 )
    {
      v113 = *(_DWORD *)(v333 + 16);
      if ( (int)v112 > 0 && v113 != 48 )
        goto LABEL_412;
    }
    v114 = 0;
LABEL_146:
    if ( !v167 )
    {
      v169 = *(_BYTE *)(v333 + 12);
      goto LABEL_276;
    }
    if ( (_DWORD)v332 )
    {
      v115 = a1[20];
      if ( !v115 || (v111 = *(_QWORD *)(v115 + 32), v111 >= *(_QWORD *)(v115 + 40)) )
      {
        v331.m128_i32[0] = v114;
        v116 = 45;
        goto LABEL_151;
      }
      *(_QWORD *)(v115 + 32) = v111 + 4;
      *(_DWORD *)v111 = 45;
      goto LABEL_321;
    }
    v213 = (_BYTE *)a1[5];
    if ( (unsigned __int64)v213 < a1[6] )
    {
      v111 = (unsigned __int64)(v213 + 1);
      a1[5] = v213 + 1;
      *v213 = 45;
      goto LABEL_321;
    }
    v331.m128_i32[0] = v114;
    v300 = 45;
    goto LABEL_532;
  }
  v334.m128i_i32[0] = v315 - (v168 >> 2);
  if ( (v169 & 0x20) == 0 )
  {
    v113 = *(_DWORD *)(v333 + 16);
    if ( v334.m128i_i32[0] > 0 && v113 != 48 )
    {
LABEL_412:
      v251 = v334.m128i_i32[0];
      if ( (_DWORD)v332 )
        v252 = sub_6A3E0(
                 (__int64)a1,
                 v113,
                 v334.m128i_i32[0],
                 *(double *)a4.m128i_i64,
                 *(double *)a5.m128_u64,
                 *(double *)a6.m128i_i64,
                 a7,
                 v118,
                 v119,
                 a10,
                 a11);
      else
        v252 = sub_6A2A0(
                 (__int64)a1,
                 v113,
                 v334.m128i_i32[0],
                 *(double *)a4.m128i_i64,
                 *(double *)a5.m128_u64,
                 *(double *)a6.m128i_i64,
                 a7,
                 v118,
                 v119,
                 a10,
                 a11);
      if ( v252 == v251 )
      {
        v167 = v336;
        v114 = v334.m128i_i32[0];
        goto LABEL_146;
      }
LABEL_153:
      if ( !v313 )
LABEL_154:
        sub_21B70(v319);
      return (unsigned int)-1;
    }
  }
  v114 = 0;
LABEL_276:
  v177 = v169;
  if ( (v169 & 0x40) == 0 )
  {
    if ( (v169 & 0x10) == 0 )
      goto LABEL_322;
    v143 = (unsigned int)v332;
    if ( (_DWORD)v332 )
    {
      v212 = a1[20];
      if ( !v212 || (v111 = *(_QWORD *)(v212 + 32), v111 >= *(_QWORD *)(v212 + 40)) )
      {
        v331.m128_i32[0] = v114;
        v116 = 32;
        goto LABEL_151;
      }
      *(_QWORD *)(v212 + 32) = v111 + 4;
      *(_DWORD *)v111 = 32;
      goto LABEL_321;
    }
    v290 = (_BYTE *)a1[5];
    if ( (unsigned __int64)v290 < a1[6] )
    {
      v111 = (unsigned __int64)(v290 + 1);
      a1[5] = v290 + 1;
      *v290 = 32;
      goto LABEL_321;
    }
    v331.m128_i32[0] = v114;
    v300 = 32;
LABEL_532:
    v301 = sub_1A150(
             (__int64)a1,
             v300,
             *(double *)a4.m128i_i64,
             *(double *)a5.m128_u64,
             *(double *)a6.m128i_i64,
             a7,
             v118,
             v119,
             a10,
             a11);
    v114 = v331.m128_i32[0];
    v120 = v301 == -1;
    goto LABEL_152;
  }
  if ( !(_DWORD)v332 )
  {
    v260 = (_BYTE *)a1[5];
    if ( (unsigned __int64)v260 < a1[6] )
    {
      v111 = (unsigned __int64)(v260 + 1);
      a1[5] = v260 + 1;
      *v260 = 43;
      goto LABEL_321;
    }
    v331.m128_i32[0] = v114;
    v300 = 43;
    goto LABEL_532;
  }
  v178 = a1[20];
  if ( v178 )
  {
    v111 = *(_QWORD *)(v178 + 32);
    if ( v111 < *(_QWORD *)(v178 + 40) )
    {
      *(_QWORD *)(v178 + 32) = v111 + 4;
      *(_DWORD *)v111 = 43;
      goto LABEL_321;
    }
  }
  v331.m128_i32[0] = v114;
  v116 = 43;
LABEL_151:
  v117 = sub_6AB50(
           (__int64)a1,
           v116,
           v111,
           v112,
           (u32 *)v143,
           v114,
           *(double *)a4.m128i_i64,
           *(double *)a5.m128_u64,
           *(double *)a6.m128i_i64,
           a7,
           v118,
           v119,
           a10,
           a11);
  v114 = v331.m128_i32[0];
  v120 = v117 == -1;
LABEL_152:
  if ( v120 )
    goto LABEL_153;
LABEL_321:
  ++v114;
  v177 = *(_BYTE *)(v333 + 12);
LABEL_322:
  if ( (v177 & 0x20) == 0 && *(_DWORD *)(v333 + 16) == 48 && v334.m128i_i32[0] > 0 )
  {
    v261 = v334.m128i_i32[0];
    v331.m128_i32[0] = v114;
    if ( (_DWORD)v332 )
      v262 = sub_6A3E0(
               (__int64)a1,
               48,
               v334.m128i_i32[0],
               *(double *)a4.m128i_i64,
               *(double *)a5.m128_u64,
               *(double *)a6.m128i_i64,
               a7,
               v118,
               v119,
               a10,
               a11);
    else
      v262 = sub_6A2A0(
               (__int64)a1,
               48,
               v334.m128i_i32[0],
               *(double *)a4.m128i_i64,
               *(double *)a5.m128_u64,
               *(double *)a6.m128i_i64,
               a7,
               v118,
               v119,
               a10,
               a11);
    if ( v262 != v261 )
      goto LABEL_153;
    v114 = v334.m128i_i32[0] + v331.m128_i32[0];
  }
  v214 = (unsigned int)v332;
  if ( (_DWORD)v332 )
  {
    if ( (*(_BYTE *)(v333 + 13) & 8) != 0 )
    {
      v331.m128_i32[0] = v114;
      sub_7A450(
        0LL,
        0LL,
        0LL,
        *(double *)a4.m128i_i64,
        *(double *)a5.m128_u64,
        *(double *)a6.m128i_i64,
        a7,
        v118,
        v119,
        a10,
        a11);
      v114 = v331.m128_i32[0];
    }
    v235 = v168 >> 2;
    v228 = (u32 *)v235;
    if ( v137 == (unsigned int *)v133 )
    {
      if ( v235 )
      {
        v236 = (__int64)a1;
        v237 = v235 + 1;
        v238 = v114;
        do
        {
          v240 = *(_QWORD *)(v236 + 160);
          v133 = (__int64 *)((char *)v133 + 4);
          v241 = *((_DWORD *)v133 - 1);
          if ( v240 && (v111 = *(_QWORD *)(v240 + 32), v111 < *(_QWORD *)(v240 + 40)) )
          {
            v214 = v111 + 4;
            *(_QWORD *)(v240 + 32) = v111 + 4;
            v239 = v241 == -1;
            *(_DWORD *)v111 = v241;
          }
          else
          {
            v331.m128_u64[0] = v236;
            v242 = sub_6AB50(
                     v236,
                     v241,
                     v111,
                     v214,
                     v228,
                     v114,
                     *(double *)a4.m128i_i64,
                     *(double *)a5.m128_u64,
                     *(double *)a6.m128i_i64,
                     a7,
                     v118,
                     v119,
                     a10,
                     a11);
            v236 = v331.m128_u64[0];
            v239 = v242 == -1;
          }
          if ( v239 )
            goto LABEL_153;
          v54 = v237 + v238 - v235--;
        }
        while ( v235 );
        v331.m128_u64[0] = 0LL;
        a1 = (_QWORD *)v236;
      }
      else
      {
        v331.m128_u64[0] = 0LL;
        v54 = v114;
      }
LABEL_346:
      if ( v317 )
      {
        sub_21B70(v331.m128_u64[0]);
        sub_21B70(v319);
        v331.m128_u64[0] = 0LL;
        v319 = 0LL;
      }
      if ( (*(_BYTE *)(v333 + 12) & 0x20) == 0 || v334.m128i_i32[0] <= 0 )
        return v54;
      v232 = v334.m128i_i32[0];
      v233 = *(_DWORD *)(v333 + 16);
      if ( (_DWORD)v332 )
        v234 = sub_6A3E0(
                 (__int64)a1,
                 v233,
                 v334.m128i_i32[0],
                 *(double *)a4.m128i_i64,
                 *(double *)a5.m128_u64,
                 *(double *)a6.m128i_i64,
                 a7,
                 v118,
                 v119,
                 a10,
                 a11);
      else
        v234 = sub_6A2A0(
                 (__int64)a1,
                 v233,
                 v334.m128i_i32[0],
                 *(double *)a4.m128i_i64,
                 *(double *)a5.m128_u64,
                 *(double *)a6.m128i_i64,
                 a7,
                 v118,
                 v119,
                 a10,
                 a11);
      if ( v234 == v232 )
      {
        v54 += v334.m128i_i32[0];
        return v54;
      }
    }
    else
    {
      v243 = a1[27];
      if ( (char *)&off_C0308 - (char *)&unk_BFAE0 <= (unsigned __int64)(v243 - (_QWORD)&unk_BFAE0) )
      {
        v329 = v228;
        LODWORD(v330) = v114;
        sub_17140(*(double *)a4.m128i_i64, *(double *)a5.m128_u64, *(double *)a6.m128i_i64, a7, v118, v119, a10, a11);
        v230 = *(__int64 (__fastcall **)(_QWORD *, __int64 *, u32 *))(v243 + 56);
        v331.m128_u64[0] = 0LL;
        v114 = (unsigned int)v330;
        v228 = v329;
      }
      else
      {
        v331.m128_u64[0] = 0LL;
        v230 = *(__int64 (__fastcall **)(_QWORD *, __int64 *, u32 *))(v243 + 56);
      }
LABEL_344:
      LODWORD(v329) = v114;
      v330 = (__int8 *)v228;
      v231 = v230(a1, v133, v228);
      if ( (__int8 *)v231 == v330 )
      {
        v54 = (_DWORD)v329 + (_DWORD)v330;
        goto LABEL_346;
      }
    }
    if ( !v313 )
    {
      sub_21B70(v331.m128_u64[0]);
      goto LABEL_154;
    }
    return (unsigned int)-1;
  }
  if ( (*(_BYTE *)(v333 + 13) & 8) != 0 )
    v322 *= *(unsigned int *)(*v326 + 168LL);
  v331.m128_i32[0] = v114;
  v215 = strlen(v324);
  v114 = v331.m128_i32[0];
  v216 = v215;
  if ( v323 )
  {
    v217 = strlen((__int64)v323);
    v114 = v331.m128_i32[0];
    v218 = (__int8 *)v217;
    v219 = v217 * (int)v320;
  }
  else
  {
    v219 = 0LL;
    v218 = 0LL;
  }
  v329 = (u32 *)(v219 + v322 + v216 + 2);
  if ( v317 )
  {
    LODWORD(v330) = v114;
    v292 = sub_21500(v219 + v322 + v216 + 2);
    v114 = (unsigned int)v330;
    v331.m128_u64[0] = v292;
    if ( !v292 )
      goto LABEL_154;
  }
  else
  {
    v220 = alloca((signed __int64)(v329 + 2));
    v331.m128_u64[0] = (unsigned __int64)&v312;
  }
  if ( v137 <= (unsigned int *)v133 )
  {
    if ( (*(_BYTE *)(v333 + 13) & 8) != 0 )
    {
      v221 = (__int64 *)v331.m128_u64[0];
      goto LABEL_515;
    }
    goto LABEL_510;
  }
  v330 = v218;
  v221 = (__int64 *)v331.m128_u64[0];
  v222 = v216;
  v325 = a1;
  v223 = v328;
  v224 = v137;
  v225 = v133;
  LODWORD(v326) = v114;
  v226 = v327;
  do
  {
    while ( 1 )
    {
      v227 = *(_DWORD *)v225;
      if ( *(_DWORD *)v225 != v223 )
        break;
      v225 = (__int64 *)((char *)v225 + 4);
      v221 = (__int64 *)sub_91D0(v221, v324, v222);
      if ( v224 <= (unsigned int *)v225 )
        goto LABEL_339;
    }
    if ( v226 == v227 )
    {
      v221 = (__int64 *)sub_91D0(v221, v323, v330);
    }
    else
    {
      *(_BYTE *)v221 = v227;
      v221 = (__int64 *)((char *)v221 + 1);
    }
    v225 = (__int64 *)((char *)v225 + 4);
  }
  while ( v224 > (unsigned int *)v225 );
LABEL_339:
  v114 = (unsigned int)v326;
  a1 = v325;
  if ( (*(_BYTE *)(v333 + 13) & 8) == 0 )
  {
    v133 = (__int64 *)v331.m128_u64[0];
    goto LABEL_341;
  }
LABEL_515:
  LODWORD(v330) = v114;
  v293 = (__int64 *)((char *)v329 + v331.m128_u64[0]);
  v294 = sub_7A450(
           v331.m128_i64[0],
           (__int64)v221,
           (u32 *)((char *)v329 + v331.m128_u64[0]),
           *(double *)a4.m128i_i64,
           *(double *)a5.m128_u64,
           *(double *)a6.m128i_i64,
           a7,
           v118,
           v119,
           a10,
           a11);
  v114 = (unsigned int)v330;
  v221 = v293;
  v133 = v294;
LABEL_341:
  v228 = (u32 *)((char *)v221 - (char *)v133);
  if ( (char *)v221 - (char *)v133 > 20 )
  {
    v229 = a1[27];
    if ( v229 - (__int64)&unk_BFAE0 >= (unsigned __int64)((char *)&off_C0308 - (char *)&unk_BFAE0) )
    {
      v329 = (u32 *)((char *)v221 - (char *)v133);
      LODWORD(v330) = v114;
      sub_17140(*(double *)a4.m128i_i64, *(double *)a5.m128_u64, *(double *)a6.m128i_i64, a7, v118, v119, a10, a11);
      v230 = *(__int64 (__fastcall **)(_QWORD *, __int64 *, u32 *))(v229 + 56);
      v114 = (unsigned int)v330;
      v228 = v329;
    }
    else
    {
      v230 = *(__int64 (__fastcall **)(_QWORD *, __int64 *, u32 *))(v229 + 56);
    }
    goto LABEL_344;
  }
  v244 = v133;
  v245 = v114;
  if ( v221 == v133 )
  {
LABEL_510:
    v54 = v114;
    goto LABEL_346;
  }
  while ( 2 )
  {
    v244 = (__int64 *)((char *)v244 + 1);
    v246 = (unsigned __int8 *)a1[5];
    v247 = *((_BYTE *)v244 - 1);
    if ( (unsigned __int64)v246 < a1[6] )
    {
      a1[5] = v246 + 1;
      *v246 = v247;
      goto LABEL_382;
    }
    if ( (unsigned int)sub_1A150(
                         (__int64)a1,
                         v247,
                         *(double *)a4.m128i_i64,
                         *(double *)a5.m128_u64,
                         *(double *)a6.m128i_i64,
                         a7,
                         v118,
                         v119,
                         a10,
                         a11) != -1 )
    {
LABEL_382:
      if ( v221 == v244 )
      {
        v54 = v245 + (_DWORD)v244 - (_DWORD)v133;
        goto LABEL_346;
      }
      continue;
    }
    break;
  }
  v54 = -1;
  if ( v313 )
    return (unsigned int)-1;
  sub_21B70(v331.m128_u64[0]);
  sub_21B70(v319);
  return v54;
}
// 7AB13: variable 'a8' is possibly undefined
// 7AB13: variable 'a9' is possibly undefined
// 7B2C5: variable 'v111' is possibly undefined
// 7B2C5: variable 'v112' is possibly undefined
// 7B2C5: variable 'v143' is possibly undefined
// 7B2C5: variable 'v118' is possibly undefined
// 7B2C5: variable 'v119' is possibly undefined
// 7B3D1: variable 'v27' is possibly undefined
// 7B3D1: variable 'v308' is possibly undefined
// 7B3D1: variable 'a14' is possibly undefined
// 7C26E: variable 'v214' is possibly undefined
// 7C26E: variable 'v228' is possibly undefined
// 7C26E: variable 'v114' is possibly undefined
// 91C0: using guessed type __int64 __fastcall sub_91C0(_QWORD, _QWORD, _QWORD);
// 91D0: using guessed type __int64 __fastcall sub_91D0(_QWORD, _QWORD, _QWORD);
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// A7C60: using guessed type __int128 xmmword_A7C60;
// A7C70: using guessed type __int128 xmmword_A7C70;
// C0308: using guessed type void *off_C0308;

//----- (000000000007D370) ----------------------------------------------------
__int64 __fastcall sub_7D370(_QWORD *a1, unsigned __int64 a2, const __m128i **a3, __m128 a4, __m128 a5, __m128 a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, u32 *a13)
{
  _QWORD *v14; // rbp
  unsigned __int64 v15; // rbx
  char v16; // al
  __int64 v17; // rdx
  _BYTE *v18; // r13
  const __m128i *v19; // rcx
  __int64 v20; // r12
  unsigned __int64 v21; // rax
  int v22; // er9
  signed __int64 v23; // rax
  __int64 v24; // r14
  char *v25; // r15
  int v26; // ecx
  char *v27; // r12
  __int64 v28; // rax
  int v29; // ecx
  int v30; // er9
  char *v31; // r8
  char *v32; // r10
  const char *v33; // rsi
  unsigned __int64 v34; // rax
  unsigned __int64 v35; // rdx
  __int64 v36; // rax
  unsigned __int64 v37; // rdx
  __int64 v38; // rdi
  __int64 v39; // r8
  __int64 v40; // rsi
  __int64 v41; // rax
  __m128i v42; // xmm4
  __int64 v43; // rax
  unsigned __int64 v44; // r11
  const char *v45; // rcx
  __int32 v46; // er9
  char *v47; // r8
  unsigned __int64 v48; // rax
  unsigned __int64 v49; // rdx
  __int64 v50; // rax
  unsigned __int64 v51; // rdx
  __int64 v52; // r8
  unsigned __int64 v53; // rcx
  __int64 v54; // rsi
  __int64 v55; // rax
  __int64 v56; // r14
  __int32 v57; // eax
  int v58; // er11
  unsigned __int64 v59; // r14
  int v60; // eax
  __int64 v61; // rax
  double v62; // xmm4_8
  double v63; // xmm5_8
  u32 v64; // er9
  u32 *v65; // r8
  char *v66; // rcx
  unsigned __int64 v67; // rdx
  unsigned __int64 v68; // rax
  char v69; // r14
  int v70; // eax
  unsigned __int32 v71; // er12
  int v72; // eax
  __int64 v73; // r12
  __int64 v74; // rax
  int v75; // er14
  __int64 v76; // rax
  __int64 v77; // rax
  _DWORD *v78; // rsi
  unsigned __int64 v79; // rdi
  unsigned __int64 v80; // rdx
  unsigned int v81; // esi
  bool v82; // al
  int v83; // er14
  __int64 v84; // rax
  int v85; // esi
  bool v86; // al
  int v87; // er14
  _BYTE *v88; // r12
  __int64 v89; // rax
  int v90; // edx
  int v91; // ebx
  _BYTE *v92; // r13
  _BYTE *v93; // rax
  unsigned int v94; // esi
  u32 v95; // er12
  unsigned __int64 v96; // rdx
  __int16 v98; // fps
  const char *v102; // r14
  bool v103; // zf
  const char *v104; // r12
  char v105; // al
  int v106; // er15
  int v107; // er13
  _BYTE *v108; // rax
  const char *v109; // r13
  u32 v110; // er14
  __int64 v111; // rax
  unsigned int v112; // esi
  bool v113; // al
  __int64 v114; // rbx
  __int64 v115; // rax
  u32 v116; // er9
  __int64 v118; // rdx
  __int64 v119; // rax
  __int64 v120; // rax
  int v121; // er10
  const char *v122; // rcx
  bool v123; // zf
  unsigned __int64 v124; // rax
  char *v125; // r8
  unsigned __int64 v126; // rdx
  __int64 v127; // rax
  char *v128; // rax
  unsigned __int64 v129; // rdx
  bool v130; // zf
  int v131; // eax
  int v132; // ecx
  __int64 v133; // rax
  char *v134; // rcx
  _BYTE *v135; // r10
  const char *v136; // rsi
  unsigned __int64 v137; // rax
  unsigned __int64 v138; // rdx
  __int64 v139; // rax
  char *v140; // r8
  unsigned __int64 v141; // rdx
  __int64 v142; // rdi
  __int64 v143; // rcx
  __int64 v144; // rsi
  __int64 v145; // rax
  __int32 v146; // eax
  __int64 v147; // rax
  const char *v148; // rcx
  const char *v149; // r13
  _BYTE *v150; // rax
  unsigned int v151; // esi
  __int64 v152; // rax
  int v153; // eax
  _BYTE *v154; // rax
  __int32 v155; // eax
  char *v156; // rax
  char v157; // dl
  int v158; // ecx
  unsigned __int8 v159; // si
  int v160; // edx
  _BOOL4 v161; // ecx
  __int16 v162; // ax
  int v163; // edx
  char *v164; // rax
  char *v165; // r10
  char *v166; // rcx
  char v167; // si
  int v168; // edx
  _BYTE *v169; // rax
  char v170; // al
  __int64 v171; // rax
  _BYTE *v172; // rax
  _BYTE *v173; // rax
  _BYTE *v174; // rax
  char v175; // di
  unsigned int v176; // esi
  __int64 v177; // rax
  bool v178; // al
  u32 v179; // er9
  unsigned int v180; // esi
  __int64 v181; // rax
  char *v182; // r14
  char *v183; // r13
  bool v184; // al
  bool v185; // cf
  __int64 v186; // rax
  unsigned int v187; // esi
  _DWORD *v188; // rax
  int v189; // edi
  int v190; // er13
  char *v191; // r12
  char *v192; // r13
  __int64 v193; // rbx
  int v194; // ebp
  int v195; // er15
  u32 *v196; // r14
  bool v197; // al
  int v198; // eax
  __int64 v199; // rax
  unsigned int v200; // esi
  int v201; // eax
  int v202; // esi
  __int64 v203; // rbx
  __int64 v204; // rax
  unsigned __int64 v205; // r14
  __int64 v206; // r15
  __int64 v207; // r12
  char *v208; // r13
  int v209; // er12
  __int64 v210; // rbx
  unsigned __int64 v211; // r15
  int v212; // eax
  _BYTE *v213; // rax
  unsigned int v214; // esi
  _BYTE *v215; // rax
  _BYTE *v216; // rax
  u32 v217; // er15
  __int64 v218; // r13
  char *v219; // r14
  u32 v220; // ebx
  __int32 v221; // er15
  _BYTE *v222; // rax
  unsigned int v223; // esi
  _BYTE *v224; // rax
  __int64 v225; // rax
  __int64 v226; // rax
  bool v227; // zf
  _BYTE *v228; // rax
  int v229; // edx
  bool v230; // al
  __int64 v231; // r12
  __int64 v232; // rax
  int v233; // eax
  int v234; // eax
  bool v235; // al
  int v236; // eax
  _BYTE *v237; // rax
  int v238; // eax
  int v239; // eax
  unsigned int v240; // esi
  int v241; // eax
  bool v242; // al
  int v243; // eax
  int v244; // eax
  int v245; // eax
  unsigned int v246; // esi
  int v247; // eax
  bool v248; // al
  int v249; // eax
  unsigned int v250; // esi
  int v251; // eax
  unsigned int v252; // esi
  int v253; // eax
  int v254; // [rsp+8h] [rbp-1A0h]
  int v255; // [rsp+8h] [rbp-1A0h]
  const char *v256; // [rsp+8h] [rbp-1A0h]
  __int64 v257; // [rsp+8h] [rbp-1A0h]
  unsigned __int64 v258; // [rsp+8h] [rbp-1A0h]
  char *v259; // [rsp+8h] [rbp-1A0h]
  char *v260; // [rsp+8h] [rbp-1A0h]
  char *v261; // [rsp+8h] [rbp-1A0h]
  char *v262; // [rsp+8h] [rbp-1A0h]
  int v263; // [rsp+8h] [rbp-1A0h]
  char *v264; // [rsp+8h] [rbp-1A0h]
  int v265; // [rsp+8h] [rbp-1A0h]
  __m128 v266; // [rsp+10h] [rbp-198h] BYREF
  char *v267; // [rsp+20h] [rbp-188h]
  _BOOL4 v268; // [rsp+28h] [rbp-180h]
  int v269; // [rsp+2Ch] [rbp-17Ch]
  __m128i v270; // [rsp+30h] [rbp-178h] BYREF
  unsigned __int64 v271; // [rsp+40h] [rbp-168h]
  char *v272; // [rsp+48h] [rbp-160h]
  char *v273; // [rsp+50h] [rbp-158h]
  char *v274; // [rsp+58h] [rbp-150h]
  u32 *v275; // [rsp+60h] [rbp-148h]
  u32 *v276; // [rsp+68h] [rbp-140h]
  __int16 v277; // [rsp+7Eh] [rbp-12Ah]
  long double v278; // [rsp+80h] [rbp-128h]
  char v279; // [rsp+A4h] [rbp-104h] BYREF
  _DWORD v280[12]; // [rsp+FCh] [rbp-ACh] BYREF
  int v281; // [rsp+12Ch] [rbp-7Ch]
  char v282[16]; // [rsp+130h] [rbp-78h] BYREF
  char v283[4]; // [rsp+140h] [rbp-68h] BYREF
  char v284[12]; // [rsp+144h] [rbp-64h] BYREF
  char v285[16]; // [rsp+150h] [rbp-58h] BYREF
  char v286[8]; // [rsp+160h] [rbp-48h] BYREF
  unsigned __int64 v287; // [rsp+168h] [rbp-40h]

  v14 = a1;
  v15 = a2;
  v287 = __readfsqword(0x28u);
  v254 = *(_DWORD *)a2;
  v269 = *(_DWORD *)(a2 + 4);
  v16 = *(_BYTE *)(a2 + 13);
  v268 = (v16 & 4) != 0;
  if ( (v16 & 1) != 0 )
  {
    v118 = *(_QWORD *)__readfsqword(0xFFFFFFB8);
    v18 = *(_BYTE **)(v118 + 80);
    LODWORD(v267) = *(_DWORD *)(v118 + 408);
  }
  else
  {
    v17 = *(_QWORD *)__readfsqword(0xFFFFFFB0);
    v18 = *(_BYTE **)(v17 + 64);
    LODWORD(v267) = *(_DWORD *)(v17 + 88);
  }
  if ( !*v18 || !(_DWORD)v267 )
    sub_CF00("*decimal != '\\0' && decimalwc != L'\\0'", "../stdio-common/printf_fphex.c", 165LL, "__printf_fphex");
  v19 = *a3;
  v20 = *(int *)(a2 + 8);
  if ( (v16 & 0x10) != 0 )
  {
    a6 = (__m128)_mm_load_si128(v19);
    a5.m128_u64[0] = a6.m128_u64[0];
    a4.m128_u64[0] = a6.m128_u64[0];
    v266 = a6;
    if ( sub_87E90(a6, a6) )
    {
      a10 = *(double *)v266.m128_u64;
      v102 = "NAN";
      v22 = _mm_movemask_ps(v266) & 8;
      v227 = (*(_BYTE *)(__readfsqword(0xFFFFFFF8) + 2 * v20 + 1) & 1) == 0;
      v104 = "N";
      if ( v227 )
        v104 = "n";
      if ( v227 )
        v102 = "nan";
    }
    else
    {
      a7 = *(double *)v266.m128_u64;
      a5 = (__m128)_mm_load_si128((const __m128i *)&xmmword_A7C70);
      a4 = (__m128)_mm_and_si128(_mm_load_si128((const __m128i *)&v266), (__m128i)xmmword_A7C60);
      v270 = (__m128i)a4;
      LODWORD(v271) = _mm_movemask_ps(v266) & 8;
      v21 = sub_87E90(a4, a5);
      v22 = v271;
      if ( v21
        || (a5 = (__m128)_mm_load_si128((const __m128i *)&xmmword_A7C70),
            a4 = (__m128)_mm_load_si128(&v270),
            v23 = sub_880A0(a4, a5),
            v22 = v271,
            v23 <= 0) )
      {
        v24 = v266.m128_u64[0];
        v25 = v286;
        LODWORD(v271) = v22;
        v26 = v20 == 65;
        v270.m128i_i64[0] = v266.m128_i64[1];
        v27 = v282;
        v28 = sub_7A1B0(v266.m128_u64[0], (__int64)v286, 0x10u, v26);
        v29 = *(_DWORD *)(a2 + 8);
        v30 = v271;
        v31 = v282;
        v32 = (char *)v28;
        v33 = "0";
        if ( v29 == 65 )
          v33 = "0";
        v34 = v24;
        do
        {
          v31 -= 4;
          *(_DWORD *)v31 = *(_DWORD *)&v33[4 * (v34 & 0xF)];
          v35 = v34;
          v34 >>= 4;
        }
        while ( v35 > 0xF );
        if ( v32 > v285 )
        {
          v275 = (u32 *)v31;
          LODWORD(v274) = v30;
          LODWORD(v273) = v29;
          v272 = v32;
          v271 = v32 - v285;
          v36 = sub_9190((__int64)v285, 48LL, v32 - v285);
          v29 = (int)v273;
          v30 = (int)v274;
          v37 = v271;
          v38 = v36;
          v39 = (__int64)v275;
          v40 = v36 - (_QWORD)v272;
          v41 = 0LL;
          do
            *(_DWORD *)(v39 + 4 * v41-- - 4) = 48;
          while ( v40 != v41 );
          v32 = (char *)v38;
          v31 = (char *)(v39 - 4 * v37);
        }
        v42 = _mm_load_si128((const __m128i *)&v266);
        v274 = v31;
        LODWORD(v273) = v30;
        v272 = (char *)(v266.m128_u32[2] | ((unsigned __int64)(unsigned int)_mm_extract_epi16(v42, 6) << 32));
        v43 = sub_7A1B0((unsigned __int64)v272, (__int64)v32, 0x10u, v29 == 65);
        v44 = (unsigned __int64)v272;
        v103 = *(_DWORD *)(v15 + 8) == 65;
        v45 = "0";
        v46 = (int)v273;
        v47 = v274;
        v271 = v43;
        if ( !v103 )
          v45 = "0";
        v48 = (unsigned __int64)v272;
        do
        {
          v47 -= 4;
          *(_DWORD *)v47 = *(_DWORD *)&v45[4 * (v48 & 0xF)];
          v49 = v48;
          v48 >>= 4;
        }
        while ( v49 > 0xF );
        if ( v271 > (unsigned __int64)v284 )
        {
          v275 = (u32 *)v44;
          v274 = v47;
          LODWORD(v273) = v46;
          v272 = (char *)(v271 - (_QWORD)v284);
          v50 = sub_9190((__int64)v284, 48LL, v271 - (_QWORD)v284);
          v51 = (unsigned __int64)v272;
          v46 = (int)v273;
          v52 = (__int64)v274;
          v44 = (unsigned __int64)v275;
          v53 = v50;
          v54 = v50 - v271;
          v55 = 0LL;
          do
            *(_DWORD *)(v52 + 4 * v55-- - 4) = 48;
          while ( v54 != v55 );
          v271 = v53;
          v47 = (char *)(v52 - 4 * v51);
        }
        v56 = v44 | v24;
        LOBYTE(v272) = 48 - (((_mm_extract_epi16(_mm_load_si128((const __m128i *)&v266), 7) & 0x7FFF) == 0) - 1);
        v266.m128_i32[0] = v270.m128i_i16[3] & 0x7FFF;
        if ( v266.m128_i32[0] )
        {
          v57 = v266.m128_i32[0];
          if ( v266.m128_i32[0] <= 16382 )
          {
            v58 = 0x3FFF - v266.m128_i32[0];
            v266.m128_i32[0] = 1;
          }
          else
          {
            v266.m128_i32[0] = 0;
            v58 = v57 - 0x3FFF;
          }
        }
        else
        {
          v58 = v56 != 0 ? 0x3FFE : 0;
          v266.m128_i32[0] = v56 != 0;
        }
        goto LABEL_28;
      }
      v102 = "INF";
      v130 = (*(_BYTE *)(__readfsqword(0xFFFFFFF8) + 2 * v20 + 1) & 1) == 0;
      v104 = "I";
      if ( v130 )
        v104 = "i";
      if ( v130 )
        v102 = "inf";
    }
    v96 = *(unsigned __int8 *)(a2 + 12);
LABEL_83:
    v105 = v96 & 0x20;
    if ( v22 )
    {
      v106 = v269 - 4;
      if ( v105 || v106 <= 0 )
      {
        v107 = 0;
        if ( !v268 )
        {
LABEL_86:
          v108 = (_BYTE *)a1[5];
          if ( (unsigned __int64)v108 < a1[6] )
          {
            v96 = (unsigned __int64)(v108 + 1);
            a1[5] = v108 + 1;
            *v108 = 45;
LABEL_88:
            v22 = v107 + 1;
            goto LABEL_89;
          }
          v230 = (unsigned int)sub_1A150(
                                 (__int64)a1,
                                 0x2Du,
                                 *(double *)a4.m128_u64,
                                 *(double *)a5.m128_u64,
                                 *(double *)a6.m128_u64,
                                 a7,
                                 a8,
                                 a9,
                                 a10,
                                 a11) == -1;
          goto LABEL_317;
        }
LABEL_111:
        v120 = a1[20];
        if ( v120 )
        {
          v96 = *(_QWORD *)(v120 + 32);
          if ( v96 < *(_QWORD *)(v120 + 40) )
          {
            v19 = (const __m128i *)(v96 + 4);
            *(_QWORD *)(v120 + 32) = v96 + 4;
            *(_DWORD *)v96 = 45;
            goto LABEL_88;
          }
        }
        v230 = (unsigned int)sub_6AB50(
                               (__int64)a1,
                               0x2Du,
                               v96,
                               (__int64)v19,
                               a13,
                               v22,
                               *(double *)a4.m128_u64,
                               *(double *)a5.m128_u64,
                               *(double *)a6.m128_u64,
                               a7,
                               a8,
                               a9,
                               a10,
                               a11) == -1;
LABEL_317:
        if ( v230 )
          return (u32)-1;
        goto LABEL_88;
      }
    }
    else if ( (v96 & 0x50) != 0 )
    {
      v106 = v269 - 4;
      if ( v105 )
        goto LABEL_149;
      if ( v106 <= 0 )
      {
        v131 = v269 - 4;
        v106 = 0;
LABEL_148:
        v22 = v106;
        v106 = v131;
        goto LABEL_149;
      }
    }
    else
    {
      v106 = v269 - 3;
      if ( v105 || v106 <= 0 )
      {
LABEL_149:
        if ( (v96 & 0x40) != 0 )
        {
          if ( v268 )
          {
            v147 = a1[20];
            if ( v147 )
            {
              v96 = *(_QWORD *)(v147 + 32);
              if ( v96 < *(_QWORD *)(v147 + 40) )
              {
                v19 = (const __m128i *)(v96 + 4);
                *(_QWORD *)(v147 + 32) = v96 + 4;
                *(_DWORD *)v96 = 43;
                goto LABEL_154;
              }
            }
            v263 = v22;
            v240 = 43;
LABEL_353:
            v241 = sub_6AB50(
                     (__int64)a1,
                     v240,
                     v96,
                     (__int64)v19,
                     a13,
                     v22,
                     *(double *)a4.m128_u64,
                     *(double *)a5.m128_u64,
                     *(double *)a6.m128_u64,
                     a7,
                     a8,
                     a9,
                     a10,
                     a11);
            v22 = v263;
            v242 = v241 == -1;
            goto LABEL_354;
          }
          v154 = (_BYTE *)a1[5];
          if ( (unsigned __int64)v154 < a1[6] )
          {
            v96 = (unsigned __int64)(v154 + 1);
            a1[5] = v154 + 1;
            *v154 = 43;
            goto LABEL_154;
          }
          v265 = v22;
          v250 = 43;
        }
        else
        {
          v96 &= 0x10u;
          if ( !(_DWORD)v96 )
          {
LABEL_89:
            if ( v268 )
              goto LABEL_90;
            goto LABEL_155;
          }
          if ( v268 )
          {
            v152 = a1[20];
            if ( v152 )
            {
              v96 = *(_QWORD *)(v152 + 32);
              if ( v96 < *(_QWORD *)(v152 + 40) )
              {
                v19 = (const __m128i *)(v96 + 4);
                *(_QWORD *)(v152 + 32) = v96 + 4;
                *(_DWORD *)v96 = 32;
                goto LABEL_154;
              }
            }
            v263 = v22;
            v240 = 32;
            goto LABEL_353;
          }
          v169 = (_BYTE *)a1[5];
          if ( (unsigned __int64)v169 < a1[6] )
          {
            v96 = (unsigned __int64)(v169 + 1);
            a1[5] = v169 + 1;
            *v169 = 32;
            goto LABEL_154;
          }
          v265 = v22;
          v250 = 32;
        }
        v251 = sub_1A150(
                 (__int64)a1,
                 v250,
                 *(double *)a4.m128_u64,
                 *(double *)a5.m128_u64,
                 *(double *)a6.m128_u64,
                 a7,
                 a8,
                 a9,
                 a10,
                 a11);
        v22 = v265;
        v242 = v251 == -1;
LABEL_354:
        if ( v242 )
          return (u32)-1;
LABEL_154:
        ++v22;
        if ( v268 )
        {
LABEL_90:
          v109 = v104 + 12;
          v110 = v22;
          while ( 1 )
          {
            v111 = a1[20];
            v104 += 4;
            v112 = *((_DWORD *)v104 - 1);
            if ( v111 && (v96 = *(_QWORD *)(v111 + 32), v96 < *(_QWORD *)(v111 + 40)) )
            {
              v19 = (const __m128i *)(v96 + 4);
              *(_QWORD *)(v111 + 32) = v96 + 4;
              v113 = v112 == -1;
              *(_DWORD *)v96 = v112;
            }
            else
            {
              v113 = (unsigned int)sub_6AB50(
                                     (__int64)a1,
                                     v112,
                                     v96,
                                     (__int64)v19,
                                     a13,
                                     v22,
                                     *(double *)a4.m128_u64,
                                     *(double *)a5.m128_u64,
                                     *(double *)a6.m128_u64,
                                     a7,
                                     a8,
                                     a9,
                                     a10,
                                     a11) == -1;
            }
            if ( v113 )
              return (u32)-1;
            ++v110;
            if ( v109 == v104 )
            {
              if ( (*(_BYTE *)(v15 + 12) & 0x20) != 0 && v106 > 0 )
              {
                v114 = v106;
                v268 = v110;
                v115 = sub_6A3E0(
                         (__int64)a1,
                         32,
                         v106,
                         *(double *)a4.m128_u64,
                         *(double *)a5.m128_u64,
                         *(double *)a6.m128_u64,
                         a7,
                         a8,
                         a9,
                         a10,
                         a11);
                v116 = v268;
                goto LABEL_99;
              }
              return v110;
            }
          }
        }
LABEL_155:
        v148 = v102 + 3;
        v149 = v102;
        do
        {
          ++v149;
          v150 = (_BYTE *)a1[5];
          v151 = *((unsigned __int8 *)v149 - 1);
          if ( (unsigned __int64)v150 >= a1[6] )
          {
            v256 = v148;
            v268 = v22;
            v153 = sub_1A150(
                     (__int64)a1,
                     v151,
                     *(double *)a4.m128_u64,
                     *(double *)a5.m128_u64,
                     *(double *)a6.m128_u64,
                     a7,
                     a8,
                     a9,
                     a10,
                     a11);
            v22 = v268;
            v148 = v256;
            if ( v153 == -1 )
              return (u32)-1;
          }
          else
          {
            a1[5] = v150 + 1;
            *v150 = v151;
          }
          v95 = v22 + (_DWORD)v149 - (_DWORD)v102;
        }
        while ( v148 != v149 );
        if ( (*(_BYTE *)(v15 + 12) & 0x20) != 0 && v106 > 0 )
        {
          v114 = v106;
          v115 = sub_6A2A0(
                   (__int64)a1,
                   32,
                   v106,
                   *(double *)a4.m128_u64,
                   *(double *)a5.m128_u64,
                   *(double *)a6.m128_u64,
                   a7,
                   a8,
                   a9,
                   a10,
                   a11);
          v116 = v95;
LABEL_99:
          if ( v115 == v114 )
            return v116 + v106;
          return (u32)-1;
        }
        return v95;
      }
    }
    v255 = v22;
    if ( v268 )
      v119 = sub_6A3E0(
               (__int64)a1,
               32,
               v106,
               *(double *)a4.m128_u64,
               *(double *)a5.m128_u64,
               *(double *)a6.m128_u64,
               a7,
               a8,
               a9,
               a10,
               a11);
    else
      v119 = sub_6A2A0(
               (__int64)a1,
               32,
               v106,
               *(double *)a4.m128_u64,
               *(double *)a5.m128_u64,
               *(double *)a6.m128_u64,
               a7,
               a8,
               a9,
               a10,
               a11);
    v22 = v255;
    if ( v119 != v106 )
      return (u32)-1;
    if ( v255 )
    {
      v107 = v106;
      if ( !v268 )
        goto LABEL_86;
      goto LABEL_111;
    }
    v96 = *(unsigned __int8 *)(a2 + 12);
    v131 = v106;
    goto LABEL_148;
  }
  v96 = *(unsigned __int8 *)(a2 + 12);
  if ( (v96 & 1) == 0 )
  {
    *(_QWORD *)&v278 = v19->m128i_i64[0];
    a4.m128_u64[0] = *(_QWORD *)&v278;
    v22 = _mm_movemask_pd((__m128d)*(unsigned __int64 *)&v278) & 1;
    a5.m128_u64[0] = fabs(*(double *)&v278);
    if ( *(double *)a5.m128_u64 <= 1.797693134862316e308 )
    {
      v121 = 0;
      v122 = "0";
      v59 = LODWORD(v278) | ((unsigned __int64)(DWORD1(v278) & 0xFFFFF) << 32);
      v123 = (_DWORD)v20 == 65;
      v27 = v282;
      if ( v123 )
        v122 = "0";
      LOBYTE(v121) = v123;
      v124 = LODWORD(v278) | ((unsigned __int64)(DWORD1(v278) & 0xFFFFF) << 32);
      v125 = v282;
      do
      {
        v125 -= 4;
        *(_DWORD *)v125 = *(_DWORD *)&v122[4 * (v124 & 0xF)];
        v126 = v124;
        v124 >>= 4;
      }
      while ( v126 > 0xF );
      v270.m128i_i32[0] = v22;
      v25 = v286;
      v266.m128_u64[0] = (unsigned __int64)v125;
      v272 = (char *)a4.m128_u64[0];
      v127 = sub_7A1B0(v59, (__int64)v286, 0x10u, v121);
      v47 = (char *)v266.m128_u64[0];
      v46 = v270.m128i_i32[0];
      v271 = v127;
      if ( v266.m128_u64[0] > (unsigned __int64)v280 )
      {
        v128 = (char *)v266.m128_u64[0];
        do
        {
          v128 -= 4;
          *(_DWORD *)v128 = 48;
        }
        while ( v128 > (char *)v280 );
        LODWORD(v272) = v46;
        v270.m128i_i64[0] = (__int64)v47;
        v129 = (unsigned __int64)&v47[~(unsigned __int64)v280] >> 2;
        v273 = (char *)a4.m128_u64[0];
        v271 += ~v129;
        v266.m128_u64[0] = v129 + 1;
        sub_9190(v271, 48LL, v129 + 1);
        v46 = (int)v272;
        v47 = (char *)(v270.m128i_i64[0] - 4 * v266.m128_u64[0]);
      }
      LOBYTE(v272) = 48 - (((a4.m128_u64[0] & 0x7FF0000000000000LL) == 0) - 1);
      v266.m128_i32[0] = (WORD3(v278) >> 4) & 0x7FF;
      if ( ((WORD3(v278) >> 4) & 0x7FF) != 0 )
      {
        v155 = v266.m128_i32[0];
        if ( v266.m128_i32[0] <= 1022 )
        {
          v58 = 1023 - v266.m128_i32[0];
          v266.m128_i32[0] = 1;
        }
        else
        {
          v266.m128_i32[0] = 0;
          v58 = v155 - 1023;
        }
        if ( !v59 )
          goto LABEL_29;
      }
      else
      {
        if ( !v59 )
        {
          v25 = (char *)v271;
          goto LABEL_30;
        }
        v266.m128_i32[0] = 1;
        v58 = 1022;
      }
      goto LABEL_176;
    }
    goto LABEL_79;
  }
  _FST7 = *(long double *)v19;
  *(long double *)&v266 = _FST7;
  __asm { fxam }
  v22 = v98 & 0x200;
  if ( fabs(_FST7) > 1.189731495357231765e4932 )
  {
LABEL_79:
    v102 = "INF";
    v103 = (*(_BYTE *)(__readfsqword(0xFFFFFFF8) + 2 * v20 + 1) & 1) == 0;
    v104 = "I";
    if ( v103 )
      v104 = "i";
    if ( v103 )
      v102 = "inf";
    goto LABEL_83;
  }
  v56 = v266.m128_u64[0];
  v25 = v286;
  v132 = v20 == 65;
  LODWORD(v271) = v98 & 0x200;
  v27 = v282;
  v278 = *(long double *)&v266;
  v133 = sub_7A1B0(v266.m128_u64[0], (__int64)v286, 0x10u, v132);
  v46 = v271;
  v134 = v282;
  v135 = (_BYTE *)v133;
  v136 = "0";
  if ( *(_DWORD *)(v15 + 8) != 65 )
    v136 = "0";
  v137 = v266.m128_u64[0];
  do
  {
    v47 = v134;
    v134 -= 4;
    *(_DWORD *)v134 = *(_DWORD *)&v136[4 * (v137 & 0xF)];
    v138 = v137;
    v137 >>= 4;
  }
  while ( v138 > 0xF );
  v266.m128_u64[0] = (unsigned __int64)v134;
  if ( v135 <= v285 )
  {
    v271 = (unsigned __int64)(v135 + 1);
    LOBYTE(v272) = *v135;
  }
  else
  {
    v273 = v47;
    LODWORD(v272) = v46;
    v270.m128i_i64[0] = (__int64)v135;
    v271 = v135 - v285;
    v139 = sub_9190((__int64)v285, 48LL, v135 - v285);
    v46 = (int)v272;
    v140 = v273;
    v141 = v271;
    v142 = v139;
    v143 = v266.m128_u64[0];
    v144 = v139 - v270.m128i_i64[0];
    v145 = 0LL;
    do
      *(_DWORD *)(v143 + 4 * v145-- - 4) = 48;
    while ( v144 != v145 );
    LOBYTE(v272) = 48;
    v271 = v142 + 1;
    v47 = &v140[-4 * v141];
  }
  v266.m128_i32[0] = WORD4(v278) & 0x7FFF;
  if ( (WORD4(v278) & 0x7FFF) != 0 )
  {
    v146 = v266.m128_i32[0];
    if ( v266.m128_i32[0] <= 16385 )
    {
      v58 = 16386 - v266.m128_i32[0];
      v266.m128_i32[0] = 1;
    }
    else
    {
      v266.m128_i32[0] = 0;
      v58 = v146 - 16386;
    }
  }
  else
  {
    v58 = v56 != 0 ? 0x4001 : 0;
    v266.m128_i32[0] = v56 != 0;
  }
LABEL_28:
  if ( !v56 )
  {
LABEL_29:
    v25 = (char *)v271;
    v59 = v58;
LABEL_30:
    v60 = 0;
    if ( v254 != -1 )
      v60 = v254;
    v254 = v60;
    goto LABEL_33;
  }
LABEL_176:
  if ( v281 == 48 )
  {
    do
    {
      v27 -= 4;
      --v25;
    }
    while ( *((_DWORD *)v27 - 1) == 48 );
  }
  v156 = &v25[-v271];
  if ( v254 == -1 )
  {
    v254 = (_DWORD)v25 - v271;
    v59 = v58;
    goto LABEL_33;
  }
  if ( (__int64)v156 <= v254 )
    goto LABEL_198;
  v157 = (char)v272;
  if ( v254 > 0 )
    v157 = *(_BYTE *)(v271 + v254 - 1);
  v158 = *(char *)(v271 + v254);
  if ( (unsigned __int8)(v157 - 65) > 5u )
  {
    if ( (unsigned __int8)(v157 - 97) > 5u )
      v159 = v157 - 48;
    else
      v159 = v157 - 87;
  }
  else
  {
    v159 = v157 - 55;
  }
  if ( (unsigned __int8)(v158 - 65) <= 5u )
  {
    v160 = (char)(v158 - 55);
LABEL_186:
    v161 = 1;
    goto LABEL_187;
  }
  if ( (unsigned __int8)(v158 - 97) <= 5u )
  {
    v160 = (char)(v158 - 87);
    goto LABEL_186;
  }
  v160 = v158 - 48;
  if ( (v158 & 7) != 0 )
    goto LABEL_186;
  v161 = (__int64)v156 > v254 + 1;
LABEL_187:
  v162 = v277 & 0xC00;
  if ( (v277 & 0xC00) == 2048 )
  {
    if ( v46 )
      goto LABEL_198;
LABEL_306:
    if ( v160 <= 7 && !v161 )
      goto LABEL_198;
    goto LABEL_192;
  }
  if ( (v277 & 0xC00u) > 0x800 )
  {
    if ( v162 == 3072 )
      goto LABEL_198;
    goto LABEL_392;
  }
  if ( v162 )
  {
    if ( v162 == 1024 )
    {
      if ( !v46 )
        goto LABEL_198;
      goto LABEL_306;
    }
LABEL_392:
    exit();
  }
  if ( v160 <= 7 || ((v159 | v161) & 1) == 0 )
    goto LABEL_198;
LABEL_192:
  v163 = v254 - 1;
  if ( v254 - 1 < 0 )
  {
LABEL_342:
    if ( (_BYTE)v272 == 57 )
    {
      v59 = v58;
      LOBYTE(v272) = *(_BYTE *)(v15 + 8);
      goto LABEL_33;
    }
    if ( *(int *)(__readfsqword(0xFFFFFFE8) + 4LL * (char)v272) > 101 )
    {
      if ( v266.m128_i32[0] )
      {
        LODWORD(v59) = v58 - 4;
        LOBYTE(v272) = 49;
        if ( v58 - 4 <= 0 )
        {
          v266.m128_i32[0] = 0;
          v59 = 4 - v58;
        }
        else
        {
          v59 = (int)v59;
        }
      }
      else
      {
        LOBYTE(v272) = 49;
        v59 = v58 + 4;
      }
      goto LABEL_33;
    }
    LOBYTE(v272) = (_BYTE)v272 + 1;
LABEL_198:
    v59 = v58;
    goto LABEL_33;
  }
  v164 = (char *)(v271 + v163);
  v165 = (char *)(v271 + v254 - 2LL - (unsigned int)v163);
  v166 = &v47[4 * v163];
  while ( 1 )
  {
    v167 = *v164;
    if ( *v164 == 57 )
    {
      v168 = *(_DWORD *)(v15 + 8);
      *(_DWORD *)v166 = v168;
      *v164 = v168;
      goto LABEL_198;
    }
    if ( *(int *)(__readfsqword(0xFFFFFFE8) + 4LL * v167) <= 101 )
      break;
    *v164-- = 48;
    v166 -= 4;
    *((_DWORD *)v166 + 1) = 48;
    if ( v165 == v164 )
      goto LABEL_342;
  }
  ++*(_DWORD *)v166;
  v59 = v58;
  *v164 = v167 + 1;
LABEL_33:
  v274 = v47;
  LODWORD(v273) = v46;
  v61 = sub_7A1B0(v59, (__int64)v283, 0xAu, 0);
  v64 = (unsigned int)v273;
  v65 = (u32 *)v274;
  v66 = &v279;
  v270.m128i_i64[0] = v61;
  do
  {
    v66 -= 4;
    v67 = v59 / 0xA;
    *(_DWORD *)v66 = *(_DWORD *)&a0_16[4 * (v59 % 0xA)];
    v68 = v59;
    v59 /= 0xAuLL;
  }
  while ( v68 > 9 );
  v69 = *(_BYTE *)(v15 + 12);
  v70 = 4;
  if ( !v64 )
    v70 = 3 - (((v69 & 0x50) == 0) - 1);
  v273 = &v283[-v270.m128i_i64[0]];
  v71 = v269 - 2 - ((unsigned int)v283 - v270.m128i_i32[0]) - (v254 + v70);
  if ( v254 > 0 || (v69 & 8) != 0 )
  {
    v72 = 1;
    if ( !v268 )
    {
      v275 = v65;
      v274 = v66;
      v269 = v64;
      v72 = strlen((__int64)v18);
      v65 = v275;
      v66 = v274;
      v64 = v269;
    }
    v71 -= v72;
  }
  v269 = v71;
  if ( (v69 & 0x20) != 0 || *(_DWORD *)(v15 + 16) == 48 || v269 <= 0 )
  {
    v75 = 0;
    if ( v64 )
    {
LABEL_48:
      v64 = v268;
      if ( v268 )
      {
        v76 = v14[20];
        if ( v76 )
        {
          v67 = *(_QWORD *)(v76 + 32);
          if ( v67 < *(_QWORD *)(v76 + 40) )
          {
            *(_QWORD *)(v76 + 32) = v67 + 4;
            *(_DWORD *)v67 = 45;
LABEL_52:
            ++v75;
            goto LABEL_53;
          }
        }
        v275 = v65;
        v246 = 45;
        v274 = v66;
        goto LABEL_362;
      }
      v224 = (_BYTE *)v14[5];
      if ( (unsigned __int64)v224 < v14[6] )
      {
        v14[5] = v224 + 1;
        *v224 = 45;
        goto LABEL_52;
      }
      v275 = v65;
      v252 = 45;
      v274 = v66;
      goto LABEL_378;
    }
  }
  else
  {
    v73 = v269;
    v276 = v65;
    v275 = (u32 *)v66;
    LODWORD(v274) = v64;
    if ( v268 )
    {
      v74 = sub_6A3E0(
              (__int64)v14,
              32,
              v269,
              *(double *)a4.m128_u64,
              *(double *)a5.m128_u64,
              *(double *)a6.m128_u64,
              a7,
              v62,
              v63,
              a10,
              a11);
      v64 = (unsigned int)v274;
      v66 = (char *)v275;
      v65 = v276;
    }
    else
    {
      v74 = sub_6A2A0(
              (__int64)v14,
              32,
              v269,
              *(double *)a4.m128_u64,
              *(double *)a5.m128_u64,
              *(double *)a6.m128_u64,
              a7,
              v62,
              v63,
              a10,
              a11);
      v65 = v276;
      v66 = (char *)v275;
      v64 = (unsigned int)v274;
    }
    if ( v74 != v73 )
      return (u32)-1;
    v75 = v269;
    if ( v64 )
      goto LABEL_48;
  }
  v170 = *(_BYTE *)(v15 + 12);
  if ( (v170 & 0x40) != 0 )
  {
    if ( v268 )
    {
      v171 = v14[20];
      if ( v171 )
      {
        v67 = *(_QWORD *)(v171 + 32);
        if ( v67 < *(_QWORD *)(v171 + 40) )
        {
          *(_QWORD *)(v171 + 32) = v67 + 4;
          *(_DWORD *)v67 = 43;
          goto LABEL_52;
        }
      }
      v275 = v65;
      v246 = 43;
      v274 = v66;
      goto LABEL_362;
    }
    v228 = (_BYTE *)v14[5];
    if ( (unsigned __int64)v228 < v14[6] )
    {
      v14[5] = v228 + 1;
      *v228 = 43;
      goto LABEL_52;
    }
    v275 = v65;
    v252 = 43;
    v274 = v66;
    goto LABEL_378;
  }
  if ( (v170 & 0x10) != 0 )
  {
    if ( v268 )
    {
      v225 = v14[20];
      if ( v225 )
      {
        v67 = *(_QWORD *)(v225 + 32);
        if ( v67 < *(_QWORD *)(v225 + 40) )
        {
          *(_QWORD *)(v225 + 32) = v67 + 4;
          *(_DWORD *)v67 = 32;
          goto LABEL_52;
        }
      }
      v275 = v65;
      v246 = 32;
      v274 = v66;
LABEL_362:
      v247 = sub_6AB50(
               (__int64)v14,
               v246,
               v67,
               (__int64)v66,
               v65,
               v64,
               *(double *)a4.m128_u64,
               *(double *)a5.m128_u64,
               *(double *)a6.m128_u64,
               a7,
               v62,
               v63,
               a10,
               a11);
      v66 = v274;
      v65 = v275;
      v248 = v247 == -1;
      goto LABEL_363;
    }
    v237 = (_BYTE *)v14[5];
    if ( (unsigned __int64)v237 < v14[6] )
    {
      v14[5] = v237 + 1;
      *v237 = 32;
      goto LABEL_52;
    }
    v275 = v65;
    v252 = 32;
    v274 = v66;
LABEL_378:
    v253 = sub_1A150(
             (__int64)v14,
             v252,
             *(double *)a4.m128_u64,
             *(double *)a5.m128_u64,
             *(double *)a6.m128_u64,
             a7,
             v62,
             v63,
             a10,
             a11);
    v66 = v274;
    v65 = v275;
    v248 = v253 == -1;
LABEL_363:
    if ( v248 )
      return (u32)-1;
    goto LABEL_52;
  }
LABEL_53:
  if ( v268 )
  {
    v77 = v14[20];
    if ( v77 )
    {
      v78 = *(_DWORD **)(v77 + 32);
      v79 = *(_QWORD *)(v77 + 40);
      if ( (unsigned __int64)v78 < v79 )
      {
        v80 = (unsigned __int64)(v78 + 1);
        *(_QWORD *)(v77 + 32) = v78 + 1;
        *v78 = 48;
        v81 = *(_DWORD *)(v15 + 8) + 23;
        goto LABEL_57;
      }
    }
    v275 = v65;
    v274 = v66;
    v234 = sub_6AB50(
             (__int64)v14,
             0x30u,
             v268,
             (__int64)v66,
             v65,
             v64,
             *(double *)a4.m128_u64,
             *(double *)a5.m128_u64,
             *(double *)a6.m128_u64,
             a7,
             v62,
             v63,
             a10,
             a11);
    v66 = v274;
    v65 = v275;
    v235 = v234 == -1;
  }
  else
  {
    v172 = (_BYTE *)v14[5];
    if ( (unsigned __int64)v172 < v14[6] )
    {
      v14[5] = v172 + 1;
      *v172 = 48;
      v81 = *(_DWORD *)(v15 + 8) + 23;
      goto LABEL_214;
    }
    v275 = v65;
    v274 = v66;
    v244 = sub_1A150(
             (__int64)v14,
             0x30u,
             *(double *)a4.m128_u64,
             *(double *)a5.m128_u64,
             *(double *)a6.m128_u64,
             a7,
             v62,
             v63,
             a10,
             a11);
    v66 = v274;
    v65 = v275;
    v235 = v244 == -1;
  }
  if ( v235 )
    return (u32)-1;
  v81 = *(_DWORD *)(v15 + 8) + 23;
  if ( v268 )
  {
    v77 = v14[20];
    if ( !v77 )
    {
LABEL_324:
      v275 = v65;
      v274 = v66;
      v233 = sub_6AB50(
               (__int64)v14,
               v81,
               v80,
               (__int64)v66,
               v65,
               v64,
               *(double *)a4.m128_u64,
               *(double *)a5.m128_u64,
               *(double *)a6.m128_u64,
               a7,
               v62,
               v63,
               a10,
               a11);
      v66 = v274;
      v65 = v275;
      v82 = v233 == -1;
      goto LABEL_59;
    }
    v80 = *(_QWORD *)(v77 + 32);
    v79 = *(_QWORD *)(v77 + 40);
LABEL_57:
    if ( v80 < v79 )
    {
      *(_QWORD *)(v77 + 32) = v80 + 4;
      v82 = v81 == -1;
      *(_DWORD *)v80 = v81;
      goto LABEL_59;
    }
    goto LABEL_324;
  }
LABEL_214:
  v173 = (_BYTE *)v14[5];
  if ( (unsigned __int64)v173 < v14[6] )
  {
    v80 = (unsigned __int64)(v173 + 1);
    v83 = v75 + 2;
    v14[5] = v173 + 1;
    *v173 = v81;
    if ( (*(_BYTE *)(v15 + 12) & 0x20) != 0 )
      goto LABEL_216;
    goto LABEL_61;
  }
  v275 = v65;
  v274 = v66;
  v243 = sub_1A150(
           (__int64)v14,
           (unsigned __int8)v81,
           *(double *)a4.m128_u64,
           *(double *)a5.m128_u64,
           *(double *)a6.m128_u64,
           a7,
           v62,
           v63,
           a10,
           a11);
  v66 = v274;
  v65 = v275;
  v82 = v243 == -1;
LABEL_59:
  if ( v82 )
    return (u32)-1;
  v83 = v75 + 2;
  if ( (*(_BYTE *)(v15 + 12) & 0x20) == 0 )
  {
LABEL_61:
    if ( *(_DWORD *)(v15 + 16) == 48 && v269 > 0 )
    {
      v231 = v269;
      v275 = v65;
      v274 = v66;
      if ( v268 )
      {
        v232 = sub_6A3E0(
                 (__int64)v14,
                 48,
                 v269,
                 *(double *)a4.m128_u64,
                 *(double *)a5.m128_u64,
                 *(double *)a6.m128_u64,
                 a7,
                 v62,
                 v63,
                 a10,
                 a11);
        v66 = v274;
        v65 = v275;
      }
      else
      {
        v232 = sub_6A2A0(
                 (__int64)v14,
                 48,
                 v269,
                 *(double *)a4.m128_u64,
                 *(double *)a5.m128_u64,
                 *(double *)a6.m128_u64,
                 a7,
                 v62,
                 v63,
                 a10,
                 a11);
        v65 = v275;
        v66 = v274;
      }
      if ( v232 != v231 )
        return (u32)-1;
      v83 += v269;
    }
  }
  if ( v268 )
  {
    v84 = v14[20];
    if ( !v84 || (v80 = *(_QWORD *)(v84 + 32), v80 >= *(_QWORD *)(v84 + 40)) )
    {
      v275 = v65;
      v274 = v66;
      v236 = sub_6AB50(
               (__int64)v14,
               (char)v272,
               v80,
               (__int64)v66,
               v65,
               v64,
               *(double *)a4.m128_u64,
               *(double *)a5.m128_u64,
               *(double *)a6.m128_u64,
               a7,
               v62,
               v63,
               a10,
               a11);
      v66 = v274;
      v65 = v275;
      if ( v236 == -1 )
        return (u32)-1;
      v87 = v83 + 1;
      if ( v254 <= 0 && (*(_BYTE *)(v15 + 12) & 8) == 0 )
      {
        v176 = *(_DWORD *)(v15 + 8) + 15;
        goto LABEL_220;
      }
      goto LABEL_238;
    }
    v85 = (char)v272;
    *(_QWORD *)(v84 + 32) = v80 + 4;
    *(_DWORD *)v80 = v85;
    v86 = v85 == -1;
LABEL_67:
    if ( v86 )
      return (u32)-1;
    v87 = v83 + 1;
    if ( v254 > 0 )
      goto LABEL_69;
    goto LABEL_218;
  }
LABEL_216:
  v174 = (_BYTE *)v14[5];
  if ( (unsigned __int64)v174 >= v14[6] )
  {
    v275 = v65;
    v274 = v66;
    v245 = sub_1A150(
             (__int64)v14,
             (unsigned __int8)v272,
             *(double *)a4.m128_u64,
             *(double *)a5.m128_u64,
             *(double *)a6.m128_u64,
             a7,
             v62,
             v63,
             a10,
             a11);
    v66 = v274;
    v65 = v275;
    v86 = v245 == -1;
    goto LABEL_67;
  }
  v175 = (char)v272;
  v80 = (unsigned __int64)(v174 + 1);
  v87 = v83 + 1;
  v14[5] = v174 + 1;
  *v174 = v175;
  if ( v254 > 0 )
    goto LABEL_69;
LABEL_218:
  if ( (*(_BYTE *)(v15 + 12) & 8) == 0 )
    goto LABEL_219;
LABEL_69:
  if ( !v268 )
  {
    v267 = v66;
    v88 = v18;
    v89 = strlen((__int64)v18);
    v66 = v267;
    v90 = v87;
    if ( v89 )
    {
      v272 = (char *)v15;
      v91 = (int)v18;
      v92 = &v18[v89];
      do
      {
        ++v88;
        v93 = (_BYTE *)v14[5];
        v94 = (unsigned __int8)*(v88 - 1);
        if ( (unsigned __int64)v93 < v14[6] )
        {
          v14[5] = v93 + 1;
          *v93 = v94;
        }
        else if ( (unsigned int)sub_1A150(
                                  (__int64)v14,
                                  v94,
                                  *(double *)a4.m128_u64,
                                  *(double *)a5.m128_u64,
                                  *(double *)a6.m128_u64,
                                  a7,
                                  v62,
                                  v63,
                                  a10,
                                  a11) == -1 )
        {
          return (u32)-1;
        }
        v90 = v87 + (_DWORD)v88 - v91;
      }
      while ( v88 != v92 );
      v66 = v267;
      v15 = (unsigned __int64)v272;
    }
    if ( v254 <= 0 )
    {
      v87 = v90;
      v176 = *(_DWORD *)(v15 + 8) + 15;
      goto LABEL_275;
    }
    v205 = v271;
    v190 = v90;
    v206 = (__int64)&v25[-v271];
    v207 = v254 - v206;
    if ( v254 <= v206 )
      v206 = v254;
    if ( v206 )
    {
      v257 = v207;
      v208 = v66;
      v209 = v90;
      v267 = (char *)v15;
      v210 = v206;
      v211 = v271;
      do
      {
        ++v205;
        v213 = (_BYTE *)v14[5];
        v214 = *(unsigned __int8 *)(v205 - 1);
        if ( (unsigned __int64)v213 < v14[6] )
        {
          v14[5] = v213 + 1;
          *v213 = v214;
        }
        else if ( (unsigned int)sub_1A150(
                                  (__int64)v14,
                                  v214,
                                  *(double *)a4.m128_u64,
                                  *(double *)a5.m128_u64,
                                  *(double *)a6.m128_u64,
                                  a7,
                                  v62,
                                  v63,
                                  a10,
                                  a11) == -1 )
        {
          return (u32)-1;
        }
        v212 = v209 + v205 - v211;
      }
      while ( v210 + v211 - v205 );
      v207 = v257;
      v15 = (unsigned __int64)v267;
      v66 = v208;
      v190 = v212;
    }
    if ( v207 <= 0 )
    {
      v87 = v190;
      v176 = *(_DWORD *)(v15 + 8) + 15;
      goto LABEL_275;
    }
    v259 = v66;
    v226 = sub_6A2A0(
             (__int64)v14,
             48,
             v207,
             *(double *)a4.m128_u64,
             *(double *)a5.m128_u64,
             *(double *)a6.m128_u64,
             a7,
             v62,
             v63,
             a10,
             a11);
    v66 = v259;
    goto LABEL_296;
  }
LABEL_238:
  v80 = v14[20];
  if ( v80 && (v188 = *(_DWORD **)(v80 + 32), (unsigned __int64)v188 < *(_QWORD *)(v80 + 40)) )
  {
    v189 = (int)v267;
    *(_QWORD *)(v80 + 32) = v188 + 1;
    *v188 = v189;
    if ( v189 == -1 )
      return (u32)-1;
    v190 = v87 + 1;
    if ( v254 <= 0 )
      goto LABEL_254;
  }
  else
  {
    v274 = (char *)v65;
    v272 = v66;
    v201 = sub_6AB50(
             (__int64)v14,
             (unsigned int)v267,
             v80,
             (__int64)v66,
             v65,
             v64,
             *(double *)a4.m128_u64,
             *(double *)a5.m128_u64,
             *(double *)a6.m128_u64,
             a7,
             v62,
             v63,
             a10,
             a11);
    v66 = v272;
    v65 = (u32 *)v274;
    if ( v201 == -1 )
      return (u32)-1;
    v190 = v87 + 1;
    if ( v254 <= 0 )
      goto LABEL_254;
  }
  v191 = &v25[-v271];
  v267 = &v25[-v271];
  if ( v254 <= (__int64)&v25[-v271] )
    v191 = (char *)v254;
  if ( v191 )
  {
    v271 = v15;
    v192 = v66;
    v193 = (__int64)v14;
    v194 = (_DWORD)v191 + 2;
    v195 = v87;
    v196 = v65;
    while ( 1 )
    {
      v199 = *(_QWORD *)(v193 + 160);
      v200 = *v196++;
      if ( v199 && (v80 = *(_QWORD *)(v199 + 32), v80 < *(_QWORD *)(v199 + 40)) )
      {
        *(_QWORD *)(v199 + 32) = v80 + 4;
        v197 = v200 == -1;
        *(_DWORD *)v80 = v200;
      }
      else
      {
        v197 = (unsigned int)sub_6AB50(
                               v193,
                               v200,
                               v80,
                               (__int64)v66,
                               v65,
                               v64,
                               *(double *)a4.m128_u64,
                               *(double *)a5.m128_u64,
                               *(double *)a6.m128_u64,
                               a7,
                               v62,
                               v63,
                               a10,
                               a11) == -1;
      }
      if ( v197 )
        return (u32)-1;
      v198 = v194 + v195 - (_DWORD)v191--;
      if ( !v191 )
      {
        v14 = (_QWORD *)v193;
        v15 = v271;
        v66 = v192;
        v190 = v198;
        break;
      }
    }
  }
  v207 = v254 - (_QWORD)v267;
  if ( v207 <= 0 )
  {
LABEL_254:
    v87 = v190;
    v176 = *(_DWORD *)(v15 + 8) + 15;
    goto LABEL_220;
  }
  v229 = v254 - (_DWORD)v267;
  v260 = v66;
  v226 = sub_6A3E0(
           (__int64)v14,
           48,
           v229,
           *(double *)a4.m128_u64,
           *(double *)a5.m128_u64,
           *(double *)a6.m128_u64,
           a7,
           v62,
           v63,
           a10,
           a11);
  v66 = v260;
LABEL_296:
  if ( v226 != v207 )
    return (u32)-1;
  v87 = v190 + v226;
LABEL_219:
  v176 = *(_DWORD *)(v15 + 8) + 15;
  if ( v268 )
  {
LABEL_220:
    v177 = v14[20];
    if ( v177 && (v80 = *(_QWORD *)(v177 + 32), v80 < *(_QWORD *)(v177 + 40)) )
    {
      *(_QWORD *)(v177 + 32) = v80 + 4;
      v178 = v176 == -1;
      *(_DWORD *)v80 = v176;
    }
    else
    {
      v262 = v66;
      v239 = sub_6AB50(
               (__int64)v14,
               v176,
               v80,
               (__int64)v66,
               v65,
               v64,
               *(double *)a4.m128_u64,
               *(double *)a5.m128_u64,
               *(double *)a6.m128_u64,
               a7,
               v62,
               v63,
               a10,
               a11);
      v66 = v262;
      v178 = v239 == -1;
    }
    if ( v178 )
      return (u32)-1;
    goto LABEL_224;
  }
LABEL_275:
  v215 = (_BYTE *)v14[5];
  if ( (unsigned __int64)v215 < v14[6] )
  {
    v185 = v266.m128_i32[0] == 0;
    v14[5] = v215 + 1;
    *v215 = v176;
    v180 = v185 ? 43 : 45;
    goto LABEL_277;
  }
  v264 = v66;
  v249 = sub_1A150(
           (__int64)v14,
           (unsigned __int8)v176,
           *(double *)a4.m128_u64,
           *(double *)a5.m128_u64,
           *(double *)a6.m128_u64,
           a7,
           v62,
           v63,
           a10,
           a11);
  v66 = v264;
  if ( v249 == -1 )
    return (u32)-1;
LABEL_224:
  v179 = v268;
  v180 = v266.m128_i32[0] == 0 ? 43 : 45;
  if ( v268 )
  {
    v181 = v14[20];
    if ( v181 && (v80 = *(_QWORD *)(v181 + 32), v80 < *(_QWORD *)(v181 + 40)) )
    {
      v95 = v87 + 2;
      *(_QWORD *)(v181 + 32) = v80 + 4;
      *(_DWORD *)v80 = v180;
    }
    else
    {
      v261 = v66;
      v95 = v87 + 2;
      v238 = sub_6AB50(
               (__int64)v14,
               v180,
               v80,
               (__int64)v66,
               v65,
               v268,
               *(double *)a4.m128_u64,
               *(double *)a5.m128_u64,
               *(double *)a6.m128_u64,
               a7,
               v62,
               v63,
               a10,
               a11);
      v66 = v261;
      if ( v238 == -1 )
        return (u32)-1;
    }
    v182 = v66;
    v183 = v273 - 1;
    if ( !v273 )
      goto LABEL_256;
    while ( 1 )
    {
      v186 = v14[20];
      v182 += 4;
      v187 = *((_DWORD *)v182 - 1);
      if ( v186 && (v80 = *(_QWORD *)(v186 + 32), v80 < *(_QWORD *)(v186 + 40)) )
      {
        v66 = (char *)(v80 + 4);
        *(_QWORD *)(v186 + 32) = v80 + 4;
        v184 = v187 == -1;
        *(_DWORD *)v80 = v187;
      }
      else
      {
        v184 = (unsigned int)sub_6AB50(
                               (__int64)v14,
                               v187,
                               v80,
                               (__int64)v66,
                               v65,
                               v179,
                               *(double *)a4.m128_u64,
                               *(double *)a5.m128_u64,
                               *(double *)a6.m128_u64,
                               a7,
                               v62,
                               v63,
                               a10,
                               a11) == -1;
      }
      if ( v184 )
        return (u32)-1;
      ++v95;
      v185 = v183-- == 0LL;
      if ( v185 )
        goto LABEL_256;
    }
  }
LABEL_277:
  v216 = (_BYTE *)v14[5];
  if ( (unsigned __int64)v216 >= v14[6] )
  {
    v217 = v87 + 2;
    if ( (unsigned int)sub_1A150(
                         (__int64)v14,
                         v180,
                         *(double *)a4.m128_u64,
                         *(double *)a5.m128_u64,
                         *(double *)a6.m128_u64,
                         a7,
                         v62,
                         v63,
                         a10,
                         a11) == -1 )
      return (u32)-1;
  }
  else
  {
    v217 = v87 + 2;
    v14[5] = v216 + 1;
    *v216 = v180;
  }
  v218 = v270.m128i_i64[0];
  v219 = &v273[v270.m128i_i64[0]];
  if ( v273 )
  {
    v258 = v15;
    v220 = v217;
    v221 = v270.m128i_i32[0];
    do
    {
      ++v218;
      v222 = (_BYTE *)v14[5];
      v223 = *(unsigned __int8 *)(v218 - 1);
      if ( (unsigned __int64)v222 < v14[6] )
      {
        v14[5] = v222 + 1;
        *v222 = v223;
      }
      else if ( (unsigned int)sub_1A150(
                                (__int64)v14,
                                v223,
                                *(double *)a4.m128_u64,
                                *(double *)a5.m128_u64,
                                *(double *)a6.m128_u64,
                                a7,
                                v62,
                                v63,
                                a10,
                                a11) == -1 )
      {
        return (u32)-1;
      }
      v95 = v220 + v218 - v221;
    }
    while ( v219 != (char *)v218 );
    v15 = v258;
  }
  else
  {
    v95 = v217;
  }
LABEL_256:
  if ( (*(_BYTE *)(v15 + 12) & 0x20) != 0 )
  {
    v202 = *(_DWORD *)(v15 + 16);
    if ( v269 > 0 && v202 != 48 )
    {
      v203 = v269;
      if ( v268 )
        v204 = sub_6A3E0(
                 (__int64)v14,
                 v202,
                 v269,
                 *(double *)a4.m128_u64,
                 *(double *)a5.m128_u64,
                 *(double *)a6.m128_u64,
                 a7,
                 v62,
                 v63,
                 a10,
                 a11);
      else
        v204 = sub_6A2A0(
                 (__int64)v14,
                 v202,
                 v269,
                 *(double *)a4.m128_u64,
                 *(double *)a5.m128_u64,
                 *(double *)a6.m128_u64,
                 a7,
                 v62,
                 v63,
                 a10,
                 a11);
      if ( v204 == v203 )
      {
        v95 += v269;
        return v95;
      }
      return (u32)-1;
    }
  }
  return v95;
}
// 7D86E: variable 'v62' is possibly undefined
// 7D86E: variable 'v63' is possibly undefined
// 7DB98: variable 'a8' is possibly undefined
// 7DB98: variable 'a9' is possibly undefined
// 7E143: variable 'v96' is possibly undefined
// 7E143: variable 'v19' is possibly undefined
// 7E143: variable 'a13' is possibly undefined
// 7E143: variable 'v22' is possibly undefined
// 7E5AF: variable 'v80' is possibly undefined
// 7E5AF: variable 'v66' is possibly undefined
// 7E5AF: variable 'v65' is possibly undefined
// 7E5AF: variable 'v179' is possibly undefined
// 7E6AB: variable 'v64' is possibly undefined
// 7EE77: variable 'v67' is possibly undefined
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// A7C60: using guessed type __int128 xmmword_A7C60;
// A7C70: using guessed type __int128 xmmword_A7C70;

//----- (000000000007F220) ----------------------------------------------------
__int64 __fastcall sub_7F220(unsigned __int8 **a1, __int64 a2)
{
  unsigned __int8 *v2; // r10
  __int64 *v4; // rdi
  unsigned __int8 v5; // r8
  unsigned __int8 *v6; // r13
  int v7; // er11
  int v8; // ebp
  _DWORD *v9; // rdx
  unsigned __int8 *v10; // rcx
  int v11; // eax
  __int64 result; // rax

  v2 = *a1;
  v4 = *(__int64 **)(qword_C1798 + 8LL * **a1);
  if ( !v4 )
    return 1LL;
  v5 = v2[1];
  v6 = 0LL;
  v7 = 0;
  v8 = 0;
  do
  {
    v9 = (_DWORD *)v4 + 3;
    v10 = v2 + 1;
    v11 = v5;
    if ( v5 )
    {
      while ( *v9 )
      {
        if ( v11 != *v9 )
          goto LABEL_10;
        v11 = *++v10;
        ++v9;
        if ( !(_BYTE)v11 )
          goto LABEL_14;
      }
    }
    else
    {
LABEL_14:
      if ( *v9 )
        goto LABEL_10;
    }
    if ( v10 - v2 > v7 )
    {
      v8 = *((_DWORD *)v4 + 2);
      v7 = (_DWORD)v10 - (_DWORD)v2;
      v6 = v10;
    }
LABEL_10:
    v4 = (__int64 *)*v4;
  }
  while ( v4 );
  result = 1LL;
  if ( v8 )
  {
    *(_WORD *)(a2 + 14) |= v8;
    result = 0LL;
    *a1 = v6;
  }
  return result;
}
// C1798: using guessed type __int64 qword_C1798;

//----- (000000000007F2F0) ----------------------------------------------------
__int64 __fastcall sub_7F2F0(unsigned int **a1, __int64 a2)
{
  unsigned int *v2; // r10
  __int64 *v4; // rdi
  unsigned int *v6; // r13
  int v7; // er11
  int v8; // ebp
  _DWORD *v9; // rax
  unsigned int *v10; // rdx
  unsigned int v11; // esi
  __int64 result; // rax

  v2 = *a1;
  v4 = *(__int64 **)(qword_C1798 + 8LL * **a1);
  if ( !v4 )
    return 1LL;
  v6 = 0LL;
  v7 = 0;
  v8 = 0;
  do
  {
    v9 = (_DWORD *)v4 + 3;
    v10 = v2 + 1;
    v11 = v2[1];
    if ( v11 )
    {
      while ( *v9 )
      {
        if ( *v9 != v11 )
          goto LABEL_10;
        v11 = v10[1];
        ++v10;
        ++v9;
        if ( !v11 )
          goto LABEL_14;
      }
    }
    else
    {
LABEL_14:
      if ( *v9 )
        goto LABEL_10;
    }
    if ( v10 - v2 > v7 )
    {
      v8 = *((_DWORD *)v4 + 2);
      v7 = v10 - v2;
      v6 = v10;
    }
LABEL_10:
    v4 = (__int64 *)*v4;
  }
  while ( v4 );
  result = 1LL;
  if ( v8 )
  {
    *(_WORD *)(a2 + 14) |= v8;
    result = 0LL;
    *a1 = v6;
  }
  return result;
}
// C1798: using guessed type __int64 qword_C1798;

//----- (000000000007F4E0) ----------------------------------------------------
signed __int64 __fastcall sub_7F4E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 v6; // rdi
  signed __int64 result; // rax

  v6 = *(_QWORD *)(a1 + 136);
  result = (unsigned int)(*(_DWORD *)(v6 + 4) - 1);
  *(_DWORD *)(v6 + 4) = result;
  if ( !(_DWORD)result )
  {
    *(_QWORD *)(v6 + 8) = 0LL;
    if ( __readfsdword(0x18u) )
    {
      result = (unsigned int)_InterlockedExchange((volatile __int32 *)v6, 0);
      if ( (int)result > 1 )
        result = sys_futex((u32 *)v6, 129, 1u, 0LL, a5, a6);
    }
    else
    {
      --*(_DWORD *)v6;
    }
  }
  return result;
}

//----- (000000000007F530) ----------------------------------------------------
void *sub_7F530()
{
  void *result; // rax

  result = &unk_C17E0;
  qword_C17C8 = (__int64)&unk_C17E0;
  return result;
}
// 9070: using guessed type __int64 __fastcall sub_9070(_QWORD, _QWORD);
// C17C8: using guessed type __int64 qword_C17C8;

//----- (000000000007F580) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_7F580(__int64 a1, u32 *a2, __int64 a3, unsigned __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, __int64 a13, __int64 a14))(_QWORD, _QWORD)
{
  u32 *v14; // r8
  bool v16; // cf
  bool v17; // zf
  const char *v18; // rdi

  v14 = *(u32 **)(a1 + 24);
  v16 = 0;
  v17 = v14 == 0LL;
  if ( v14 )
  {
    a4 = 14LL;
    v18 = "out of memory";
    a2 = v14;
    do
    {
      if ( !a4 )
        break;
      v16 = *(_BYTE *)a2 < *v18;
      v17 = *(_BYTE *)a2 == *v18;
      a2 = (u32 *)((char *)a2 + 1);
      ++v18;
      --a4;
    }
    while ( v17 );
    if ( (!v16 && !v17) != v16 )
      sub_21B70((__int64)v14, a5, a6, a7, a8, a9, a10, a11, a12, (__int64)a2, a3, a4, v14, a14);
  }
  return sub_21B70(a1, a5, a6, a7, a8, a9, a10, a11, a12, (__int64)a2, a3, a4, v14, a14);
}
// 7F5AE: variable 'a9' is possibly undefined
// 7F5AE: variable 'a10' is possibly undefined
// 7F5AE: variable 'a3' is possibly undefined
// 7F5AE: variable 'a4' is possibly undefined
// 7F5AE: variable 'v14' is possibly undefined
// 7F5AE: variable 'a14' is possibly undefined
// 9268: using guessed type __int64 __fastcall sub_9268(_QWORD, _QWORD);

//----- (000000000007F5F0) ----------------------------------------------------
__int64 __fastcall sub_7F5F0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14)
{
  u32 *v14; // r8
  bool v15; // cf
  bool v16; // zf
  unsigned __int64 v17; // rcx
  const char *v18; // rdi
  const char *v19; // rsi
  __int64 result; // rax
  unsigned int v21; // edi
  unsigned __int8 *v22; // rbp
  double v23; // xmm4_8
  double v24; // xmm5_8
  __int64 v25; // rax
  _BYTE *v26; // rdx
  const char *v27; // rcx
  int v28; // eax
  __int64 v29; // rdx
  __int64 v30; // r9
  double v31; // xmm4_8
  double v32; // xmm5_8
  bool v33; // cf
  bool v34; // zf
  unsigned __int64 v35; // rcx
  const char *v36; // rdi
  const char *v37; // rsi
  __int64 v38; // rdx
  void *v39; // rbx
  __int64 v40; // rax
  _BYTE *v41; // rdx
  const char *v42; // rcx
  int v43; // eax
  __int64 v44; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v45; // [rsp+8h] [rbp-20h]

  v45 = __readfsqword(0x28u);
  v44 = 0LL;
  v38 = (unsigned int)dword_C17C0;
  v39 = (void *)qword_C17C8;
  if ( dword_C17C0 )
  {
    if ( qword_C17C8 )
      goto LABEL_3;
  }
  else
  {
    v39 = &unk_C17E0;
    v38 = dword_C17C0 | 2u;
    qword_C17C8 = (__int64)&unk_C17E0;
    dword_C17C0 |= 2u;
    if ( &unk_C17E0 )
      goto LABEL_3;
  }
  v39 = &unk_C17E0;
LABEL_3:
  v14 = (u32 *)*((_QWORD *)v39 + 3);
  if ( *((_DWORD *)v39 + 1) )
  {
    v15 = 0;
    v16 = v14 == 0LL;
    if ( v14 )
    {
      v17 = 14LL;
      v18 = "out of memory";
      v19 = (const char *)*((_QWORD *)v39 + 3);
      do
      {
        if ( !v17 )
          break;
        v15 = *v19 < (unsigned int)*v18;
        v16 = *v19++ == *v18++;
        --v17;
      }
      while ( v16 );
      if ( (!v15 && !v16) != v15 )
        sub_21B70(*((_QWORD *)v39 + 3), a1, a2, a3, a4, a5, a6, a7, a8, (__int64)v19, v38, v17, v14, a14);
      *((_QWORD *)v39 + 3) = 0LL;
    }
    return v44;
  }
  if ( !v14 )
    return v44;
  v21 = *(_DWORD *)v39;
  v44 = *((_QWORD *)v39 + 3);
  if ( v21 )
  {
    v22 = sub_7FC80(v21, a1, a2, a3, a4, a5, a6, a7, a8);
    v25 = sub_CF50("libc", *((unsigned __int8 **)v39 + 3), 5u, a1, a2, a3, a4, v23, v24, a7, a8);
    v26 = (_BYTE *)*((_QWORD *)v39 + 2);
    v27 = (const char *)&unk_A6E65;
    if ( *v26 )
      v27 = ": ";
    v28 = sub_130A0(&v44, (unsigned __int64)"%s%s%s: %s", v26, v27, v25, v22, v44, v45);
    v33 = v28 != -1;
    v34 = v28 == -1;
    if ( v28 != -1 )
    {
LABEL_17:
      v35 = 14LL;
      v36 = "out of memory";
      v37 = (const char *)*((_QWORD *)v39 + 3);
      do
      {
        if ( !v35 )
          break;
        v33 = *v37 < (unsigned int)*v36;
        v34 = *v37++ == *v36++;
        --v35;
      }
      while ( v34 );
      if ( (!v33 && !v34) != v33 )
        sub_21B70(
          *((_QWORD *)v39 + 3),
          a1,
          a2,
          a3,
          a4,
          v31,
          v32,
          a7,
          a8,
          (__int64)v37,
          v29,
          v35,
          *((u32 **)v39 + 3),
          v30);
      result = v44;
      *((_QWORD *)v39 + 3) = v44;
      goto LABEL_23;
    }
  }
  else
  {
    v40 = sub_CF50("libc", (unsigned __int8 *)v14, 5u, a1, a2, a3, a4, a5, a6, a7, a8);
    v41 = (_BYTE *)*((_QWORD *)v39 + 2);
    v42 = (const char *)&unk_A6E65;
    if ( *v41 )
      v42 = ": ";
    v43 = sub_130A0(&v44, (unsigned __int64)"%s%s%s", v41, v42, v40);
    v33 = v43 != -1;
    v34 = v43 == -1;
    if ( v43 != -1 )
      goto LABEL_17;
  }
  result = v44;
LABEL_23:
  *((_DWORD *)v39 + 1) = 1;
  return result;
}
// 7F6CB: variable 'v23' is possibly undefined
// 7F6CB: variable 'v24' is possibly undefined
// 7F85B: variable 'v31' is possibly undefined
// 7F85B: variable 'v32' is possibly undefined
// 7F85B: variable 'v29' is possibly undefined
// 7F85B: variable 'v30' is possibly undefined
// 9070: using guessed type __int64 __fastcall sub_9070(_QWORD, _QWORD);
// 9220: using guessed type __int64 __fastcall sub_9220(_QWORD, _QWORD);
// 9250: using guessed type __int64 __fastcall sub_9250(_QWORD);
// C17C0: using guessed type int dword_C17C0;
// C17C8: using guessed type __int64 qword_C17C8;

//----- (000000000007F870) ----------------------------------------------------
_BOOL8 __fastcall sub_7F870(void (__fastcall *a1)(__int64), __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14)
{
  __int64 v15; // rbp
  __int64 v16; // rdi
  bool v17; // zf
  __int64 v19; // rdx
  void *v20; // rbx

  v15 = a2;
  v19 = (unsigned int)dword_C17C0;
  v20 = (void *)qword_C17C8;
  if ( dword_C17C0 )
  {
    if ( qword_C17C8 )
      goto LABEL_3;
  }
  else
  {
    v20 = &unk_C17E0;
    v19 = dword_C17C0 | 2u;
    qword_C17C8 = (__int64)&unk_C17E0;
    dword_C17C0 |= 2u;
    if ( &unk_C17E0 )
      goto LABEL_3;
  }
  a2 = 32LL;
  v20 = (void *)sub_22260(1uLL, 0x20uLL, a3, a4, a5, a6, a7, a8, a9, a10, v19, a12, a13, a14);
  if ( !v20 )
    v20 = &unk_C17E0;
LABEL_3:
  v16 = *((_QWORD *)v20 + 3);
  if ( v16 )
  {
    if ( *((_BYTE *)v20 + 8) )
      sub_21B70(v16, a3, a4, a5, a6, a7, a8, a9, a10, a2, v19, a12, a13, a14);
    *((_QWORD *)v20 + 3) = 0LL;
  }
  *(_DWORD *)v20 = sub_50290((_QWORD *)v20 + 2, (_QWORD *)v20 + 3, (bool *)v20 + 8, a1, v15, a14);
  v17 = *((_QWORD *)v20 + 3) == 0LL;
  *((_DWORD *)v20 + 1) = v17;
  return !v17;
}
// 7F8F8: variable 'a7' is possibly undefined
// 7F8F8: variable 'a8' is possibly undefined
// 7F8F8: variable 'v19' is possibly undefined
// 7F8F8: variable 'a12' is possibly undefined
// 7F8F8: variable 'a13' is possibly undefined
// 7F8F8: variable 'a14' is possibly undefined
// 9070: using guessed type __int64 __fastcall sub_9070(_QWORD, _QWORD);
// 9220: using guessed type __int64 __fastcall sub_9220(_QWORD, _QWORD);
// 9250: using guessed type __int64 __fastcall sub_9250(_QWORD);
// 9268: using guessed type __int64 __fastcall sub_9268(_QWORD, _QWORD);
// C17C0: using guessed type int dword_C17C0;
// C17C8: using guessed type __int64 qword_C17C8;

//----- (000000000007F9E0) ----------------------------------------------------
_QWORD *__fastcall sub_7F9E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *result; // rax

  result = (_QWORD *)sub_7A020(a1, (__int64)"_dlfcn_hook", a3, a4, a5, a6);
  if ( result )
    *result = off_BFA20;
  return result;
}
// BFA20: using guessed type __int64 (__fastcall *off_BFA20[9])();

//----- (000000000007FA10) ----------------------------------------------------
__int64 __fastcall sub_7FA10(unsigned __int64 a1, _QWORD *a2)
{
  unsigned int v4; // er14
  _QWORD *v5; // rax
  _QWORD *v6; // r8
  _BYTE *v7; // rax
  __int64 v8; // rdx
  unsigned int *v9; // r11
  unsigned int *v10; // rsi
  int v11; // edx
  unsigned int *v12; // rax
  unsigned int *v13; // rdi
  __int64 v14; // r15
  __int64 v15; // rax
  __int64 v16; // r9
  __int64 v17; // rax
  unsigned __int64 v18; // r14
  unsigned __int64 v19; // r10
  __int64 v20; // rcx
  unsigned int *v21; // rdx
  __int16 v22; // cx
  bool v23; // zf
  __int64 v24; // rax
  __int64 v26; // rax
  unsigned int *v27; // rcx
  unsigned __int8 v28; // dl
  __int16 v29; // ax
  unsigned __int64 v30; // rax
  unsigned __int64 v31; // rdx
  __int64 v32; // rdi
  unsigned int v33; // [rsp+Ch] [rbp-3Ch]

  v4 = 0;
  v5 = sub_81070(a1);
  v6 = v5;
  if ( !v5 )
    return v4;
  v7 = (_BYTE *)v5[1];
  v8 = v6[106];
  *a2 = v7;
  a2[1] = v8;
  if ( !*v7 && (*((_BYTE *)v6 + 796) & 3) == 0 )
    *a2 = off_BEFD8;
  v9 = (unsigned int *)v6[84];
  v10 = *(unsigned int **)(v6[14] + 8LL);
  v33 = *(_DWORD *)(v6[18] + 8LL);
  if ( v9 )
  {
    v11 = *((_DWORD *)v6 + 189);
    if ( v11 )
    {
      v12 = (unsigned int *)v6[97];
      v9 = 0LL;
      v13 = v12 + 1;
      v14 = (__int64)&v12[v11 - 1 + 1];
      while ( 1 )
      {
        v15 = *v12;
        if ( (_DWORD)v15 )
          break;
LABEL_6:
        v12 = v13;
        if ( (unsigned int *)v14 == v13 )
          goto LABEL_21;
        ++v13;
      }
      v16 = v6[98];
      v17 = v16 + 4 * v15;
      while ( 1 )
      {
        v21 = &v10[6 * (unsigned int)((v17 - v16) >> 2)];
        v22 = *((_WORD *)v21 + 3);
        if ( v22 )
        {
          if ( v22 == -15 )
            goto LABEL_16;
        }
        else if ( !*((_QWORD *)v21 + 1) )
        {
          goto LABEL_16;
        }
        if ( (v21[1] & 0xF) == 6 )
          goto LABEL_16;
        v18 = *((_QWORD *)v21 + 1);
        v19 = v18 + *v6;
        if ( a1 < v19 )
          goto LABEL_16;
        if ( v22 )
        {
          v20 = *((_QWORD *)v21 + 2);
          if ( !v20 )
          {
            if ( a1 == v19 )
              goto LABEL_48;
            goto LABEL_16;
          }
        }
        else
        {
          if ( a1 == v19 )
            goto LABEL_48;
          v20 = *((_QWORD *)v21 + 2);
        }
        if ( a1 < v19 + v20 )
        {
LABEL_48:
          if ( (!v9 || v18 > *((_QWORD *)v9 + 1)) && v33 > *v21 )
            v9 = &v10[6 * (unsigned int)((v17 - v16) >> 2)];
        }
LABEL_16:
        v17 += 4LL;
        if ( (*(_BYTE *)(v17 - 4) & 1) != 0 )
          goto LABEL_6;
      }
    }
    v9 = 0LL;
    goto LABEL_21;
  }
  v26 = v6[12];
  v27 = *(unsigned int **)(v6[13] + 8LL);
  if ( v26 )
    v27 = &v10[6 * *(unsigned int *)(*(_QWORD *)(v26 + 8) + 4LL)];
  if ( v10 < v27 )
  {
    v28 = *((_BYTE *)v10 + 4);
    if ( (unsigned __int8)((v28 >> 4) - 1) <= 1u )
      goto LABEL_32;
    while ( 1 )
    {
      while ( 1 )
      {
        do
        {
          do
          {
            v10 += 6;
            if ( v10 >= v27 )
              goto LABEL_21;
            v28 = *((_BYTE *)v10 + 4);
          }
          while ( (unsigned __int8)((v28 >> 4) - 1) > 1u );
LABEL_32:
          ;
        }
        while ( (*((_BYTE *)v10 + 5) & 3u) - 1 <= 1 || (v28 & 0xF) == 6 );
        v29 = *((_WORD *)v10 + 3);
        if ( v29 )
          break;
        v30 = *((_QWORD *)v10 + 1);
        if ( v30 )
        {
          v31 = v30 + *v6;
          if ( a1 >= v31 )
          {
            if ( a1 == v31 )
            {
LABEL_40:
              if ( (!v9 || *((_QWORD *)v9 + 1) < v30) && v33 > *v10 )
                v9 = v10;
            }
            else
            {
              v32 = *((_QWORD *)v10 + 2);
LABEL_39:
              if ( a1 < v32 + v31 )
                goto LABEL_40;
            }
          }
        }
      }
      if ( v29 != -15 )
      {
        v30 = *((_QWORD *)v10 + 1);
        v31 = v30 + *v6;
        if ( a1 >= v31 )
        {
          v32 = *((_QWORD *)v10 + 2);
          if ( v32 )
            goto LABEL_39;
          if ( a1 == v31 )
            goto LABEL_40;
        }
      }
    }
  }
LABEL_21:
  if ( v9 )
  {
    v23 = *((_WORD *)v9 + 3) == 0xFFF1;
    a2[2] = *(_QWORD *)(v6[13] + 8LL) + *v9;
    if ( v23 )
      v24 = 0LL;
    else
      v24 = *v6;
    v4 = 1;
    a2[3] = *((_QWORD *)v9 + 1) + v24;
  }
  else
  {
    a2[2] = 0LL;
    v4 = 1;
    a2[3] = 0LL;
  }
  return v4;
}
// 8397B: conditional instruction was optimized away because of 'rbp.8==0'
// 83984: conditional instruction was optimized away because of 'rbx.8==0'
// 9228: using guessed type __int64 __fastcall sub_9228(_QWORD);
// 9248: using guessed type __int64 __fastcall sub_9248(_QWORD);
// BEFD8: using guessed type void *off_BEFD8;

//----- (000000000007FA20) ----------------------------------------------------
void __fastcall sub_7FA20(__int64 a1, _QWORD *a2)
{
  _QWORD *v2; // rax
  _QWORD *v3; // r8
  _BYTE *v4; // rax
  __int64 v5; // rdx

  v2 = sub_81070(a1);
  v3 = v2;
  if ( v2 )
  {
    v4 = (_BYTE *)v2[1];
    v5 = v3[106];
    *a2 = v4;
    a2[1] = v5;
    if ( *v4 )
    {
      if ( v3[84] )
      {
        if ( *((_DWORD *)v3 + 189) )
          JUMPOUT(0x838E0LL);
        JUMPOUT(0x8396FLL);
      }
      JUMPOUT(0x839E8LL);
    }
    JUMPOUT(0x83B30LL);
  }
  JUMPOUT(0x839BALL);
}
// 838CD: control flows out of bounds to 838E0
// 83855: control flows out of bounds to 839BA
// 83871: control flows out of bounds to 83B30
// 838A3: control flows out of bounds to 839E8
// 838B2: control flows out of bounds to 8396F
// 9228: using guessed type __int64 __fastcall sub_9228(_QWORD);

//----- (000000000007FA50) ----------------------------------------------------
void __fastcall sub_7FA50(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  if ( *(_DWORD *)(a1 + 8) <= 0xAu )
    __asm { jmp     rax }
  sub_50110(0LL, 0LL, 0LL, "unsupported dlinfo request", a2, a3, a4, a5, a6, a7, a8, a9);
}

//----- (000000000007FB30) ----------------------------------------------------
_BOOL8 __fastcall sub_7FB30(__int64 a1, int a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v15; // [rsp+0h] [rbp-28h] BYREF
  int v16; // [rsp+8h] [rbp-20h]
  __int64 v17; // [rsp+10h] [rbp-18h]
  unsigned __int64 v18; // [rsp+18h] [rbp-10h]

  v18 = __readfsqword(0x28u);
  v15 = a1;
  v16 = a2;
  v17 = a3;
  return -sub_7F870(
            (void (__fastcall *)(__int64))sub_7FA50,
            (__int64)&v15,
            a7,
            a8,
            a9,
            a10,
            a11,
            a12,
            a13,
            a14,
            a3,
            a4,
            a5,
            a6);
}

//----- (000000000007FB90) ----------------------------------------------------
__int64 __fastcall sub_7FB90(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 v9; // rdx
  int v10; // esi
  _BYTE *v12; // rdi
  int v13; // esi
  __int64 v15; // [rsp-10h] [rbp-18h]

  if ( *(_QWORD *)a1 )
    sub_50110(22LL, 0LL, 0LL, "invalid namespace", a2, a3, a4, a5, a6, a7, a8, a9);
  v9 = *(_QWORD *)(a1 + 32);
  v10 = *(_DWORD *)(a1 + 16);
  v12 = *(_BYTE **)(a1 + 8);
  v13 = v10 | 0x80000000;
  if ( !v12 )
    v12 = &unk_A6E65;
  *(_QWORD *)(a1 + 24) = sub_81120(v12, v13, v9, 0LL, (unsigned int)dword_C14E0, qword_C14D8, (__int64)qword_C1270);
  return v15;
}
// 7FBE0: variable 'v15' is possibly undefined
// C14D8: using guessed type __int64 qword_C14D8;
// C14E0: using guessed type int dword_C14E0;

//----- (000000000007FC00) ----------------------------------------------------
__int64 __fastcall sub_7FC00(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 result; // rax
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23[2]; // [rsp+0h] [rbp-38h] BYREF
  int v24; // [rsp+10h] [rbp-28h]
  __int64 v25; // [rsp+18h] [rbp-20h]
  unsigned __int64 v26; // [rsp+20h] [rbp-18h]
  unsigned __int64 v27; // [rsp+28h] [rbp-10h]

  v27 = __readfsqword(0x28u);
  v23[0] = a1;
  v23[1] = a2;
  v24 = a3;
  v26 = a4;
  v16 = sub_7F870(
          (void (__fastcall *)(__int64))sub_7FB90,
          (__int64)v23,
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14,
          a3,
          a4,
          a5,
          a6);
  result = 0LL;
  if ( !(_DWORD)v16 )
  {
    sub_7A160(v25, (__int64)v23, v14, v15, v16, v17);
    sub_7F9E0(v25, (__int64)v23, v19, v20, v21, v22);
    result = v25;
  }
  return result;
}
// 7FC48: variable 'v14' is possibly undefined
// 7FC48: variable 'v15' is possibly undefined
// 7FC48: variable 'v17' is possibly undefined
// 7FC52: variable 'v19' is possibly undefined
// 7FC52: variable 'v20' is possibly undefined
// 7FC52: variable 'v21' is possibly undefined
// 7FC52: variable 'v22' is possibly undefined

//----- (000000000007FC80) ----------------------------------------------------
unsigned __int8 *__fastcall sub_7FC80(unsigned int a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  unsigned __int64 *v9; // rsi
  unsigned int v10; // er14
  __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  u32 *v13; // r8
  __int64 v14; // r9
  unsigned __int8 *v15; // r12
  double v16; // xmm4_8
  double v17; // xmm5_8
  unsigned __int64 *v18; // rbp
  double v19; // xmm4_8
  double v20; // xmm5_8
  unsigned __int64 v22; // r15
  double v23; // xmm4_8
  double v24; // xmm5_8
  const char *v25; // rbp
  unsigned __int64 *v26; // [rsp+0h] [rbp-40h]

  v9 = (unsigned __int64 *)__readfsqword(0xFFFFFFA8);
  v10 = __readfsdword(0xFFFFFFC0);
  v15 = (unsigned __int8 *)sub_68F10(a1);
  if ( v15 )
  {
    v18 = (unsigned __int64 *)sub_83BE0(v9);
    v15 = (unsigned __int8 *)sub_CF50("libc", v15, 5u, a2, a3, a4, a5, v19, v20, a8, a9);
    sub_83BE0(v18);
  }
  else
  {
    v22 = __readfsqword(0x10u);
    sub_21B70(*(_QWORD *)(v22 + 2432), a2, a3, a4, a5, v16, v17, a8, a9, (__int64)v9, v11, v12, v13, v14);
    v26 = (unsigned __int64 *)sub_83BE0(v9);
    v25 = (const char *)sub_CF50("libc", "Unknown error ", 5u, a2, a3, a4, a5, v23, v24, a8, a9);
    sub_83BE0(v26);
    if ( (unsigned int)sub_130A0((__int64 *)(v22 + 2432), (unsigned __int64)"%s%d", v25, a1) == -1 )
      *(_QWORD *)(v22 + 2432) = 0LL;
    else
      v15 = *(unsigned __int8 **)(v22 + 2432);
  }
  __writefsdword(0xFFFFFFC0, v10);
  return v15;
}
// 7FD6A: variable 'v19' is possibly undefined
// 7FD6A: variable 'v20' is possibly undefined
// 7FDA0: variable 'v16' is possibly undefined
// 7FDA0: variable 'v17' is possibly undefined
// 7FDA0: variable 'v11' is possibly undefined
// 7FDA0: variable 'v12' is possibly undefined
// 7FDA0: variable 'v13' is possibly undefined
// 7FDA0: variable 'v14' is possibly undefined
// 7FDC5: variable 'v23' is possibly undefined
// 7FDC5: variable 'v24' is possibly undefined

//----- (000000000007FCA0) ----------------------------------------------------
signed __int64 (__fastcall *sub_7FCA0())(__m128i *a1, const __m128i *a2)
{
  signed __int64 (__fastcall *result)(__m128i *, const __m128i *); // rax

  result = (signed __int64 (__fastcall *)(__m128i *, const __m128i *))&loc_7FE20;
  if ( (BYTE10(xmmword_C1364) & 0x10) != 0 )
    result = sub_7FED0;
  return result;
}
// C1364: using guessed type __int128 xmmword_C1364;

//----- (000000000007FCC0) ----------------------------------------------------
__int64 __fastcall sub_7FCC0(_QWORD *a1, __int64 a2)
{
  __int64 v2; // r12
  _BYTE *v3; // rax

  v2 = *a1;
  if ( !*a1 )
    return v2;
  v3 = (_BYTE *)(v2 + sub_91E0(*a1, a2));
  if ( *v3 )
  {
    *v3 = 0;
    *a1 = v3 + 1;
    return v2;
  }
  *a1 = 0LL;
  return v2;
}
// 91E0: using guessed type __int64 __fastcall sub_91E0(_QWORD, _QWORD);

//----- (000000000007FED0) ----------------------------------------------------
signed __int64 __fastcall sub_7FED0(__m128i *a1, const __m128i *a2)
{
  __int64 v2; // rcx
  const __m128i *v3; // rax
  __int8 *v4; // rax
  int v5; // edx
  __m128i v6; // xmm0
  int v7; // esi
  __m128i v8; // xmm1
  int v9; // ecx
  signed __int64 result; // rax
  __m128i v11; // xmm1
  int v12; // ecx
  __m128i *v13; // rax
  int i; // ecx
  char v15[256]; // [rsp+0h] [rbp-100h] BYREF

  if ( !a2->m128i_i8[0] )
    return 0LL;
  v5 = (unsigned __int8)a2 & 0xF;
  if ( ((unsigned __int8)a2 & 0xF) != 0 )
  {
    v6 = _mm_shuffle_epi8(
           _mm_load_si128((const __m128i *)((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL)),
           _mm_loadu_si128((const __m128i *)((char *)&unk_92860 + ((unsigned __int8)a2 & 0xF))));
    if ( 16 - v5 == _mm_cmpistri(v6, v6, 58) )
    {
      v11 = _mm_load_si128((const __m128i *)(((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL) + 16));
      v12 = _mm_cmpistri(v11, v11, 58);
      if ( v12 + 16 - v5 > 16 )
      {
LABEL_19:
        memset(v15, 0, sizeof(v15));
        v2 = 0LL;
        v3 = a2;
        do
        {
          if ( !v3->m128i_i8[0] )
            break;
          LOBYTE(v2) = v3->m128i_i8[0];
          v15[v2] = v3->m128i_i8[0];
          LOBYTE(v2) = v3->m128i_i8[1];
          if ( !(_BYTE)v2 )
            break;
          v15[v2] = v2;
          LOBYTE(v2) = v3->m128i_i8[2];
          if ( !(_BYTE)v2 )
            break;
          v15[v2] = v2;
          LOBYTE(v2) = v3->m128i_i8[3];
          v3 = (const __m128i *)((char *)v3 + 4);
          v15[v2] = v2;
        }
        while ( (_BYTE)v2 );
        v4 = &a1[-1].m128i_i8[12];
        while ( 1 )
        {
          v4 += 4;
          LOBYTE(v2) = *v4;
          if ( ((unsigned __int8)*v4 & (unsigned __int8)v15[v2]) == 0 )
            return v4 - (__int8 *)a1;
          LOBYTE(v2) = v4[1];
          if ( ((unsigned __int8)v2 & (unsigned __int8)v15[v2]) == 0 )
            goto LABEL_31;
          LOBYTE(v2) = v4[2];
          if ( ((unsigned __int8)v2 & (unsigned __int8)v15[v2]) == 0 )
            goto LABEL_30;
          LOBYTE(v2) = v4[3];
          if ( ((unsigned __int8)v2 & (unsigned __int8)v15[v2]) == 0 )
          {
            ++v4;
LABEL_30:
            ++v4;
LABEL_31:
            ++v4;
            return v4 - (__int8 *)a1;
          }
        }
      }
      if ( v12 )
        v6 = _mm_loadu_si128(a2);
    }
  }
  else
  {
    v6 = _mm_load_si128(a2);
    if ( _mm_cmpistri(v6, v6, 58) == 16 && a2[1].m128i_i8[0] )
      goto LABEL_19;
  }
  v7 = (unsigned __int8)a1 & 0xF;
  if ( ((unsigned __int8)a1 & 0xF) != 0 )
  {
    v8 = _mm_shuffle_epi8(
           _mm_load_si128((const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL)),
           _mm_loadu_si128((const __m128i *)((char *)&unk_92860 + ((unsigned __int8)a1 & 0xF))));
    v9 = _mm_cmpistri(v6, v8, 18);
    result = v9;
    if ( 16 - v7 > v9 || 16 - v7 > _mm_cmpistri(v8, v8, 58) )
      return result;
    v13 = (__m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL) + 16);
  }
  else
  {
    v13 = a1;
  }
  for ( i = _mm_cmpistri(v6, *v13, 18); !_mm_cmpistrc(v6, *v13, 18); i = _mm_cmpistri(v6, *v13, 18) )
    ++v13;
  return &v13->m128i_i8[i] - (__int8 *)a1;
}

//----- (0000000000080000) ----------------------------------------------------
void *sub_80000()
{
  void *result; // rax

  result = sub_80080;
  if ( (dword_C1434 & 0x800) == 0 && (BYTE4(xmmword_C1384) & 0x20) != 0 && (dword_C1434 & 0x100) != 0 )
    result = sub_803B0;
  return result;
}
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (0000000000080030) ----------------------------------------------------
void *sub_80030()
{
  void *v0; // r8

  v0 = sub_483D0;
  if ( (dword_C1434 & 0x800) == 0 && (BYTE4(xmmword_C1384) & 0x20) != 0 && (dword_C1434 & 0x100) != 0 )
  {
    v0 = sub_48550;
    if ( (DWORD1(xmmword_C1384) & 0x10000) != 0 && (dword_C1434 & 0x4000) == 0 )
      v0 = sub_486D0;
  }
  return v0;
}
// C1384: using guessed type __int128 xmmword_C1384;
// C1434: using guessed type int dword_C1434;

//----- (0000000000080080) ----------------------------------------------------
__int64 __fastcall sub_80080(const __m128i *a1, unsigned int a2, __int64 a3)
{
  __m128i v3; // xmm1
  unsigned __int64 v4; // rdx
  unsigned int v5; // ecx
  __m128i v6; // xmm1
  unsigned __int64 v7; // rax
  char v8; // cc
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  const __m128i *v13; // rdi
  unsigned __int64 v14; // rax
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // rdx
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __m128i v21; // xmm4
  __int64 v22; // rax
  char v23; // cl
  __m128i v24; // xmm0
  __m128i v25; // xmm2
  int v26; // eax
  __m128i v27; // xmm3
  __m128i v28; // xmm1
  __int64 v29; // rax
  unsigned __int64 v30; // rdx
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // rdx
  unsigned __int64 v33; // rax
  unsigned __int64 v34; // rdx
  unsigned __int64 v35; // rax

  v3 = _mm_cvtsi32_si128(a2);
  if ( !a3 )
    return 0LL;
  v4 = 4 * a3;
  v5 = (unsigned __int8)a1 & 0x3F;
  v6 = _mm_shuffle_epi32(v3, 0);
  if ( v5 <= 0x30 )
  {
    LODWORD(v7) = _mm_movemask_epi8(_mm_cmpeq_epi32(_mm_loadu_si128(a1), v6));
    if ( (_DWORD)v7 )
      goto LABEL_44;
    v8 = v4 <= 0x10;
    v9 = v4 - 16;
    if ( v8 )
      return 0LL;
    a1 = (const __m128i *)((unsigned __int64)&a1[1] & 0xFFFFFFFFFFFFFFF0LL);
    v10 = (v5 & 0xF) + v9;
    v8 = v10 <= 0x40;
    v11 = v10 - 64;
    if ( v8 )
      goto LABEL_29;
    goto LABEL_12;
  }
  v12 = (unsigned __int8)a1 & 0xF;
  v13 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL);
  LODWORD(v14) = _mm_movemask_epi8(_mm_cmpeq_epi32(_mm_load_si128(v13), v6)) >> v12;
  if ( (_DWORD)v14 )
  {
    _BitScanForward((unsigned int *)&v14, v14);
    if ( v4 > v14 )
      return (__int64)v13 + v14 + v12;
    return 0LL;
  }
  v16 = 16 - v12;
  v8 = v4 <= v16;
  v17 = v4 - v16;
  if ( !v8 )
  {
    a1 = v13 + 1;
    v8 = v17 <= 0x40;
    v11 = v17 - 64;
    if ( v8 )
      goto LABEL_29;
LABEL_12:
    LODWORD(v18) = _mm_movemask_epi8(_mm_cmpeq_epi32(_mm_load_si128(a1), v6));
    if ( (_DWORD)v18 )
      goto LABEL_41;
    LODWORD(v19) = _mm_movemask_epi8(_mm_cmpeq_epi32(_mm_load_si128(a1 + 1), v6));
    if ( (_DWORD)v19 )
      goto LABEL_42;
    LODWORD(v20) = _mm_movemask_epi8(_mm_cmpeq_epi32(_mm_load_si128(a1 + 2), v6));
    if ( (_DWORD)v20 )
      goto LABEL_43;
    v21 = _mm_cmpeq_epi32(_mm_load_si128(a1 + 3), v6);
    a1 += 4;
    LODWORD(v22) = _mm_movemask_epi8(v21);
    if ( (_DWORD)v22 )
      goto LABEL_40;
    if ( ((unsigned __int8)a1 & 0x3F) == 0 )
      goto LABEL_23;
    v8 = v11 <= 0x40;
    v11 -= 64LL;
    if ( !v8 )
    {
      LODWORD(v18) = _mm_movemask_epi8(_mm_cmpeq_epi32(_mm_load_si128(a1), v6));
      if ( (_DWORD)v18 )
        goto LABEL_41;
      LODWORD(v19) = _mm_movemask_epi8(_mm_cmpeq_epi32(_mm_load_si128(a1 + 1), v6));
      if ( (_DWORD)v19 )
        goto LABEL_42;
      LODWORD(v20) = _mm_movemask_epi8(_mm_cmpeq_epi32(_mm_load_si128(a1 + 2), v6));
      if ( !(_DWORD)v20 )
      {
        LODWORD(v22) = _mm_movemask_epi8(_mm_cmpeq_epi32(_mm_load_si128(a1 + 3), v6));
        a1 += 4;
        if ( !(_DWORD)v22 )
        {
          v23 = (char)a1;
          a1 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL);
          v11 += v23 & 0x3F;
LABEL_23:
          while ( 1 )
          {
            v8 = v11 <= 0x40;
            v11 -= 64LL;
            if ( v8 )
              goto LABEL_29;
            v24 = _mm_cmpeq_epi32(_mm_load_si128(a1), v6);
            v25 = _mm_cmpeq_epi32(_mm_load_si128(a1 + 1), v6);
            v26 = _mm_movemask_epi8(
                    _mm_max_epu8(
                      _mm_max_epu8(_mm_cmpeq_epi32(_mm_load_si128(a1 + 3), v6), v25),
                      _mm_max_epu8(_mm_cmpeq_epi32(_mm_load_si128(a1 + 2), v6), v24)));
            a1 += 4;
            if ( v26 )
            {
              a1 -= 4;
              LODWORD(v18) = _mm_movemask_epi8(v24);
              if ( (_DWORD)v18 )
                goto LABEL_41;
              LODWORD(v19) = _mm_movemask_epi8(v25);
              if ( (_DWORD)v19 )
                goto LABEL_42;
              v27 = _mm_cmpeq_epi32(_mm_load_si128(a1 + 2), v6);
              v28 = _mm_cmpeq_epi32(v6, a1[3]);
              LODWORD(v20) = _mm_movemask_epi8(v27);
              if ( (_DWORD)v20 )
                goto LABEL_43;
              _BitScanForward((unsigned int *)&v29, _mm_movemask_epi8(v28));
              return (__int64)&a1[3] + v29;
            }
          }
        }
LABEL_40:
        _BitScanForward((unsigned int *)&v22, v22);
        return (__int64)&a1[-1] + v22;
      }
LABEL_43:
      _BitScanForward((unsigned int *)&v20, v20);
      return (__int64)&a1[2] + v20;
    }
LABEL_29:
    v8 = ((int)v11 + 32 < 0) ^ __OFADD__(32, (_DWORD)v11) | ((_DWORD)v11 == -32);
    v30 = (unsigned int)(v11 + 32);
    if ( !v8 )
    {
      LODWORD(v18) = _mm_movemask_epi8(_mm_cmpeq_epi32(_mm_load_si128(a1), v6));
      if ( !(_DWORD)v18 )
      {
        LODWORD(v19) = _mm_movemask_epi8(_mm_cmpeq_epi32(_mm_load_si128(a1 + 1), v6));
        if ( !(_DWORD)v19 )
        {
          LODWORD(v31) = _mm_movemask_epi8(_mm_cmpeq_epi32(_mm_load_si128(a1 + 2), v6));
          if ( (_DWORD)v31 )
          {
            _BitScanForward((unsigned int *)&v31, v31);
            if ( v30 > v31 )
              return (__int64)&a1[2] + v31;
          }
          else
          {
            v8 = (int)v30 <= 16;
            v32 = (unsigned int)(v30 - 16);
            if ( !v8 )
            {
              LODWORD(v33) = _mm_movemask_epi8(_mm_cmpeq_epi32(v6, a1[3]));
              if ( !(_DWORD)v33 )
                return 0LL;
              _BitScanForward((unsigned int *)&v33, v33);
              if ( v32 > v33 )
                return (__int64)&a1[3] + v33;
            }
          }
          return 0LL;
        }
LABEL_42:
        _BitScanForward((unsigned int *)&v19, v19);
        return (__int64)&a1[1] + v19;
      }
LABEL_41:
      _BitScanForward((unsigned int *)&v18, v18);
      return (__int64)a1 + v18;
    }
    v4 = (unsigned int)(v30 + 32);
    LODWORD(v7) = _mm_movemask_epi8(_mm_cmpeq_epi32(_mm_load_si128(a1), v6));
    if ( !(_DWORD)v7 )
    {
      v8 = (unsigned int)v4 <= 0x10;
      v34 = (unsigned int)(v4 - 16);
      if ( !v8 )
      {
        LODWORD(v35) = _mm_movemask_epi8(_mm_cmpeq_epi32(v6, a1[1]));
        if ( !(_DWORD)v35 )
          return 0LL;
        _BitScanForward((unsigned int *)&v35, v35);
        if ( v34 > v35 )
          return (__int64)&a1[1] + v35;
      }
      return 0LL;
    }
LABEL_44:
    _BitScanForward((unsigned int *)&v7, v7);
    if ( v4 > v7 )
      return (__int64)a1 + v7;
  }
  return 0LL;
}
// 800FF: variable 'v14' is possibly undefined
// 80282: variable 'v29' is possibly undefined
// 80323: variable 'v22' is possibly undefined
// 80333: variable 'v18' is possibly undefined
// 80343: variable 'v19' is possibly undefined
// 80353: variable 'v20' is possibly undefined
// 80366: variable 'v7' is possibly undefined
// 80376: variable 'v35' is possibly undefined
// 80386: variable 'v31' is possibly undefined
// 80396: variable 'v33' is possibly undefined

//----- (00000000000803B0) ----------------------------------------------------
unsigned __int64 __fastcall sub_803B0(unsigned __int64 a1, int _ESI, __int64 a3)
{
  unsigned __int64 v5; // rdx
  unsigned int v7; // ecx
  char v9; // cc
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rdi
  unsigned __int64 result; // rax
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // rdx
  unsigned __int64 v24; // rcx
  unsigned __int64 v33; // rdx
  unsigned __int64 v37; // rdx
  unsigned __int64 v40; // rdx

  if ( !a3 )
    return 0LL;
  __asm { vmovd   xmm0, esi }
  v5 = 4 * a3;
  __asm { vpbroadcastd ymm0, xmm0 }
  v7 = a1 & 0x3F;
  if ( v7 <= 0x20 )
  {
    __asm
    {
      vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
    {
LABEL_31:
      __asm { tzcnt   eax, eax }
      if ( v5 > _RAX )
      {
        result = a1 + _RAX;
        __asm { vzeroupper }
        return result;
      }
      goto LABEL_39;
    }
    v9 = v5 <= 0x20;
    v10 = v5 - 32;
    if ( !v9 )
    {
      a1 = (a1 + 32) & 0xFFFFFFFFFFFFFFE0LL;
      v11 = (v7 & 0x1F) + v10;
      v9 = v11 <= 0x80;
      v12 = v11 - 128;
      if ( v9 )
        goto LABEL_20;
      goto LABEL_12;
    }
    goto LABEL_39;
  }
  v13 = a1 & 0x1F;
  v14 = a1 & 0xFFFFFFFFFFFFFFE0LL;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  _RAX = (unsigned int)(_EAX >> v13);
  if ( (_DWORD)_RAX )
  {
    __asm { tzcnt   eax, eax }
    if ( v5 > _RAX )
    {
      result = v13 + v14 + _RAX;
      __asm { vzeroupper }
      return result;
    }
    goto LABEL_39;
  }
  v18 = 32 - v13;
  v9 = v5 <= v18;
  v19 = v5 - v18;
  if ( v9 )
  {
LABEL_39:
    __asm { vzeroupper }
    return 0LL;
  }
  a1 = v14 + 32;
  v9 = v19 <= 0x80;
  v12 = v19 - 128;
  if ( v9 )
    goto LABEL_20;
LABEL_12:
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_41;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+20h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_42;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+40h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_43;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+60h]
    vpmovmskb eax, ymm1
  }
  if ( !(_DWORD)_RAX )
  {
    a1 += 128LL;
    v9 = v12 <= 0x80;
    v12 -= 128LL;
    if ( !v9 )
    {
      v24 = a1 & 0x7F;
      a1 &= 0xFFFFFFFFFFFFFF80LL;
      v12 += v24;
      while ( 1 )
      {
        __asm
        {
          vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
          vpcmpeqd ymm2, ymm0, ymmword ptr [rdi+20h]
          vpcmpeqd ymm3, ymm0, ymmword ptr [rdi+40h]
          vpcmpeqd ymm4, ymm0, ymmword ptr [rdi+60h]
          vpor    ymm5, ymm2, ymm1
          vpor    ymm6, ymm4, ymm3
          vpor    ymm5, ymm6, ymm5
          vpmovmskb eax, ymm5
        }
        if ( _EAX )
          break;
        a1 += 128LL;
        v9 = v12 <= 0x80;
        v12 -= 128LL;
        if ( v9 )
          goto LABEL_20;
      }
      __asm { vpmovmskb eax, ymm1 }
      if ( !(_DWORD)_RAX )
      {
        __asm { vpmovmskb eax, ymm2 }
        if ( !(_DWORD)_RAX )
        {
          __asm { vpmovmskb eax, ymm3 }
          if ( !(_DWORD)_RAX )
          {
            __asm { vpmovmskb eax, ymm4 }
            goto LABEL_48;
          }
LABEL_43:
          __asm { tzcnt   eax, eax }
          result = a1 + _RAX + 64;
          __asm { vzeroupper }
          return result;
        }
LABEL_42:
        __asm { tzcnt   eax, eax }
        result = a1 + _RAX + 32;
        __asm { vzeroupper }
        return result;
      }
LABEL_41:
      __asm { tzcnt   eax, eax }
      result = a1 + _RAX;
      __asm { vzeroupper }
      return result;
    }
LABEL_20:
    v9 = ((int)v12 + 64 < 0) ^ __OFADD__(64, (_DWORD)v12) | ((_DWORD)v12 == -64);
    v33 = (unsigned int)(v12 + 64);
    if ( !v9 )
    {
      __asm
      {
        vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
        vpmovmskb eax, ymm1
      }
      if ( (_DWORD)_RAX )
        goto LABEL_41;
      __asm
      {
        vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+20h]
        vpmovmskb eax, ymm1
      }
      if ( (_DWORD)_RAX )
        goto LABEL_42;
      __asm
      {
        vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+40h]
        vpmovmskb eax, ymm1
      }
      if ( (_DWORD)_RAX )
      {
        __asm { tzcnt   eax, eax }
        if ( v33 > _RAX )
        {
          result = a1 + _RAX + 64;
          __asm { vzeroupper }
          return result;
        }
      }
      else
      {
        v9 = (int)v33 <= 32;
        v37 = (unsigned int)(v33 - 32);
        if ( !v9 )
        {
          __asm
          {
            vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+60h]
            vpmovmskb eax, ymm1
          }
          if ( !(_DWORD)_RAX )
          {
            result = 0LL;
            __asm { vzeroupper }
            return result;
          }
          __asm { tzcnt   eax, eax }
          if ( v37 > _RAX )
          {
            result = a1 + _RAX + 96;
            __asm { vzeroupper }
            return result;
          }
        }
      }
      goto LABEL_39;
    }
    v5 = (unsigned int)(v33 + 64);
    __asm
    {
      vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( !(_DWORD)_RAX )
    {
      v9 = (int)v5 <= 32;
      v40 = (unsigned int)(v5 - 32);
      if ( !v9 )
      {
        __asm
        {
          vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+20h]
          vpmovmskb eax, ymm1
        }
        if ( !(_DWORD)_RAX )
        {
          result = 0LL;
          __asm { vzeroupper }
          return result;
        }
        __asm { tzcnt   eax, eax }
        if ( v40 > _RAX )
        {
          result = a1 + _RAX + 32;
          __asm { vzeroupper }
          return result;
        }
      }
      goto LABEL_39;
    }
    goto LABEL_31;
  }
LABEL_48:
  __asm { tzcnt   eax, eax }
  result = a1 + _RAX + 96;
  __asm { vzeroupper }
  return result;
}
// 805A7: variable '_RAX' is possibly undefined

//----- (0000000000080680) ----------------------------------------------------
unsigned __int64 __fastcall sub_80680(unsigned int a1, struct linux_dirent64 *a2, unsigned __int64 a3)
{
  unsigned __int64 result; // rax

  if ( a3 > 0x7FFFFFFF )
    LODWORD(a3) = 0x7FFFFFFF;
  result = sys_getdents64(a1, a2, a3);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (00000000000806C0) ----------------------------------------------------
signed __int64 sub_806C0()
{
  return sys_getpid();
}

//----- (00000000000806D0) ----------------------------------------------------
unsigned __int64 __fastcall sub_806D0(unsigned __int64 a1, char *a2, size_t a3, loff_t a4)
{
  unsigned __int64 result; // rax

  result = sys_pread64(a1, a2, a3, a4);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = -1LL;
  }
  return result;
}

//----- (0000000000080710) ----------------------------------------------------
unsigned __int64 __fastcall sub_80710(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 result; // rax

  result = (unsigned int)dword_C18C0 * ((unsigned __int64)(*(_QWORD *)(a3 + 168) - qword_C18C8) >> 17)
         + (((unsigned int)dword_C18C0
           * (unsigned __int64)(unsigned __int16)((unsigned __int64)(*(_QWORD *)(a3 + 168) - qword_C18C8) >> 1)) >> 16);
  if ( result < qword_C18D0 )
    ++*(_WORD *)(qword_C18D8 + 2 * result);
  return result;
}
// C18C0: using guessed type int dword_C18C0;
// C18C8: using guessed type __int64 qword_C18C8;
// C18D0: using guessed type __int64 qword_C18D0;
// C18D8: using guessed type __int64 qword_C18D8;

//----- (0000000000080760) ----------------------------------------------------
__int64 __fastcall sub_80760(__int64 a1, unsigned __int64 a2, __int64 a3, int a4)
{
  struct itimerval v7; // [rsp+0h] [rbp-E8h] BYREF
  __int64 v8[17]; // [rsp+20h] [rbp-C8h] BYREF
  int v9; // [rsp+A8h] [rbp-40h]
  unsigned __int64 v10; // [rsp+B8h] [rbp-30h]

  v10 = __readfsqword(0x28u);
  if ( a1 )
  {
    if ( !qword_C18D8
      || (sub_85B30(2, &stru_C18A0, 0LL) & 0x80000000) == 0LL && (int)sub_5D270(27, (__int64)&unk_C1800, 0LL) >= 0 )
    {
      qword_C18D8 = a1;
      qword_C18D0 = a2 >> 1;
      qword_C18C8 = a3;
      dword_C18C0 = a4;
      v8[0] = (__int64)sub_80710;
      v9 = 268435460;
      v8[1] = -1LL;
      if ( (int)sub_5D270(27, (__int64)v8, (__int64)&unk_C1800) >= 0 )
      {
        v7.it_value.tv_sec = 0LL;
        v7.it_value.tv_usec = 1000000 / (int)sub_80920();
        v7.it_interval = (timeval)_mm_loadu_si128((const __m128i *)&v7.it_value);
        return sub_85B30(2, &v7, &stru_C18A0);
      }
    }
  }
  else
  {
    if ( !qword_C18D8 )
      return 0LL;
    if ( (sub_85B30(2, &stru_C18A0, 0LL) & 0x80000000) == 0LL )
    {
      qword_C18D8 = 0LL;
      return sub_5D270(27, (__int64)&unk_C1800, 0LL);
    }
  }
  return 0xFFFFFFFFLL;
}
// 80920: using guessed type __int64 sub_80920(void);
// C18C0: using guessed type int dword_C18C0;
// C18C8: using guessed type __int64 qword_C18C8;
// C18D0: using guessed type __int64 qword_C18D0;
// C18D8: using guessed type __int64 qword_C18D8;

//----- (0000000000080920) ----------------------------------------------------
__int64 sub_80920()
{
  return (unsigned int)dword_C12C0;
}
// 80920: using guessed type __int64 __fastcall sub_80920();
// C12C0: using guessed type int dword_C12C0;

//----- (0000000000080930) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_80930(__int64 a1, unsigned int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10))(unsigned __int8 *, __int64 *, __int64)
{
  unsigned __int8 *v11; // rdi
  __int64 *v12; // rsi
  unsigned __int64 v13; // rcx
  __int64 v14; // rbx
  unsigned int *v15; // rax
  __int64 v16; // r8
  __int64 (__fastcall **v17)(unsigned __int8 *, __int64 *, __int64); // rbx
  __int64 v18; // r8
  int v19; // edx
  u32 *v20; // r8
  __int64 *v21; // r9
  __int64 v22; // rdx
  __int64 (__fastcall *v23)(unsigned __int8 *, __int64 *, __int64); // r8
  volatile __int32 *v25; // rax
  signed __int64 v26; // rax
  __int64 v27; // [rsp-10h] [rbp-28h]
  unsigned int *v28; // [rsp+8h] [rbp-10h] BYREF

  v11 = *(unsigned __int8 **)(*(_QWORD *)(a1 + 104) + 8LL);
  v12 = (__int64 *)(*(_QWORD *)(*(_QWORD *)(a1 + 248) + 8LL) + 24LL * a2);
  v13 = v12[1];
  v14 = *v12;
  v15 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8LL) + 24 * HIDWORD(v13));
  v16 = *(_QWORD *)a1;
  v28 = v15;
  v17 = (__int64 (__fastcall **)(unsigned __int8 *, __int64 *, __int64))(v16 + v14);
  if ( (_DWORD)v13 != 7 )
    sub_CF00("ELFW(R_TYPE)(reloc->r_info) == ELF_MACHINE_JMP_SLOT", "dl-runtime.c", 77LL, "_dl_fixup");
  if ( (*((_BYTE *)v15 + 5) & 3) != 0 )
  {
    v22 = 0LL;
    if ( *((_WORD *)v15 + 3) == 0xFFF1 )
      v16 = 0LL;
    goto LABEL_13;
  }
  v18 = *(_QWORD *)(a1 + 464);
  if ( v18 )
  {
    v18 = *(_QWORD *)(a1 + 744) + 24LL * (*(_WORD *)(*(_QWORD *)(v18 + 8) + 2 * HIDWORD(v13)) & 0x7FFF);
    if ( !*(_DWORD *)(v18 + 8) )
      v18 = 0LL;
  }
  v19 = 1;
  if ( __readfsdword(0x18u) )
  {
    __writefsdword(0x1Cu, 1u);
    v19 = 5;
  }
  v12 = (__int64 *)a1;
  v11 += *v15;
  v21 = (__int64 *)sub_73690(
                     v11,
                     a1,
                     &v28,
                     *(__int64 ***)(a1 + 912),
                     (const char **)v18,
                     1,
                     a3,
                     a4,
                     a5,
                     a6,
                     a7,
                     a8,
                     a9,
                     a10,
                     v19,
                     0LL);
  v22 = v27;
  if ( __readfsdword(0x18u) )
  {
    LODWORD(v25) = _InterlockedExchange(MK_FP(0, 28LL), 0);
    if ( (_DWORD)v25 == 2 )
    {
      v11 = (unsigned __int8 *)(__readfsqword(0x10u) + 28);
      v12 = &qword_80 + 1;
      v26 = sys_futex((u32 *)v11, 129, 1u, 0LL, v20, (u32)v21);
    }
  }
  v15 = v28;
  v23 = 0LL;
  if ( v28 )
  {
    if ( *((_WORD *)v28 + 3) == 0xFFF1 || !v21 )
      v16 = 0LL;
    else
      v16 = *v21;
LABEL_13:
    v23 = (__int64 (__fastcall *)(unsigned __int8 *, __int64 *, __int64))(*((_QWORD *)v15 + 1) + v16);
    if ( (v15[1] & 0xF) == 10 )
      v23 = (__int64 (__fastcall *)(unsigned __int8 *, __int64 *, __int64))v23(v11, v12, v22);
  }
  if ( !dword_C1478 )
    *v17 = v23;
  return v23;
}
// 80A12: variable 'v27' is possibly undefined
// 80A2F: variable 'v21' is possibly undefined
// 80A68: variable 'v22' is possibly undefined
// 80AAE: variable 'v20' is possibly undefined
// 80: using guessed type __int64 qword_80;
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// C1478: using guessed type int dword_C1478;

//----- (0000000000080AF0) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_80AF0(__int64 a1, unsigned int a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, _QWORD *a13))(unsigned __int8 *, __int64 *, __int64)
{
  __int64 v14; // rbx
  __int64 v16; // rbx
  __int64 v17; // rdx
  unsigned __int64 v18; // rsi
  unsigned int *v19; // rax
  __int64 v20; // r8
  int v21; // ecx
  __int64 **v22; // rcx
  u32 *v23; // r8
  u32 v24; // er9
  __int64 (__fastcall *v25)(__int64, unsigned __int64, __int64); // r13
  __int64 v26; // r13
  volatile __int32 *v28; // rax
  signed __int64 v29; // rax
  int v30; // [rsp-10h] [rbp-48h]
  __int64 v31; // [rsp-10h] [rbp-48h]
  unsigned int *v32; // [rsp+8h] [rbp-30h] BYREF

  v14 = *(_QWORD *)(a1 + 824);
  if ( v14 )
  {
    v16 = 32LL * a2 + v14;
    if ( *(_DWORD *)(v16 + 28) )
    {
      v25 = *(__int64 (__fastcall **)(__int64, unsigned __int64, __int64))v16;
LABEL_20:
      *a13 = -1LL;
      sub_77C60(a3, (__int64)v25);
      return (__int64 (__fastcall *)(unsigned __int8 *, __int64 *, __int64))v25;
    }
    v17 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + 8LL);
    v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 248) + 8LL) + 24LL * a2 + 8);
    v19 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8LL) + 24 * HIDWORD(v18));
    v32 = v19;
    if ( (_DWORD)v18 != 7 )
      sub_CF00("ELFW(R_TYPE)(reloc->r_info) == ELF_MACHINE_JMP_SLOT", "dl-runtime.c", 232LL, "_dl_profile_fixup");
    if ( (*((_BYTE *)v19 + 5) & 3) != 0 )
    {
      if ( *((_WORD *)v19 + 3) != 0xFFF1 )
      {
        v26 = *(_QWORD *)a1;
LABEL_15:
        v25 = (__int64 (__fastcall *)(__int64, unsigned __int64, __int64))(*((_QWORD *)v19 + 1) + v26);
        if ( (v19[1] & 0xF) == 10 )
          v25 = (__int64 (__fastcall *)(__int64, unsigned __int64, __int64))v25(a1, v18, v17);
LABEL_17:
        if ( !dword_C1478 )
        {
          *(_QWORD *)v16 = v25;
          *(_DWORD *)(v16 + 28) = 1;
        }
        goto LABEL_20;
      }
    }
    else
    {
      v20 = *(_QWORD *)(a1 + 464);
      if ( v20 )
      {
        v20 = *(_QWORD *)(a1 + 744) + 24LL * (*(_WORD *)(*(_QWORD *)(v20 + 8) + 2 * HIDWORD(v18)) & 0x7FFF);
        if ( !*(_DWORD *)(v20 + 8) )
          v20 = 0LL;
      }
      v21 = 1;
      if ( __readfsdword(0x18u) )
      {
        __writefsdword(0x1Cu, 1u);
        v21 = 5;
      }
      v30 = v21;
      v18 = a1;
      v22 = *(__int64 ***)(a1 + 912);
      a1 = v17 + *v19;
      v23 = (u32 *)sub_73690(
                     (unsigned __int8 *)a1,
                     v18,
                     &v32,
                     v22,
                     (const char **)v20,
                     1,
                     a4,
                     a5,
                     a6,
                     a7,
                     a8,
                     a9,
                     a10,
                     a11,
                     v30,
                     0LL);
      v17 = v31;
      if ( __readfsdword(0x18u) )
      {
        LODWORD(v28) = _InterlockedExchange(MK_FP(0, 28LL), 0);
        if ( (_DWORD)v28 == 2 )
        {
          a1 = __readfsqword(0x10u) + 28;
          v18 = 129LL;
          v29 = sys_futex((u32 *)a1, 129, 1u, 0LL, v23, v24);
        }
      }
      v19 = v32;
      v25 = 0LL;
      if ( !v32 )
        goto LABEL_17;
      if ( *((_WORD *)v32 + 3) != 0xFFF1 && v23 )
      {
        v26 = *(_QWORD *)v23;
        goto LABEL_15;
      }
    }
    v26 = 0LL;
    goto LABEL_15;
  }
  *a13 = -1LL;
  return sub_80930(a1, a2, a4, a5, a6, a7, a8, a9, a10, a11);
}
// 80BFD: variable 'v31' is possibly undefined
// 80C1E: variable 'v23' is possibly undefined
// 80CA0: variable 'v17' is possibly undefined
// 80D12: variable 'v24' is possibly undefined
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// C1478: using guessed type int dword_C1478;

//----- (0000000000080D40) ----------------------------------------------------
void sub_80D40()
{
  ;
}

//----- (0000000000080D50) ----------------------------------------------------
_DWORD *__fastcall sub_80D50(__int64 a1)
{
  __int64 v1; // r15
  void **v2; // rax
  unsigned int v3; // er12
  unsigned int v4; // ebx
  __int64 v5; // rdx
  char v6; // al
  void **v7; // rax
  __int64 v8; // rcx
  void **v9; // rdx
  unsigned int v10; // ecx
  int v11; // eax
  void **v12; // rdx
  _DWORD *result; // rax

  v1 = *(_QWORD *)(a1 + 48);
  v2 = &off_BF0E0 + 19 * v1;
  v3 = *((_DWORD *)v2[2] + 2);
  if ( *(_DWORD *)(a1 + 712) )
  {
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)(*(_QWORD *)(a1 + 704) + 8LL * v4);
      v6 = *(_BYTE *)(v5 + 796);
      if ( (v6 & 0x10) == 0 )
      {
        *(_BYTE *)(v5 + 796) = v6 | 0x10;
        v7 = &off_BF0E0 + 19 * v1;
        if ( *((_DWORD *)v7 + 6) <= v3 )
          sub_CF00("new_nlist < ns->_ns_global_scope_alloc", "dl-open.c", 183LL, "add_to_global_update");
        v8 = v3++;
        *(_QWORD *)(*(_QWORD *)v7[2] + 8 * v8) = v5;
        if ( (dword_C14B4 & 0x200) != 0 )
          sub_76EA0("\nadd %s [%lu] to global scope\n", *(const char **)(v5 + 8), *(_QWORD *)(v5 + 48));
      }
      ++v4;
    }
    while ( *(_DWORD *)(a1 + 712) > v4 );
    v9 = &off_BF0E0 + 19 * v1;
    v10 = *((_DWORD *)v9 + 7);
    v11 = *((_DWORD *)v9[2] + 2);
    if ( v10 < v3 - v11 )
      sub_CF00("added <= ns->_ns_global_scope_pending_adds", "dl-open.c", 197LL, "add_to_global_update");
  }
  else
  {
    v10 = *((_DWORD *)v2 + 7);
    v11 = *((_DWORD *)v2[2] + 2);
  }
  v12 = &off_BF0E0 + 19 * v1;
  *((_DWORD *)v12 + 7) = v10 + v11 - v3;
  result = v12[2];
  result[2] = v3;
  return result;
}
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// BF0E0: using guessed type void *off_BF0E0;
// C14B4: using guessed type int dword_C14B4;

//----- (0000000000080EB0) ----------------------------------------------------
__int64 __fastcall sub_80EB0(__int64 *a1)
{
  __int64 v1; // r14
  __int64 v2; // r13
  __int64 v3; // r12
  unsigned int v4; // ebp
  __int64 v5; // rbx
  __int64 v6; // r15
  __int64 result; // rax
  __int64 v8; // rbx
  __int64 v9; // rdi
  __int64 v10; // r15
  void (__fastcall **v11)(_QWORD, __int64, __int64); // rax
  void (__fastcall **v12)(_QWORD, __int64, __int64); // rbx
  __int64 v13; // r15
  char v14; // al
  const char *v15; // rsi

  v1 = *a1;
  v2 = a1[3];
  v3 = a1[2];
  v4 = *((_DWORD *)a1 + 2);
  v5 = *(_QWORD *)(*a1 + 320);
  v6 = *(_QWORD *)(*a1 + 328);
  if ( qword_C1310 )
  {
    v14 = *(_BYTE *)(*(_QWORD *)(qword_C1310 + 40) + 796LL);
    if ( (v14 & 4) == 0 && (v14 & 3) != 0 )
      goto LABEL_27;
    if ( (*(_BYTE *)(qword_C1310 + 796) & 8) == 0 )
      sub_86CD0(qword_C1310, *((_DWORD *)a1 + 2), a1[2], a1[3]);
    qword_C1310 = 0LL;
  }
  if ( v5 )
  {
    if ( v6 )
    {
      v10 = *(_QWORD *)(v6 + 8) >> 3;
      if ( (_DWORD)v10 )
      {
        if ( (dword_C14B4 & 2) != 0 )
        {
          v15 = *(const char **)(v1 + 8);
          if ( !*v15 )
          {
            v15 = (const char *)off_BEFD8;
            if ( !off_BEFD8 )
              v15 = "<main program>";
          }
          sub_76EA0("\ncalling preinit: %s\n\n", v15);
        }
        v11 = (void (__fastcall **)(_QWORD, __int64, __int64))(*(_QWORD *)(v5 + 8) + *(_QWORD *)v1);
        v12 = v11 + 1;
        v13 = (__int64)&v11[(unsigned int)(v10 - 1) + 1];
        while ( 1 )
        {
          (*v11)(v4, v3, v2);
          v11 = v12;
          if ( (void (__fastcall **)(_QWORD, __int64, __int64))v13 == v12 )
            break;
          ++v12;
        }
      }
    }
  }
  result = *(unsigned int *)(v1 + 712);
  if ( (_DWORD)result )
  {
    v8 = 8LL * (unsigned int)(result - 1);
    while ( 1 )
    {
      v9 = *(_QWORD *)(*(_QWORD *)(v1 + 968) + v8);
      result = *(unsigned __int8 *)(*(_QWORD *)(v9 + 40) + 796LL);
      if ( (result & 4) == 0 && (result & 3) != 0 )
        break;
      if ( (*(_BYTE *)(v9 + 796) & 8) == 0 )
        result = sub_86CD0(v9, v4, v3, v2);
      v8 -= 8LL;
      if ( v8 == -8 )
        return result;
    }
LABEL_27:
    sub_CF00("l->l_real->l_relocated || l->l_real->l_type == lt_executable", "dl-init.c", 35LL, "call_init");
  }
  return result;
}
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// BEFD8: using guessed type void *off_BEFD8;
// C1310: using guessed type __int64 qword_C1310;
// C14B4: using guessed type int dword_C14B4;

//----- (0000000000080ED0) ----------------------------------------------------
void __fastcall __noreturn sub_80ED0(_BYTE **a1)
{
  sub_50110(12LL, *a1, 0LL, "cannot extend global scope");
}

//----- (0000000000080EF0) ----------------------------------------------------
unsigned __int64 __fastcall sub_80EF0(__int64 a1)
{
  __int64 v2; // rbx
  int v3; // edx
  unsigned int v4; // esi
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // rdx
  __int64 v8; // rdi
  int v9; // ecx
  bool v10; // cf
  void **v11; // rax
  const void **v12; // r13
  unsigned __int64 result; // rax
  __int64 v14; // r14
  unsigned __int64 v15; // rcx
  __int64 v16; // rcx
  unsigned int v17; // er15
  const void *v18; // r8
  unsigned __int64 v19; // rcx
  void *v20; // rax
  const void *v21; // rsi
  void *v22; // rdi
  __int64 v23; // rdx
  void *v24; // rcx
  const void *v25; // [rsp+8h] [rbp-40h]

  v2 = *(_QWORD *)(a1 + 48);
  v3 = *(_DWORD *)(a1 + 712);
  v4 = *((_DWORD *)&off_BF0E0 + 38 * v2 + 7);
  if ( v3 )
  {
    v5 = *(_QWORD *)(a1 + 704);
    v6 = (unsigned int)(v3 - 1);
    v7 = v5 + 8;
    v8 = v5 + 8 + 8 * v6;
    v9 = 0;
    while ( 1 )
    {
      v10 = (*(_BYTE *)(*(_QWORD *)v5 + 796LL) & 0x10) == 0;
      v5 = v7;
      v9 += v10;
      if ( v8 == v7 )
        break;
      v7 += 8LL;
    }
    v10 = __CFADD__(v4, v9);
    v4 += v9;
    *((_DWORD *)&off_BF0E0 + 38 * v2 + 7) = v4;
    if ( v10 )
      goto LABEL_18;
  }
  v11 = &off_BF0E0 + 19 * v2;
  v12 = (const void **)v11[2];
  result = *((unsigned int *)v11 + 6);
  v14 = *((unsigned int *)v12 + 2);
  v15 = v14 + v4;
  if ( (_DWORD)result )
  {
    if ( result >= v15 )
      return result;
    v16 = 2 * v15;
    result = (unsigned int)v16;
    v17 = v16;
    if ( v16 == (unsigned int)v16 )
    {
      v18 = *v12;
      if ( !(_DWORD)v16 )
        return result;
      goto LABEL_13;
    }
LABEL_18:
    sub_80ED0(*(_BYTE ***)(a1 + 56));
  }
  v19 = v15 + 8;
  result = (unsigned int)v19;
  v17 = v19;
  if ( v19 != (unsigned int)v19 )
    goto LABEL_18;
  v18 = 0LL;
  if ( !(_DWORD)v19 )
    return result;
LABEL_13:
  v25 = v18;
  v20 = (void *)sub_21500(8LL * v17);
  if ( !v20 )
    goto LABEL_18;
  v21 = *v12;
  v22 = v20;
  v24 = memcpy(v20, *v12, 8 * v14);
  *((_DWORD *)&off_BF0E0 + 38 * v2 + 6) = v17;
  *v12 = v24;
  if ( !__readfsdword(0x18u) )
    return sub_21B70(v25);
  qword_C12E0(v22, v21, v23, v24, v25);
  return sub_21B70(v25);
}
// 81051: variable 'v23' is possibly undefined
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// BF0E0: using guessed type void *off_BF0E0;
// C12E0: using guessed type __int64 (__fastcall *qword_C12E0)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000081070) ----------------------------------------------------
_QWORD *__fastcall sub_81070(unsigned __int64 a1)
{
  _QWORD *v1; // r12

  if ( !qword_BF088 )
    return 0LL;
  v1 = off_BF0E0;
  if ( !off_BF0E0 )
    return 0LL;
  while ( v1[106] > a1
       || v1[107] <= a1
       || (*((_BYTE *)v1 + 797) & 0x40) == 0 && !(unsigned int)sub_83B60((__int64)v1, a1) )
  {
    v1 = (_QWORD *)v1[3];
    if ( !v1 )
      return 0LL;
  }
  if ( v1[6] )
    sub_CF00("ns == l->l_ns", "dl-open.c", 219LL, "_dl_find_dso_for_object");
  return v1;
}
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// BF088: using guessed type __int64 qword_BF088;
// BF0E0: using guessed type void *off_BF0E0;

//----- (0000000000081120) ----------------------------------------------------
__int64 __fastcall sub_81120(_BYTE *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  unsigned int v9; // er13
  __int64 v10; // rdx
  __int64 v11; // rsi
  __m128i v13[2]; // [rsp+0h] [rbp-A8h] BYREF
  _BYTE *v14; // [rsp+20h] [rbp-88h] BYREF
  int v15; // [rsp+28h] [rbp-80h]
  __int64 v16; // [rsp+30h] [rbp-78h]
  __int64 v17; // [rsp+38h] [rbp-70h]
  __int64 v18; // [rsp+40h] [rbp-68h]
  int v19; // [rsp+48h] [rbp-60h]
  char v20; // [rsp+4Ch] [rbp-5Ch]
  int v21; // [rsp+50h] [rbp-58h]
  __int64 v22; // [rsp+58h] [rbp-50h]
  __int64 v23; // [rsp+60h] [rbp-48h]

  if ( (a2 & 3) == 0 )
    sub_50110(22LL, a1, 0LL, "invalid mode for dlopen()");
  if ( a4 == -1 )
    sub_50110(22LL, a1, 0LL, "no more namespaces available for dlmopen()");
  if ( ((a4 + 2) & 0xFFFFFFFFFFFFFFFDLL) != 0 )
    sub_50110(22LL, a1, 0LL, "invalid target namespace in dlmopen()");
  v14 = a1;
  v22 = a6;
  v15 = a2;
  v16 = a3;
  v17 = 0LL;
  v18 = a4;
  v21 = a5;
  v23 = a7;
  v9 = sub_50170((__int64)v13, (void (__fastcall *)(__int64))sub_814C0, (__int64)&v14, a4, a5, a6);
  sub_79A50();
  v11 = v18;
  if ( v18 >= 0 )
  {
    v10 = 19 * v18;
    *((_DWORD *)&off_BF0E0 + 38 * v18 + 7) = v19;
  }
  if ( v13[0].m128i_i64[1] )
  {
    if ( !v20 )
    {
      v10 = 19 * a4;
      *(&off_BF0E0 + 19 * a4 + 4) = 0LL;
    }
    if ( v17 )
    {
      if ( (a2 & 0x8000000) == 0 )
        byte_C0380 = 1;
      sub_82030(v17, 1LL, v10);
      v11 = v18;
    }
    if ( !*((_DWORD *)sub_4D270(0LL, v11) + 6) )
      sub_500B0(v9, v13, 0LL);
    sub_CF00("_dl_debug_initialize (0, args.nsid)->r_state == RT_CONSISTENT", "dl-open.c", 913LL, "_dl_open");
  }
  if ( *((_DWORD *)sub_4D270(0LL, v11) + 6) )
    sub_CF00("_dl_debug_initialize (0, args.nsid)->r_state == RT_CONSISTENT", "dl-open.c", 922LL, "_dl_open");
  return v17;
}
// 812AE: variable 'v10' is possibly undefined
// 9228: using guessed type __int64 __fastcall sub_9228(_QWORD);
// 9248: using guessed type __int64 __fastcall sub_9248(_QWORD);
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// 79A50: using guessed type __int64 sub_79A50(void);
// BF0E0: using guessed type void *off_BF0E0;
// C0380: using guessed type char byte_C0380;

//----- (0000000000081380) ----------------------------------------------------
signed __int64 __fastcall sub_81380(_QWORD *a1, unsigned int a2)
{
  const char *v3; // rsi
  __int64 v4; // rax
  __int64 v5; // rbp
  __int64 v6; // rdx
  unsigned int v7; // ebx
  const char *v8; // rsi

  v3 = (const char *)a1[1];
  if ( !*v3 )
  {
    v3 = (const char *)off_BEFD8;
    if ( !off_BEFD8 )
      v3 = "<main program>";
  }
  sub_76EA0("object=%s [%lu]\n", v3, a1[6]);
  v4 = a1[114];
  if ( v4 )
  {
    v5 = 8LL * (int)a2;
    if ( *(_QWORD *)(v4 + v5) )
    {
      do
      {
        sub_76EA0(" scope %u:", a2);
        v6 = *(_QWORD *)(a1[114] + v5);
        if ( *(_DWORD *)(v6 + 8) )
        {
          v7 = 0;
          do
          {
            v8 = *(const char **)(*(_QWORD *)(*(_QWORD *)v6 + 8LL * v7) + 8LL);
            if ( !*v8 )
            {
              v8 = (const char *)off_BEFD8;
              if ( !off_BEFD8 )
                v8 = "<program name unknown>";
            }
            ++v7;
            sub_76F50(" %s", v8);
            v6 = *(_QWORD *)(a1[114] + v5);
          }
          while ( *(_DWORD *)(v6 + 8) > v7 );
        }
        v5 += 8LL;
        ++a2;
        sub_76F50((_BYTE *)&off_8FB58 + 2);
      }
      while ( *(_QWORD *)(a1[114] + v5) );
    }
  }
  else
  {
    sub_76EA0(" no scope\n");
  }
  return sub_76EA0((_BYTE *)&off_8FB58 + 2);
}
// 8FB58: using guessed type void *off_8FB58;
// BEFD8: using guessed type void *off_BEFD8;

//----- (00000000000814C0) ----------------------------------------------------
__int64 __fastcall sub_814C0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  _BYTE *v10; // r14
  _QWORD *v11; // r13
  _QWORD *v12; // rbp
  __int64 v13; // r13
  void **v14; // rax
  bool v15; // zf
  double v16; // xmm4_8
  double v17; // xmm5_8
  __int64 result; // rax
  __int64 v19; // r15
  __int64 v20; // rcx
  unsigned int v21; // ebp
  __int64 v22; // rcx
  u32 *v23; // r8
  __int64 v24; // r9
  double v25; // xmm4_8
  double v26; // xmm5_8
  _QWORD *v27; // rdi
  __int64 v28; // rsi
  unsigned __int64 *v29; // rdx
  __int64 v30; // rcx
  int v31; // er8
  void (*v32)(void); // r9
  double v33; // xmm4_8
  double v34; // xmm5_8
  int v35; // er14
  __int64 **v36; // rsi
  unsigned int v37; // eax
  u32 *v38; // r8
  unsigned int v39; // ecx
  __int64 *v40; // rdx
  unsigned int v41; // edi
  unsigned int v42; // edx
  int v43; // er13
  __int64 v44; // r12
  unsigned __int64 v45; // rbp
  __int64 v46; // rdi
  unsigned int v47; // er14
  unsigned int v48; // eax
  __int64 v49; // r12
  __int64 *v50; // rax
  __int64 **v51; // rdx
  __int64 *v52; // rdx
  unsigned __int64 v53; // rdx
  unsigned __int64 v54; // rax
  __int64 **v55; // rbp
  void *v56; // rdi
  void *v57; // rax
  __int64 v58; // r11
  int v59; // eax
  char v60; // bp
  unsigned int v61; // er14
  __int64 v62; // rdi
  void **v63; // rcx
  __int64 i; // r14
  unsigned int v65; // er12
  unsigned int v66; // er14
  __int64 v67; // r8
  __int64 v68; // rdi
  __int64 ***v69; // r10
  __int64 **v70; // rax
  __int64 ***v71; // rdx
  __int64 **v72; // rax
  __int64 v73; // rdx
  unsigned __int64 v74; // rax
  unsigned int v75; // ebp
  __int64 v76; // r14
  __int64 v77; // rbp
  __int64 v78; // rax
  unsigned int v79; // [rsp+Ch] [rbp-7Ch]
  unsigned int v80; // [rsp+Ch] [rbp-7Ch]
  __int64 v81; // [rsp+18h] [rbp-70h]
  unsigned __int64 v82; // [rsp+28h] [rbp-60h]
  __int64 v83; // [rsp+30h] [rbp-58h] BYREF
  int v84; // [rsp+38h] [rbp-50h]
  __int64 v85; // [rsp+40h] [rbp-48h]
  __int64 v86; // [rsp+48h] [rbp-40h]

  v10 = *(_BYTE **)a1;
  v79 = *(_DWORD *)(a1 + 8);
  if ( sub_9210(*(_QWORD *)a1, 36LL) || (v13 = *(_QWORD *)(a1 + 32), v13 == -2) || (v12 = 0LL, !sub_9210(v10, 47LL)) )
  {
    v11 = off_BF0E0;
    v12 = sub_81070(*(_QWORD *)(a1 + 16));
    if ( !v12 )
      v12 = v11;
    v13 = *(_QWORD *)(a1 + 32);
    if ( v13 == -2 )
    {
      v13 = v12[6];
      *(_QWORD *)(a1 + 32) = v13;
    }
  }
  v14 = &off_BF0E0 + 19 * v13;
  v15 = v14[4] == 0LL;
  LODWORD(v14) = *((_DWORD *)v14 + 7);
  *(_BYTE *)(a1 + 44) = !v15;
  *(_DWORD *)(a1 + 40) = (_DWORD)v14;
  sub_4D270(0LL, v13);
  result = sub_71D90((__int64)v12, v10, 2, 0, v79 | 0x10000000, *(_QWORD *)(a1 + 32), a2, a3, a4, a5, v16, v17, a8, a9);
  *(_QWORD *)(a1 + 24) = result;
  v19 = result;
  if ( !result )
  {
    if ( (v79 & 4) == 0 )
      sub_CF00("mode & RTLD_NOLOAD", "dl-open.c", 533LL, "dl_open_worker");
    return result;
  }
  result = v79;
  if ( (v79 & 0x40000000) != 0 )
    return result;
  v20 = (unsigned int)(*(_DWORD *)(v19 + 792) + 1);
  v15 = *(_QWORD *)(v19 + 704) == 0LL;
  *(_DWORD *)(v19 + 792) = v20;
  if ( !v15 )
  {
    if ( (dword_C14B4 & 0x40) != 0 )
      sub_76EA0("opening file=%s [%lu]; direct_opencount=%u\n\n", *(const char **)(v19 + 8), *(_QWORD *)(v19 + 48), v20);
    if ( (v79 & 0x100) == 0 )
    {
      if ( (v79 & 0x1000) != 0 )
      {
        if ( (dword_C14B4 & 0x40) != 0 && !*(_BYTE *)(v19 + 799) )
          sub_76EA0("marking %s [%lu] as NODELETE\n", *(const char **)(v19 + 8), *(_QWORD *)(v19 + 48));
        *(_BYTE *)(v19 + 799) = 1;
      }
      goto LABEL_124;
    }
    if ( (*(_BYTE *)(v19 + 796) & 0x10) != 0 )
    {
      if ( (v79 & 0x1000) == 0 )
      {
LABEL_124:
        result = (__int64)sub_4D270(0LL, *(_QWORD *)(a1 + 32));
        if ( *(_DWORD *)(result + 24) )
          sub_CF00(
            "_dl_debug_initialize (0, args->nsid)->r_state == RT_CONSISTENT",
            "dl-open.c",
            573LL,
            "dl_open_worker");
        return result;
      }
    }
    else
    {
      sub_80EF0(v19);
      if ( (v79 & 0x1000) == 0 )
      {
LABEL_119:
        if ( (*(_BYTE *)(v19 + 796) & 0x10) == 0 )
          sub_80D50(v19);
        goto LABEL_124;
      }
    }
    if ( (dword_C14B4 & 0x40) != 0 && !*(_BYTE *)(v19 + 799) )
      sub_76EA0("marking %s [%lu] as NODELETE\n", *(const char **)(v19 + 8), *(_QWORD *)(v19 + 48));
    *(_BYTE *)(v19 + 799) = 1;
    goto LABEL_119;
  }
  if ( (v79 & 0x1000) != 0 )
    *(_BYTE *)(v19 + 800) = 1;
  v21 = 0;
  sub_85C30(v19, 0LL, 0, 0, v79 & 0x88000008);
  if ( *(_DWORD *)(v19 + 712) )
  {
    do
    {
      while ( 1 )
      {
        v27 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)(v19 + 704) + 8LL * v21) + 40LL);
        if ( !v27[93] )
          break;
        if ( *(_DWORD *)(v19 + 712) <= ++v21 )
          goto LABEL_16;
      }
      ++v21;
      sub_86F50(v27, 0, 0, v22, v23, v24, a2, a3, a4, a5, v25, v26, a8, a9);
    }
    while ( *(_DWORD *)(v19 + 712) > v21 );
  }
LABEL_16:
  v28 = *(_QWORD *)(a1 + 32);
  *((_DWORD *)sub_4D270(0LL, v28) + 6) = 0;
  sub_4D260();
  sub_83570(v19, v28, v29, v30, v31);
  if ( (dword_C14B4 & 0x200) != 0 )
    sub_81380((_QWORD *)v19, 0);
  v35 = v79 & 0x8000001;
  if ( !dword_C14B0 )
    v35 = v79 & 0x8000000;
  v36 = *(__int64 ***)(v19 + 968);
  v37 = 0;
  v38 = 0LL;
  v39 = -1;
  v40 = *v36;
  do
  {
    v41 = v37++;
    if ( (*(_BYTE *)(v40[5] + 796) & 4) == 0 )
    {
      v38 = (u32 *)v37;
      if ( v39 == -1 )
        v39 = v41;
    }
    v40 = v36[v37];
  }
  while ( v40 );
  v42 = (_DWORD)v38 - 1;
  if ( v39 >= (unsigned int)v38 )
  {
    v43 = 0;
  }
  else
  {
    v43 = 0;
    v44 = 8LL * v42;
    v45 = 8 * (v42 - (unsigned __int64)(v42 - v39));
    while ( 1 )
    {
      v46 = (__int64)v36[(unsigned __int64)v44 / 8];
      if ( (*(_BYTE *)(*(_QWORD *)(v46 + 40) + 796LL) & 4) == 0 )
      {
        v36 = *(__int64 ***)(v46 + 912);
        v43 = 1;
        sub_74900(v46, v36, v35, 0, v38, v32, a2, a3, a4, a5, v33, v34, a8, a9);
      }
      if ( v45 == v44 )
        break;
      v36 = *(__int64 ***)(v19 + 968);
      v44 -= 8LL;
    }
  }
  v47 = 0;
  if ( !*(_DWORD *)(v19 + 712) )
    goto LABEL_122;
  do
  {
    v49 = *(_QWORD *)(*(_QWORD *)(v19 + 704) + 8LL * v47);
    if ( (*(_BYTE *)(v49 + 796) & 0xB) == 10 )
    {
      v36 = *(__int64 ***)(v49 + 912);
      v50 = *v36;
      if ( *v36 )
      {
        v51 = v36 + 1;
        while ( v50 != (__int64 *)(v19 + 704) )
        {
          v50 = *v51++;
          if ( !v50 )
          {
            do
            {
              v52 = v50;
              v50 = (__int64 *)((char *)v50 + 1);
            }
            while ( v36[(_QWORD)v50] );
            v53 = (unsigned __int64)v52 + 2;
            goto LABEL_41;
          }
        }
      }
      else
      {
        v53 = 1LL;
LABEL_41:
        v54 = *(_QWORD *)(v49 + 904);
        if ( v54 <= v53 )
        {
          v55 = (__int64 **)(v49 + 872);
          if ( v54 > 3 || (v81 = 4LL, v56 = (void *)(v49 + 872), v55 == v36) )
          {
            v82 = v53;
            v81 = 2 * v54;
            v78 = sub_21500(16 * v54);
            v53 = v82;
            v56 = (void *)v78;
            if ( !v78 )
              sub_50110(12LL, "dlopen", 0LL, "cannot create scope list");
          }
          v57 = memcpy(v56, v36, 8 * v53);
          v58 = *(_QWORD *)(v49 + 912);
          *(_QWORD *)(v49 + 912) = v57;
          if ( v55 != (__int64 **)v58 )
            sub_78000(v58);
          *(_QWORD *)(v49 + 904) = v81;
        }
      }
    }
    v48 = *(_DWORD *)(v19 + 712);
    ++v47;
  }
  while ( v47 < v48 );
  if ( v48 )
  {
    v60 = 0;
    v61 = 0;
    do
    {
      while ( 1 )
      {
        v62 = *(_QWORD *)(*(_QWORD *)(v19 + 704) + 8LL * v61);
        if ( (*(_BYTE *)(v62 + 796) & 8) == 0 )
        {
          if ( *(_QWORD *)(v62 + 1080) )
            break;
        }
        if ( ++v61 >= *(_DWORD *)(v19 + 712) )
          goto LABEL_60;
      }
      v36 = 0LL;
      v60 = 1;
      ++v61;
      sub_4DA40(v62, 0);
    }
    while ( v61 < *(_DWORD *)(v19 + 712) );
  }
  else
  {
LABEL_122:
    v60 = 0;
  }
LABEL_60:
  v80 = v79 & 0x100;
  if ( v80 )
    sub_80EF0(v19);
  v63 = &off_BF0E0;
  for ( i = (__int64)*(&off_BF0E0 + 19 * *(_QWORD *)(v19 + 48)); i; i = *(_QWORD *)(i + 24) )
  {
    if ( *(_BYTE *)(i + 800) )
    {
      if ( (dword_C14B4 & 0x40) != 0 )
      {
        v36 = *(__int64 ***)(i + 8);
        sub_76EA0("activating NODELETE for %s [%lu]\n", (const char *)v36, *(_QWORD *)(i + 48));
      }
      *(_WORD *)(i + 799) = 1;
    }
  }
  v65 = *(_DWORD *)(v19 + 712);
  v66 = 0;
  v67 = v65;
  if ( !v65 )
  {
    if ( v60 )
      goto LABEL_101;
    goto LABEL_48;
  }
  do
  {
    v36 = 0LL;
    v68 = *(_QWORD *)(*(_QWORD *)(v19 + 704) + 8LL * v66);
    if ( (*(_BYTE *)(v68 + 796) & 0xB) != 10 )
    {
      if ( (dword_C14B4 & 0x200) == 0 )
      {
LABEL_71:
        v67 = *(unsigned int *)(v19 + 712);
        goto LABEL_72;
      }
LABEL_83:
      sub_81380((_QWORD *)v68, (unsigned int)v36);
      goto LABEL_71;
    }
    v69 = *(__int64 ****)(v68 + 912);
    v70 = *v69;
    if ( !*v69 )
    {
      v74 = 1LL;
      v73 = 0LL;
      v36 = 0LL;
LABEL_81:
      if ( *(_QWORD *)(v68 + 904) <= v74 )
        sub_CF00("cnt + 1 < imap->l_scope_max", "dl-open.c", 334LL, "update_scopes");
      v69[v74] = 0LL;
      *(_QWORD *)(*(_QWORD *)(v68 + 912) + v73) = v19 + 704;
      if ( (dword_C14B4 & 0x200) == 0 )
        goto LABEL_71;
      goto LABEL_83;
    }
    v36 = (__int64 **)(v19 + 704);
    v71 = v69 + 1;
    while ( v70 != v36 )
    {
      v70 = *v71++;
      if ( !v70 )
      {
        v36 = 0LL;
        do
        {
          v72 = v36;
          v36 = (__int64 **)((char *)v36 + 1);
          v73 = 8LL * (_QWORD)v36;
        }
        while ( v69[(_QWORD)v36] );
        v74 = (unsigned __int64)v72 + 2;
        goto LABEL_81;
      }
    }
LABEL_72:
    ++v66;
    v65 = v67;
  }
  while ( v66 < (unsigned int)v67 );
  if ( !v60 )
    goto LABEL_48;
  if ( (_DWORD)v67 )
  {
    v75 = 0;
    do
    {
      while ( 1 )
      {
        v36 = *(__int64 ***)(v19 + 704);
        v76 = (__int64)v36[v75];
        if ( (*(_BYTE *)(v76 + 796) & 8) == 0 )
        {
          if ( *(_QWORD *)(v76 + 1080) )
          {
            v36 = (__int64 **)(&dword_0 + 1);
            sub_4DA40(v76, 1);
            v67 = *(unsigned int *)(v19 + 712);
            if ( (*(_BYTE *)(v76 + 797) & 4) != 0 )
              break;
          }
        }
        if ( ++v75 >= (unsigned int)v67 )
          goto LABEL_101;
      }
      if ( (_DWORD)v67 == v65 )
        v65 = v75;
      ++v75;
    }
    while ( v75 < (unsigned int)v67 );
  }
LABEL_101:
  if ( !++qword_C0340 )
    sub_77200("TLS generation counter wrapped!  Please report this.", v36);
  while ( v65 < *(_DWORD *)(v19 + 712) )
  {
    v77 = *(_QWORD *)(*(_QWORD *)(v19 + 704) + 8LL * v65);
    if ( (*(_WORD *)(v77 + 796) & 0x408) == 1024 && *(_QWORD *)(v77 + 1080) )
    {
      *(_BYTE *)(v77 + 797) &= 0xFBu;
      off_BF0A0(v77);
      if ( (*(_BYTE *)(v77 + 797) & 4) != 0 )
        sub_CF00("imap->l_need_tls_init == 0", "dl-open.c", 430LL, "update_tls_slotinfo");
    }
    ++v65;
  }
LABEL_48:
  if ( v43 )
  {
    if ( !*(_BYTE *)(a1 + 44) )
      goto LABEL_91;
  }
  else
  {
    if ( *(_BYTE *)(a1 + 44) )
      goto LABEL_50;
LABEL_91:
    sub_832B0((__int64 *)*(&off_BF0E0 + 19 * *(_QWORD *)(a1 + 32) + 4), 0);
  }
LABEL_50:
  v59 = *(_DWORD *)(a1 + 48);
  v83 = v19;
  v84 = v59;
  v85 = *(_QWORD *)(a1 + 56);
  v86 = *(_QWORD *)(a1 + 64);
  sub_50170(0LL, (void (__fastcall *)(__int64))sub_80EB0, (__int64)&v83, (__int64)v63, v67, (__int64)v32);
  result = v80;
  if ( v80 )
    result = (__int64)sub_80D50(v19);
  dword_BF628 = 1;
  if ( (dword_C14B4 & 0x40) != 0 )
    result = sub_76EA0(
               "opening file=%s [%lu]; direct_opencount=%u\n\n",
               *(const char **)(v19 + 8),
               *(_QWORD *)(v19 + 48),
               *(unsigned int *)(v19 + 792));
  return result;
}
// 8156C: variable 'v16' is possibly undefined
// 8156C: variable 'v17' is possibly undefined
// 8161E: variable 'v22' is possibly undefined
// 8161E: variable 'v23' is possibly undefined
// 8161E: variable 'v24' is possibly undefined
// 8161E: variable 'v25' is possibly undefined
// 8161E: variable 'v26' is possibly undefined
// 81653: variable 'v29' is possibly undefined
// 81653: variable 'v30' is possibly undefined
// 81653: variable 'v31' is possibly undefined
// 8171B: variable 'v38' is possibly undefined
// 8171B: variable 'v32' is possibly undefined
// 8171B: variable 'v33' is possibly undefined
// 8171B: variable 'v34' is possibly undefined
// 81880: variable 'v63' is possibly undefined
// 81880: variable 'v67' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);
// 9210: using guessed type __int64 __fastcall sub_9210(_QWORD, _QWORD);
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// BF0A0: using guessed type __int64 (__fastcall *off_BF0A0)(_QWORD);
// BF0E0: using guessed type void *off_BF0E0;
// BF628: using guessed type int dword_BF628;
// C0340: using guessed type __int64 qword_C0340;
// C14B0: using guessed type int dword_C14B0;
// C14B4: using guessed type int dword_C14B4;

//----- (0000000000081E80) ----------------------------------------------------
void (**__fastcall sub_81E80(_QWORD *a1))(void)
{
  void (**result)(void); // rax
  void (**v2)(void); // rbp
  void (**v3)(void); // rbx
  __int64 v4; // rdx

  result = (void (**)(void))a1[34];
  if ( result )
  {
    v2 = (void (**)(void))((char *)result[1] + *a1);
    result = (void (**)(void))(*(_QWORD *)(a1[36] + 8LL) >> 3);
    if ( (_DWORD)result )
    {
      v3 = &v2[(int)result - 1];
      do
      {
        (*v3)();
        result = v3--;
      }
      while ( v2 != result );
    }
  }
  v4 = a1[21];
  if ( v4 )
    result = (void (**)(void))((__int64 (*)(void))(*(_QWORD *)(v4 + 8) + *a1))();
  return result;
}

//----- (0000000000081F00) ----------------------------------------------------
__int64 __fastcall sub_81F00(__int64 a1, unsigned __int64 *a2, __int64 a3, unsigned __int8 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  unsigned __int64 v13; // rax
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // rsi
  unsigned __int64 *v17; // rax
  unsigned __int64 v18; // rdx
  __int64 v19; // rsi
  unsigned __int64 v21; // rcx
  unsigned __int64 v22; // rdi
  __int64 v23; // rsi

  v13 = a1 - a3;
  v15 = *a2;
  if ( v13 < *a2 )
  {
    v17 = &a2[2 * v13];
    v18 = v17[3];
    if ( v18 )
    {
      if ( *(_QWORD *)(v18 + 1112) != a1 )
        sub_CF00(
          (__int64)"old_map->l_tls_modid == idx",
          (__int64)"dl-close.c",
          0x50u,
          "remove_slotinfo",
          a5,
          a6,
          a7,
          a8,
          a9,
          a10,
          a11,
          a12);
      v19 = qword_C0340;
      v17[3] = 0LL;
      v17[2] = v19 + 1;
    }
    if ( qword_C0388 != a1 )
      return 1LL;
  }
  else
  {
    v16 = a2[1];
    if ( v16 )
    {
      if ( (unsigned __int8)sub_81F00(a1, v16, a3 + v15, a4) )
        return 1LL;
      a1 = a3 + *a2;
    }
    else if ( a4 )
    {
      sub_CF00(
        (__int64)"! should_be_there",
        (__int64)"dl-close.c",
        0x3Bu,
        "remove_slotinfo",
        a5,
        a6,
        a7,
        a8,
        a9,
        a10,
        a11,
        a12);
    }
  }
  v21 = qword_C0370 + 1;
  if ( a3 )
    v21 = 0LL;
  v22 = a1 - a3;
  do
  {
    if ( v22 <= v21 )
      return 0LL;
    v23 = a3 - 1 + v22--;
  }
  while ( !a2[2 * v22 + 3] );
  qword_C0388 = v23;
  return 1LL;
}
// C0340: using guessed type __int64 qword_C0340;
// C0370: using guessed type __int64 qword_C0370;
// C0388: using guessed type __int64 qword_C0388;

//----- (0000000000082030) ----------------------------------------------------
__int64 __fastcall sub_82030(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_8203E(a1, a2, a3, 0x3FFFFFFFFLL);
}
// 8203E: using guessed type __int64 __fastcall sub_8203E(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000008203E) ----------------------------------------------------
void __fastcall sub_8203E(__int64 a1, char a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12)
{
  int v12; // eax
  __int64 v13; // rdx
  __int64 v14; // r15
  __int64 v15; // r12
  int v16; // er9
  signed __int64 v17; // rax
  void *v18; // rsp
  void *v19; // rsp
  void *v20; // rsp
  _DWORD *v21; // rax
  _BYTE *v22; // rcx
  int v23; // edx
  double v24; // xmm4_8
  double v25; // xmm5_8
  unsigned int v26; // er9
  __int64 v27; // r11
  __int64 v28; // r10
  signed int v29; // edi
  unsigned int *v30; // rsi
  __int64 v31; // rcx
  __int64 v32; // rax
  _QWORD *v33; // rdx
  __int64 i; // rax
  signed int v35; // eax
  __int64 v36; // rax
  unsigned int v37; // edx
  signed int v38; // eax
  __int64 v39; // r8
  __int64 v40; // rax
  _BOOL8 v41; // rdx
  _BOOL4 v42; // eax
  __int64 v43; // rdx
  unsigned int v44; // esi
  __int64 v45; // r10
  __int64 v46; // r9
  __int64 v47; // r11
  __int64 v48; // r8
  __int64 v49; // rbx
  char v50; // al
  __int64 v51; // r12
  unsigned int v52; // er13
  char v53; // dl
  __int64 *v54; // rax
  unsigned __int64 v55; // rsi
  __int64 v56; // rdx
  __int64 v57; // r14
  __int64 *v58; // rcx
  __int64 v59; // rax
  __int64 *v60; // rdi
  __int64 v61; // r11
  __int64 v62; // rsi
  __int64 v63; // rbx
  __int64 *v64; // rax
  __int64 v65; // rdi
  __int64 v66; // rdi
  int v67; // eax
  bool v68; // zf
  char v69; // al
  __int64 v70; // rax
  const char *v71; // rsi
  __int64 v72; // rcx
  __int64 v73; // rax
  __int64 v74; // rax
  unsigned int v75; // eax
  unsigned int v76; // ecx
  __int64 v77; // rdx
  __int64 v78; // rdx
  __int64 *v79; // rax
  __int64 v80; // rsi
  __int64 v81; // rdi
  void **v82; // rax
  double v83; // xmm4_8
  double v84; // xmm5_8
  __int64 v85; // rcx
  u32 *v86; // r8
  __int64 v87; // r9
  __int64 v88; // r11
  __int64 v89; // r10
  _BYTE *v90; // rbx
  __int64 *v91; // r12
  __int64 v92; // r13
  __int64 v93; // r15
  char *v94; // rax
  unsigned __int64 v95; // rcx
  u32 *v96; // r8
  __int64 v97; // r9
  double v98; // xmm4_8
  double v99; // xmm5_8
  __int64 v100; // rdx
  __int64 v101; // rax
  __int64 v102; // rdx
  unsigned __int64 v103; // rcx
  u32 *v104; // r8
  __int64 v105; // r9
  double v106; // xmm4_8
  double v107; // xmm5_8
  __int64 v108; // rdi
  __int64 v109; // rdx
  unsigned __int64 v110; // rcx
  u32 *v111; // r8
  __int64 v112; // r9
  double v113; // xmm4_8
  double v114; // xmm5_8
  __int64 v115; // rdx
  unsigned __int64 v116; // rcx
  u32 *v117; // r8
  __int64 v118; // r9
  double v119; // xmm4_8
  double v120; // xmm5_8
  __int64 v121; // r14
  __int64 v122; // rdi
  __int64 v123; // rdx
  unsigned __int64 v124; // rcx
  u32 *v125; // r8
  __int64 v126; // r9
  double v127; // xmm4_8
  double v128; // xmm5_8
  __int64 v129; // rdi
  __int64 v130; // rdi
  __int64 v131; // rdi
  void **v132; // rcx
  void *v133; // rdx
  char *v134; // rdx
  unsigned __int64 v135; // rax
  __int64 v136; // rdx
  unsigned int *v137; // rbx
  unsigned int j; // eax
  __int64 v139; // r12
  __int64 v140; // rdx
  _BOOL8 v141; // rdx
  int v142; // esi
  __int64 v143; // rdx
  unsigned int v144; // esi
  __int64 v145; // rdx
  __int64 v146; // rdx
  unsigned __int64 v147; // rcx
  __int64 *v148; // rbx
  __int64 v149; // rax
  int v150; // er12
  int v151; // er13
  __int64 v152; // r14
  __int64 v153; // rax
  __int64 v154; // rcx
  _BYTE v155[8]; // [rsp+0h] [rbp-B0h] BYREF
  void **v156; // [rsp+8h] [rbp-A8h]
  __int64 v157; // [rsp+10h] [rbp-A0h]
  __int64 *v158; // [rsp+18h] [rbp-98h]
  _BYTE *v159; // [rsp+20h] [rbp-90h]
  unsigned int v160; // [rsp+28h] [rbp-88h]
  unsigned __int8 v161; // [rsp+2Ch] [rbp-84h]
  char v162; // [rsp+2Dh] [rbp-83h]
  char v163; // [rsp+2Eh] [rbp-82h]
  char v164; // [rsp+2Fh] [rbp-81h]
  __int64 v165; // [rsp+30h] [rbp-80h]
  void **v166; // [rsp+38h] [rbp-78h]
  __int64 v167; // [rsp+40h] [rbp-70h]
  __int64 v168; // [rsp+48h] [rbp-68h]
  __int64 v169; // [rsp+50h] [rbp-60h]
  __int64 v170; // [rsp+58h] [rbp-58h]
  __int64 v171; // [rsp+60h] [rbp-50h]
  _BYTE *v172; // [rsp+68h] [rbp-48h]
  unsigned __int64 v173; // [rsp+70h] [rbp-40h]
  _BYTE *v174; // [rsp+78h] [rbp-38h]

  v12 = *(_DWORD *)(a1 + 792);
  v163 = a2;
  v13 = (unsigned int)(v12 - 1);
  *(_DWORD *)(a1 + 792) = v13;
  if ( (*(_QWORD *)(a1 + 792) & a12) == 0x200000000LL )
  {
    if ( !dword_C18E0 )
    {
      v14 = *(_QWORD *)(a1 + 48);
      v156 = &off_BF0E0 + 19 * v14 + 5;
      v166 = &off_BF0E0 + 19 * v14;
      while ( 1 )
      {
        v159 = v155;
        dword_C18E0 = 1;
        v15 = *((unsigned int *)v166 + 2);
        v16 = *((_DWORD *)v166 + 2);
        v17 = 16 * ((unsigned __int64)(v15 + 15) >> 4);
        v18 = alloca(v17);
        v19 = alloca(v17);
        v20 = alloca(16 * ((unsigned __int64)(8 * v15 + 15) >> 4));
        v21 = *v166;
        if ( *v166 )
        {
          v22 = v155;
          v23 = 0;
          do
          {
            v21[251] = v23;
            v22 += 8;
            ++v23;
            *((_QWORD *)v22 - 1) = v21;
            v21 = (_DWORD *)*((_QWORD *)v21 + 3);
          }
          while ( v21 );
        }
        else
        {
          v23 = 0;
        }
        if ( v16 != v23 )
          sub_CF00(
            (__int64)"idx == nloaded",
            (__int64)"dl-close.c",
            0xB5u,
            "_dl_close_worker",
            a3,
            a4,
            a5,
            a6,
            a7,
            a8,
            a9,
            a10);
        v172 = v155;
        LODWORD(v173) = v16;
        v174 = v155;
        sub_9190((__int64)v155, 0LL, v15);
        sub_9190((__int64)v155, 0LL, v15);
        v26 = v173;
        v27 = (__int64)v174;
        v28 = (__int64)v172;
        if ( !(_DWORD)v173 )
        {
          v141 = v14 == 0;
          v142 = v141;
          v143 = (__int64)&v174[v141];
          v144 = -v142;
          if ( v14 )
            sub_83000((__int64)v172, v144, v143, 1);
          else
            sub_83000((__int64)(v172 + 8), v144, v143, 1);
          goto LABEL_89;
        }
        v29 = 0;
        do
        {
          while ( v155[v29] )
          {
LABEL_11:
            if ( ++v29 >= v26 )
              goto LABEL_43;
          }
          v31 = *(_QWORD *)(v28 + 8LL * v29);
          if ( (*(_QWORD *)(v31 + 792) & 0x3FFFFFFFFLL) != 0x200000000LL
            || *(_BYTE *)(v31 + 799)
            || *(_QWORD *)(v31 + 1120)
            || *(_BYTE *)(v27 + v29) )
          {
            *(_BYTE *)(v27 + v29) = 1;
            v155[v29] = 1;
            v32 = *(_QWORD *)(v31 + 968);
            *(_DWORD *)(v31 + 1004) = -1;
            if ( v32 )
            {
              v33 = (_QWORD *)(v32 + 8);
              for ( i = *(_QWORD *)(v32 + 8); i; ++v33 )
              {
                v36 = *(int *)(i + 1004);
                if ( (_DWORD)v36 != -1 )
                {
                  if ( (int)v36 < 0 || (unsigned int)v36 >= v26 )
                    sub_CF00(
                      (__int64)"(*lp)->l_idx >= 0 && (*lp)->l_idx < nloaded",
                      (__int64)"dl-close.c",
                      0xDFu,
                      "_dl_close_worker",
                      a3,
                      a4,
                      a5,
                      a6,
                      v24,
                      v25,
                      a9,
                      a10);
                  if ( !*(_BYTE *)(v27 + v36) )
                  {
                    *(_BYTE *)(v27 + v36) = 1;
                    v35 = *(_DWORD *)(*v33 + 1004LL);
                    if ( v35 <= v29 )
                      v29 = v35 - 1;
                  }
                }
                i = v33[1];
              }
            }
            v30 = *(unsigned int **)(v31 + 976);
            if ( v30 && *v30 )
            {
              v37 = 0;
              do
              {
                v39 = *(_QWORD *)&v30[2 * v37 + 2];
                v40 = *(int *)(v39 + 1004);
                if ( (_DWORD)v40 != -1 )
                {
                  if ( (int)v40 < 0 || (unsigned int)v40 >= v26 )
                    sub_CF00(
                      (__int64)"jmap->l_idx >= 0 && jmap->l_idx < nloaded",
                      (__int64)"dl-close.c",
                      0xF8u,
                      "_dl_close_worker",
                      a3,
                      a4,
                      a5,
                      a6,
                      v24,
                      v25,
                      a9,
                      a10);
                  if ( !*(_BYTE *)(v27 + v40) )
                  {
                    *(_BYTE *)(v27 + v40) = 1;
                    v38 = *(_DWORD *)(v39 + 1004);
                    if ( v38 <= v29 )
                      v29 = v38 - 1;
                    v30 = *(unsigned int **)(v31 + 976);
                  }
                }
                ++v37;
              }
              while ( *v30 > v37 );
            }
            goto LABEL_11;
          }
          ++v29;
        }
        while ( v29 < v26 );
LABEL_43:
        v41 = v14 == 0;
        v42 = v41;
        v43 = v27 + v41;
        v44 = v26 - v42;
        v172 = (_BYTE *)v27;
        LODWORD(v173) = v26;
        v174 = (_BYTE *)v28;
        if ( v14 )
        {
          sub_83000(v28, v44, v43, 1);
          v162 = 0;
        }
        else
        {
          sub_83000(v28 + 8, v44, v43, 1);
          v162 = 1;
        }
        v45 = (__int64)v174;
        v46 = (unsigned int)v173;
        v47 = (__int64)v172;
        LOBYTE(v172) = 0;
        v48 = 0xFFFFFFFFLL;
        LODWORD(v171) = 0;
        v49 = 0LL;
        v164 = 0;
        LODWORD(v174) = v173;
        v173 = v47;
        do
        {
          while ( 1 )
          {
            v51 = *(_QWORD *)(v45 + 8 * v49);
            v52 = v49;
            if ( *(_QWORD *)(v51 + 48) != v14 )
              sub_CF00(
                (__int64)"imap->l_ns == nsid",
                (__int64)"dl-close.c",
                0x116u,
                "_dl_close_worker",
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10);
            v50 = *(_BYTE *)(v51 + 796);
            v72 = v173;
            v53 = v50 & 3;
            if ( !*(_BYTE *)(v173 + v49) )
            {
              if ( v53 != 2 || *(_BYTE *)(v51 + 799) )
                sub_CF00(
                  (__int64)"imap->l_type == lt_loaded && !imap->l_nodelete_active",
                  (__int64)"dl-close.c",
                  0x11Au,
                  "_dl_close_worker",
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  a9,
                  a10);
              if ( (v50 & 8) != 0 )
              {
                if ( (dword_C14B4 & 2) != 0 )
                {
                  v71 = *(const char **)(v51 + 8);
                  v170 = v45;
                  LODWORD(v172) = v48;
                  sub_76EA0("\ncalling fini: %s [%lu]\n\n", v71, v14);
                  v45 = v170;
                  v48 = (unsigned int)v172;
                }
                if ( *(_QWORD *)(v51 + 272) || *(_QWORD *)(v51 + 168) )
                {
                  v170 = v45;
                  LODWORD(v172) = v48;
                  sub_50170(0LL, (void (__fastcall *)(__int64))sub_81E80, v51, v72, v48, v46);
                  v45 = v170;
                  v48 = (unsigned int)v172;
                  v50 = *(_BYTE *)(v51 + 796);
                }
                else
                {
                  v50 = *(_BYTE *)(v51 + 796);
                }
              }
              *(_BYTE *)(v51 + 797) |= 0x20u;
              LOBYTE(v172) = 1;
              LODWORD(v171) = v171 - (((v50 & 0x10) == 0) - 1);
              if ( (unsigned int)v48 > (unsigned int)v49 )
                v48 = (unsigned int)v49;
              goto LABEL_55;
            }
            if ( v53 == 2 )
              break;
LABEL_55:
            if ( (unsigned int)v174 <= (unsigned int)++v49 )
              goto LABEL_88;
          }
          if ( *(_QWORD *)(v51 + 704) )
          {
            v54 = *(__int64 **)(v51 + 912);
            v169 = 0LL;
            v55 = 1LL;
            v56 = *v54;
            v170 = (__int64)v54;
            if ( !v56 )
              goto LABEL_82;
          }
          else
          {
            v169 = *(_QWORD *)(v51 + 968);
            if ( v169 )
            {
              if ( *(_QWORD *)(v169 + 8) )
              {
                v75 = 1;
                do
                  v76 = v75++;
                while ( *(_QWORD *)(v169 + 8LL * v75) );
                v77 = 8LL * (v76 + 2);
              }
              else
              {
                v77 = 16LL;
                v75 = 1;
              }
              *(_DWORD *)(v51 + 712) = v75;
              v78 = v169 + v77;
              v169 = v51 + 704;
              v79 = *(__int64 **)(v51 + 912);
              *(_QWORD *)(v51 + 704) = v78;
              v56 = *v79;
              v170 = (__int64)v79;
              if ( !v56 )
              {
LABEL_94:
                *(_QWORD *)(v51 + 704) = 0LL;
                *(_DWORD *)(v51 + 712) = 0;
                goto LABEL_82;
              }
              v55 = 2LL;
            }
            else
            {
              v55 = 1LL;
              v56 = **(_QWORD **)(v51 + 912);
              v170 = *(_QWORD *)(v51 + 912);
              if ( !v56 )
                goto LABEL_82;
            }
          }
          v57 = v51 + 720;
          v46 = 0LL;
          v58 = (__int64 *)(v170 + 8);
          v59 = v56;
          v60 = (__int64 *)(v170 + 8);
          do
          {
            while ( v59 != v57 )
            {
              if ( *(_QWORD *)(v59 - 656) != v14 )
                sub_CF00(
                  (__int64)"tmap->l_ns == nsid",
                  (__int64)"dl-close.c",
                  0x174u,
                  "_dl_close_worker",
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  a9,
                  a10);
              if ( *(_DWORD *)(v59 + 300) == -1 )
                break;
              v59 = *v60++;
              v46 = 1LL;
              if ( !v59 )
                goto LABEL_67;
            }
            v59 = *v60++;
            ++v55;
          }
          while ( v59 );
LABEL_67:
          if ( (_BYTE)v46 )
          {
            v168 = v51 + 872;
            if ( v51 + 872 == v170 || (v167 = 4LL, v61 = v51 + 872, v55 > 3) )
            {
              v73 = *(_QWORD *)(v51 + 904);
              v157 = v45;
              v160 = v48;
              v161 = v46;
              v158 = (__int64 *)(v170 + 8);
              v165 = v56;
              v167 = v73;
              v74 = sub_21500(
                      (u32 *)(8 * v73),
                      v55,
                      v56,
                      (__int64)v58,
                      (u32 *)v48,
                      v46,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      a9,
                      a10);
              v56 = v165;
              v58 = v158;
              v46 = v161;
              v61 = v74;
              v48 = v160;
              v45 = v157;
              if ( !v74 )
                sub_50110(12LL, "dlclose", 0LL, "cannot create scope list", a3, a4, a5, a6, a7, a8, a9, a10);
            }
            v165 = v49;
            v62 = 0LL;
            v63 = v169;
            do
            {
              while ( 1 )
              {
                v65 = 8 * v62;
                v64 = (__int64 *)(v61 + 8 * v62);
                if ( v56 != v57 && *(_DWORD *)(v56 + 300) != -1 )
                  break;
                ++v58;
                *v64 = v56;
                ++v62;
                v64 = (__int64 *)(v61 + v65 + 8);
                v56 = *(v58 - 1);
                if ( !v56 )
                  goto LABEL_77;
              }
              if ( v63 )
              {
                *v64 = v63;
                ++v62;
                v64 = (__int64 *)(v61 + v65 + 8);
                v63 = 0LL;
              }
              v56 = *v58++;
            }
            while ( v56 );
LABEL_77:
            v49 = v165;
            v66 = v170;
            *v64 = 0LL;
            *(_QWORD *)(v51 + 912) = v61;
            if ( v168 == v66 )
            {
              v164 = v46;
            }
            else
            {
              v169 = v45;
              LODWORD(v170) = v48;
              v67 = sub_78000(v66, v62, v56, (__int64)v58, (u32 *)v48, v46, a3, a4, a5, a6, a7, a8, a9, a10);
              v48 = (unsigned int)v170;
              v45 = v169;
              v68 = v67 == 0;
              v69 = v164;
              if ( !v68 )
                v69 = 0;
              v164 = v69;
            }
            *(_QWORD *)(v51 + 904) = v167;
          }
          else if ( v169 )
          {
            goto LABEL_94;
          }
LABEL_82:
          v70 = *(_QWORD *)(v51 + 736);
          if ( v70 && *(_DWORD *)(v70 + 1004) != -1 )
            *(_QWORD *)(v51 + 736) = 0LL;
          if ( (unsigned int)v48 > v52 )
            v48 = v52;
          ++v49;
        }
        while ( (unsigned int)v174 > (unsigned int)v49 );
LABEL_88:
        if ( (_BYTE)v172 )
        {
          v80 = v14;
          v81 = 0LL;
          v168 = v45;
          v169 = v173;
          LODWORD(v173) = (_DWORD)v174;
          LODWORD(v174) = v48;
          v82 = sub_4D270(0LL, v14);
          *((_DWORD *)v82 + 6) = 2;
          v170 = (__int64)v82;
          sub_4D260();
          v85 = (unsigned int)v171;
          v86 = (u32 *)(unsigned int)v174;
          LODWORD(v87) = v173;
          v88 = v169;
          v89 = v168;
          if ( (_DWORD)v171 )
          {
            v137 = (unsigned int *)v166[2];
            v80 = v137[2];
            for ( j = v137[2]; j; --j )
            {
              v139 = *(_QWORD *)v137;
              v85 = *(_QWORD *)(*(_QWORD *)v137 + 8LL * (j - 1));
              if ( (*(_BYTE *)(v85 + 797) & 0x20) == 0 )
              {
                v85 = (unsigned int)v171;
                if ( (_DWORD)v171 + j != (_DWORD)v80 )
                {
                  v81 = 0LL;
                  v140 = 0LL;
                  do
                  {
                    v85 = *(_QWORD *)(v139 + 8 * v140);
                    if ( (*(_BYTE *)(v85 + 797) & 0x20) == 0 )
                    {
                      if ( (_DWORD)v81 != (_DWORD)v140 )
                      {
                        v80 = (unsigned int)v81;
                        *(_QWORD *)(v139 + 8LL * (unsigned int)v81) = v85;
                      }
                      v81 = (unsigned int)(v81 + 1);
                    }
                    ++v140;
                  }
                  while ( j > (unsigned int)v140 );
                  j = v81;
                }
                break;
              }
            }
            v137[2] = j;
          }
          if ( __readfsdword(0x18u) )
          {
            v145 = (unsigned int)v171;
            if ( (_DWORD)v171 || v164 || qword_C12D8 && *(_QWORD *)qword_C12D8 )
            {
              v169 = v89;
              v171 = v88;
              LODWORD(v173) = v87;
              LODWORD(v174) = (_DWORD)v86;
              qword_C12E0(v81, v80, v145, v85, v86);
              v148 = (__int64 *)qword_C12D8;
              v86 = (u32 *)(unsigned int)v174;
              v87 = (unsigned int)v173;
              v88 = v171;
              v89 = v169;
              if ( qword_C12D8 )
              {
                v149 = *(_QWORD *)qword_C12D8;
                if ( *(_QWORD *)qword_C12D8 )
                {
                  v150 = (int)v174;
                  v151 = v173;
                  v152 = v171;
                  do
                  {
                    v153 = v149 - 1;
                    v174 = (_BYTE *)v89;
                    *v148 = v153;
                    sub_21B70(v148[v153 + 1], a3, a4, a5, a6, v83, v84, a9, a10, v80, v146, v147, v86, v87);
                    v149 = *v148;
                    v89 = (__int64)v174;
                  }
                  while ( *v148 );
                  LODWORD(v86) = v150;
                  LODWORD(v87) = v151;
                  v88 = v152;
                }
              }
            }
          }
          if ( (unsigned int)v86 < (unsigned int)v87 )
          {
            LOBYTE(v171) = 0;
            v90 = (_BYTE *)(v88 + (unsigned int)v86);
            v91 = (__int64 *)(v89 + 8LL * (unsigned int)v86);
            v169 = v14;
            v174 = 0LL;
            v173 = 0LL;
            v92 = (__int64)&v90[(unsigned int)(v87 - 1 - (_DWORD)v86) + 1];
            do
            {
              while ( *v90 )
              {
                ++v90;
                ++v91;
                if ( (_BYTE *)v92 == v90 )
                  goto LABEL_141;
              }
              v93 = *v91;
              if ( (*(_BYTE *)(*v91 + 796) & 3) != 2 )
                sub_CF00(
                  (__int64)"imap->l_type == lt_loaded",
                  (__int64)"dl-close.c",
                  0x22Fu,
                  "_dl_close_worker",
                  a3,
                  a4,
                  a5,
                  a6,
                  v83,
                  v84,
                  a9,
                  a10);
              if ( *(_QWORD *)(v93 + 1080) )
              {
                v80 = qword_C0378;
                if ( qword_C0378
                  && !(unsigned __int8)sub_81F00(
                                         *(_QWORD *)(v93 + 1112),
                                         (unsigned __int64 *)qword_C0378,
                                         0LL,
                                         (*(_BYTE *)(*v91 + 796) & 8) != 0,
                                         a3,
                                         a4,
                                         a5,
                                         a6,
                                         v83,
                                         v84,
                                         a9,
                                         a10) )
                {
                  qword_C0388 = qword_C0370;
                }
                v135 = *(_QWORD *)(v93 + 1104);
                LOBYTE(v171) = (_BYTE)v172;
                if ( v135 + 1 > 1 )
                {
                  if ( !v173 || v135 == v173 )
                  {
                    v173 = v135 - *(_QWORD *)(v93 + 1080);
                    LOBYTE(v171) = (_BYTE)v172;
                    if ( v174 )
                      v135 = (unsigned __int64)v174;
                    v174 = (_BYTE *)v135;
                  }
                  else
                  {
                    v136 = v135 - *(_QWORD *)(v93 + 1080);
                    if ( (_BYTE *)v136 == v174 )
                    {
                      v174 = (_BYTE *)v135;
                    }
                    else if ( (_BYTE *)qword_C0360 == v174 )
                    {
                      v154 = v173;
                      v174 = (_BYTE *)v135;
                      v173 = v136;
                      qword_C0360 = v154;
                    }
                    else if ( v135 == qword_C0360 )
                    {
                      qword_C0360 = v135 - *(_QWORD *)(v93 + 1080);
                    }
                    else if ( v135 > (unsigned __int64)v174 )
                    {
                      v174 = (_BYTE *)v135;
                      v173 = v136;
                    }
                  }
                }
              }
              if ( v163 )
              {
                v94 = (char *)v166[10];
                if ( v94 )
                {
                  v132 = v166;
                  v133 = v166[11];
                  if ( v133 )
                  {
                    v134 = &v94[32 * (_QWORD)v133];
                    do
                    {
                      if ( *((_QWORD *)v94 + 1) && *((_QWORD *)v94 + 3) == v93 )
                      {
                        *((_QWORD *)v94 + 1) = 0LL;
                        *(_DWORD *)v94 = 0;
                        v132[12] = (char *)v132[12] - 1;
                      }
                      v94 += 32;
                    }
                    while ( v94 != v134 );
                  }
                }
              }
              sub_83550(v93);
              if ( !v162 )
                sub_CF00(
                  (__int64)"nsid == LM_ID_BASE",
                  (__int64)"dl-close.c",
                  0x2BBu,
                  "_dl_close_worker",
                  a3,
                  a4,
                  a5,
                  a6,
                  v98,
                  v99,
                  a9,
                  a10);
              v100 = *(_QWORD *)(v93 + 32);
              if ( !v100 )
                sub_CF00(
                  (__int64)"imap->l_prev != NULL",
                  (__int64)"dl-close.c",
                  0x2BCu,
                  "_dl_close_worker",
                  a3,
                  a4,
                  a5,
                  a6,
                  v98,
                  v99,
                  a9,
                  a10);
              v101 = *(_QWORD *)(v93 + 24);
              --dword_BF0E8;
              *(_QWORD *)(v100 + 24) = v101;
              if ( v101 )
                *(_QWORD *)(v101 + 32) = v100;
              sub_21B70(*(_QWORD *)(v93 + 744), a3, a4, a5, a6, v98, v99, a9, a10, v80, v100, v95, v96, v97);
              v108 = *(_QWORD *)(v93 + 840);
              if ( v108 != -1 )
                sub_21B70(v108, a3, a4, a5, a6, v106, v107, a9, a10, v80, v102, v103, v104, v105);
              sub_21B70(*(_QWORD *)(v93 + 976), a3, a4, a5, a6, v106, v107, a9, a10, v80, v102, v103, v104, v105);
              if ( (dword_C14B4 & 0x40) != 0 )
              {
                v80 = *(_QWORD *)(v93 + 8);
                sub_76EA0("\nfile=%s [%lu];  destroying link map\n", (const char *)v80, *(_QWORD *)(v93 + 48));
              }
              sub_21B70(*(_QWORD *)(v93 + 8), a3, a4, a5, a6, v113, v114, a9, a10, v80, v109, v110, v111, v112);
              v121 = *(_QWORD *)(v93 + 56);
              do
              {
                while ( 1 )
                {
                  v122 = v121;
                  v121 = *(_QWORD *)(v121 + 8);
                  if ( !*(_DWORD *)(v122 + 16) )
                    break;
                  if ( !v121 )
                    goto LABEL_130;
                }
                sub_21B70(v122, a3, a4, a5, a6, v119, v120, a9, a10, v80, v115, v116, v117, v118);
              }
              while ( v121 );
LABEL_130:
              sub_21B70(*(_QWORD *)(v93 + 968), a3, a4, a5, a6, v119, v120, a9, a10, v80, v115, v116, v117, v118);
              v129 = *(_QWORD *)(v93 + 912);
              if ( v129 != v93 + 872 )
                sub_21B70(v129, a3, a4, a5, a6, v127, v128, a9, a10, v80, v123, v124, v125, v126);
              if ( *(char *)(v93 + 796) < 0 )
                sub_21B70(*(_QWORD *)(v93 + 680), a3, a4, a5, a6, v127, v128, a9, a10, v80, v123, v124, v125, v126);
              v130 = *(_QWORD *)(v93 + 808);
              if ( v130 != -1 )
                sub_21B70(v130, a3, a4, a5, a6, v127, v128, a9, a10, v80, v123, v124, v125, v126);
              v131 = *(_QWORD *)(v93 + 952);
              if ( v131 != -1 )
                sub_21B70(v131, a3, a4, a5, a6, v127, v128, a9, a10, v80, v123, v124, v125, v126);
              if ( qword_C1310 == v93 )
                qword_C1310 = 0LL;
              ++v90;
              ++v91;
              sub_21B70(v93, a3, a4, a5, a6, v127, v128, a9, a10, v80, v123, v124, v125, v126);
            }
            while ( (_BYTE *)v92 != v90 );
LABEL_141:
            v14 = v169;
            if ( (_BYTE)v171 )
            {
              if ( !++qword_C0340 )
                sub_77200("TLS generation counter wrapped!  Please report as described in <https://bugs.archlinux.org/>.\n");
              if ( (_BYTE *)qword_C0360 == v174 )
                qword_C0360 = v173;
            }
          }
          if ( !*v166 && qword_BF088 - 1 == v14 )
            qword_BF088 = v14;
          *(_DWORD *)(v170 + 24) = 0;
          sub_4D260();
        }
LABEL_89:
        if ( dword_C18E0 != 2 )
        {
          dword_C18E0 = 0;
          return;
        }
      }
    }
    dword_C18E0 = 2;
  }
  if ( (dword_C14B4 & 0x40) != 0 )
    sub_76EA0("\nclosing file=%s; direct_opencount=%u\n", *(const char **)(a1 + 8), v13);
}
// 82265: variable 'v24' is possibly undefined
// 82265: variable 'v25' is possibly undefined
// 8240C: variable 'v72' is possibly undefined
// 8240C: variable 'v46' is possibly undefined
// 825CB: variable 'a7' is possibly undefined
// 825CB: variable 'a8' is possibly undefined
// 829D5: variable 'v98' is possibly undefined
// 829D5: variable 'v99' is possibly undefined
// 829D5: variable 'v95' is possibly undefined
// 829D5: variable 'v96' is possibly undefined
// 829D5: variable 'v97' is possibly undefined
// 829E7: variable 'v106' is possibly undefined
// 829E7: variable 'v107' is possibly undefined
// 829E7: variable 'v102' is possibly undefined
// 829E7: variable 'v103' is possibly undefined
// 829E7: variable 'v104' is possibly undefined
// 829E7: variable 'v105' is possibly undefined
// 82A09: variable 'v113' is possibly undefined
// 82A09: variable 'v114' is possibly undefined
// 82A09: variable 'v109' is possibly undefined
// 82A09: variable 'v110' is possibly undefined
// 82A09: variable 'v111' is possibly undefined
// 82A09: variable 'v112' is possibly undefined
// 82A2B: variable 'v119' is possibly undefined
// 82A2B: variable 'v120' is possibly undefined
// 82A2B: variable 'v115' is possibly undefined
// 82A2B: variable 'v116' is possibly undefined
// 82A2B: variable 'v117' is possibly undefined
// 82A2B: variable 'v118' is possibly undefined
// 82A54: variable 'v127' is possibly undefined
// 82A54: variable 'v128' is possibly undefined
// 82A54: variable 'v123' is possibly undefined
// 82A54: variable 'v124' is possibly undefined
// 82A54: variable 'v125' is possibly undefined
// 82A54: variable 'v126' is possibly undefined
// 82BC7: variable 'v83' is possibly undefined
// 82BC7: variable 'v84' is possibly undefined
// 82DEE: variable 'v146' is possibly undefined
// 82DEE: variable 'v147' is possibly undefined
// 82DEE: variable 'v86' is possibly undefined
// 82DEE: variable 'v87' is possibly undefined
// 9228: using guessed type __int64 __fastcall sub_9228(_QWORD);
// 9248: using guessed type __int64 __fastcall sub_9248(_QWORD);
// BF088: using guessed type __int64 qword_BF088;
// BF0E0: using guessed type void *off_BF0E0;
// BF0E8: using guessed type int dword_BF0E8;
// C0340: using guessed type __int64 qword_C0340;
// C0360: using guessed type __int64 qword_C0360;
// C0370: using guessed type __int64 qword_C0370;
// C0378: using guessed type __int64 qword_C0378;
// C0388: using guessed type __int64 qword_C0388;
// C12D8: using guessed type __int64 qword_C12D8;
// C12E0: using guessed type __int64 (__fastcall *qword_C12E0)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// C1310: using guessed type __int64 qword_C1310;
// C14B4: using guessed type int dword_C14B4;
// C18E0: using guessed type int dword_C18E0;

//----- (0000000000082F70) ----------------------------------------------------
__int64 __fastcall sub_82F70(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  __int64 result; // rax

  if ( !*(_BYTE *)(a1 + 799) )
  {
    if ( !*(_DWORD *)(a1 + 792) )
      sub_50110(0LL, *(_BYTE **)(a1 + 8), 0LL, "shared object not open", a4, a5, a6, a7, a8, a9, a10, a11);
    result = sub_82030(a1, 0LL, a3);
  }
  return result;
}
// 9228: using guessed type __int64 __fastcall sub_9228(_QWORD);
// 9248: using guessed type __int64 __fastcall sub_9248(_QWORD);

//----- (0000000000083000) ----------------------------------------------------
void __fastcall sub_83000(__int64 a1, unsigned int a2, __int64 a3, char a4)
{
  unsigned int v4; // er14
  __int64 v5; // rdx
  void *v6; // rsp
  __int64 v7; // r8
  bool v8; // zf
  __int64 *v9; // rdi
  __int64 v10; // rbx
  __int64 v11; // r12
  __int64 v12; // r13
  __int64 v13; // rsi
  __int64 *v14; // rax
  __int64 v15; // rax
  char *v16; // rdi
  __int64 v17; // rdx
  __int64 v18; // r10
  int v19; // ecx
  __int64 v20; // r13
  __int64 v21; // r11
  __int64 v22; // r8
  __int64 v23; // rdi
  __int64 v24; // rdx
  char v25; // bl
  unsigned int v26; // ebx
  _DWORD *v27; // rax
  _DWORD *v28; // rdx
  unsigned int v29; // eax
  __int64 v30; // r10
  __int64 *v31; // rax
  __int64 v32; // rdx
  __int64 *v33; // [rsp+0h] [rbp-90h] BYREF
  __int64 v34; // [rsp+8h] [rbp-88h]
  __int64 v35; // [rsp+10h] [rbp-80h]
  __int64 v36; // [rsp+18h] [rbp-78h]
  unsigned int v37; // [rsp+24h] [rbp-6Ch]
  __int64 v38; // [rsp+28h] [rbp-68h]
  __int64 v39; // [rsp+30h] [rbp-60h]
  __int64 v40; // [rsp+38h] [rbp-58h]
  __int64 v41; // [rsp+40h] [rbp-50h]
  __int16 v42; // [rsp+4Ah] [rbp-46h]
  unsigned int v43; // [rsp+4Ch] [rbp-44h]
  __int64 v44; // [rsp+50h] [rbp-40h]
  char v45; // [rsp+5Bh] [rbp-35h]
  unsigned int i; // [rsp+5Ch] [rbp-34h]

  v44 = a1;
  v43 = a2;
  v34 = a3;
  v45 = a4;
  if ( a2 > 1 )
  {
    v4 = 0;
    v5 = 2LL * a2;
    v33 = (__int64 *)&v33;
    v6 = alloca(16 * ((unsigned __int64)(v5 + 15) >> 4));
    sub_9190((__int64)&v33, 0LL, v5);
    v7 = 0LL;
    v37 = a2 - 1;
    v36 = a2 - 1;
    v35 = v44 + 8 * v36;
LABEL_3:
    for ( i = 1; ; i = v26 + 1 )
    {
      v8 = v45 == 0;
      v42 = *((_WORD *)&v33 + v7) + 1;
      *((_WORD *)&v33 + v7) = v42;
      v9 = (__int64 *)(v44 + 8 * v7);
      v10 = *v9;
      if ( v8 )
        break;
      if ( *(_QWORD *)(v10 + 40) != v10 )
        goto LABEL_9;
      if ( *(_DWORD *)(v10 + 1004) != -1 )
        break;
      v15 = i;
      if ( v43 == i )
        return;
LABEL_10:
      v16 = (char *)&v33 + 2 * v15;
LABEL_16:
      v26 = i;
      v4 = i;
      sub_9190((__int64)v16, 0LL, 2LL * (v43 - i));
      v7 = v26;
    }
    if ( v4 < v37 )
    {
      v11 = v36;
      v12 = v35;
      do
      {
        v13 = *(_QWORD *)v12;
        v14 = *(__int64 **)(*(_QWORD *)v12 + 968LL);
        if ( v14 )
        {
          while ( 1 )
          {
            v17 = *v14;
            if ( !*v14 )
              break;
            ++v14;
            if ( v17 == v10 )
            {
LABEL_13:
              v38 = v7;
              LODWORD(v39) = v11;
              v40 = (unsigned int)v11 - v4;
              v41 = i;
              sub_9050(v9, v44 + 8LL * i, 8 * v40);
              v18 = v41;
              v19 = v39;
              *(_QWORD *)v12 = v10;
              v20 = v34;
              v21 = v40;
              v22 = v38;
              if ( v34 )
              {
                v23 = v34 + v38;
                v24 = v40;
                LODWORD(v38) = v19;
                v25 = *(_BYTE *)(v34 + v22);
                v39 = v22;
                v40 = v18;
                v41 = v21;
                sub_9050(v23, v34 + v18, v24);
                *(_BYTE *)(v20 + v11) = v25;
                v19 = v38;
                v22 = v39;
                v18 = v40;
                v21 = v41;
              }
              v16 = (char *)&v33 + 2 * v18;
              if ( *(unsigned __int16 *)v16 <= v43 - v4 )
              {
                LODWORD(v40) = v19;
                v41 = v22;
                sub_9050((char *)&v33 + 2 * v22, (char *)&v33 + 2 * v18, 2 * v21);
                v7 = v41;
                *((_WORD *)&v33 + (unsigned int)v40) = v42;
                goto LABEL_3;
              }
              goto LABEL_16;
            }
          }
        }
        if ( v45 )
        {
          v27 = *(_DWORD **)(v13 + 976);
          if ( v27 )
          {
            v28 = v27 + 2;
            v29 = *v27 - 1;
            while ( v29 != -1 )
            {
              v30 = v29--;
              if ( *(_QWORD *)&v28[2 * v30] == v10 )
              {
                v31 = *(__int64 **)(v10 + 968);
                if ( v31 )
                {
                  while ( 1 )
                  {
                    v32 = *v31;
                    if ( !*v31 )
                      break;
                    ++v31;
                    if ( v13 == v32 )
                      goto LABEL_8;
                  }
                }
                goto LABEL_13;
              }
            }
          }
        }
LABEL_8:
        --v11;
        v12 -= 8LL;
      }
      while ( v4 < (unsigned int)v11 );
    }
LABEL_9:
    v15 = i;
    if ( v43 == i )
      return;
    goto LABEL_10;
  }
}
// 9050: using guessed type __int64 __fastcall sub_9050(_QWORD, _QWORD, _QWORD);

//----- (00000000000832B0) ----------------------------------------------------
void __fastcall sub_832B0(__int64 *a1, unsigned __int8 a2)
{
  unsigned int *v2; // rax
  __int64 v3; // rdx

  if ( a1 )
  {
    v2 = sub_87780((__int64)a1, "__libc_early_init", 0x69682ACu, (__int64)"GLIBC_PRIVATE", 157536133);
    if ( !v2 )
      sub_CF00("sym != NULL", "dl-call-libc-early-init.c", 37LL, "_dl_call_libc_early_init");
    if ( *((_WORD *)v2 + 3) == 0xFFF1 )
      v3 = 0LL;
    else
      v3 = *a1;
    ((void (__fastcall *)(_QWORD))(*((_QWORD *)v2 + 1) + v3))(a2);
  }
}
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000083340) ----------------------------------------------------
unsigned __int64 (__fastcall *__fastcall sub_83340(__int64 a1, __int64 a2, __m128 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10))()
{
  __int64 v10; // r13
  __int64 v11; // r12
  unsigned __int64 (__fastcall *result)(); // rax
  __int64 v14; // rbp
  __int64 v15; // rdx
  __int64 v16; // rdi
  unsigned int *v17; // rax
  __int64 v18; // r8
  __int64 v19; // rdx
  unsigned int *v20; // [rsp+8h] [rbp-30h] BYREF

  v10 = *(_QWORD *)(a1 + 8);
  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 664) + 8LL) + *(_QWORD *)a2;
  result = *(unsigned __int64 (__fastcall **)())a1;
  if ( v11 == *(_QWORD *)a1 )
  {
    v14 = a2;
    result = *(unsigned __int64 (__fastcall **)())a1;
    if ( v11 == *(_QWORD *)a1 )
    {
      *(_QWORD *)a1 = sub_79B40;
      v15 = *(unsigned int *)(v10 + 12);
      v16 = *(_QWORD *)(*(_QWORD *)(a2 + 104) + 8LL);
      v17 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)(a2 + 112) + 8LL) + 24 * v15);
      v20 = v17;
      if ( !(*((_BYTE *)v17 + 4) >> 4) || (*((_BYTE *)v17 + 5) & 3) != 0 )
        goto LABEL_10;
      v18 = *(_QWORD *)(a2 + 464);
      if ( v18 )
      {
        v18 = *(_QWORD *)(a2 + 744) + 24LL * (*(_WORD *)(*(_QWORD *)(v18 + 8) + 2 * v15) & 0x7FFF);
        if ( !*(_DWORD *)(v18 + 8) )
          v18 = 0LL;
      }
      v14 = sub_73690(
              (unsigned __int8 *)(*v17 + v16),
              a2,
              &v20,
              *(__int64 ***)(a2 + 912),
              (const char **)v18,
              1,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              a9,
              a10,
              1,
              0LL);
      if ( v20 )
      {
LABEL_10:
        v19 = *(_QWORD *)(v14 + 1104);
        if ( (unsigned __int64)(v19 + 1) <= 1 )
        {
          sub_74730(v14);
          v19 = *(_QWORD *)(v14 + 1104);
        }
        *(_QWORD *)(a1 + 8) = *((_QWORD *)v20 + 1) + *(_QWORD *)(v10 + 16) - v19;
        result = (unsigned __int64 (__fastcall *)())sub_79A90;
        *(_QWORD *)a1 = sub_79A90;
      }
      else
      {
        *(_QWORD *)(a1 + 8) = *(_QWORD *)(v10 + 16);
        result = sub_79AA0;
        *(_QWORD *)a1 = sub_79AA0;
      }
    }
  }
  return result;
}
// 9228: using guessed type __int64 __fastcall sub_9228(_QWORD);
// 9248: using guessed type __int64 __fastcall sub_9248(_QWORD);
// 79A90: using guessed type __int64 __fastcall sub_79A90();
// 79B40: using guessed type __int64 __fastcall sub_79B40();

//----- (00000000000834E0) ----------------------------------------------------
__int64 __fastcall sub_834E0(__int64 a1)
{
  return *(_QWORD *)a1;
}
// 9228: using guessed type __int64 __fastcall sub_9228(_QWORD);
// 9248: using guessed type __int64 __fastcall sub_9248(_QWORD);

//----- (0000000000083550) ----------------------------------------------------
unsigned __int64 __fastcall sub_83550(__int64 a1)
{
  return munmap(*(void **)(a1 + 848), *(_QWORD *)(a1 + 856) - *(_QWORD *)(a1 + 848));
}

//----- (0000000000083570) ----------------------------------------------------
__int64 __fastcall sub_83570(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4, int a5)
{
  int v5; // esi
  __int64 result; // rax
  unsigned __int8 v8; // r11
  unsigned int v9; // er8
  int v10; // ebp
  int v11; // edi
  __int64 v12; // rcx
  char v13; // r14
  __int64 v14; // r9
  __int64 *v15; // rdi
  __int64 v16; // rbx
  __int64 v17; // r12
  unsigned int v18; // er13
  int v19; // esi
  signed __int64 v20; // rax
  char v21; // dl
  char v22; // r8
  __int64 v23; // r9
  __int64 v24; // r10
  __int64 v25; // rcx
  __int64 v26; // rdx
  char v27; // [rsp+0h] [rbp-4Ah]
  char v28; // [rsp+1h] [rbp-49h]
  __int64 v29; // [rsp+Ah] [rbp-40h]

  v5 = byte_C1470 & 3;
  result = ((unsigned __int8)byte_C1470 >> 2) & 3;
  LOBYTE(a3) = v5 == 1 && (_DWORD)result == 1;
  if ( (_BYTE)a3 || (dword_C1474 & 3) == 0 )
    return result;
  v27 = dword_C1474 & 1;
  v28 = (dword_C1474 & 2) != 0;
  v8 = dword_C1474 & (v5 != 2);
  LOBYTE(a5) = (_DWORD)result != 2;
  v9 = ((unsigned int)dword_C1474 >> 1) & a5;
  LOBYTE(v10) = v9 | v8;
  if ( (unsigned __int8)v9 | v8 )
  {
    v11 = *(_DWORD *)(a1 + 712);
    v12 = (unsigned int)(v11 - 1);
    if ( v11 )
    {
      v13 = 0;
      v14 = 0LL;
      v29 = *(_QWORD *)(a1 + 968);
      v15 = (__int64 *)(v29 + 8LL * (unsigned int)v12);
      v16 = 0LL;
      while ( 1 )
      {
        v17 = *v15;
        if ( (*(_BYTE *)(*v15 + 796) & 8) == 0 )
          break;
LABEL_16:
        v12 = (unsigned int)(v12 - 1);
        --v15;
        if ( (_DWORD)v12 == -1 )
        {
          if ( v27 != v8 || v28 != (_BYTE)v9 )
          {
            if ( v5 != 3 && (_BYTE)a3 )
              sub_50110(
                0LL,
                *(_BYTE **)(*(_QWORD *)(v29 + 8 * v16) + 8LL),
                "dlopen",
                "rebuild shared object with IBT support enabled");
            if ( (_DWORD)result == 3 )
              goto LABEL_35;
            if ( v13 )
              sub_50110(
                0LL,
                *(_BYTE **)(*(_QWORD *)(v29 + 8 * v14) + 8LL),
                "dlopen",
                "rebuild shared object with SHSTK support enabled");
            if ( v5 == 3 )
            {
LABEL_35:
              LOBYTE(v10) = v8;
              goto LABEL_39;
            }
          }
          return result;
        }
      }
      v18 = (unsigned int)a3 ^ 1;
      if ( v5 == 1 )
      {
        LOBYTE(v18) = (v8 ^ v27) & v18;
        if ( (_BYTE)v18 )
        {
          a3 = (unsigned __int64 *)v18;
          v16 = (unsigned int)v12;
        }
        LOBYTE(v17) = *(_BYTE *)(v17 + 801);
      }
      else
      {
        LOWORD(v17) = *(unsigned __int8 *)(v17 + 801);
        v8 &= (unsigned __int16)v17 >> 1;
        LOBYTE(v18) = (v8 ^ v27) & v18;
        if ( (_BYTE)v18 )
          a3 = (unsigned __int64 *)v18;
        if ( (_BYTE)v18 )
          v16 = v12;
        if ( (_DWORD)result == 1 )
          goto LABEL_12;
      }
      LOBYTE(v9) = ((unsigned __int8)v17 >> 2) & v9;
LABEL_12:
      if ( v28 != (_BYTE)v9 )
        v13 = v10;
      if ( v28 != (_BYTE)v9 )
        v14 = v12;
      goto LABEL_16;
    }
    v27 ^= v8;
    LOBYTE(v10) = dword_C1474 & (v5 != 2);
    v28 ^= v9;
  }
  else
  {
    LOBYTE(v9) = 0;
  }
  if ( (v27 || v28) && ((_DWORD)result == 3 || v5 == 3) )
  {
    v16 = 0LL;
LABEL_39:
    v19 = (unsigned __int8)v10 ^ 1;
    if ( !(_BYTE)v9 )
      v19 = (unsigned __int8)v10 ^ 1 | 2;
    v20 = sys_arch_prctl((struct task_struct *)((char *)&stru_2FF8.r_info + 2), v19, a3);
    if ( (_DWORD)v20 )
    {
      v25 = *(_QWORD *)(v24 + 968);
      if ( v21 )
        v26 = *(_QWORD *)(v25 + 8 * v16);
      else
        v26 = *(_QWORD *)(v25 + 8 * v23);
      sub_50110((unsigned int)-(int)v20, *(_BYTE **)(v26 + 8), "dlopen", "can't disable CET");
    }
    v10 = (unsigned __int8)v10;
    dword_C1474 &= ~v19;
    result = (unsigned __int8)v10 | 2u;
    if ( v22 )
      v10 = (unsigned __int8)v10 | 2;
    __writefsdword(0x48u, v10);
  }
  return result;
}
// 83773: variable 'v24' is possibly undefined
// 8377C: variable 'v21' is possibly undefined
// 8377E: variable 'v23' is possibly undefined
// 837B4: variable 'v22' is possibly undefined
// 2FF8: using guessed type Elf64_Rela stru_2FF8;
// C1470: using guessed type char byte_C1470;
// C1474: using guessed type int dword_C1474;

//----- (0000000000083B60) ----------------------------------------------------
__int64 __fastcall sub_83B60(__int64 a1, __int64 a2)
{
  int v2; // ecx
  __int64 v3; // rsi
  __int64 v4; // rdi
  __int64 v5; // rdx
  __int64 v6; // rax
  __int64 v7; // rdx

  v2 = *(unsigned __int16 *)(a1 + 696);
  v3 = a2 - *(_QWORD *)a1;
  if ( !(_WORD)v2 )
    return 0LL;
  v4 = *(_QWORD *)(a1 + 680);
  v5 = 56LL * (unsigned __int16)v2;
  v6 = v4 + v5 - 56;
  v7 = v4 + v5 - 112 - 56LL * (unsigned int)(v2 - 1);
  while ( *(_DWORD *)v6 != 1 || (unsigned __int64)(v3 - *(_QWORD *)(v6 + 16)) >= *(_QWORD *)(v6 + 40) )
  {
    v6 -= 56LL;
    if ( v6 == v7 )
      return 0LL;
  }
  return 1LL;
}

//----- (0000000000083BE0) ----------------------------------------------------
unsigned __int64 __fastcall sub_83BE0(unsigned __int64 *a1)
{
  unsigned __int64 v1; // r8

  v1 = __readfsqword(0xFFFFFFA8);
  if ( a1 )
  {
    if ( a1 == (unsigned __int64 *)-1LL )
      a1 = (unsigned __int64 *)off_BF8E0;
    __writefsqword(0xFFFFFFA8, (unsigned __int64)a1);
    if ( &dword_0 != (__int64 (**)(void))-2LL )
      __writefsqword(0xFFFFFFA0, (unsigned __int64)a1);
    if ( &dword_0 != (__int64 (**)(void))-2LL )
      __writefsqword(0xFFFFFFB8, (unsigned __int64)(a1 + 4));
    if ( &dword_0 != (__int64 (**)(void))-2LL )
      __writefsqword(0xFFFFFFB0, (unsigned __int64)(a1 + 1));
    __writefsqword(0xFFFFFFF8, a1[13]);
    __writefsqword(0xFFFFFFE8, a1[14]);
    __writefsqword(0xFFFFFFF0, a1[15]);
  }
  if ( (void ***)v1 == off_BF8E0 )
    v1 = -1LL;
  return v1;
}
// 0: using guessed type __int64 (*dword_0)(void);
// BF8E0: using guessed type void **off_BF8E0[6];

//----- (0000000000083D80) ----------------------------------------------------
__int64 __fastcall sub_83D80(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdx
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rcx

  v3 = a3 - 1;
  if ( v3 < 0 )
    return 0LL;
  while ( 1 )
  {
    v5 = *(_QWORD *)(a1 + 8 * v3);
    v6 = *(_QWORD *)(a2 + 8 * v3);
    if ( v5 != v6 )
      break;
    if ( v3-- == 0 )
      return 0LL;
  }
  return v6 < v5 ? 1 : -1;
}

//----- (0000000000083DC0) ----------------------------------------------------
__int64 __fastcall sub_83DC0(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4, __int64 *a5, __int64 a6)
{
  unsigned __int64 *v9; // r12
  unsigned __int64 v10; // r13
  __int64 v11; // r14
  unsigned __int64 v12; // rcx
  __int64 v13; // rbp
  __int64 v14; // rax
  __int64 *v15; // r14
  unsigned __int64 v16; // r12
  __int64 v17; // r13
  unsigned __int64 v18; // rbx
  bool v19; // cf
  unsigned __int128 v20; // rtt
  unsigned __int64 v21; // rcx
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // rsi
  __int64 v24; // rdi
  unsigned __int64 v25; // rdx
  __int64 v26; // r9
  __int64 v27; // rcx
  unsigned __int128 v28; // rtt
  __int64 v29; // rcx
  unsigned __int128 v30; // rtt
  __int64 *v32; // rax
  __int64 v33; // rdx
  unsigned __int64 *v34; // r11
  __int64 v35; // r9
  __int64 v36; // r10
  unsigned __int64 v37; // rcx
  unsigned __int64 v38; // rdi
  __int64 v39; // rbx
  unsigned __int64 v40; // rsi
  unsigned __int64 v41; // rdi
  unsigned __int64 v42; // rcx
  unsigned __int128 v43; // rtt
  unsigned __int64 v44; // rdi
  unsigned __int128 v45; // rax
  unsigned __int128 v46; // kr10_16
  int v47; // eax
  __int64 *v48; // [rsp+0h] [rbp-88h]
  __int64 v49; // [rsp+8h] [rbp-80h]
  __int64 *v50; // [rsp+8h] [rbp-80h]
  __int64 *v51; // [rsp+8h] [rbp-80h]
  __int64 *v54; // [rsp+20h] [rbp-68h]
  unsigned __int64 v55; // [rsp+20h] [rbp-68h]
  __int64 v56; // [rsp+28h] [rbp-60h]
  __int64 v57; // [rsp+30h] [rbp-58h]
  __int64 v58; // [rsp+38h] [rbp-50h]
  __int64 v59; // [rsp+48h] [rbp-40h]

  if ( a6 != 1 )
  {
    if ( a6 != 2 )
    {
      if ( !a6 )
        BUG();
      v57 = 0LL;
      v9 = &a3[a4 - a6];
      v56 = a6;
      v10 = a5[a6 - 1];
      v11 = a5[a6 - 2];
      v58 = 8 * a6 - 8;
      v12 = *(unsigned __int64 *)((char *)v9 + v58);
      v59 = 8 * a6 - 16;
      v48 = (__int64 *)((char *)v9 + v58);
      if ( v10 <= v12 )
      {
        if ( v10 < v12
          || (v55 = v9[a6 - 1],
              v50 = a5,
              v47 = sub_83D80((__int64)v9, (__int64)a5, a6 - 1),
              a5 = v50,
              v12 = v55,
              v47 >= 0) )
        {
          v51 = a5;
          sub_85440((__int64)v9, v9, a5, a6);
          a5 = v51;
          v57 = 1LL;
          v12 = *v48;
        }
      }
      v13 = a4 + a2 - a6 - 1;
      if ( v13 >= 0 )
      {
        v14 = v11;
        v54 = a5;
        v15 = (__int64 *)v9;
        v16 = v10;
        v17 = v14;
        do
        {
          if ( a2 > v13 )
          {
            v49 = *v48;
            v32 = &v15[v56];
            if ( a6 > 0 )
            {
              do
              {
                v33 = *--v32;
                v32[1] = v33;
              }
              while ( v15 != v32 );
            }
            *v15 = 0LL;
          }
          else
          {
            --v15;
            v49 = v15[v56];
            v48 = (__int64 *)((char *)v15 + v58);
          }
          v18 = -1LL;
          if ( v16 != v12 )
          {
            *(_QWORD *)&v20 = *v48;
            *((_QWORD *)&v20 + 1) = v12;
            v18 = v20 / v16;
            v21 = v20 % v16;
            v22 = v18 * v17;
            v23 = (v18 * (unsigned __int128)(unsigned __int64)v17) >> 64;
            while ( v23 > v21 || v23 == v21 && *(__int64 *)((char *)v15 + v59) < v22 )
            {
              --v18;
              v19 = __CFADD__(v16, v21);
              v21 += v16;
              if ( v19 )
                break;
              v23 = (__PAIR128__(v23, v22) - (unsigned __int64)v17) >> 64;
              v22 -= v17;
            }
          }
          if ( v49 != sub_854F0((unsigned __int64 *)v15, (unsigned __int64 *)v54, a6, v18) )
          {
            --v18;
            sub_87CF0((__int64)v15, v15, v54, a6);
          }
          *(_QWORD *)(a1 + 8 * v13) = v18;
          v12 = *v48;
          v19 = v13-- == 0;
        }
        while ( !v19 );
      }
      return v57;
    }
    v34 = &a3[a4 - 2];
    v35 = a5[1];
    v36 = *a5;
    v57 = 0LL;
    v37 = v34[1];
    v38 = *v34;
    if ( __PAIR128__(v35, v36) <= __PAIR128__(v37, v38) )
    {
      v57 = 1LL;
      v37 = (__PAIR128__(v37, v38) - __PAIR128__(v35, v36)) >> 64;
      v38 -= v36;
    }
    v39 = a2 + a4 - 3;
    if ( v39 < 0 )
    {
LABEL_46:
      v34[1] = v37;
      *v34 = v38;
      return v57;
    }
    while ( 1 )
    {
      if ( a2 <= v39 )
      {
        v40 = *--v34;
        if ( v35 != v37 )
          goto LABEL_42;
      }
      else
      {
        *v34 = 0LL;
        v40 = 0LL;
        if ( v35 != v37 )
        {
LABEL_42:
          *(_QWORD *)&v43 = v38;
          *((_QWORD *)&v43 + 1) = v37;
          v44 = v43 / (unsigned __int64)v35;
          v42 = v43 % (unsigned __int64)v35;
          v45 = v44 * (unsigned __int128)(unsigned __int64)v36;
          goto LABEL_43;
        }
      }
      v19 = __CFADD__(v35, v38);
      v41 = v35 + v38;
      v42 = v41;
      if ( v19 )
      {
        *(_QWORD *)(a1 + 8 * v39) = -1LL;
        v37 = (__PAIR128__(v41 - v36, v36) + v40) >> 64;
        v38 = v36 + v40;
        v19 = v39-- == 0;
        if ( v19 )
          goto LABEL_46;
      }
      else
      {
        *(_QWORD *)&v45 = -v36;
        v44 = -1LL;
        *((_QWORD *)&v45 + 1) = (v36 == 0) + v36 - 1;
        do
        {
LABEL_43:
          if ( v45 <= __PAIR128__(v42, v40) )
            break;
          --v44;
          v45 -= (unsigned __int64)v36;
          v19 = __CFADD__(v35, v42);
          v42 += v35;
        }
        while ( !v19 );
        *(_QWORD *)(a1 + 8 * v39) = v44;
        v46 = __PAIR128__(v42, v40) - v45;
        v37 = v46 >> 64;
        v38 = v46;
        v19 = v39-- == 0;
        if ( v19 )
          goto LABEL_46;
      }
    }
  }
  v24 = *a5;
  v25 = a3[a4 - 1];
  v57 = 0LL;
  if ( *a5 <= v25 )
  {
    v57 = 1LL;
    v25 -= v24;
  }
  v26 = 8 * a2 + a1;
  if ( a4 - 2 >= 0 )
  {
    v27 = a4 - 2;
    do
    {
      *(_QWORD *)&v28 = a3[v27];
      *((_QWORD *)&v28 + 1) = v25;
      v25 = v28 % (unsigned __int64)v24;
      *(_QWORD *)(v26 + v27 * 8) = v28 / (unsigned __int64)v24;
      --v27;
    }
    while ( v27 != -1 );
  }
  if ( a2 > 0 )
  {
    v29 = v26 - 8;
    do
    {
      v29 -= 8LL;
      *(_QWORD *)&v30 = 0LL;
      *((_QWORD *)&v30 + 1) = v25;
      v25 = v30 % (unsigned __int64)v24;
      *(_QWORD *)(v29 + 8) = v30 / (unsigned __int64)v24;
    }
    while ( a1 - 8 != v29 );
  }
  *a3 = v25;
  return v57;
}

//----- (00000000000841E0) ----------------------------------------------------
unsigned __int64 __fastcall sub_841E0(__int64 a1, __int64 a2, unsigned __int64 a3, char a4)
{
  unsigned __int64 *v4; // rdi
  unsigned __int64 *v5; // rsi
  unsigned int v6; // eax
  unsigned __int64 v7; // r10
  unsigned __int64 v8; // r11
  unsigned __int64 result; // rax
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // r9
  bool v13; // cf

  v4 = (unsigned __int64 *)(a1 + 8 * a3 - 8);
  v5 = (unsigned __int64 *)(a2 + 8 * a3 - 8);
  v6 = a3 & 3;
  if ( (a3 & 3) == 0 )
  {
    v7 = *v5;
    v8 = *(v5 - 1);
    result = *v5 >> (64 - a4);
    v10 = *(v5 - 2);
    v4 += 3;
    v11 = a3 - 4;
    while ( 1 )
    {
      v12 = *(v5 - 3);
      *(v4 - 3) = (v7 << a4) | (v8 >> (64 - a4));
      v5 -= 4;
      v4 -= 4;
      v13 = v11 < 4;
      v11 -= 4LL;
      if ( v13 )
        break;
LABEL_12:
      v7 = *v5;
      *v4 = (v8 << a4) | (v10 >> (64 - a4));
LABEL_13:
      v8 = *(v5 - 1);
      *(v4 - 1) = (v10 << a4) | (v12 >> (64 - a4));
LABEL_14:
      v10 = *(v5 - 2);
      *(v4 - 2) = (v12 << a4) | (v7 >> (64 - a4));
    }
    goto LABEL_16;
  }
  if ( v6 >= 2 )
  {
    if ( v6 != 2 )
    {
      v8 = *v5;
      v10 = *(v5 - 1);
      result = *v5 >> (64 - a4);
      v12 = *(v5 - 2);
      v5 -= 3;
      v13 = a3 < 4;
      v11 = a3 - 4;
      if ( !v13 )
        goto LABEL_12;
LABEL_16:
      *v4 = (v8 << a4) | (v10 >> (64 - a4));
      *(v4 - 1) = (v10 << a4) | (v12 >> (64 - a4));
      *(v4 - 2) = v12 << a4;
      return result;
    }
    v10 = *v5;
    v12 = *(v5 - 1);
    result = *v5 >> (64 - a4);
    v13 = a3 < 3;
    v11 = a3 - 3;
    if ( !v13 )
    {
      v7 = *(v5 - 2);
      v5 -= 2;
      ++v4;
      goto LABEL_13;
    }
    *v4 = (v10 << a4) | (v12 >> (64 - a4));
    *(v4 - 1) = v12 << a4;
  }
  else
  {
    v12 = *v5;
    result = *v5 >> (64 - a4);
    v13 = a3 < 2;
    v11 = a3 - 2;
    if ( !v13 )
    {
      v7 = *(v5 - 1);
      v8 = *(v5 - 2);
      --v5;
      v4 += 2;
      goto LABEL_14;
    }
    *v4 = v12 << a4;
  }
  return result;
}

//----- (0000000000084300) ----------------------------------------------------
unsigned __int64 __fastcall sub_84300(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 a3, char a4)
{
  unsigned int v4; // eax
  unsigned __int64 v5; // r10
  unsigned __int64 v6; // r11
  unsigned __int64 result; // rax
  unsigned __int64 v8; // r8
  unsigned __int64 *v9; // rsi
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r9
  bool v12; // cf

  v4 = a3 & 3;
  if ( (a3 & 3) == 0 )
  {
    v5 = *a2;
    v6 = a2[1];
    result = *a2 << (64 - a4);
    v8 = a2[2];
    v9 = a2 + 1;
    a1 -= 3;
    v10 = a3 - 4;
    while ( 1 )
    {
      v11 = v9[2];
      a1[3] = (v5 >> a4) | (v6 << (64 - a4));
      v9 += 4;
      a1 += 4;
      v12 = v10 < 4;
      v10 -= 4LL;
      if ( v12 )
        break;
LABEL_12:
      v5 = *(v9 - 1);
      *a1 = (v6 >> a4) | (v8 << (64 - a4));
LABEL_13:
      v6 = *v9;
      a1[1] = (v8 >> a4) | (v11 << (64 - a4));
LABEL_14:
      v8 = v9[1];
      a1[2] = (v11 >> a4) | (v5 << (64 - a4));
    }
    goto LABEL_16;
  }
  if ( v4 >= 2 )
  {
    if ( v4 != 2 )
    {
      v6 = *a2;
      v8 = a2[1];
      result = *a2 << (64 - a4);
      v11 = a2[2];
      v9 = a2 + 4;
      v12 = a3 < 4;
      v10 = a3 - 4;
      if ( !v12 )
        goto LABEL_12;
LABEL_16:
      *a1 = (v6 >> a4) | (v8 << (64 - a4));
      a1[1] = (v8 >> a4) | (v11 << (64 - a4));
      a1[2] = v11 >> a4;
      return result;
    }
    v8 = *a2;
    v11 = a2[1];
    result = *a2 << (64 - a4);
    v12 = a3 < 3;
    v10 = a3 - 3;
    if ( !v12 )
    {
      v5 = a2[2];
      v9 = a2 + 3;
      --a1;
      goto LABEL_13;
    }
    *a1 = (v8 >> a4) | (v11 << (64 - a4));
    a1[1] = v11 >> a4;
  }
  else
  {
    v11 = *a2;
    result = *a2 << (64 - a4);
    v12 = a3 < 2;
    v10 = a3 - 2;
    if ( !v12 )
    {
      v5 = a2[1];
      v6 = a2[2];
      v9 = a2 + 2;
      a1 -= 2;
      goto LABEL_14;
    }
    *a1 = v11 >> a4;
  }
  return result;
}

//----- (0000000000084410) ----------------------------------------------------
__int64 __fastcall sub_84410(__int64 *a1, __int64 *a2, __int64 a3, unsigned __int64 *a4, __int64 a5)
{
  __int64 v5; // r13
  __int64 v6; // rbx
  __int64 result; // rax
  unsigned __int64 v8; // rcx
  __int64 *v9; // r12
  __int64 v10; // r14
  void *v11; // rsp
  __int64 v12; // rdx
  __int64 *v13; // r12
  __int64 *v14; // r9
  __int64 v15; // r13
  void *v16; // rsp
  __int64 v17; // rax
  __int64 *v18; // rbx
  __int64 *v19; // r12
  __int64 v20; // rax
  char *v21; // rdi
  _BOOL8 v22; // rdx
  char *v23; // rsi
  __int64 v24; // rdx
  __int64 v25; // rax
  __int64 *v26; // rcx
  __int64 *v27; // r14
  unsigned __int64 *v28; // r12
  __int64 v29; // rdx
  size_t v30; // r8
  __int64 *v31; // r15
  __int64 v32; // rax
  bool v33; // cf
  _QWORD *v34; // r10
  __int64 *v35; // rsi
  __int64 *v36; // rdi
  __int64 v37; // rax
  __int64 *v38; // rcx
  __int64 i; // rax
  __int64 v40; // [rsp+0h] [rbp-80h] BYREF
  __int64 v41; // [rsp+8h] [rbp-78h]
  void *v42; // [rsp+10h] [rbp-70h]
  _QWORD *v43; // [rsp+18h] [rbp-68h]
  __int64 *v44; // [rsp+20h] [rbp-60h]
  __int64 *v45; // [rsp+28h] [rbp-58h]
  unsigned __int64 *v46; // [rsp+30h] [rbp-50h]
  __int64 *v47; // [rsp+38h] [rbp-48h]
  unsigned __int64 v48; // [rsp+48h] [rbp-38h]

  v5 = a3;
  v6 = a5;
  v45 = a1;
  v46 = a4;
  v48 = __readfsqword(0x28u);
  result = 0LL;
  if ( a5 <= 31 )
  {
    if ( !a5 )
      return result;
    v8 = *a4;
    if ( v8 > 1 )
    {
      result = sub_847C0(v45, a2, a3, v8);
    }
    else
    {
      if ( v8 != 1 )
      {
        if ( a3 > 0 )
          sub_9190((__int64)v45, 0LL, 8 * a3);
        goto LABEL_8;
      }
      if ( a3 <= 0 )
      {
LABEL_8:
        result = 0LL;
        goto LABEL_20;
      }
      v38 = v45;
      for ( i = 0LL; i != a3; ++i )
        v38[i] = a2[i];
      result = 0LL;
    }
LABEL_20:
    v26 = v45;
    v45[v5] = result;
    v27 = v26 + 1;
    if ( v6 > 1 )
    {
      v47 = &v26[v6];
      v28 = v46 + 1;
      do
      {
        if ( *v28 <= 1 )
        {
          result = 0LL;
          if ( *v28 == 1 )
            result = sub_87CF0((__int64)v27, v27, a2, v5);
        }
        else
        {
          result = sub_87DA0(v27, (unsigned __int64 *)a2, v5, *v28);
        }
        v27[v5] = result;
        ++v28;
        ++v27;
      }
      while ( v27 != v47 );
    }
    return result;
  }
  v9 = v45;
  v10 = a3 - a5;
  v11 = alloca(16 * a5 + 16);
  v43 = (_QWORD *)(16 * a5 + 16);
  v44 = &v40;
  sub_849E0(v45, a2, v46, a5, &v40);
  v12 = 8 * v6;
  v47 = (__int64 *)(8 * v6);
  v13 = &v9[v6];
  v14 = &a2[v6];
  if ( v6 > v10 )
    goto LABEL_17;
  v40 = v5;
  v15 = v6;
  v16 = alloca((signed __int64)v43);
  v43 = (__int64 *)((char *)&v40 + v12);
  v42 = (char *)&v40 + v12 + 8;
  v17 = v6 - 1;
  v18 = v13;
  v19 = v14;
  v41 = v17;
  do
  {
    sub_849E0(&v40, v19, v46, v15, v44);
    v20 = sub_87CF0((__int64)v18, v18, &v40, v15);
    v18 = (__int64 *)((char *)v18 + (_QWORD)v47);
    v21 = (char *)(v18 + 1);
    v22 = __CFADD__(*v43, v20);
    *v18 = *v43 + v20;
    if ( !v22 )
    {
      v29 = v41;
      v23 = (char *)v42;
      if ( v21 == v42 )
        goto LABEL_15;
LABEL_28:
      v30 = 8 * v29;
      if ( v29 <= 0 )
        v30 = 8LL;
      memcpy(v21, v23, v30);
      goto LABEL_15;
    }
    v23 = (char *)v42;
    v24 = v15 - 1;
    while ( 1 )
    {
      v25 = *(_QWORD *)v23;
      v21 += 8;
      v23 += 8;
      *((_QWORD *)v21 - 1) = ++v25;
      if ( v25 )
        break;
      if ( !--v24 )
        goto LABEL_15;
    }
    if ( v23 != v21 )
    {
      v29 = v24 - 1;
      if ( v29 > 0 )
        goto LABEL_28;
    }
LABEL_15:
    v10 -= v15;
    v19 = (__int64 *)((char *)v19 + (_QWORD)v47);
  }
  while ( v15 <= v10 );
  v14 = v19;
  v13 = v18;
  v6 = v15;
  v5 = v40;
LABEL_17:
  if ( v10 )
  {
    v31 = v44;
    sub_84410(v44, v46, v6, v14, v10);
    v32 = sub_87CF0((__int64)v13, v13, v31, v6);
    v33 = __CFADD__(*(__int64 *)((char *)v31 + (_QWORD)v47), v32);
    v34 = (__int64 *)((char *)v47 + (_QWORD)v13);
    v35 = (__int64 *)((char *)v31 + (_QWORD)v47 + 8);
    *v34 = *(__int64 *)((char *)v31 + (_QWORD)v47) + v32;
    v36 = v34 + 1;
    if ( v33 )
    {
      while ( --v10 )
      {
        v37 = *v35;
        ++v36;
        ++v35;
        *(v36 - 1) = ++v37;
        if ( v37 )
          goto LABEL_35;
      }
    }
    else
    {
LABEL_35:
      if ( v36 != v35 && v10 > 1 )
        memcpy(v36, v35, 8 * v10 - 8);
    }
  }
  return v45[v5 - 1 + v6];
}

//----- (00000000000847C0) ----------------------------------------------------
__int64 __fastcall sub_847C0(_QWORD *a1, _QWORD *a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int128 v5; // rax
  __int64 v6; // r11
  _QWORD *v7; // rsi
  _QWORD *v8; // rdi
  __int64 v9; // r11
  unsigned __int64 v10; // r9
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // rbx
  unsigned __int64 v14; // r8
  __int64 v15; // rbx
  unsigned __int64 v16; // r10
  unsigned __int64 v17; // r10
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // r9
  unsigned __int64 v20; // kr00_8
  unsigned __int128 v21; // rax
  unsigned __int128 v22; // rax
  unsigned __int64 v23; // kr08_8
  unsigned __int128 v24; // rax

  v5 = 0 + a4 * (unsigned __int128)(unsigned __int64)*a2;
  switch ( a3 & 3 )
  {
    case 0LL:
      v7 = &a2[a3];
      v8 = &a1[a3 - 2];
      v9 = -a3;
      v13 = *((_QWORD *)&v5 + 1);
      v14 = v5;
      goto LABEL_12;
    case 2LL:
      v7 = &a2[a3 - 2];
      v8 = &a1[a3 - 4];
      v9 = -a3;
      v17 = v5;
      *(_QWORD *)&v5 = v7[v9 + 3];
      v19 = *((_QWORD *)&v5 + 1);
      goto LABEL_14;
    case 3LL:
      v7 = &a2[a3 - 1];
      v8 = &a1[a3 - 3];
      v9 = -a3;
      v16 = *((_QWORD *)&v5 + 1);
      v15 = v5;
      goto LABEL_13;
  }
  v6 = a3 - 1;
  if ( v6 )
  {
    v7 = &a2[v6 + 1];
    v8 = &a1[v6 - 1];
    v9 = -v6;
    v10 = v5;
    *(_QWORD *)&v5 = v7[v9];
    v12 = *((_QWORD *)&v5 + 1);
    while ( 1 )
    {
      v8[v9 + 1] = v10;
      v13 = (a4 * (unsigned __int128)v11 + v12) >> 64;
      v14 = a4 * v11 + v12;
LABEL_12:
      v21 = a4 * (unsigned __int128)(unsigned __int64)v7[v9 + 1];
      v8[v9 + 2] = v14;
      v16 = (v21 + v13) >> 64;
      v15 = v21 + v13;
LABEL_13:
      v22 = a4 * (unsigned __int128)(unsigned __int64)v7[v9 + 2];
      v8[v9 + 3] = v15;
      v23 = v22;
      v18 = v7[v9 + 3];
      v19 = (__PAIR128__(*((unsigned __int64 *)&v22 + 1), v23) + v16) >> 64;
      v17 = v23 + v16;
LABEL_14:
      v24 = a4 * (unsigned __int128)v18;
      v9 += 4LL;
      if ( v9 >= 0 )
        break;
      v8[v9] = v17;
      v20 = v24;
      v11 = v7[v9];
      v12 = (__PAIR128__(*((unsigned __int64 *)&v24 + 1), v20) + v19) >> 64;
      v10 = v20 + v19;
    }
    v8[v9] = v17;
    *((_QWORD *)&v5 + 1) = (v24 + v19) >> 64;
    v8[v9 + 1] = v24 + v19;
  }
  else
  {
    *a1 = a4 * *a2;
  }
  return *((_QWORD *)&v5 + 1);
}

//----- (00000000000848E0) ----------------------------------------------------
unsigned __int64 __fastcall sub_848E0(_QWORD *a1, __int64 *a2, unsigned __int64 *a3, __int64 a4)
{
  unsigned __int64 result; // rax
  __int64 *v7; // rbx
  __int64 v8; // rbp
  unsigned __int64 v9; // rcx
  __int64 i; // rax

  if ( *a3 > 1 )
  {
    result = sub_847C0(a1, a2, a4, *a3);
  }
  else
  {
    if ( *a3 == 1 )
    {
      if ( a4 > 0 )
      {
        for ( i = 0LL; i != a4; ++i )
          a1[i] = a2[i];
      }
    }
    else if ( a4 > 0 )
    {
      sub_9190((__int64)a1, 0LL, 8 * a4);
    }
    result = 0LL;
  }
  a1[a4] = result;
  v7 = a1 + 1;
  if ( a4 > 1 )
  {
    v8 = 1LL;
    do
    {
      v9 = a3[v8];
      if ( v9 <= 1 )
      {
        result = 0LL;
        if ( v9 == 1 )
          result = sub_87CF0((__int64)v7, v7, a2, a4);
      }
      else
      {
        result = sub_87DA0(v7, (unsigned __int64 *)a2, a4, v9);
      }
      ++v8;
      v7[a4] = result;
      ++v7;
    }
    while ( a4 != v8 );
  }
  return result;
}

//----- (00000000000849E0) ----------------------------------------------------
__int64 __fastcall sub_849E0(__int64 *a1, __int64 *a2, unsigned __int64 *a3, __int64 a4, __int64 *a5)
{
  __int64 v8; // rbx
  __int64 v9; // rbx
  __int64 result; // rax
  __int64 v11; // r12
  __int64 *v12; // r14
  __int64 v13; // rsi
  unsigned __int64 *v14; // rdx
  unsigned __int64 *v15; // r10
  unsigned __int64 *v16; // r10
  __int64 i; // rax
  _BOOL8 v18; // rax
  __int64 *v19; // r10
  __int64 *v20; // r11
  __int64 v21; // rax
  __int64 *v22; // r10
  __int64 *v23; // r11
  __int64 v24; // r15
  bool v25; // cf
  __int64 v26; // rdi
  __int64 v27; // rax
  __int64 v28; // r15
  __int64 v29; // rax
  __int64 v30; // rdi
  __int64 v31; // rax
  __int64 *v34; // [rsp+10h] [rbp-68h]
  __int64 v35; // [rsp+10h] [rbp-68h]
  __int64 v36; // [rsp+10h] [rbp-68h]
  __int64 *v37; // [rsp+20h] [rbp-58h]
  int v38; // [rsp+20h] [rbp-58h]
  __int64 *v39; // [rsp+20h] [rbp-58h]
  __int64 *v40; // [rsp+20h] [rbp-58h]
  __int64 *v41; // [rsp+28h] [rbp-50h]
  __int64 *v42; // [rsp+30h] [rbp-48h]
  unsigned __int64 *v43; // [rsp+38h] [rbp-40h]

  v8 = a4 & 1;
  if ( (a4 & 1) != 0 )
  {
    v9 = a4 - 1;
    if ( a4 - 1 <= 31 )
      sub_848E0(a1, a2, a3, a4 - 1);
    else
      sub_849E0(a1, a2, a3, a4 - 1);
    a1[2 * v9] = sub_87DA0(&a1[v9], (unsigned __int64 *)a2, v9, a3[v9]);
    result = sub_87DA0(&a1[v9], a3, a4, a2[v9]);
    a1[a4 + v9] = result;
    return result;
  }
  v11 = a4 >> 1;
  v12 = &a1[a4];
  v13 = a4 >> 1;
  v14 = &a3[v13];
  v34 = (__int64 *)v14;
  v37 = &a2[v13];
  if ( a4 >> 1 <= 31 )
    sub_848E0(&a1[a4], &a2[v13], v14, a4 >> 1);
  else
    sub_849E0(&a1[a4], &a2[v13], v14, a4 >> 1);
  if ( (int)sub_83D80((__int64)v37, (__int64)a2, v11) < 0 )
  {
    sub_85440((__int64)a1, (unsigned __int64 *)a2, v37, v11);
    v38 = 1;
  }
  else
  {
    sub_85440((__int64)a1, (unsigned __int64 *)v37, a2, v11);
    v38 = 0;
  }
  if ( (int)sub_83D80((__int64)v34, (__int64)a3, v11) < 0 )
  {
    sub_85440((__int64)&a1[v13], a3, v34, v11);
  }
  else
  {
    sub_85440((__int64)&a1[v13], (unsigned __int64 *)v34, (__int64 *)a3, v11);
    v38 ^= 1u;
  }
  v15 = (unsigned __int64 *)&a1[v13];
  if ( v11 > 31 )
  {
    sub_849E0(a5, a1, v15, v11);
    v16 = (unsigned __int64 *)&a1[v13];
LABEL_14:
    for ( i = 0LL; i < v11; ++i )
      v16[i] = v12[i];
    goto LABEL_16;
  }
  sub_848E0(a5, a1, v15, v11);
  v16 = (unsigned __int64 *)&a1[v13];
  if ( v11 > 0 )
    goto LABEL_14;
LABEL_16:
  v43 = v16;
  v35 = sub_87CF0((__int64)v12, v12, &a1[v11 + a4], v11);
  if ( v38 )
  {
    v18 = sub_85440((__int64)v43, v43, a5, a4);
    v19 = (__int64 *)v43;
    v20 = &a1[v11 + a4];
    v36 = v35 - v18;
  }
  else
  {
    v31 = sub_87CF0((__int64)v43, (__int64 *)v43, a5, a4);
    v20 = &a1[v11 + a4];
    v36 = v35 + v31;
    v19 = (__int64 *)v43;
  }
  if ( v11 <= 31 )
  {
    v39 = v20;
    v41 = v19;
    sub_848E0(a5, a2, a3, v11);
    v21 = sub_87CF0((__int64)v41, v41, a5, a4);
    v22 = v41;
    v23 = v39;
    v24 = v21 + v36;
    if ( !(v21 + v36) )
      goto LABEL_20;
    v25 = __CFADD__(*v39, v24);
    *v39 += v24;
    if ( !v25 )
      goto LABEL_20;
    goto LABEL_32;
  }
  v40 = v20;
  v42 = v19;
  sub_849E0(a5, a2, a3, v11);
  v27 = sub_87CF0((__int64)v42, v42, a5, a4);
  v22 = v42;
  v23 = v40;
  v28 = v27 + v36;
  if ( v27 + v36 )
  {
    v25 = __CFADD__(*v40, v28);
    *v40 += v28;
    if ( v25 )
    {
LABEL_32:
      v29 = 0LL;
      do
      {
        if ( v11 - 1 == v29 )
          break;
        v30 = v23[v29 + 1];
        v23[++v29] = v30 + 1;
      }
      while ( v30 == -1 );
LABEL_20:
      if ( v11 <= 0 )
        goto LABEL_22;
      goto LABEL_21;
    }
  }
  do
  {
LABEL_21:
    a1[v8] = a5[v8];
    ++v8;
  }
  while ( v11 > v8 );
LABEL_22:
  result = sub_87CF0((__int64)v22, v22, &a5[v13], v11);
  if ( result )
  {
    v25 = __CFADD__(*v12, 1LL);
    result = *v12 + 1;
    *v12 = result;
    if ( v25 )
    {
      result = 0LL;
      do
      {
        if ( result == a4 - 1 )
          break;
        v26 = v12[result + 1];
        v12[++result] = v26 + 1;
      }
      while ( v26 == -1 );
    }
  }
  return result;
}

//----- (0000000000084E90) ----------------------------------------------------
unsigned __int64 __fastcall sub_84E90(_QWORD *a1, unsigned __int64 *a2, __int64 a3)
{
  unsigned __int64 v4; // rcx
  unsigned __int64 result; // rax
  __int64 v6; // rbp
  __int64 *v7; // rbx
  unsigned __int64 v8; // rcx
  __int64 i; // rax

  v4 = *a2;
  if ( *a2 > 1 )
  {
    result = sub_847C0(a1, a2, a3, v4);
  }
  else
  {
    if ( *a2 == 1 )
    {
      if ( a3 > 0 )
      {
        for ( i = 0LL; ; v4 = a2[i] )
        {
          a1[i++] = v4;
          if ( a3 == i )
            break;
        }
      }
    }
    else if ( a3 > 0 )
    {
      sub_9190((__int64)a1, 0LL, 8 * a3);
    }
    result = 0LL;
  }
  a1[a3] = result;
  v6 = 1LL;
  v7 = a1 + 1;
  if ( a3 > 1 )
  {
    do
    {
      v8 = a2[v6];
      if ( v8 <= 1 )
      {
        result = 0LL;
        if ( v8 == 1 )
          result = sub_87CF0((__int64)v7, v7, (__int64 *)a2, a3);
      }
      else
      {
        result = sub_87DA0(v7, a2, a3, v8);
      }
      ++v6;
      v7[a3] = result;
      ++v7;
    }
    while ( a3 != v6 );
  }
  return result;
}

//----- (0000000000084F90) ----------------------------------------------------
__int64 __fastcall sub_84F90(unsigned __int64 *a1, unsigned __int64 *a2, __int64 a3, __int64 *a4)
{
  __int64 v5; // rbx
  __int64 v6; // rbx
  unsigned __int64 *v7; // r13
  __int64 result; // rax
  __int64 v9; // r12
  __int64 v10; // rcx
  __int64 *v11; // r15
  __int64 *v12; // r8
  unsigned __int64 *v13; // r15
  __int64 i; // rax
  _BOOL8 v15; // rax
  __int64 *v16; // r8
  unsigned __int64 *v17; // r11
  __int64 v18; // rax
  bool v19; // zf
  __int64 v20; // rax
  unsigned __int64 *v21; // r11
  __int64 *v22; // r8
  bool v23; // cf
  __int64 v24; // rdi
  _BOOL8 v25; // rax
  __int64 v26; // rax
  __int64 v27; // rax
  __int64 v28; // rax
  unsigned __int64 v29; // rsi
  __int64 v31; // [rsp+8h] [rbp-60h]
  __int64 v32; // [rsp+10h] [rbp-58h]
  __int64 *v33; // [rsp+10h] [rbp-58h]
  __int64 v34; // [rsp+10h] [rbp-58h]
  unsigned __int64 *v35; // [rsp+10h] [rbp-58h]
  __int64 *v36; // [rsp+18h] [rbp-50h]
  __int64 v37; // [rsp+18h] [rbp-50h]
  __int64 v38; // [rsp+18h] [rbp-50h]
  __int64 *v39; // [rsp+20h] [rbp-48h]
  unsigned __int64 *v40; // [rsp+20h] [rbp-48h]
  __int64 *v41; // [rsp+20h] [rbp-48h]
  __int64 *v42; // [rsp+28h] [rbp-40h]

  v5 = a3 & 1;
  if ( (a3 & 1) != 0 )
  {
    v6 = a3 - 1;
    if ( a3 - 1 <= 31 )
      sub_84E90(a1, a2, a3 - 1);
    else
      sub_84F90(a1, a2, a3 - 1, a4);
    v7 = &a2[v6];
    a1[2 * v6] = sub_87DA0((__int64 *)&a1[v6], a2, v6, *v7);
    result = sub_87DA0((__int64 *)&a1[v6], a2, a3, *v7);
    a1[a3 + v6] = result;
    return result;
  }
  v9 = a3 >> 1;
  v32 = a3;
  v10 = a3 >> 1;
  v31 = v10 * 8;
  v11 = (__int64 *)&a2[v10];
  v36 = (__int64 *)&a1[a3];
  if ( a3 >> 1 <= 31 )
    sub_84E90(&a1[a3], &a2[v10], a3 >> 1);
  else
    sub_84F90(&a1[a3], v11, a3 >> 1, a4);
  if ( (int)sub_83D80((__int64)v11, (__int64)a2, v9) < 0 )
    sub_85440((__int64)a1, a2, v11, v9);
  else
    sub_85440((__int64)a1, (unsigned __int64 *)v11, (__int64 *)a2, v9);
  if ( v9 > 31 )
  {
    sub_84F90(a4, a1, v9, &a4[v32]);
    v12 = (__int64 *)&a1[a3];
  }
  else
  {
    sub_84E90(a4, a1, v9);
    v12 = (__int64 *)&a1[a3];
    if ( v9 <= 0 )
    {
      v34 = sub_87CF0((__int64)v36, v36, (__int64 *)&a1[v9 + a3], v9);
      v13 = (unsigned __int64 *)((char *)a1 + v31);
      v25 = sub_85440((__int64)a1 + v31, (unsigned __int64 *)((char *)a1 + v31), a4, a3);
      v16 = (__int64 *)&a1[a3];
      v17 = &a1[v9 + a3];
      v38 = v34 - v25;
      goto LABEL_27;
    }
  }
  v13 = (unsigned __int64 *)((char *)a1 + v31);
  for ( i = 0LL; i < v9; ++i )
    v13[i] = v12[i];
  v39 = v12;
  v37 = sub_87CF0((__int64)v12, v12, (__int64 *)&a1[v9 + a3], v9);
  v15 = sub_85440((__int64)v13, v13, a4, a3);
  v16 = v39;
  v17 = &a1[v9 + a3];
  v38 = v37 - v15;
  if ( v9 <= 31 )
  {
LABEL_27:
    v41 = v16;
    v35 = v17;
    sub_84E90(a4, a2, v9);
    v26 = sub_87CF0((__int64)v13, (__int64 *)v13, a4, a3);
    v19 = v38 + v26 == 0;
    v27 = v38 + v26;
    v21 = v35;
    v22 = v41;
    if ( v19 )
      goto LABEL_32;
    v23 = __CFADD__(*v35, v27);
    *v35 += v27;
    if ( !v23 )
      goto LABEL_32;
    goto LABEL_29;
  }
  v42 = v39;
  v40 = &a1[v9 + a3];
  sub_84F90(a4, a2, v9, &a4[v32]);
  v18 = sub_87CF0((__int64)v13, (__int64 *)v13, a4, a3);
  v19 = v38 + v18 == 0;
  v20 = v38 + v18;
  v21 = v40;
  v22 = v42;
  if ( !v19 )
  {
    v23 = __CFADD__(*v40, v20);
    *v40 += v20;
    if ( v23 )
    {
LABEL_29:
      v28 = 0LL;
      do
      {
        if ( v9 - 1 == v28 )
          break;
        v29 = v21[v28 + 1];
        v21[++v28] = v29 + 1;
      }
      while ( v29 == -1LL );
LABEL_32:
      if ( v9 <= 0 )
        goto LABEL_18;
      goto LABEL_17;
    }
  }
  do
  {
LABEL_17:
    a1[v5] = a4[v5];
    ++v5;
  }
  while ( v9 > v5 );
LABEL_18:
  v33 = v22;
  result = sub_87CF0((__int64)v13, (__int64 *)v13, (__int64 *)((char *)a4 + v31), v9);
  if ( result )
  {
    v23 = __CFADD__(*v33, 1LL);
    result = *v33 + 1;
    *v33 = result;
    if ( v23 )
    {
      result = 0LL;
      do
      {
        if ( result == a3 - 1 )
          break;
        v24 = v33[result + 1];
        v33[++result] = v24 + 1;
      }
      while ( v24 == -1 );
    }
  }
  return result;
}

//----- (0000000000085440) ----------------------------------------------------
_BOOL8 __fastcall sub_85440(__int64 a1, unsigned __int64 *a2, __int64 *a3, __int64 a4)
{
  unsigned __int64 v4; // r10
  __int64 v5; // r11
  unsigned __int64 *v6; // rsi
  __int64 *v7; // rdx
  __int64 v8; // rdi
  char v9; // al
  __int64 v10; // rcx
  int v11; // eax
  __int64 v12; // rcx
  bool v13; // cf
  bool v14; // cf
  unsigned __int64 v15; // r8
  __int64 v16; // r9
  bool v17; // cf
  bool v18; // cf
  unsigned __int64 v19; // r8
  __int64 v20; // r9
  unsigned __int64 v22; // rtt
  unsigned __int64 v23; // rtt
  unsigned __int64 v24; // rtt
  unsigned __int64 v25; // rtt

  v4 = *a2;
  v5 = *a3;
  v6 = &a2[a4 - 1];
  v7 = &a3[a4 - 1];
  v8 = a1 + 8 * a4 - 16;
  v9 = a4;
  v10 = -a4;
  v11 = v9 & 3;
  if ( !v11 )
  {
    v14 = 0;
    v15 = v4;
    v16 = v5;
    v12 = v10 + 4;
    goto LABEL_9;
  }
  v12 = (unsigned int)v11 + v10;
  if ( v11 < 2 )
  {
    v17 = 0;
    goto LABEL_12;
  }
  if ( v11 == 2 )
  {
    v18 = 0;
    v19 = v4;
    v20 = v5;
    goto LABEL_11;
  }
  v13 = 0;
  while ( 1 )
  {
    v19 = v6[v12 - 1];
    v20 = v7[v12 - 1];
    v24 = v13 + v5;
    v18 = v4 < v24;
    *(_QWORD *)(v8 + 8 * v12 - 8) = v4 - v24;
LABEL_11:
    v4 = v6[v12];
    v5 = v7[v12];
    v25 = v18 + v20;
    v17 = v19 < v25;
    *(_QWORD *)(v8 + 8 * v12) = v19 - v25;
LABEL_12:
    if ( !v12 )
      break;
    v12 += 4LL;
    v15 = v6[v12 - 3];
    v16 = v7[v12 - 3];
    v22 = v17 + v5;
    v14 = v4 < v22;
    *(_QWORD *)(v8 + 8 * v12 - 24) = v4 - v22;
LABEL_9:
    v4 = v6[v12 - 2];
    v5 = v7[v12 - 2];
    v23 = v14 + v16;
    v13 = v15 < v23;
    *(_QWORD *)(v8 + 8 * v12 - 16) = v15 - v23;
  }
  *(_QWORD *)(v8 + 8) = v4 - (v17 + v5);
  return v4 < (unsigned __int64)v17 + v5;
}

//----- (00000000000854F0) ----------------------------------------------------
unsigned __int64 __fastcall sub_854F0(unsigned __int64 *a1, unsigned __int64 *a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // rbx
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // r10
  unsigned __int64 *v7; // rdi
  unsigned __int64 *v8; // rsi
  unsigned __int128 v9; // rax
  __int64 v10; // rbp
  unsigned __int64 v11; // r11
  unsigned __int128 v12; // rax
  __int64 v13; // rbx
  __int64 v14; // r8
  unsigned __int64 v15; // rax
  __int64 v16; // r9
  unsigned __int64 v17; // r8
  __int64 v18; // r9
  unsigned __int64 v19; // r11
  unsigned __int64 v20; // rax
  __int64 v21; // rbp
  unsigned __int128 v22; // rax
  bool v23; // cf
  unsigned __int64 v24; // r10
  unsigned __int64 v25; // r11
  _BOOL8 v26; // rtt
  unsigned __int128 v27; // rax
  unsigned __int64 v28; // r10
  __int64 v29; // r8
  _BOOL8 v30; // rtt
  unsigned __int64 v31; // r11
  unsigned __int64 v32; // r10

  v4 = -a3;
  v5 = *a2;
  v6 = *a1;
  v7 = &a1[a3 - 2];
  v8 = &a2[a3];
  v9 = a4 * (unsigned __int128)v5;
  if ( _bittest((const int *)&v4, 0) )
  {
    v13 = v4 + 1;
    if ( v13 < 0 )
    {
      v18 = *((_QWORD *)&v9 + 1);
      v17 = v9;
      v19 = a4 * v8[v13];
      v20 = v8[v13 + 1];
      v21 = (a4 * (unsigned __int128)v8[v13]) >> 64;
      goto LABEL_8;
    }
  }
  else
  {
    v10 = *((_QWORD *)&v9 + 1);
    v11 = v9;
    v12 = a4 * (unsigned __int128)v8[v4 + 1];
    v13 = v4 + 2;
    if ( v13 < 0 )
    {
      v14 = v12;
      *(_QWORD *)&v12 = v8[v13];
      v16 = *((_QWORD *)&v12 + 1);
      while ( 1 )
      {
        v27 = a4 * (unsigned __int128)v15;
        v23 = v6 < v11;
        v28 = v6 - v11;
        v19 = v27;
        v20 = v8[v13 + 1];
        v30 = v23;
        v23 = __CFADD__(v23, v14);
        v29 = v30 + v14;
        v23 |= __CFADD__(v10, v29);
        v17 = v10 + v29;
        v7[v13] = v28;
        v6 = v7[v13 + 1];
        v21 = *((_QWORD *)&v27 + 1);
        v18 = v23 + v16;
LABEL_8:
        v13 += 2LL;
        if ( v13 >= 0 )
          break;
        v22 = a4 * (unsigned __int128)v20;
        v23 = v6 < v17;
        v24 = v6 - v17;
        v14 = v22;
        v15 = v8[v13];
        v26 = v23;
        v23 = __CFADD__(v23, v19);
        v25 = v26 + v19;
        v23 |= __CFADD__(v18, v25);
        v11 = v18 + v25;
        v7[v13 - 1] = v24;
        v6 = v7[v13];
        v16 = *((_QWORD *)&v22 + 1);
        v10 = v23 + v21;
      }
      v12 = a4 * (unsigned __int128)v20;
      v23 = __CFADD__(v6 < v17, v19);
      v31 = (v6 < v17) + v19;
      v23 |= __CFADD__(v18, v31);
      v11 = v18 + v31;
      *(v7 - 1) = v6 - v17;
      v10 = v23 + v21;
    }
    v23 = __CFADD__(*v7 < v11, (_QWORD)v12);
    *(_QWORD *)&v12 = (*v7 < v11) + (_QWORD)v12;
    v23 |= __CFADD__(v10, (_QWORD)v12);
    *(_QWORD *)&v9 = v10 + v12;
    *v7 -= v11;
    *((_QWORD *)&v9 + 1) = v23 + *((_QWORD *)&v12 + 1);
  }
  v32 = v7[1];
  v7[1] = v32 - v9;
  return *((_QWORD *)&v9 + 1) + (v32 < (unsigned __int64)v9) + (unsigned __int64)(unsigned int)v13;
}

//----- (00000000000855E0) ----------------------------------------------------
__int64 __fastcall sub_855E0(__int64 *a1, double a2, __int64 a3, _DWORD *a4, _DWORD *a5)
{
  __int64 v6; // rdx
  __int64 result; // rax
  unsigned __int64 v8; // rcx

  *a5 = *(_QWORD *)&a2 >> 63;
  *a4 = ((*(_QWORD *)&a2 >> 52) & 0x7FF) - 1023;
  v6 = *(_QWORD *)&a2 & 0xFFFFFFFFFFFFFLL;
  *a1 = *(_QWORD *)&a2 & 0xFFFFFFFFFFFFFLL;
  if ( (HIWORD(a2) & 0x7FF0) != 0 )
  {
    result = 1LL;
    *a1 = v6 | 0x10000000000000LL;
  }
  else
  {
    if ( v6 )
    {
      _BitScanReverse64(&v8, v6);
      LODWORD(v8) = (v8 ^ 0x3F) - 11;
      *a1 = v6 << v8;
      *a4 = -1022 - v8;
    }
    else
    {
      *a4 = 0;
    }
    result = 1LL;
  }
  return result;
}

//----- (0000000000085670) ----------------------------------------------------
__int64 __fastcall sub_85670(_QWORD *a1, __int64 a2, _DWORD *a3, int *a4, __int64 a5, __int64 a6, __int64 a7, __int16 a8)
{
  __int64 result; // rax
  __int64 v9; // rax
  unsigned __int64 v10; // rcx

  *a4 = HIBYTE(a8) >> 7;
  *a3 = (a8 & 0x7FFF) - 0x3FFF;
  *a1 = a7;
  if ( (a8 & 0x7FFF) != 0 )
  {
    if ( a7 )
      return 1LL;
    if ( (a8 & 0x7FFF) != 0x7FFF )
    {
LABEL_3:
      *a3 = 0;
      return 1LL;
    }
    result = 1LL;
  }
  else
  {
    if ( !a7 )
      goto LABEL_3;
    v9 = a7 & 0x7FFFFFFFFFFFFFFFLL;
    if ( (a7 & 0x7FFFFFFFFFFFFFFFLL) != 0 )
    {
      _BitScanReverse64(&v10, v9);
      LODWORD(v10) = v10 ^ 0x3F;
      *a1 = v9 << v10;
      *a3 = -16382 - v10;
      result = 1LL;
    }
    else
    {
      *a1 = 0x8000000000000000LL;
      result = 1LL;
      *a3 = -16382;
    }
  }
  return result;
}

//----- (0000000000085730) ----------------------------------------------------
__int64 __fastcall sub_85730(_QWORD *a1, __m128i a2, __int64 a3, _DWORD *a4, _DWORD *a5)
{
  __m128i v6; // xmm1
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rax
  unsigned __int64 v10; // rax
  int v11; // eax
  unsigned __int64 v12; // r8
  __m128i v13; // [rsp+0h] [rbp-18h] BYREF

  v13 = a2;
  v6 = _mm_load_si128(&v13);
  *a5 = (unsigned __int64)a2.m128i_i64[1] >> 63;
  *a4 = (a2.m128i_i16[7] & 0x7FFF) - 0x3FFF;
  v7 = v13.m128i_i64[0];
  v8 = a2.m128i_u32[2] | ((unsigned __int64)(unsigned int)_mm_extract_epi16(v6, 6) << 32);
  *a1 = v13.m128i_i64[0];
  a1[1] = v8;
  if ( (_mm_extract_epi16(v6, 7) & 0x7FFF) != 0 )
  {
    a1[1] = v8 | 0x1000000000000LL;
    return 2LL;
  }
  if ( !v7 )
  {
    if ( !v8 )
    {
      *a4 = 0;
      return 2LL;
    }
    goto LABEL_10;
  }
  if ( v8 )
  {
LABEL_10:
    _BitScanReverse64(&v12, v8);
    LODWORD(v12) = (v12 ^ 0x3F) - 15;
    *a1 = v7 << v12;
    a1[1] = (v7 >> (64 - (unsigned __int8)v12)) | (v8 << v12);
    *a4 = -16382 - v12;
    return 2LL;
  }
  _BitScanReverse64(&v10, v7);
  v11 = v10 ^ 0x3F;
  if ( v11 <= 14 )
  {
    a1[1] = v7 >> (15 - (unsigned __int8)v11);
    *a1 = v7 << ((unsigned __int8)v11 + 49);
  }
  else
  {
    *a1 = 0LL;
    a1[1] = v7 << ((unsigned __int8)v11 - 15);
  }
  *a4 = -16431 - v11;
  return 2LL;
}

//----- (0000000000085860) ----------------------------------------------------
__int64 __fastcall sub_85860(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  int v9; // esi
  __int64 v10; // rdx
  _BYTE *v12; // rdi
  int v13; // esi
  const char *v15; // rax
  double v16; // xmm4_8
  double v17; // xmm5_8
  __int64 v18; // [rsp-10h] [rbp-18h]

  v9 = *(_DWORD *)(a1 + 8);
  if ( (v9 & 0xBFFFEEF0) != 0 )
  {
    v15 = (const char *)sub_CF50("libc", "invalid mode parameter", 5u, a2, a3, a4, a5, a6, a7, a8, a9);
    sub_50110(0LL, 0LL, 0LL, v15, a2, a3, a4, a5, v16, v17, a8, a9);
  }
  v10 = *(_QWORD *)(a1 + 24);
  v12 = *(_BYTE **)a1;
  v13 = v9 | 0x80000000;
  if ( !v12 )
    v12 = &unk_A6E65;
  *(_QWORD *)(a1 + 16) = sub_81120(v12, v13, v10, 0LL, (unsigned int)dword_C14E0, qword_C14D8, (__int64)qword_C1270);
  return v18;
}
// 858B1: variable 'v18' is possibly undefined
// 858D6: variable 'v16' is possibly undefined
// 858D6: variable 'v17' is possibly undefined
// C14D8: using guessed type __int64 qword_C14D8;
// C14E0: using guessed type int dword_C14E0;

//----- (00000000000858E0) ----------------------------------------------------
__int64 __fastcall sub_858E0(__int64 a1, int a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 result; // rax
  __int64 v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // [rsp+0h] [rbp-38h] BYREF
  int v24; // [rsp+8h] [rbp-30h]
  __int64 v25; // [rsp+10h] [rbp-28h]
  __int64 v26; // [rsp+18h] [rbp-20h]
  unsigned __int64 v27; // [rsp+28h] [rbp-10h]

  v27 = __readfsqword(0x28u);
  v23 = a1;
  v24 = a2;
  v26 = a3;
  v16 = sub_7F870(
          (void (__fastcall *)(__int64))sub_85860,
          (__int64)&v23,
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14,
          a3,
          a4,
          a5,
          a6);
  result = 0LL;
  if ( !(_DWORD)v16 )
  {
    sub_7A160(v25, (__int64)&v23, v14, v15, v16, v17);
    sub_7F9E0(v25, (__int64)&v23, v19, v20, v21, v22);
    result = v25;
  }
  return result;
}
// 85923: variable 'v14' is possibly undefined
// 85923: variable 'v15' is possibly undefined
// 85923: variable 'v17' is possibly undefined
// 8592D: variable 'v19' is possibly undefined
// 8592D: variable 'v20' is possibly undefined
// 8592D: variable 'v21' is possibly undefined
// 8592D: variable 'v22' is possibly undefined

//----- (0000000000085960) ----------------------------------------------------
// attributes: thunk
__int64 __fastcall sub_85960(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  return sub_82F70(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

//----- (0000000000085970) ----------------------------------------------------
_BOOL8 __fastcall sub_85970(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14)
{
  return -sub_7F870((void (__fastcall *)(__int64))sub_85960, a1, a2, a3, a4, a5, a6, a7, a8, a9, a11, a12, a13, a14);
}

//----- (00000000000859A0) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_859A0(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9))(__m128i *, __int64 (__fastcall *)(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9))
{
  __int64 (__fastcall *result)(__m128i *, __int64 (__fastcall *)(__int64, __m128, double, double, double, double, double, double, double)); // rax

  result = sub_87CD0(*(_QWORD *)a1, *(unsigned __int8 **)(a1 + 8), *(_QWORD *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8, a9);
  *(_QWORD *)(a1 + 24) = result;
  return result;
}

//----- (00000000000859C0) ----------------------------------------------------
__int64 __fastcall sub_859C0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  bool v14; // zf
  __int64 result; // rax
  __int64 v16[7]; // [rsp+0h] [rbp-38h] BYREF

  v16[5] = __readfsqword(0x28u);
  v16[2] = a3;
  v16[0] = a1;
  v16[1] = a2;
  v14 = !sub_7F870(
           (void (__fastcall *)(__int64))sub_859A0,
           (__int64)v16,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a3,
           a4,
           a5,
           a6);
  result = 0LL;
  if ( v14 )
    result = v16[3];
  return result;
}
// 9228: using guessed type __int64 __fastcall sub_9228(_QWORD);
// 9248: using guessed type __int64 __fastcall sub_9248(_QWORD);

//----- (0000000000085A60) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_85A60(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9))(__m128i *, __int64 (__fastcall *)(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9))
{
  __int64 (__fastcall *result)(__m128i *, __int64 (__fastcall *)(__int64, __m128, double, double, double, double, double, double, double)); // rax

  result = sub_87BD0(
             *(_QWORD *)a1,
             *(unsigned __int8 **)(a1 + 8),
             *(unsigned __int8 **)(a1 + 16),
             *(_QWORD *)(a1 + 24),
             a2,
             a3,
             a4,
             a5,
             a6,
             a7,
             a8,
             a9);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

//----- (0000000000085A90) ----------------------------------------------------
__int64 __fastcall sub_85A90(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  bool v14; // zf
  __int64 result; // rax
  __int64 v16[7]; // [rsp+0h] [rbp-38h] BYREF

  v16[5] = __readfsqword(0x28u);
  v16[0] = a1;
  v16[1] = a2;
  v16[3] = a4;
  v16[2] = a3;
  v14 = !sub_7F870(
           (void (__fastcall *)(__int64))sub_85A60,
           (__int64)v16,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a3,
           a4,
           a5,
           a6);
  result = 0LL;
  if ( v14 )
    result = v16[4];
  return result;
}
// 9228: using guessed type __int64 __fastcall sub_9228(_QWORD);
// 9248: using guessed type __int64 __fastcall sub_9248(_QWORD);

//----- (0000000000085B30) ----------------------------------------------------
unsigned __int64 __fastcall sub_85B30(int a1, struct itimerval *a2, struct itimerval *a3)
{
  unsigned __int64 result; // rax

  result = sys_setitimer(a1, a2, a3);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000085B60) ----------------------------------------------------
__int64 __fastcall sub_85B60(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rdx
  __int64 result; // rax
  _QWORD *v4; // r12
  __int64 v5; // rsi
  __int64 v6; // rbx

  *a1 = a2;
  v2 = *(_QWORD *)(a2 + 968);
  *(_BYTE *)(a2 + 796) = *(_BYTE *)(a2 + 796) & 0x9F | 0x20;
  result = 1LL;
  if ( v2 )
  {
    v4 = a1 + 1;
    v5 = *(_QWORD *)(v2 + 8);
    v6 = v2 + 8;
    if ( v5 )
    {
      do
      {
        if ( (*(_BYTE *)(v5 + 796) & 0x60) == 0 )
          v4 += sub_85B60(v4, v5);
        v5 = *(_QWORD *)(v6 + 8);
        v6 += 8LL;
      }
      while ( v5 );
      result = v4 - a1;
    }
  }
  return result;
}

//----- (0000000000085BF0) ----------------------------------------------------
__int64 __fastcall sub_85BF0(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 v10; // rdi
  char v11; // dl
  __int64 result; // rax

  v10 = *(_QWORD *)a1;
  v11 = *(_BYTE *)(v10 + 796) & 3;
  if ( !v11 )
    v11 = 1;
  result = sub_71D90(
             v10,
             *(_BYTE **)(a1 + 24),
             v11,
             *(_DWORD *)(a1 + 8),
             *(_DWORD *)(a1 + 12),
             *(_QWORD *)(v10 + 48),
             a2,
             a3,
             a4,
             a5,
             a6,
             a7,
             a8,
             a9);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

//----- (0000000000085C30) ----------------------------------------------------
__int64 __fastcall sub_85C30(__int64 a1, __int64 *a2, unsigned int a3, int a4, int a5)
{
  __int64 v5; // r9
  void *v6; // rsp
  char v7; // al
  int *v8; // rdx
  __int64 v10; // rcx
  __int64 v11; // rsi
  int v12; // er10
  __int64 v13; // r14
  _QWORD *v14; // r15
  bool v15; // zf
  int v16; // eax
  __int64 v17; // rbx
  __int64 *v18; // rax
  __int64 *v19; // r12
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 *v22; // rbx
  __int64 v23; // rax
  unsigned int v24; // eax
  __int64 v25; // rax
  char v26; // cl
  int v27; // edx
  _BYTE *v28; // r13
  __int64 v29; // rcx
  __int64 v30; // r8
  __int64 v31; // r9
  _BYTE *v32; // r12
  __int64 v33; // rcx
  __int64 v34; // r8
  __int64 v35; // r9
  __int64 v36; // r15
  unsigned int v37; // er12
  _QWORD *v38; // r14
  __int64 v39; // rsi
  unsigned int v40; // er8
  int v41; // edi
  __int64 v42; // rax
  unsigned int v43; // ebx
  _QWORD *v44; // rdx
  __int64 v45; // rax
  unsigned int *v46; // rdi
  __int64 v47; // rcx
  __int64 v48; // rsi
  _DWORD *v49; // rsi
  _DWORD *v50; // r12
  unsigned int v51; // er15
  _QWORD *v52; // rbx
  unsigned int *v53; // r13
  unsigned int v54; // er14
  __int64 v55; // rax
  unsigned int v56; // er11
  char *v57; // rax
  __int8 *v58; // rdi
  unsigned int v59; // ecx
  __int64 v60; // rsi
  __int64 v61; // rax
  __int64 v62; // rcx
  _QWORD *v63; // rsi
  __int64 j; // rax
  unsigned int v65; // eax
  __int64 v66; // rdx
  __int64 v67; // rax
  __int64 v68; // rax
  __int64 v69; // rdi
  __int64 result; // rax
  unsigned __int16 v71; // ax
  const __m128i *v72; // roff
  __int64 v73; // rax
  __int64 v74; // rax
  int v75; // edi
  __int64 v76; // rsi
  __int64 v77; // rdx
  __int64 v78; // rdx
  __int64 v79; // rsi
  _QWORD *v80; // r15
  size_t v81; // rax
  unsigned __int64 v82; // r14
  __int64 v83; // rbx
  __int64 v84; // r13
  __int64 v85; // rax
  unsigned int v86; // eax
  unsigned int v87; // er12
  unsigned int v88; // edi
  int v89; // edx
  _QWORD *i; // rax
  __int64 v91; // rax
  __int64 v92; // rdx
  __m128i *v93; // rdx
  __m128i *v94; // rsi
  const __m128i *v95; // rsi
  __int64 v96; // rdi
  __m128i *v97; // rdx
  __int64 v98; // rdx
  const char *v99; // rdx
  __m128i v100; // [rsp+1Ah] [rbp-518h] BYREF
  __int64 v101; // [rsp+2Ah] [rbp-508h]
  unsigned int v102; // [rsp+36h] [rbp-4FCh]
  _QWORD *v103; // [rsp+3Ah] [rbp-4F8h] BYREF
  char *v104; // [rsp+42h] [rbp-4F0h]
  __m128i *v105; // [rsp+4Ah] [rbp-4E8h]
  int v106; // [rsp+52h] [rbp-4E0h] BYREF
  int v107; // [rsp+56h] [rbp-4DCh]
  __m128i *v108; // [rsp+5Ah] [rbp-4D8h]
  __int64 v109; // [rsp+62h] [rbp-4D0h]
  __int64 v110; // [rsp+6Ah] [rbp-4C8h]
  __m128i v111; // [rsp+72h] [rbp-4C0h]
  __int64 v112; // [rsp+82h] [rbp-4B0h]
  __m128i *v113; // [rsp+8Ah] [rbp-4A8h]
  __int64 v114; // [rsp+92h] [rbp-4A0h]
  size_t v115; // [rsp+9Ah] [rbp-498h]
  __m128i v116[2]; // [rsp+A2h] [rbp-490h] BYREF
  __int64 v117; // [rsp+C2h] [rbp-470h] BYREF
  int v118; // [rsp+CAh] [rbp-468h]
  int v119; // [rsp+CEh] [rbp-464h]
  __int64 v120; // [rsp+D2h] [rbp-460h]
  _BYTE *v121; // [rsp+DAh] [rbp-458h]
  __int64 v122; // [rsp+E2h] [rbp-450h]
  __int64 v123[2]; // [rsp+F2h] [rbp-440h] BYREF
  char v124[1072]; // [rsp+102h] [rbp-430h] BYREF

  v5 = a3;
  v106 = a5;
  v6 = alloca(16 * ((24 * (unsigned __int64)(a3 + 2) + 23) >> 4));
  v7 = *(_BYTE *)(a1 + 796);
  v112 = a1;
  v107 = a4;
  LOBYTE(v115) = v7;
  v8 = &v106;
  v104 = (char *)a1;
  LODWORD(v103) = 0;
  v105 = (__m128i *)&v106;
  *(_BYTE *)(a1 + 796) = v7 & 0x9F | 0x20;
  if ( (_DWORD)v5 )
  {
    LODWORD(v10) = 1;
    LODWORD(v109) = v5 + 1;
    do
    {
      v11 = *a2;
      v12 = v10;
      *v8 = 0;
      v10 = (unsigned int)(v10 + 1);
      ++a2;
      v8 += 6;
      *((_QWORD *)v8 - 2) = v11;
      *((_QWORD *)v8 - 1) = &(&v103)[3 * v10];
      *(_BYTE *)(v11 + 796) = *(_BYTE *)(v11 + 796) & 0x9F | 0x20;
    }
    while ( (_DWORD)v5 != v12 );
    v13 = (__int64)v104;
    v113 = (__m128i *)&(&v103)[3 * v5];
  }
  else
  {
    v113 = (__m128i *)&v103;
    v13 = v112;
    LODWORD(v109) = 1;
  }
  v123[1] = 1024LL;
  v113[1].m128i_i64[0] = 0LL;
  v104 = v124;
  v123[0] = (__int64)v124;
  v102 = __readfsdword(0xFFFFFFC0);
  __writefsdword(0xFFFFFFC0, 0);
  v108 = (__m128i *)&v103;
  v103 = &v103;
  while ( 1 )
  {
    v14 = *(_QWORD **)(v13 + 704);
    v108->m128i_i32[0] = 1;
    if ( v14 )
    {
      v14 = 0LL;
    }
    else if ( !*(_QWORD *)(v13 + 968) && v112 != v13 )
    {
      v71 = *(_WORD *)(v13 + 698);
      if ( v71 )
      {
        if ( !(unsigned __int8)sub_6BAD0(v123, v71, 8LL) )
          sub_50110(12LL, *(_BYTE **)(v112 + 8), 0LL, "cannot allocate dependency buffer");
        v14 = (_QWORD *)v123[0];
      }
    }
    if ( *(_QWORD *)(v13 + 72) )
      break;
    if ( *(_QWORD *)(v13 + 488) )
      break;
    v15 = *(_QWORD *)(v13 + 472) == 0LL;
    LODWORD(v115) = 0;
    if ( !v15 )
      break;
LABEL_11:
    if ( v14 )
    {
      v16 = v115;
      v14[(unsigned int)v115] = 0LL;
      v17 = (unsigned int)(v16 + 1);
      v18 = (__int64 *)sub_21500(8LL * (unsigned int)(2 * v16 + 3));
      v19 = v18;
      if ( !v18 )
      {
        if ( (char *)v123[0] != v104 )
          sub_21B70(v123[0]);
        sub_50110(12LL, *(_BYTE **)(v112 + 8), 0LL, "cannot allocate dependency list");
      }
      *v18 = v13;
      memcpy(v18 + 1, v14, 8 * v17);
      memcpy(&v19[(unsigned int)(v115 + 2)], v19, 8 * v17);
      *(_BYTE *)(v13 + 798) |= 1u;
      *(_QWORD *)(v13 + 968) = v19;
    }
    v20 = (__int64)v108;
    if ( v108->m128i_i32[0] )
    {
      do
      {
        v20 = *(_QWORD *)(v20 + 16);
        if ( !v20 )
        {
          v36 = (__int64)v103;
          v37 = 0;
          goto LABEL_33;
        }
      }
      while ( *(_DWORD *)v20 );
      v108 = (__m128i *)v20;
    }
    v13 = v108->m128i_i64[1];
  }
  v21 = *(_QWORD *)(v13 + 104);
  v22 = *(__int64 **)(v13 + 16);
  v117 = v13;
  v114 = *(_QWORD *)(v21 + 8);
  v120 = v114;
  v118 = v107;
  v119 = v106;
  v23 = *v22;
  if ( !*v22 )
  {
    LODWORD(v115) = 0;
    goto LABEL_11;
  }
  LODWORD(v115) = 0;
  v105 = v108;
  while ( v23 != 1 )
  {
    if ( (v23 & 0xFFFFFFFFFFFFFFFDLL) == 2147483645 )
    {
      v32 = (_BYTE *)(v22[1] + v114);
      if ( sub_70080((__int64)v32) )
        sub_50110(0LL, v32, 0LL, "DST not allowed in SUID/SGID programs");
      v121 = v32;
      if ( (dword_C14B4 & 1) != 0 )
      {
        v99 = *(const char **)(v13 + 8);
        if ( !*v99 )
        {
          v99 = (const char *)off_BEFD8;
          if ( !off_BEFD8 )
            v99 = "<main program>";
        }
        sub_76EA0("load auxiliary object=%s requested by file=%s\n", v32, v99);
      }
      v24 = sub_50170((__int64)v116, (void (__fastcall *)(__int64))sub_85BF0, (__int64)&v117, v33, v34, v35);
      if ( !v116[0].m128i_i64[1] )
      {
        v72 = v105;
        v100 = _mm_loadu_si128(v105);
        v73 = v105[1].m128i_i64[0];
        v111 = v100;
        v101 = v73;
        v74 = v122;
        v105->m128i_i32[0] = 0;
        v72->m128i_i64[1] = v74;
        if ( v14 )
        {
          v75 = v115;
          v14[(unsigned int)v115] = v74;
          v74 = v122;
          LODWORD(v115) = v75 + 1;
        }
        if ( (*(_BYTE *)(v74 + 796) & 0x60) != 0 )
        {
          v93 = &v100;
          do
          {
            v94 = v93;
            v93 = (__m128i *)v93[1].m128i_i64[0];
            if ( !v93 )
            {
              v95 = v105;
              *v105 = _mm_load_si128(&v100);
              v95[1].m128i_i64[0] = v101;
              goto LABEL_24;
            }
          }
          while ( v93->m128i_i64[1] != v74 );
          v105[1].m128i_i64[0] = (__int64)&v100;
          v96 = (__int64)v113;
          v97 = (__m128i *)v94[1].m128i_i64[0];
          v15 = v97 == v113;
          v98 = v97[1].m128i_i64[0];
          if ( v15 )
            v96 = (__int64)v94;
          v94[1].m128i_i64[0] = v98;
          v76 = *(_QWORD *)(v74 + 32);
          v113 = (__m128i *)v96;
          v77 = *(_QWORD *)(v74 + 24);
          if ( v76 )
          {
LABEL_98:
            *(_QWORD *)(v76 + 24) = v77;
            v77 = *(_QWORD *)(v74 + 24);
          }
        }
        else
        {
          v76 = *(_QWORD *)(v74 + 32);
          LODWORD(v109) = v109 + 1;
          v105[1].m128i_i64[0] = (__int64)&v100;
          *(_BYTE *)(v74 + 796) = *(_BYTE *)(v74 + 796) & 0x9F | 0x20;
          v77 = *(_QWORD *)(v74 + 24);
          if ( v76 )
            goto LABEL_98;
        }
        if ( v77 )
          *(_QWORD *)(v77 + 32) = v76;
        v78 = v100.m128i_i64[1];
        *(_QWORD *)(v74 + 32) = *(_QWORD *)(v100.m128i_i64[1] + 32);
        *(_QWORD *)(v78 + 32) = v74;
        v79 = *(_QWORD *)(v74 + 32);
        if ( v79 )
          *(_QWORD *)(v79 + 24) = v74;
        *(_QWORD *)(v74 + 24) = v78;
        if ( v113 == v105 )
        {
          v105 = &v100;
          v113 = &v100;
        }
        else
        {
          v105 = &v100;
        }
        goto LABEL_24;
      }
      if ( *v22 != 2147483645 )
        goto LABEL_31;
      sub_79330(v116);
    }
LABEL_24:
    v23 = v22[2];
    v22 += 2;
    if ( !v23 )
      goto LABEL_11;
  }
  v28 = (_BYTE *)(v22[1] + v114);
  if ( sub_70080((__int64)v28) )
    sub_50110(0LL, v28, 0LL, "DST not allowed in SUID/SGID programs");
  v121 = v28;
  v24 = sub_50170((__int64)v116, (void (__fastcall *)(__int64))sub_85BF0, (__int64)&v117, v29, v30, v31);
  if ( !v116[0].m128i_i64[1] )
  {
    v25 = v122;
    if ( (*(_BYTE *)(v122 + 796) & 0x60) == 0 )
    {
      LODWORD(v109) = v109 + 1;
      v100.m128i_i64[1] = v122;
      v100.m128i_i32[0] = 0;
      v101 = 0LL;
      v113[1].m128i_i64[0] = (__int64)&v100;
      v26 = *(_BYTE *)(v25 + 796);
      v113 = &v100;
      *(_BYTE *)(v25 + 796) = v26 & 0x9F | 0x20;
    }
    if ( v14 )
    {
      v27 = v115;
      v14[(unsigned int)v115] = v25;
      LODWORD(v115) = v27 + 1;
    }
    goto LABEL_24;
  }
LABEL_31:
  v36 = (__int64)v103;
  v37 = v24;
  if ( !v24 )
    v37 = -1;
LABEL_33:
  if ( (char *)v123[0] != v104 )
    sub_21B70(v123[0]);
  if ( !__readfsdword(0xFFFFFFC0) && v102 )
    __writefsdword(0xFFFFFFC0, v102);
  v114 = *(_QWORD *)(v112 + 968);
  if ( v114 )
  {
    LOBYTE(v115) = *(_BYTE *)(v112 + 796);
    if ( (v115 & 3) == 2 )
    {
      if ( *(_QWORD *)(v112 + 704) )
        sub_CF00("map->l_searchlist.r_list == NULL", "dl-deps.c", 472LL, "_dl_map_object_deps");
    }
    else
    {
      v114 = 0LL;
    }
  }
  v38 = (_QWORD *)sub_21500(8LL * (unsigned int)(2 * v109 + 1));
  if ( !v38 )
LABEL_155:
    sub_50110(12LL, *(_BYTE **)(v112 + 8), 0LL, "cannot allocate symbol search list");
  v39 = v112;
  v40 = -1;
  v41 = v107;
  v42 = (unsigned int)(v109 + 1);
  *(_DWORD *)(v112 + 712) = v109;
  v43 = 0;
  v44 = &v38[v42];
  *(_QWORD *)(v39 + 704) = v44;
  do
  {
    v45 = *(_QWORD *)(v36 + 8);
    if ( v41 && (*(_BYTE *)(v45 + 797) & 2) != 0 )
    {
      --*(_DWORD *)(v39 + 712);
    }
    else
    {
      v44[v43] = v45;
      if ( v39 == v45 )
        v40 = v43;
      ++v43;
    }
    *(_BYTE *)(v45 + 796) &= 0x9Fu;
    v36 = *(_QWORD *)(v36 + 16);
  }
  while ( v36 );
  if ( (dword_C14B4 & 0x800) == 0 || off_BF0E0 != (void *)v112 )
  {
    v46 = *(unsigned int **)(v112 + 976);
    if ( !v46 )
      goto LABEL_69;
    if ( v43 )
    {
LABEL_51:
      v47 = 0LL;
      do
      {
        v48 = v44[v47++];
        *(_BYTE *)(v48 + 796) = *(_BYTE *)(v48 + 796) & 0x9F | 0x20;
      }
      while ( v43 > (unsigned int)v47 );
      v49 = v46 + 2;
      *(_BYTE *)(v112 + 796) &= 0x9Fu;
      if ( !*v46 )
        goto LABEL_67;
      goto LABEL_54;
    }
LABEL_110:
    v49 = v46 + 2;
    *(_BYTE *)(v112 + 796) &= 0x9Fu;
    if ( !*v46 )
      goto LABEL_111;
LABEL_54:
    v111.m128i_i32[0] = v37;
    v50 = (_DWORD *)v36;
    LODWORD(v108) = v43;
    v51 = 0;
    v52 = v49;
    v53 = v46;
    v113 = (__m128i *)(v49 + 2);
    LODWORD(v110) = v40;
    v109 = (__int64)v38;
    do
    {
      while ( 1 )
      {
        v54 = v51 + 1;
        if ( (*(_BYTE *)(v52[v51] + 796LL) & 0x60) != 0 )
        {
          v115 = 8LL * v51;
          v55 = sub_21500(8LL * *(unsigned int *)(v112 + 984) + 8);
          v50 = (_DWORD *)v55;
          if ( v55 )
            break;
        }
        ++v51;
        if ( *v53 <= v54 )
          goto LABEL_65;
      }
      memcpy((void *)(v55 + 8), v52, v115);
      v56 = *v53;
      if ( v54 >= *v53 )
      {
        v59 = v51;
      }
      else
      {
        v57 = (char *)&v52[v54];
        v58 = &v113->m128i_i8[8 * v54 + 8 * (unsigned __int64)(v56 - 2 - v51)];
        v59 = v51;
        do
        {
          if ( (*(_BYTE *)(*(_QWORD *)v57 + 796LL) & 0x60) == 0 )
          {
            v60 = v59++;
            *(_QWORD *)&v50[2 * v60 + 2] = *(_QWORD *)v57;
          }
          v57 += 8;
        }
        while ( v58 != v57 );
        v54 = v56;
      }
      *v50 = v59;
      v51 = v54 + 1;
    }
    while ( *v53 > v54 + 1 );
LABEL_65:
    v43 = (unsigned int)v108;
    v36 = (__int64)v50;
    v40 = v110;
    v38 = (_QWORD *)v109;
    v37 = v111.m128i_i32[0];
    if ( !(_DWORD)v108 )
      goto LABEL_111;
    v44 = *(_QWORD **)(v112 + 704);
LABEL_67:
    v61 = 0LL;
    do
    {
      v62 = v44[v61++];
      *(_BYTE *)(v62 + 796) &= 0x9Fu;
    }
    while ( v43 > (unsigned int)v61 );
    goto LABEL_69;
  }
  if ( !v43 )
  {
    v46 = *(unsigned int **)(v112 + 976);
    if ( !v46 )
      goto LABEL_111;
    goto LABEL_110;
  }
  v108 = 0LL;
  v80 = v38;
  v81 = 8LL * (v43 - 1);
  v111.m128i_i32[0] = v43;
  v82 = 0LL;
  v83 = v112;
  v115 = v81;
  LODWORD(v110) = v37;
  LODWORD(v109) = v40;
  while ( 1 )
  {
    v84 = v44[v82 / 8];
    if ( v83 != v84 )
    {
      v85 = *(_QWORD *)(v84 + 920);
      if ( !v85 || !*(_DWORD *)(v85 + 8) )
      {
        if ( *(_QWORD *)(v84 + 488) || *(_QWORD *)(v84 + 472) )
          sub_50110(22LL, *(_BYTE **)(v84 + 8), 0LL, "Filters not supported with LD_TRACE_PRELINKING");
        v86 = sub_85B60(v80, v44[v82 / 8]);
        v87 = v86;
        v88 = v86;
        if ( v86 > v111.m128i_i32[0] )
          sub_CF00("cnt <= nlist", "dl-deps.c", 533LL, "_dl_map_object_deps");
        if ( v86 )
        {
          v89 = 0;
          *(_BYTE *)(*v80 + 796LL) &= 0x9Fu;
          for ( i = v80 + 1; v88 != ++v89; ++i )
          {
            *(_BYTE *)(*i + 796LL) &= 0x9Fu;
            if ( *(_QWORD *)(*i + 192LL) )
              *(_BYTE *)(v84 + 797) |= 0x80u;
          }
        }
        v113 = (__m128i *)(8LL * v87 + 16);
        v91 = sub_21500(v113);
        v92 = (__int64)v113;
        *(_QWORD *)(v84 + 920) = v91;
        if ( !v91 )
          goto LABEL_155;
        *(_DWORD *)(v91 + 8) = v87;
        *(_QWORD *)v91 = v91 + 16;
        memcpy((void *)(v91 + 16), v80, v92 - 16);
      }
    }
    if ( v115 == v82 )
      break;
    v44 = *(_QWORD **)(v83 + 704);
    v82 += 8LL;
  }
  v38 = v80;
  v37 = v110;
  v40 = v109;
  v36 = (__int64)v108;
  v43 = v111.m128i_i32[0];
  v46 = *(unsigned int **)(v112 + 976);
  if ( v46 )
  {
    v44 = *(_QWORD **)(v112 + 704);
    goto LABEL_51;
  }
LABEL_69:
  if ( v40 >= v43 )
LABEL_111:
    sub_CF00("map_index < nlist", "dl-deps.c", 596LL, "_dl_map_object_deps");
  v63 = *(_QWORD **)(v112 + 704);
  if ( v40 )
  {
    *v38 = v63[v40];
    for ( j = 0LL; j != v40; ++j )
      v38[j + 1] = v63[j];
    v65 = v40 + 1;
    if ( v40 + 1 < v43 )
    {
      v66 = v65;
      v67 = v65;
      do
      {
        v38[v67] = v63[v67];
        ++v67;
      }
      while ( v66 + v43 - 2 - v40 + 1 != v67 );
    }
  }
  else
  {
    memcpy(v38, v63, 8LL * v43);
  }
  sub_83000((__int64)(v38 + 1), v43 - 1, 0LL, 0);
  v38[v43] = 0LL;
  v68 = v112;
  *(_BYTE *)(v112 + 798) |= 1u;
  *(_QWORD *)(v68 + 968) = v38;
  if ( v36 )
  {
    v69 = *(_QWORD *)(v68 + 976);
    *(_QWORD *)(v68 + 976) = v36;
    sub_78000(v69);
  }
  result = v114;
  if ( v114 )
    result = sub_78000(v114);
  if ( v37 )
  {
    if ( v37 == -1 )
      v37 = 0;
    sub_500B0(v37, v116, 0LL);
  }
  return result;
}
// 85F8E: variable 'v29' is possibly undefined
// 85F8E: variable 'v30' is possibly undefined
// 85F8E: variable 'v31' is possibly undefined
// 866C3: variable 'v33' is possibly undefined
// 866C3: variable 'v34' is possibly undefined
// 866C3: variable 'v35' is possibly undefined
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// 21500: using guessed type __int64 __fastcall sub_21500(_QWORD);
// 21B70: using guessed type __int64 __fastcall sub_21B70(_QWORD);
// 77EB0: using guessed type __int64 __fastcall sub_77EB0(_QWORD, _QWORD, _QWORD, _QWORD);
// BD7E0: using guessed type int dword_BD7E0;
// BEFD8: using guessed type void *off_BEFD8;
// BF0E0: using guessed type void *off_BF0E0;
// C14B4: using guessed type int dword_C14B4;
// C14B8: using guessed type __int64 qword_C14B8;

//----- (0000000000086CD0) ----------------------------------------------------
__int64 __fastcall sub_86CD0(__int64 a1, unsigned int a2, __int64 a3, __int64 a4)
{
  const char *v7; // rsi
  __int64 result; // rax
  __int64 v9; // rcx
  __int64 v10; // rdx
  __int64 v11; // rbx
  __int64 v12; // r14

  v7 = *(const char **)(a1 + 8);
  result = *(unsigned __int8 *)(a1 + 796) | 8u;
  *(_BYTE *)(a1 + 796) |= 8u;
  if ( *v7 )
  {
    if ( (dword_C14B4 & 2) == 0 )
      goto LABEL_3;
LABEL_15:
    sub_76EA0("\ncalling init: %s\n\n", v7);
    goto LABEL_3;
  }
  if ( (result & 3) == 0 )
    return result;
  if ( (dword_C14B4 & 2) != 0 )
  {
    v7 = (const char *)off_BEFD8;
    if ( !off_BEFD8 )
      v7 = "<main program>";
    goto LABEL_15;
  }
LABEL_3:
  result = *(_QWORD *)(a1 + 160);
  if ( result )
    result = ((__int64 (__fastcall *)(_QWORD, __int64, __int64))(*(_QWORD *)a1 + *(_QWORD *)(result + 8)))(a2, a3, a4);
  v9 = *(_QWORD *)(a1 + 264);
  if ( v9 )
  {
    result = *(_QWORD *)(v9 + 8) + *(_QWORD *)a1;
    v10 = *(_QWORD *)(*(_QWORD *)(a1 + 280) + 8LL) >> 3;
    if ( (_DWORD)v10 )
    {
      v11 = result + 8;
      v12 = result + 8 + 8LL * (unsigned int)(v10 - 1);
      while ( 1 )
      {
        (*(void (__fastcall **)(_QWORD, __int64, __int64))result)(a2, a3, a4);
        result = v11;
        if ( v12 == v11 )
          break;
        v11 += 8LL;
      }
    }
  }
  return result;
}
// BEFD8: using guessed type void *off_BEFD8;
// C14B4: using guessed type int dword_C14B4;

//----- (0000000000086F50) ----------------------------------------------------
__int64 __fastcall sub_86F50(_QWORD *a1, unsigned int a2, unsigned int a3, __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v14; // rax
  __int64 v15; // r13
  _QWORD *v16; // rbp
  __int64 v17; // rax
  unsigned int *v18; // rax
  unsigned int v19; // er15
  __int64 v20; // r12
  __int64 v21; // rbx
  __int64 i; // rdx
  char *j; // r12
  const char *v24; // r13
  int v25; // ebx
  _QWORD *v26; // r14
  const char *v27; // rbp
  __int64 v28; // r11
  __int64 v29; // rax
  __int64 v30; // rdx
  char *v31; // r14
  __int64 v32; // r12
  __int64 v33; // rbp
  int v34; // er13
  __int64 v35; // rbx
  __int64 v36; // rax
  __int64 v37; // rax
  __int64 v38; // r8
  __int64 v39; // r9
  const char *v40; // rsi
  __int64 v41; // rax
  unsigned int v43; // er13
  const char *v44; // rsi
  const char *v45; // rdx
  __int64 v46; // rax
  unsigned int v47; // ebx
  __int64 v48; // rax
  __int64 v49; // rsi
  __int64 v50; // rax
  unsigned int *k; // rdi
  char *l; // rax
  int v53; // er8
  __int64 v54; // rcx
  __int64 v55; // rdx
  __int64 v56; // rdx
  __int64 v57; // rax
  __int64 v58; // rax
  const char *v59; // rsi
  __int64 m; // rax
  __int64 v61; // rcx
  __int64 v62; // rdx
  __int64 v63; // rdx
  __int64 v64; // rax
  __int64 v65; // r8
  __int64 v66; // r9
  const char *v67; // rsi
  unsigned int v68; // edi
  const char *v69; // rsi
  const char *v70; // rsi
  char v71; // [rsp+0h] [rbp-C8h]
  __int64 v72; // [rsp+0h] [rbp-C8h]
  _QWORD *v73; // [rsp+8h] [rbp-C0h]
  __int64 v74; // [rsp+10h] [rbp-B8h]
  unsigned int *v75; // [rsp+18h] [rbp-B0h]
  __int16 v76; // [rsp+26h] [rbp-A2h]
  _QWORD *v77; // [rsp+28h] [rbp-A0h]
  __int64 v78; // [rsp+28h] [rbp-A0h]
  __int64 v79; // [rsp+30h] [rbp-98h]
  __int64 v80; // [rsp+38h] [rbp-90h]
  __int64 v82; // [rsp+48h] [rbp-80h]
  char v83[13]; // [rsp+63h] [rbp-65h] BYREF
  __m128i v84[5]; // [rsp+70h] [rbp-58h] BYREF

  v14 = a1[13];
  if ( !v14 )
    return 0LL;
  v15 = *(_QWORD *)(v14 + 8);
  v16 = a1;
  v17 = a1[44];
  v82 = v17;
  v80 = a1[46];
  if ( !v17 )
  {
    v19 = 0;
    if ( !v80 )
      return 0LL;
LABEL_50:
    for ( i = *v16 + *(_QWORD *)(v80 + 8); ; i += v46 )
    {
      if ( v19 < (*(_WORD *)(i + 4) & 0x7FFFu) )
        v19 = *(_WORD *)(i + 4) & 0x7FFF;
      v46 = *(unsigned int *)(i + 16);
      if ( !(_DWORD)v46 )
        break;
    }
    goto LABEL_55;
  }
  v18 = (unsigned int *)(*a1 + *(_QWORD *)(v17 + 8));
  v19 = 0;
  v75 = v18;
  if ( *(_WORD *)v18 != 1 )
  {
    v83[0] = 0;
    v64 = sub_7A1B0(*(unsigned __int16 *)v18, (__int64)v83, 0xAu, 0);
    v67 = (const char *)a1[1];
    if ( !*v67 )
    {
      v67 = (const char *)off_BEFD8;
      if ( !off_BEFD8 )
        v67 = "<main program>";
    }
    sub_78F10(v84, (__int64)v67, "unsupported version %s of Verneed record", v64, v65, v66, v71);
    v68 = 0;
LABEL_89:
    sub_500B0(v68, v84, 0LL);
  }
  v72 = v15;
  while ( 1 )
  {
    v20 = v72 + v75[1];
    v21 = (__int64)*(&off_BF0E0 + 19 * v16[6]);
    if ( v21 )
    {
      while ( !(unsigned int)sub_772B0(v20, v21) )
      {
        v21 = *(_QWORD *)(v21 + 24);
        if ( !v21 )
          goto LABEL_36;
      }
    }
    else
    {
LABEL_36:
      if ( !*((_DWORD *)v16 + 178) )
        goto LABEL_41;
      v43 = 0;
      while ( !(unsigned int)sub_772B0(v20, *(_QWORD *)(v16[88] + 8LL * v43)) )
      {
        if ( ++v43 >= *((_DWORD *)v16 + 178) )
          goto LABEL_41;
      }
      v21 = *(_QWORD *)(v16[88] + 8LL * v43);
      if ( !v21 )
LABEL_41:
        sub_CF00("needed != NULL", "dl-version.c", 205LL, "_dl_check_map_versions");
    }
    a4 = a3;
    if ( !a3 || (*(_BYTE *)(v21 + 797) & 2) == 0 )
    {
      v74 = v21;
      v73 = v16;
      for ( j = (char *)v75 + v75[2]; ; j += v41 )
      {
        v24 = (const char *)(v72 + *((unsigned int *)j + 2));
        v25 = *(_DWORD *)j;
        v76 = *((_WORD *)j + 2);
        v26 = *(_QWORD **)(v74 + 40);
        v27 = (const char *)v73[1];
        if ( !*v27 )
        {
          v27 = (const char *)off_BEFD8;
          if ( !off_BEFD8 )
            v27 = "<main program>";
        }
        v28 = *(_QWORD *)(v26[13] + 8LL);
        if ( (dword_C14B4 & 0x10) != 0 )
        {
          v45 = (const char *)v26[1];
          if ( !*v45 )
          {
            v45 = (const char *)off_BEFD8;
            if ( !off_BEFD8 )
              v45 = "<main program>";
          }
          v78 = *(_QWORD *)(v26[13] + 8LL);
          sub_76EA0(
            "checking for version `%s' in file %s [%lu] required by file %s [%lu]\n",
            v24,
            v45,
            v26[6],
            v27,
            v73[6]);
          v28 = v78;
        }
        v29 = v26[46];
        if ( v29 )
        {
          v30 = *(_QWORD *)(v29 + 8);
          if ( !v30 )
            sub_CF00("def_offset != 0", "dl-version.c", 88LL, "match_symbol");
          i = *v26 + v30;
          if ( *(_WORD *)i != 1 )
          {
LABEL_23:
            v83[0] = 0;
            v37 = sub_7A1B0(*(unsigned __int16 *)i, (__int64)v83, 0xAu, 0);
            v40 = (const char *)v26[1];
            if ( !*v40 )
            {
              v40 = (const char *)off_BEFD8;
              if ( !off_BEFD8 )
                v40 = "<main program>";
            }
            sub_78F10(v84, (__int64)v40, "unsupported version %s of Verdef record", v37, v38, v39, v72);
            goto LABEL_27;
          }
          v77 = v26;
          v31 = j;
          v32 = v28;
          v79 = (__int64)v27;
          v33 = (__int64)v24;
          v34 = v25;
          v35 = i;
          while ( 1 )
          {
            if ( v34 == *(_DWORD *)(v35 + 8)
              && !(unsigned int)sub_91B0(v33, v32 + *(unsigned int *)(v35 + *(unsigned int *)(v35 + 12))) )
            {
              j = v31;
              goto LABEL_30;
            }
            v36 = *(unsigned int *)(v35 + 16);
            if ( !(_DWORD)v36 )
              break;
            v35 += v36;
            if ( *(_WORD *)v35 != 1 )
            {
              v26 = v77;
              i = v35;
              goto LABEL_23;
            }
          }
          j = v31;
          if ( (v76 & 2) == 0 )
          {
            v69 = (const char *)v77[1];
            if ( !*v69 )
            {
              v69 = (const char *)off_BEFD8;
              if ( !off_BEFD8 )
                v69 = "<main program>";
            }
            sub_78F10(v84, (__int64)v69, "version `%s' not found (required by %s)", v33, v79, a6, v72);
            goto LABEL_27;
          }
          if ( a2 )
          {
            v59 = (const char *)v77[1];
            if ( !*v59 )
            {
              v59 = (const char *)off_BEFD8;
              if ( !off_BEFD8 )
                v59 = "<main program>";
            }
            sub_78F10(v84, (__int64)v59, "weak version `%s' not found (required by %s)", v33, v79, a6, v72);
            goto LABEL_27;
          }
        }
        else
        {
          i = a2;
          if ( a2 )
          {
            v44 = (const char *)v26[1];
            if ( !*v44 )
            {
              v44 = (const char *)off_BEFD8;
              if ( !off_BEFD8 )
                v44 = "<main program>";
            }
            sub_78F10(
              v84,
              (__int64)v44,
              "no version information available (required by %s)",
              (__int64)v27,
              (__int64)v27,
              a6,
              v72);
LABEL_27:
            sub_500B0(0, v84, "version lookup error");
          }
        }
LABEL_30:
        if ( v19 < (*((_WORD *)j + 3) & 0x7FFFu) )
          v19 = *((_WORD *)j + 3) & 0x7FFF;
        v41 = *((unsigned int *)j + 3);
        if ( !(_DWORD)v41 )
          break;
      }
      v16 = v73;
    }
    v58 = v75[3];
    if ( !(_DWORD)v58 )
      break;
    v75 = (unsigned int *)((char *)v75 + v58);
  }
  v15 = v72;
  if ( v80 )
    goto LABEL_50;
LABEL_55:
  if ( !v19 )
    return 0LL;
  v47 = v19 + 1;
  v48 = sub_22260(v19 + 1, 0x18uLL, a7, a8, a9, a10, a11, a12, a13, a14, i, a4, a5, a6);
  v16[93] = v48;
  v49 = v48;
  if ( !v48 )
  {
    v70 = (const char *)v16[1];
    if ( !*v70 )
    {
      v70 = (const char *)off_BEFD8;
      if ( !off_BEFD8 )
        v70 = "<main program>";
    }
    sub_78E60((const char **)v84, (__int64)v70, (__int64)"cannot allocate version reference table");
    v68 = 12;
    goto LABEL_89;
  }
  v50 = v16[58];
  *((_DWORD *)v16 + 188) = v47;
  v16[104] = *(_QWORD *)(v50 + 8);
  if ( v82 )
  {
    for ( k = (unsigned int *)(*v16 + *(_QWORD *)(v82 + 8)); ; k = (unsigned int *)((char *)k + v57) )
    {
      for ( l = (char *)k + k[2]; ; l += v56 )
      {
        if ( v47 > (*((_WORD *)l + 3) & 0x7FFFu) )
        {
          v53 = *(_DWORD *)l;
          v54 = v49 + 24LL * (*((_WORD *)l + 3) & 0x7FFF);
          *(_DWORD *)(v54 + 12) = *((_WORD *)l + 3) & 0x8000;
          v55 = *((unsigned int *)l + 2);
          *(_DWORD *)(v54 + 8) = v53;
          *(_QWORD *)v54 = v15 + v55;
          *(_QWORD *)(v54 + 16) = v15 + k[1];
        }
        v56 = *((unsigned int *)l + 3);
        if ( !(_DWORD)v56 )
          break;
      }
      v57 = k[3];
      if ( !(_DWORD)v57 )
        break;
    }
  }
  if ( v80 )
  {
    for ( m = *v16 + *(_QWORD *)(v80 + 8); ; m += v63 )
    {
      if ( (*(_BYTE *)(m + 2) & 1) == 0 )
      {
        v61 = *(unsigned int *)(m + *(unsigned int *)(m + 12));
        v62 = v49 + 24LL * (*(_WORD *)(m + 4) & 0x7FFF);
        *(_DWORD *)(v62 + 8) = *(_DWORD *)(m + 8);
        *(_QWORD *)v62 = v15 + v61;
        *(_QWORD *)(v62 + 16) = 0LL;
      }
      v63 = *(unsigned int *)(m + 16);
      if ( !(_DWORD)v63 )
        break;
    }
  }
  return 0LL;
}
// 8713E: variable 'v38' is possibly undefined
// 8713E: variable 'v39' is possibly undefined
// 8728F: variable 'a6' is possibly undefined
// 8732F: variable 'a11' is possibly undefined
// 8732F: variable 'a12' is possibly undefined
// 8732F: variable 'i' is possibly undefined
// 8732F: variable 'a4' is possibly undefined
// 8732F: variable 'a5' is possibly undefined
// 87550: variable 'v65' is possibly undefined
// 87550: variable 'v66' is possibly undefined
// 87550: variable 'v71' is possibly undefined
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);
// CF00: using guessed type __int64 __fastcall sub_CF00(_QWORD, _QWORD, _QWORD, _QWORD);
// BEFD8: using guessed type void *off_BEFD8;
// BF0E0: using guessed type void *off_BF0E0;
// C14B4: using guessed type int dword_C14B4;

//----- (00000000000876C0) ----------------------------------------------------
unsigned int *__fastcall sub_876C0(_QWORD *a1, __int64 a2, __int64 a3, int a4, unsigned int a5)
{
  __int64 v7; // rbp
  unsigned int *v8; // r12
  int v9; // eax
  int v10; // edx
  __int64 v11; // rax

  v7 = a5;
  v8 = (unsigned int *)(*(_QWORD *)(a1[14] + 8LL) + 24LL * a5);
  v9 = v8[1] & 0xF;
  if ( !*((_QWORD *)v8 + 1) && *((_WORD *)v8 + 3) != 0xFFF1 && (_BYTE)v9 != 6 )
    return 0LL;
  v10 = 1127;
  if ( !_bittest(&v10, v9) )
    return 0LL;
  if ( (unsigned int)sub_91B0(*(_QWORD *)(a1[13] + 8LL) + *v8, a2) )
    return 0LL;
  v11 = a1[93] + 24LL * (*(_WORD *)(a1[104] + 2 * v7) & 0x7FFF);
  if ( *(_DWORD *)(v11 + 8) != a4 )
    return 0LL;
  if ( (unsigned int)sub_91B0(*(_QWORD *)v11, a3) )
    v8 = 0LL;
  return v8;
}
// 91B0: using guessed type __int64 __fastcall sub_91B0(_QWORD, _QWORD);

//----- (0000000000087780) ----------------------------------------------------
unsigned int *__fastcall sub_87780(__int64 a1, unsigned __int8 *a2, unsigned int a3, __int64 a4, int a5)
{
  unsigned int *v8; // r9
  unsigned int v9; // ecx
  unsigned int v10; // er10
  __int64 v11; // rax
  int *i; // rbx
  int v13; // er15
  unsigned int *v14; // rax
  __int64 v16; // rax
  __int64 v17; // rsi
  __int64 v18; // rdx
  __int64 v19; // rax
  __int64 v20; // rdx
  unsigned __int8 v21; // dl
  __int64 v22; // rsi
  __int64 v23; // rax
  __int64 v24; // rdx
  unsigned __int64 v25; // rax
  unsigned __int8 *j; // rsi
  __int64 k; // rbx
  unsigned int v28; // [rsp+4h] [rbp-44h]
  __int64 v29; // [rsp+8h] [rbp-40h]

  v8 = *(unsigned int **)(a1 + 768);
  v9 = *(_DWORD *)(a1 + 756);
  if ( v8 )
  {
    v10 = a3;
    v8 = 0LL;
    v11 = *(unsigned int *)(*(_QWORD *)(a1 + 776) + 4LL * (a3 % v9));
    if ( (_DWORD)v11 )
    {
      v29 = *(_QWORD *)(a1 + 784);
      for ( i = (int *)(v29 + 4 * v11); ; ++i )
      {
        v13 = *i;
        if ( !((v10 ^ *i) >> 1) )
        {
          v28 = v10;
          v14 = sub_876C0((_QWORD *)a1, (__int64)a2, a4, a5, ((__int64)i - v29) >> 2);
          v10 = v28;
          v8 = v14;
          if ( v14 )
            break;
        }
        if ( (v13 & 1) != 0 )
          return 0LL;
      }
    }
  }
  else
  {
    v16 = *a2;
    if ( *a2 )
    {
      v17 = a2[1];
      if ( (_BYTE)v17 )
      {
        v18 = a2[2];
        v19 = v17 + 16 * v16;
        if ( (_BYTE)v18 && (v19 = v18 + 16 * v19, v20 = a2[3], (_BYTE)v20) && (v19 = v20 + 16 * v19, (v21 = a2[4]) != 0) )
        {
          v22 = 16 * v19;
          v23 = v21;
          v24 = a2[5];
          v25 = v22 + v23;
          for ( j = a2 + 5; (_BYTE)v24; v24 = *j )
          {
            ++j;
            v25 = ((v24 + 16 * v25) >> 24) & 0xF0 ^ (v24 + 16 * v25);
          }
          v16 = 4 * ((v25 & 0xFFFFFFF) % v9);
        }
        else
        {
          v16 = 4LL * ((unsigned int)v19 % v9);
        }
      }
      else
      {
        v16 = 4LL * ((unsigned __int8)v16 % v9);
      }
    }
    for ( k = *(unsigned int *)(*(_QWORD *)(a1 + 784) + v16);
          (_DWORD)k;
          LODWORD(k) = *(_DWORD *)(*(_QWORD *)(a1 + 776) + 4 * k) )
    {
      v8 = sub_876C0((_QWORD *)a1, (__int64)a2, a4, a5, k);
      if ( v8 )
        break;
    }
  }
  return v8;
}

//----- (0000000000087950) ----------------------------------------------------
__int64 __fastcall sub_87950(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  __int64 v10; // [rsp-10h] [rbp-18h]

  *(_QWORD *)a1 = sub_73690(
                    *(unsigned __int8 **)(a1 + 8),
                    *(_QWORD *)a1,
                    *(unsigned int ***)(a1 + 40),
                    *(__int64 ***)(*(_QWORD *)a1 + 912LL),
                    *(const char ***)(a1 + 16),
                    0,
                    a2,
                    a3,
                    a4,
                    a5,
                    a6,
                    a7,
                    a8,
                    a9,
                    *(_DWORD *)(a1 + 24),
                    0LL);
  return v10;
}
// 8797F: variable 'v10' is possibly undefined

//----- (0000000000087990) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_87990(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3, const char **a4, int a5, __m128 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13))(__m128i *, __int64 (__fastcall *)(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9))
{
  __int64 **v16; // rcx
  __int64 (__fastcall *v17)(__int64, __m128, double, double, double, double, double, double, double); // rsi
  __m128i *v18; // rdi
  __int64 *v19; // rcx
  __int64 (__fastcall *result)(__m128i *, __int64 (__fastcall *)(__int64, __m128, double, double, double, double, double, double, double)); // rax
  __int64 v21; // rax
  __int64 **v22; // rax
  double v23; // xmm4_8
  double v24; // xmm5_8
  __int64 **v25; // rsi
  __int64 **v26; // rax
  __int64 **v27; // rcx
  __int64 v28; // rax
  __int64 v29; // rcx
  _QWORD *v30; // rsi
  __int64 v31; // r9
  double v32; // xmm4_8
  double v33; // xmm5_8
  u32 *v34; // r8
  u32 v35; // er9
  double v36; // xmm4_8
  double v37; // xmm5_8
  volatile __int32 *v38; // rax
  signed __int64 v39; // rax
  __int64 (__fastcall *v40)(__int64, __m128, double, double, double, double, double, double, double); // [rsp-10h] [rbp-A8h]
  __m128i *v41; // [rsp-8h] [rbp-A0h]
  unsigned int *v43; // [rsp+18h] [rbp-80h] BYREF
  __m128i v44[2]; // [rsp+20h] [rbp-78h] BYREF
  __int64 v45[3]; // [rsp+40h] [rbp-58h] BYREF
  int v46; // [rsp+58h] [rbp-40h]
  unsigned int **v47; // [rsp+68h] [rbp-30h]
  unsigned __int64 v48; // [rsp+78h] [rbp-20h]

  v48 = __readfsqword(0x28u);
  v43 = 0LL;
  if ( a1 )
  {
    if ( a1 != -1 )
    {
      v16 = (__int64 **)(a1 + 920);
      v17 = (__int64 (__fastcall *)(__int64, __m128, double, double, double, double, double, double, double))a1;
      v18 = (__m128i *)a2;
      v19 = (__int64 *)sub_73690(a2, (__int64)v17, &v43, v16, a4, 0, a6, a7, a8, a9, a10, a11, a12, a13, a5, 0LL);
      goto LABEL_4;
    }
    v22 = (__int64 **)sub_81070(a3);
    v25 = v22;
    if ( v22 )
    {
      if ( v22 != off_BF0E0 )
      {
LABEL_14:
        v26 = v25;
        do
        {
          v27 = v26;
          v26 = (__int64 **)v26[92];
        }
        while ( v26 );
        v28 = sub_73690(a2, (__int64)v25, &v43, v27 + 115, a4, 0, a6, a7, a8, a9, v23, v24, a12, a13, 0, (__int64)v25);
        goto LABEL_17;
      }
    }
    else
    {
      v25 = (__int64 **)off_BF0E0;
      if ( !off_BF0E0 )
        goto LABEL_21;
    }
    if ( (unsigned __int64)v25[106] <= a3 && (unsigned __int64)v25[107] > a3 )
      goto LABEL_14;
LABEL_21:
    sub_50110(
      0LL,
      0LL,
      0LL,
      "RTLD_NEXT used in code not dynamically loaded",
      *(double *)a6.m128_u64,
      a7,
      a8,
      a9,
      v23,
      v24,
      a12,
      a13);
  }
  v30 = sub_81070(a3);
  if ( !v30 )
    v30 = off_BF0E0;
  if ( !__readfsdword(0x18u) )
  {
    v28 = sub_73690(
            a2,
            (__int64)v30,
            &v43,
            (__int64 **)v30[114],
            a4,
            0,
            a6,
            a7,
            a8,
            a9,
            v32,
            v33,
            a12,
            a13,
            a5 | 1u,
            0LL);
LABEL_17:
    v17 = v40;
    v18 = v41;
    v19 = (__int64 *)v28;
    goto LABEL_4;
  }
  v45[1] = (__int64)a2;
  v45[0] = (__int64)v30;
  v45[2] = (__int64)a4;
  v46 = a5 | 5;
  v47 = &v43;
  __writefsdword(0x1Cu, 1u);
  v17 = sub_87950;
  v18 = v44;
  v34 = (u32 *)(unsigned int)sub_50170(
                               (__int64)v44,
                               (void (__fastcall *)(__int64))sub_87950,
                               (__int64)v45,
                               v29,
                               a5 | 5u,
                               v31);
  LODWORD(v38) = _InterlockedExchange(MK_FP(0, 28LL), 0);
  if ( (_DWORD)v38 == 2 )
  {
    v18 = (__m128i *)(__readfsqword(0x10u) + 28);
    v17 = (__int64 (__fastcall *)(__int64, __m128, double, double, double, double, double, double, double))(&qword_80 + 1);
    v39 = sys_futex((u32 *)v18, 129, 1u, 0LL, v34, v35);
  }
  v19 = (__int64 *)v45[0];
  if ( v44[0].m128i_i64[1] )
    sub_500B0((unsigned int)v34, v44, 0LL, a6, a7, a8, a9, v36, v37, a12, a13);
LABEL_4:
  result = 0LL;
  if ( v43 )
  {
    if ( *((_WORD *)v43 + 3) == 0xFFF1 || !v19 )
      v21 = 0LL;
    else
      v21 = *v19;
    result = (__int64 (__fastcall *)(__m128i *, __int64 (__fastcall *)(__int64, __m128, double, double, double, double, double, double, double)))(*((_QWORD *)v43 + 1) + v21);
    if ( (v43[1] & 0xF) == 10 )
      result = (__int64 (__fastcall *)(__m128i *, __int64 (__fastcall *)(__int64, __m128, double, double, double, double, double, double, double)))result(v18, v17);
  }
  return result;
}
// 87A8F: variable 'v23' is possibly undefined
// 87A8F: variable 'v24' is possibly undefined
// 87A94: variable 'v40' is possibly undefined
// 87A95: variable 'v41' is possibly undefined
// 87B20: variable 'v32' is possibly undefined
// 87B20: variable 'v33' is possibly undefined
// 87B67: variable 'v29' is possibly undefined
// 87B67: variable 'v31' is possibly undefined
// 87B9D: variable 'v35' is possibly undefined
// 87BB8: variable 'v34' is possibly undefined
// 87BB8: variable 'v36' is possibly undefined
// 87BB8: variable 'v37' is possibly undefined
// 80: using guessed type __int64 qword_80;
// BF0E0: using guessed type void *off_BF0E0;

//----- (0000000000087BD0) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_87BD0(__int64 a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int64 a4, __m128 a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12))(__m128i *, __int64 (__fastcall *)(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9))
{
  __int64 v13; // rcx
  unsigned __int64 v14; // rax
  unsigned __int8 v16; // dl
  __int64 v17; // rax
  __int64 v18; // rdx
  __int64 v19; // rdx
  __int64 v20; // rdx
  unsigned __int8 *v21; // rcx
  __int64 v22; // rdx
  const char *v24; // [rsp+0h] [rbp-28h] BYREF
  int v25; // [rsp+8h] [rbp-20h]
  int v26; // [rsp+Ch] [rbp-1Ch]
  __int64 v27; // [rsp+10h] [rbp-18h]
  unsigned __int64 v28; // [rsp+18h] [rbp-10h]

  v13 = *a3;
  v28 = __readfsqword(0x28u);
  LODWORD(v14) = 0;
  v24 = (const char *)a3;
  v26 = 1;
  if ( v13 )
  {
    v16 = a3[1];
    if ( v16 )
    {
      v17 = v16;
      v18 = a3[2];
      v14 = 16 * v13 + v17;
      if ( (_BYTE)v18 )
      {
        v14 = v18 + 16 * v14;
        v19 = a3[3];
        if ( (_BYTE)v19 )
        {
          v14 = v19 + 16 * v14;
          v20 = a3[4];
          if ( (_BYTE)v20 )
          {
            v21 = a3 + 5;
            v14 = v20 + 16 * v14;
            v22 = a3[5];
            if ( (_BYTE)v22 )
            {
              do
              {
                ++v21;
                v14 = ((v22 + 16 * v14) >> 24) & 0xF0 ^ (v22 + 16 * v14);
                v22 = *v21;
              }
              while ( (_BYTE)v22 );
              LODWORD(v14) = v14 & 0xFFFFFFF;
            }
          }
        }
      }
    }
    else
    {
      LODWORD(v14) = (unsigned __int8)v13;
    }
  }
  v25 = v14;
  v27 = 0LL;
  return sub_87990(a1, a2, a4, &v24, 0, a5, a6, a7, a8, a9, a10, a11, a12);
}

//----- (0000000000087CD0) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_87CD0(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3, __m128 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11))(__m128i *, __int64 (__fastcall *)(__int64 a1, __m128 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9))
{
  return sub_87990(a1, a2, a3, 0LL, 2, a4, a5, a6, a7, a8, a9, a10, a11);
}

//----- (0000000000087CF0) ----------------------------------------------------
__int64 __fastcall sub_87CF0(__int64 a1, __int64 *a2, __int64 *a3, __int64 a4)
{
  __int64 v4; // r10
  __int64 v5; // r11
  __int64 *v6; // rsi
  __int64 *v7; // rdx
  __int64 v8; // rdi
  char v9; // al
  __int64 v10; // rcx
  int v11; // eax
  __int64 v12; // rcx
  bool v13; // cf
  char v14; // cf
  __int64 v15; // r8
  __int64 v16; // r9
  char v17; // cf
  char v18; // cf
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // r10
  __int64 v22; // rtt
  __int64 v24; // r10
  __int64 v25; // rtt
  __int64 v26; // r8
  __int64 v27; // rtt
  __int64 v28; // r10
  _BOOL8 v29; // rtt
  __int64 v30; // r8
  __int64 v31; // rtt

  v4 = *a2;
  v5 = *a3;
  v6 = &a2[a4 - 1];
  v7 = &a3[a4 - 1];
  v8 = a1 + 8 * a4 - 16;
  v9 = a4;
  v10 = -a4;
  v11 = v9 & 3;
  if ( !v11 )
  {
    v14 = 0;
    v15 = v4;
    v16 = v5;
    v12 = v10 + 4;
    goto LABEL_9;
  }
  v12 = (unsigned int)v11 + v10;
  if ( v11 < 2 )
  {
    v17 = 0;
    goto LABEL_12;
  }
  if ( v11 == 2 )
  {
    v18 = 0;
    v19 = v4;
    v20 = v5;
    goto LABEL_11;
  }
  v13 = 0;
  while ( 1 )
  {
    v19 = v6[v12 - 1];
    v20 = v7[v12 - 1];
    v29 = v13;
    v13 = __CFADD__(v13, v4);
    v28 = v29 + v4;
    v18 = v13 | __CFADD__(v5, v28);
    *(_QWORD *)(v8 + 8 * v12 - 8) = v5 + v28;
LABEL_11:
    v4 = v6[v12];
    v5 = v7[v12];
    v31 = v18;
    v13 = __CFADD__(v18, v19);
    v30 = v31 + v19;
    v17 = v13 | __CFADD__(v20, v30);
    *(_QWORD *)(v8 + 8 * v12) = v20 + v30;
LABEL_12:
    if ( !v12 )
      break;
    v12 += 4LL;
    v15 = v6[v12 - 3];
    v16 = v7[v12 - 3];
    v25 = v17;
    v13 = __CFADD__(v17, v4);
    v24 = v25 + v4;
    v14 = v13 | __CFADD__(v5, v24);
    *(_QWORD *)(v8 + 8 * v12 - 24) = v5 + v24;
LABEL_9:
    v4 = v6[v12 - 2];
    v5 = v7[v12 - 2];
    v27 = v14;
    v13 = __CFADD__(v14, v15);
    v26 = v27 + v15;
    v13 |= __CFADD__(v16, v26);
    *(_QWORD *)(v8 + 8 * v12 - 16) = v16 + v26;
  }
  v22 = v17;
  v13 = __CFADD__(v17, v4);
  v21 = v22 + v4;
  *(_QWORD *)(v8 + 8) = v5 + v21;
  return v13 | (unsigned __int8)__CFADD__(v5, v21);
}

//----- (0000000000087DA0) ----------------------------------------------------
unsigned __int64 __fastcall sub_87DA0(__int64 *a1, unsigned __int64 *a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // rbx
  unsigned __int64 v5; // rax
  __int64 v6; // r10
  __int64 *v7; // rdi
  unsigned __int64 *v8; // rsi
  unsigned __int128 v9; // rax
  __int64 v10; // rbp
  __int64 v11; // r11
  unsigned __int128 v12; // rax
  __int64 v13; // rbx
  __int64 v14; // r8
  unsigned __int64 v15; // rax
  __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // r9
  unsigned __int64 v19; // r11
  unsigned __int64 v20; // rax
  __int64 v21; // rbp
  unsigned __int128 v22; // rax
  bool v23; // cf
  __int64 v24; // r10
  unsigned __int64 v25; // r11
  _BOOL8 v26; // rtt
  unsigned __int128 v27; // rax
  __int64 v28; // r10
  __int64 v29; // r8
  _BOOL8 v30; // rtt
  unsigned __int64 v31; // r11
  __int64 v32; // r10

  v4 = -a3;
  v5 = *a2;
  v6 = *a1;
  v7 = &a1[a3 - 2];
  v8 = &a2[a3];
  v9 = a4 * (unsigned __int128)v5;
  if ( _bittest((const int *)&v4, 0) )
  {
    v13 = v4 + 1;
    if ( v13 < 0 )
    {
      v18 = *((_QWORD *)&v9 + 1);
      v17 = v9;
      v19 = a4 * v8[v13];
      v20 = v8[v13 + 1];
      v21 = (a4 * (unsigned __int128)v8[v13]) >> 64;
      goto LABEL_8;
    }
  }
  else
  {
    v10 = *((_QWORD *)&v9 + 1);
    v11 = v9;
    v12 = a4 * (unsigned __int128)v8[v4 + 1];
    v13 = v4 + 2;
    if ( v13 < 0 )
    {
      v14 = v12;
      *(_QWORD *)&v12 = v8[v13];
      v16 = *((_QWORD *)&v12 + 1);
      while ( 1 )
      {
        v27 = a4 * (unsigned __int128)v15;
        v23 = __CFADD__(v11, v6);
        v28 = v11 + v6;
        v19 = v27;
        v20 = v8[v13 + 1];
        v30 = v23;
        v23 = __CFADD__(v23, v14);
        v29 = v30 + v14;
        v23 |= __CFADD__(v10, v29);
        v17 = v10 + v29;
        v7[v13] = v28;
        v6 = v7[v13 + 1];
        v21 = *((_QWORD *)&v27 + 1);
        v18 = v23 + v16;
LABEL_8:
        v13 += 2LL;
        if ( v13 >= 0 )
          break;
        v22 = a4 * (unsigned __int128)v20;
        v23 = __CFADD__(v17, v6);
        v24 = v17 + v6;
        v14 = v22;
        v15 = v8[v13];
        v26 = v23;
        v23 = __CFADD__(v23, v19);
        v25 = v26 + v19;
        v23 |= __CFADD__(v18, v25);
        v11 = v18 + v25;
        v7[v13 - 1] = v24;
        v6 = v7[v13];
        v16 = *((_QWORD *)&v22 + 1);
        v10 = v23 + v21;
      }
      v12 = a4 * (unsigned __int128)v20;
      v23 = __CFADD__(__CFADD__(v17, v6), v19);
      v31 = __CFADD__(v17, v6) + v19;
      v23 |= __CFADD__(v18, v31);
      v11 = v18 + v31;
      *(v7 - 1) = v17 + v6;
      v10 = v23 + v21;
    }
    v23 = __CFADD__(__CFADD__(v11, *v7), (_QWORD)v12);
    *(_QWORD *)&v12 = __CFADD__(v11, *v7) + (_QWORD)v12;
    v23 |= __CFADD__(v10, (_QWORD)v12);
    *(_QWORD *)&v9 = v10 + v12;
    *v7 += v11;
    *((_QWORD *)&v9 + 1) = v23 + *((_QWORD *)&v12 + 1);
  }
  v32 = v7[1];
  v7[1] = v9 + v32;
  return *((_QWORD *)&v9 + 1) + __CFADD__((_QWORD)v9, v32) + (unsigned __int64)(unsigned int)v13;
}

//----- (0000000000087E90) ----------------------------------------------------
unsigned __int64 __fastcall sub_87E90(__m128 a1, __m128 a2)
{
  unsigned __int64 v2; // r9
  __int128 v3; // rdi
  unsigned __int64 v4; // rdx
  unsigned __int64 result; // rax
  int v6; // er8
  unsigned __int64 v7; // [rsp+0h] [rbp-38h]

  _mm_getcsr();
  *(_QWORD *)&v3 = a2.m128_u64[0];
  v2 = a1.m128_u64[1] & 0xFFFFFFFFFFFFLL;
  *((_QWORD *)&v3 + 1) = a2.m128_u64[1] & 0xFFFFFFFFFFFFLL;
  v4 = HIWORD(a2.m128_u64[1]) & 0x7FFF;
  result = HIWORD(a1.m128_u64[1]) & 0x7FFF;
  if ( (a1.m128_i16[7] & 0x7FFF) == 0 )
  {
    if ( a1.m128_u64[0] | v2 )
    {
      v6 = 2;
      if ( v4 != 0x7FFF )
      {
LABEL_4:
        v7 = result;
        sub_88330(v6);
        return v7;
      }
LABEL_18:
      if ( v3 != 0 )
      {
        if ( result != 0x7FFF )
          goto LABEL_20;
LABEL_38:
        if ( !(v2 | a1.m128_u64[0]) )
        {
LABEL_30:
          if ( !(*((_QWORD *)&v3 + 1) | a2.m128_u64[0]) )
            goto LABEL_21;
LABEL_20:
          if ( (a2.m128_u64[1] & 0x800000000000LL) != 0 )
          {
LABEL_21:
            result = 1LL;
            goto LABEL_25;
          }
LABEL_10:
          LOBYTE(v6) = v6 | 1;
          result = 1LL;
          goto LABEL_4;
        }
        goto LABEL_9;
      }
LABEL_24:
      result = 0LL;
      goto LABEL_25;
    }
    if ( !v4 )
    {
      if ( a2.m128_u64[0] | *((_QWORD *)&v3 + 1) )
      {
        LOBYTE(v6) = 2;
        goto LABEL_4;
      }
      v6 = 0;
      goto LABEL_24;
    }
    if ( v4 != 0x7FFF )
      return result;
LABEL_17:
    v6 = 0;
    goto LABEL_18;
  }
  if ( v4 )
  {
    if ( result == 0x7FFF )
    {
      if ( a1.m128_u64[0] | v2 )
      {
        if ( (a1.m128_u64[1] & 0x800000000000LL) == 0 )
        {
          LOBYTE(v6) = 0;
          goto LABEL_10;
        }
        if ( v4 != 0x7FFF || !(*((_QWORD *)&v3 + 1) | a2.m128_u64[0]) )
          return 1LL;
        v6 = 0;
        goto LABEL_20;
      }
      if ( v4 != 0x7FFF )
        return 0LL;
      v6 = 0;
      if ( v3 != 0 )
        goto LABEL_38;
      goto LABEL_24;
    }
    if ( v4 != 0x7FFF )
      return 0LL;
    goto LABEL_17;
  }
  v6 = 2 * (v3 != 0);
  if ( result != 0x7FFF || !(v2 | a1.m128_u64[0]) )
    goto LABEL_24;
LABEL_9:
  if ( (a1.m128_u64[1] & 0x800000000000LL) == 0 )
    goto LABEL_10;
  result = 1LL;
  if ( v4 == 0x7FFF )
    goto LABEL_30;
LABEL_25:
  if ( v6 )
    goto LABEL_4;
  return result;
}

//----- (00000000000880A0) ----------------------------------------------------
unsigned __int64 __fastcall sub_880A0(__m128 a1, __m128 a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 v3; // r11
  unsigned __int64 v4; // rdx
  unsigned __int64 result; // rax
  signed __int64 v6; // rsi
  signed __int64 v7; // rdi
  int v8; // er10
  unsigned __int64 v9; // rbx
  unsigned __int64 v10; // [rsp+0h] [rbp-48h]

  _mm_getcsr();
  v2 = a1.m128_u64[1] >> 63;
  v3 = a1.m128_u64[1] & 0xFFFFFFFFFFFFLL;
  v4 = a2.m128_u64[1] & 0xFFFFFFFFFFFFLL;
  result = a2.m128_u64[1] >> 63;
  v6 = HIWORD(a2.m128_u64[1]) & 0x7FFF;
  v7 = HIWORD(a1.m128_u64[1]) & 0x7FFF;
  if ( (a1.m128_i16[7] & 0x7FFF) != 0 )
  {
    if ( v6 )
    {
      if ( v7 != 0x7FFF )
      {
        if ( v6 != 0x7FFF || __PAIR128__(a2.m128_u64[0], v4) == 0 )
        {
          v8 = 0;
          goto LABEL_15;
        }
        LOBYTE(v8) = 0;
        goto LABEL_20;
      }
      v8 = 0;
      if ( a1.m128_u64[0] | v3 )
        goto LABEL_20;
    }
    else
    {
      v8 = 2 * (__PAIR128__(a2.m128_u64[0], v4) != 0);
      if ( v7 != 0x7FFF )
      {
        if ( !v7 )
          goto LABEL_5;
        goto LABEL_14;
      }
      if ( a1.m128_u64[0] | v3 )
        goto LABEL_20;
    }
    if ( v6 == 0x7FFF )
    {
      if ( __PAIR128__(a2.m128_u64[0], v4) == 0 )
        goto LABEL_15;
      goto LABEL_20;
    }
    if ( v6 )
      goto LABEL_15;
LABEL_14:
    if ( __PAIR128__(a2.m128_u64[0], v4) == 0 )
      goto LABEL_16;
    goto LABEL_15;
  }
  if ( a1.m128_u64[0] | v3 )
  {
    v8 = 2;
  }
  else
  {
    v8 = 0;
    if ( !v6 )
    {
      v9 = a1.m128_u64[0] | v3;
      v8 = 2 * (__PAIR128__(a2.m128_u64[0], v4) != 0);
LABEL_6:
      if ( __PAIR128__(a2.m128_u64[0], v4) == 0 )
      {
        result = 0LL;
        if ( !v9 )
          goto LABEL_27;
LABEL_16:
        result = v2 == 0 ? 1LL : -1LL;
        if ( !v8 )
          return result;
LABEL_21:
        v10 = result;
        sub_88330(v8);
        return v10;
      }
LABEL_7:
      if ( !v9 )
        goto LABEL_26;
      goto LABEL_15;
    }
  }
  if ( v6 != 0x7FFF )
  {
LABEL_5:
    v9 = a1.m128_u64[0] | v3;
    if ( v6 )
      goto LABEL_7;
    goto LABEL_6;
  }
  if ( __PAIR128__(a2.m128_u64[0], v4) != 0 )
  {
LABEL_20:
    LOBYTE(v8) = v8 | 1;
    result = 2LL;
    goto LABEL_21;
  }
  if ( !(a1.m128_u64[0] | v3) )
    goto LABEL_26;
LABEL_15:
  if ( v2 != result )
    goto LABEL_16;
  if ( v7 > v6 )
  {
    if ( a2.m128_i64[1] >= 0 )
    {
      result = 1LL;
      goto LABEL_27;
    }
    goto LABEL_52;
  }
  if ( v7 < v6 )
  {
LABEL_26:
    if ( a2.m128_i64[1] < 0 )
      goto LABEL_27;
LABEL_52:
    result = -1LL;
    goto LABEL_27;
  }
  if ( v3 > v4 || a1.m128_u64[0] > a2.m128_u64[0] && v3 == v4 )
    goto LABEL_16;
  if ( v3 < v4 || a1.m128_u64[0] < a2.m128_u64[0] && v3 == v4 )
  {
    result = -1LL;
    if ( a1.m128_i64[1] < 0 )
      result = a1.m128_u64[1] >> 63;
  }
  else
  {
    result = 0LL;
  }
LABEL_27:
  if ( v8 )
    goto LABEL_21;
  return result;
}

//----- (0000000000088330) ----------------------------------------------------
float __fastcall sub_88330(char a1)
{
  float result; // xmm0_4
  __int16 v3; // [rsp+4h] [rbp-1Ch]

  if ( (a1 & 1) != 0 )
    result = 0.0 / 0.0;
  if ( (a1 & 2) != 0 )
  {
    __asm { fnstenv [rsp+var_20] }
    v3 |= 2u;
    __asm { fldenv  [rsp+var_20] }
  }
  if ( (a1 & 4) != 0 )
    result = 1.0 / 0.0;
  if ( (a1 & 8) != 0 )
  {
    __asm { fnstenv [rsp+var_20] }
    v3 |= 8u;
    __asm { fldenv  [rsp+var_20] }
  }
  if ( (a1 & 0x10) != 0 )
  {
    __asm { fnstenv [rsp+var_20] }
    v3 |= 0x10u;
    __asm { fldenv  [rsp+var_20] }
  }
  if ( (a1 & 0x20) != 0 )
    result = 1.0 / 3.0;
  return result;
}
// A6380: using guessed type int dword_A6380;

//----- (00000000000883B0) ----------------------------------------------------
void sub_883B0()
{
  memset(&byte_C1900, 8, 17);
}
// C1900: using guessed type char byte_C1900;

//----- (0000000000088430) ----------------------------------------------------
char *__fastcall sub_88430(__int64 a1, __int64 a2)
{
  __int64 v3; // rax
  char *v4; // rdx
  char *v5; // rsi
  __int64 v6; // rcx
  char *result; // rax
  _QWORD *v8; // rax
  __int64 v9; // [rsp+8h] [rbp-10h] BYREF

  if ( ((*(_BYTE *)(a2 + 199) & 0x40) == 0 || !*(_BYTE *)(a2 + 223)) && !*(_QWORD *)(a2 + 56) )
  {
    if ( byte_C1907 != 8 )
      goto LABEL_33;
    v9 = *(_QWORD *)(a2 + 144);
    if ( (*(_BYTE *)(a2 + 199) & 0x40) != 0 )
      *(_BYTE *)(a2 + 223) = 0;
    *(_QWORD *)(a2 + 56) = &v9;
  }
  v3 = 0LL;
  do
  {
    while ( 1 )
    {
      v4 = *(char **)(a1 + 8 * v3);
      v5 = *(char **)(a2 + 8 * v3);
      if ( *(_BYTE *)(a1 + v3 + 216) )
        goto LABEL_33;
      if ( *(_BYTE *)(a2 + v3 + 216) )
      {
        if ( v4 )
        {
          if ( byte_C1900[v3] != 8 )
            goto LABEL_33;
          *(_QWORD *)v4 = v5;
        }
        goto LABEL_8;
      }
      if ( v4 != 0LL && v5 != 0LL && v4 != v5 )
        break;
LABEL_8:
      if ( ++v3 == 17 )
        goto LABEL_19;
    }
    v6 = (unsigned __int8)byte_C1900[v3];
    if ( (unsigned int)v6 < 8 )
    {
      if ( (v6 & 4) != 0 )
      {
        *(_DWORD *)v4 = *(_DWORD *)v5;
        *(_DWORD *)&v4[v6 - 4] = *(_DWORD *)&v5[v6 - 4];
      }
      else if ( byte_C1900[v3] )
      {
        *v4 = *v5;
        if ( (v6 & 2) != 0 )
          *(_WORD *)&v4[v6 - 2] = *(_WORD *)&v5[v6 - 2];
      }
      goto LABEL_8;
    }
    ++v3;
    *(_QWORD *)v4 = *(_QWORD *)v5;
    *(_QWORD *)&v4[v6 - 8] = *(_QWORD *)&v5[v6 - 8];
    qmemcpy(
      (void *)((unsigned __int64)(v4 + 8) & 0xFFFFFFFFFFFFFFF8LL),
      (const void *)(v5 - &v4[-((unsigned __int64)(v4 + 8) & 0xFFFFFFFFFFFFFFF8LL)]),
      8LL * (((unsigned int)v4 - (((_DWORD)v4 + 8) & 0xFFFFFFF8) + (unsigned int)v6) >> 3));
  }
  while ( v3 != 17 );
LABEL_19:
  result = 0LL;
  if ( ((*(_BYTE *)(a1 + 199) & 0x40) == 0 || !*(_BYTE *)(a1 + 223)) && !*(_QWORD *)(a1 + 56) )
  {
    v8 = *(_QWORD **)(a2 + 56);
    if ( (*(_BYTE *)(a2 + 199) & 0x40) != 0 && *(_BYTE *)(a2 + 223) )
      return (char *)v8 + *(_QWORD *)(a2 + 208) - *(_QWORD *)(a1 + 144);
    if ( byte_C1907 == 8 )
    {
      v8 = (_QWORD *)*v8;
      return (char *)v8 + *(_QWORD *)(a2 + 208) - *(_QWORD *)(a1 + 144);
    }
LABEL_33:
    exit();
  }
  return result;
}
// C1907: using guessed type char byte_C1907;

//----- (00000000000885D0) ----------------------------------------------------
_QWORD *__fastcall sub_885D0(__int64 a1, char a2, __int64 a3, _QWORD *a4)
{
  unsigned __int8 v4; // r8
  __int64 *v5; // rax
  __int64 v6; // rdx
  _QWORD *result; // rax

  if ( a2 == -1 )
    goto LABEL_18;
  v4 = a2 & 0x70;
  if ( (a2 & 0x70) == 48 )
    goto LABEL_13;
  if ( v4 > 0x30u )
  {
    if ( v4 == 64 )
    {
      if ( a2 == 80 )
        goto LABEL_10;
LABEL_6:
      if ( (a2 & 0xFu) <= 0xC )
        __asm { jmp     rax }
      goto LABEL_18;
    }
    if ( v4 != 80 )
      goto LABEL_18;
LABEL_13:
    if ( a2 == 80 )
      goto LABEL_10;
    goto LABEL_6;
  }
  if ( v4 != 32 )
  {
    if ( v4 <= 0x20u && (a2 & 0x60) == 0 )
      goto LABEL_13;
LABEL_18:
    exit();
  }
  if ( a2 != 80 )
    goto LABEL_6;
LABEL_10:
  v5 = (__int64 *)((a3 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  v6 = *v5;
  result = v5 + 1;
  *a4 = v6;
  return result;
}

//----- (0000000000088780) ----------------------------------------------------
__int64 __fastcall sub_88780(_BYTE *a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  unsigned __int8 v4; // al

  if ( (unsigned __int64)a1 < a2 )
  {
    v4 = *a1 - 3;
    if ( v4 <= 0xEEu )
      __asm { jmp     rax }
    exit();
  }
  return a4;
}

//----- (0000000000088EB0) ----------------------------------------------------
unsigned __int64 __fastcall sub_88EB0(const __m128i *a1, __int64 a2)
{
  __int64 v3; // rax
  int v4; // eax
  __int64 v5; // rdx
  _QWORD *v6; // r11
  __int64 v7; // r11
  __int64 v8; // rsi
  int v9; // ecx
  char *v10; // rdi
  char v11; // dl
  unsigned __int64 v12; // rax
  __int64 v13; // rbx
  char *v14; // r8
  __int8 *v15; // rbp
  const __m128i *v16; // r13
  __int8 *v17; // r14
  unsigned __int64 result; // rax
  const __m128i *v19; // [rsp+8h] [rbp-160h]
  __int64 v21; // [rsp+38h] [rbp-130h] BYREF
  __int128 v22[3]; // [rsp+40h] [rbp-128h] BYREF
  __m128i v23; // [rsp+70h] [rbp-F8h]
  __m128i v24; // [rsp+80h] [rbp-E8h]
  __m128i v25; // [rsp+90h] [rbp-D8h]
  __m128i v26; // [rsp+A0h] [rbp-C8h]
  __m128i v27; // [rsp+B0h] [rbp-B8h]
  __m128i v28; // [rsp+C0h] [rbp-A8h]
  __m128i v29; // [rsp+D0h] [rbp-98h]
  __m128i v30; // [rsp+E0h] [rbp-88h]
  __m128i v31; // [rsp+F0h] [rbp-78h]
  __m128i v32; // [rsp+100h] [rbp-68h]
  __int128 v33[5]; // [rsp+110h] [rbp-58h]

  v22[0] = (__int128)_mm_loadu_si128(a1);
  v22[1] = (__int128)_mm_loadu_si128(a1 + 1);
  v22[2] = (__int128)_mm_loadu_si128(a1 + 2);
  v23 = _mm_loadu_si128(a1 + 3);
  v24 = _mm_loadu_si128(a1 + 4);
  v25 = _mm_loadu_si128(a1 + 5);
  v26 = _mm_loadu_si128(a1 + 6);
  v27 = _mm_loadu_si128(a1 + 7);
  v28 = _mm_loadu_si128(a1 + 8);
  v29 = _mm_loadu_si128(a1 + 9);
  v30 = _mm_loadu_si128(a1 + 10);
  v31 = _mm_loadu_si128(a1 + 11);
  v3 = a1[12].m128i_i64[0];
  v32 = _mm_loadu_si128(a1 + 12);
  v33[0] = (__int128)_mm_loadu_si128(a1 + 13);
  v33[1] = (__int128)_mm_loadu_si128(a1 + 14);
  if ( (!_bittest64(&v3, 0x3Eu) || !HIBYTE(v33[0])) && !v23.m128i_i64[1] )
  {
    if ( byte_C1907 != 8 )
      goto LABEL_30;
    v21 = a1[9].m128i_i64[0];
    if ( (v32.m128i_i8[7] & 0x40) != 0 )
      HIBYTE(v33[0]) = 0;
    v23.m128i_i64[1] = (__int64)&v21;
  }
  if ( (a1[12].m128i_i8[7] & 0x40) != 0 )
    a1[13].m128i_i8[15] = 0;
  a1[3].m128i_i64[1] = 0LL;
  v4 = *(_DWORD *)(a2 + 320);
  if ( v4 == 1 )
  {
    v5 = *(_QWORD *)(a2 + 304);
    if ( (int)v5 <= 17 )
    {
      v6 = (_QWORD *)*((_QWORD *)v22 + (int)v5);
      if ( (v32.m128i_i8[7] & 0x40) != 0 && *((_BYTE *)v33 + (int)v5 + 8) )
        goto LABEL_12;
      if ( byte_C1900[(int)v5] == 8 )
      {
        v6 = (_QWORD *)*v6;
LABEL_12:
        v7 = (__int64)v6 + *(_QWORD *)(a2 + 296);
        goto LABEL_17;
      }
    }
LABEL_30:
    exit();
  }
  if ( v4 != 2 )
    exit();
  v8 = 0LL;
  v9 = 0;
  v10 = *(char **)(a2 + 312);
  do
  {
    v11 = *v10++;
    v12 = (unsigned __int64)(v11 & 0x7F) << v9;
    v9 += 7;
    v8 |= v12;
  }
  while ( v11 < 0 );
  v7 = sub_88780(v10, (unsigned __int64)&v10[v8], (__int64)v22, 0LL);
LABEL_17:
  v13 = a2;
  v14 = byte_C1900;
  v15 = &a1[13].m128i_i8[8];
  v19 = a1;
  v16 = a1;
  a1[9].m128i_i64[0] = v7;
  v17 = &a1[14].m128i_i8[10];
  do
  {
    if ( *(_DWORD *)(v13 + 8) <= 5u )
      __asm { jmp     rax }
    ++v15;
    v13 += 16LL;
    v16 = (const __m128i *)((char *)v16 + 8);
    ++v14;
  }
  while ( v17 != v15 );
  result = v19[12].m128i_i64[0] & 0x7FFFFFFFFFFFFFFFLL;
  if ( *(_BYTE *)(a2 + 371) )
    result = v19[12].m128i_i64[0] | 0x8000000000000000LL;
  v19[12].m128i_i64[0] = result;
  return result;
}
// C1907: using guessed type char byte_C1907;

//----- (00000000000892F0) ----------------------------------------------------
void __fastcall sub_892F0(char *a1, unsigned __int64 a2, __int64 a3, _QWORD *a4)
{
  unsigned __int64 v7; // rcx
  __int64 v8; // rax
  char v9; // si
  char v10; // cl
  __int64 v11; // rax
  char v12; // si
  __int64 v13; // rax
  __int64 v14; // r9
  unsigned __int8 v15; // si
  int v16; // ecx
  char v17; // r8
  unsigned __int64 v18; // rdx
  __int64 v19; // r9
  __int64 *v20; // rax

  a4[36] = 0LL;
  while ( (unsigned __int64)a1 < a2 )
  {
    v7 = a4[41];
    if ( v7 >= *(_QWORD *)(a3 + 152) + (*(_QWORD *)(a3 + 192) >> 63) )
      break;
    v8 = (unsigned __int8)*a1;
    v9 = *a1 & 0xC0;
    switch ( v9 )
    {
      case 64:
        ++a1;
        a4[41] = v7 + a4[44] * (v8 & 0x3F);
        break;
      case -128:
        v12 = *a1++;
        v13 = v8 & 0x3F;
        v14 = 0LL;
        v15 = v12 & 0x3F;
        v16 = 0;
        do
        {
          v17 = *a1++;
          v18 = (unsigned __int64)(v17 & 0x7F) << v16;
          v16 += 7;
          v14 |= v18;
        }
        while ( v17 < 0 );
        v19 = a4[43] * v14;
        if ( v15 <= 0x11u )
        {
          v20 = &a4[2 * v13];
          *((_DWORD *)v20 + 2) = 1;
          *v20 = v19;
        }
        break;
      case -64:
        v10 = *a1;
        v11 = v8 & 0x3F;
        ++a1;
        if ( (v10 & 0x3Fu) <= 0x11 )
          LODWORD(a4[2 * v11 + 1]) = 0;
        break;
      default:
        if ( (unsigned __int8)v8 <= 0x2Fu )
          __asm { jmp     rax }
        exit();
    }
  }
}

//----- (0000000000089B47) ----------------------------------------------------
void sub_89B47()
{
  JUMPOUT(0x894F8LL);
}
// 89B57: control flows out of bounds to 894F8

//----- (0000000000089B60) ----------------------------------------------------
__int64 __fastcall sub_89B60(_QWORD *a1, char *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14)
{
  __int64 *v15; // rdx
  unsigned int *v17; // rax
  unsigned int *v18; // r13
  _BYTE *v19; // r14
  char *v20; // rbx
  char *v21; // rax
  unsigned __int8 v22; // di
  char v23; // si
  __int64 v24; // r8
  int v25; // ecx
  unsigned __int64 v26; // rdx
  unsigned int v27; // ecx
  __int64 v28; // r8
  char *v29; // r9
  char v30; // si
  unsigned __int64 v31; // rdx
  int v32; // ecx
  __int64 v33; // r8
  char v34; // si
  unsigned __int64 v35; // rdx
  char v36; // dl
  char *v37; // r15
  char *v38; // rbx
  __int64 *v39; // rcx
  char v40; // dl
  char v41; // al
  unsigned __int8 v42; // al
  __int64 v43; // rdx
  char *v44; // rdx
  char v45; // r8
  __int64 v46; // rdi
  int v47; // ecx
  char v48; // si
  unsigned __int64 v49; // rax
  char *v50; // r14
  __int64 result; // rax
  __int64 v52; // rdx
  __int64 v53; // rax
  __int64 v54; // rdi
  int v55; // ecx
  char v56; // si
  unsigned __int64 v57; // rdx
  char v58; // dl
  __int64 v59; // rax
  __int64 v60; // rax
  __int64 v61; // rdx
  __int64 v62; // rcx
  __int64 *v63; // [rsp+8h] [rbp-50h]
  __int64 v64[8]; // [rsp+18h] [rbp-40h] BYREF

  memset(a2, 0, 0x180uLL);
  a1[26] = 0LL;
  a1[20] = 0LL;
  v15 = (__int64 *)a1[19];
  if ( !v15 )
    return 5LL;
  v17 = sub_8D2D0(
          (unsigned int *)((char *)v15 + (a1[24] >> 63) - 1),
          a1 + 21,
          v15,
          0LL,
          a13,
          a14,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          a9,
          a10);
  v18 = v17;
  if ( !v17 )
  {
    v59 = a1[19];
    if ( *(_BYTE *)v59 == 72 && *(_QWORD *)(v59 + 1) == 0x50F0000000FC0C7LL )
    {
      v60 = a1[18];
      v61 = *(_QWORD *)(v60 + 160);
      *((_DWORD *)a2 + 80) = 1;
      *((_QWORD *)a2 + 38) = 7LL;
      *((_DWORD *)a2 + 2) = 1;
      *(_QWORD *)a2 = v60 + 144 - v61;
      *((_QWORD *)a2 + 37) = v61 - v60;
      *((_QWORD *)a2 + 2) = v60 + 136 - v61;
      *((_QWORD *)a2 + 16) = v60 + 40 - v61;
      *((_QWORD *)a2 + 4) = v60 + 152 - v61;
      *((_QWORD *)a2 + 18) = v60 + 48 - v61;
      *((_QWORD *)a2 + 6) = v60 + 128 - v61;
      *((_QWORD *)a2 + 20) = v60 + 56 - v61;
      *((_QWORD *)a2 + 8) = v60 + 112 - v61;
      *((_QWORD *)a2 + 22) = v60 + 64 - v61;
      *((_QWORD *)a2 + 10) = v60 + 104 - v61;
      *((_QWORD *)a2 + 24) = v60 + 72 - v61;
      *((_DWORD *)a2 + 6) = 1;
      *((_QWORD *)a2 + 26) = v60 + 80 - v61;
      *((_DWORD *)a2 + 10) = 1;
      *((_DWORD *)a2 + 14) = 1;
      *((_DWORD *)a2 + 18) = 1;
      *((_DWORD *)a2 + 22) = 1;
      *((_DWORD *)a2 + 26) = 1;
      *((_QWORD *)a2 + 12) = v60 + 120 - v61;
      *((_DWORD *)a2 + 34) = 1;
      *((_DWORD *)a2 + 38) = 1;
      *((_DWORD *)a2 + 42) = 1;
      *((_DWORD *)a2 + 46) = 1;
      *((_DWORD *)a2 + 50) = 1;
      *((_DWORD *)a2 + 54) = 1;
      *((_DWORD *)a2 + 58) = 1;
      *((_QWORD *)a2 + 28) = v60 + 88 - v61;
      v62 = v60 + 96 - v61;
      *((_DWORD *)a2 + 62) = 1;
      *((_QWORD *)a2 + 32) = v60 + 168 - v61;
      result = 0LL;
      *((_QWORD *)a2 + 30) = v62;
      *((_DWORD *)a2 + 66) = 1;
      *((_QWORD *)a2 + 45) = 16LL;
      a2[371] = 1;
      return result;
    }
    return 5LL;
  }
  *((_QWORD *)a2 + 41) = a1[23];
  v19 = (char *)v17 - (int)v17[1] + 4;
  v20 = v19 + 9;
  v21 = (char *)sub_231C0() + (_QWORD)(v19 + 9) + 1;
  if ( v19[9] == 101 && v19[10] == 104 )
  {
    v52 = *(_QWORD *)v21;
    v20 = v19 + 11;
    v21 += 8;
    *((_QWORD *)a2 + 47) = v52;
  }
  v22 = v19[8];
  v23 = *v21;
  if ( v22 > 3u )
  {
    if ( v23 != 8 || v21[1] )
      return 3LL;
    v23 = v21[2];
    v21 += 2;
  }
  v24 = 0LL;
  v25 = 0;
  while ( 1 )
  {
    ++v21;
    v26 = (unsigned __int64)(v23 & 0x7F) << v25;
    v25 += 7;
    v24 |= v26;
    if ( v23 >= 0 )
      break;
    v23 = *v21;
  }
  *((_QWORD *)a2 + 44) = v24;
  v27 = 0;
  v28 = 0LL;
  do
  {
    v29 = v21;
    v30 = *v21++;
    v31 = (unsigned __int64)(v30 & 0x7F) << v27;
    v27 += 7;
    v28 |= v31;
  }
  while ( v30 < 0 );
  if ( v27 <= 0x3F && (v30 & 0x40) != 0 )
    v28 |= -1LL << v27;
  *((_QWORD *)a2 + 43) = v28;
  v32 = 0;
  v33 = 0LL;
  if ( v22 == 1 )
  {
    v53 = (unsigned __int8)*v21;
    a2[369] = -1;
    *((_QWORD *)a2 + 45) = v53;
    v36 = *v20;
    v21 = v29 + 2;
    if ( *v20 != 122 )
      goto LABEL_16;
  }
  else
  {
    do
    {
      v34 = *v21++;
      v35 = (unsigned __int64)(v34 & 0x7F) << v32;
      v32 += 7;
      v33 |= v35;
    }
    while ( v34 < 0 );
    *((_QWORD *)a2 + 45) = v33;
    a2[369] = -1;
    v36 = *v20;
    if ( *v20 != 122 )
    {
LABEL_16:
      v37 = 0LL;
      if ( !v36 )
      {
        v37 = v21;
        goto LABEL_26;
      }
      goto LABEL_17;
    }
  }
  v54 = 0LL;
  v55 = 0;
  do
  {
    v56 = *v21++;
    v57 = (unsigned __int64)(v56 & 0x7F) << v55;
    v55 += 7;
    v54 |= v57;
  }
  while ( v56 < 0 );
  a2[370] = 1;
  v36 = v20[1];
  v37 = &v21[v54];
  if ( !v36 )
    goto LABEL_26;
  ++v20;
LABEL_17:
  v38 = v20 + 1;
  v39 = v64;
  do
  {
    while ( v36 == 76 )
    {
      v40 = *v21;
      ++v38;
      ++v21;
      a2[369] = v40;
      v36 = *(v38 - 1);
      if ( !v36 )
        goto LABEL_25;
    }
    switch ( v36 )
    {
      case 'R':
        v58 = *v21++;
        a2[368] = v58;
        break;
      case 'P':
        v63 = v39;
        v21 = (char *)sub_885D0((__int64)a1, *v21, (__int64)(v21 + 1), v39);
        v39 = v63;
        *((_QWORD *)a2 + 42) = v64[0];
        break;
      case 'S':
        a2[371] = 1;
        break;
      case 'B':
        break;
      default:
        goto LABEL_54;
    }
    v36 = *v38++;
  }
  while ( v36 );
LABEL_25:
  if ( !v37 )
  {
    v37 = v21;
LABEL_54:
    if ( !v37 )
      return 3LL;
  }
LABEL_26:
  sub_892F0(v37, (unsigned __int64)&v19[*(unsigned int *)v19 + 4], (__int64)a1, a2);
  v41 = a2[368];
  if ( v41 == -1 )
  {
    v43 = 2LL;
    goto LABEL_30;
  }
  v42 = v41 & 7;
  if ( v42 == 2 )
  {
    v43 = 3LL;
    goto LABEL_30;
  }
  if ( v42 <= 2u )
  {
    if ( !v42 )
      goto LABEL_47;
    goto LABEL_65;
  }
  v43 = 4LL;
  if ( v42 != 3 )
  {
    if ( v42 == 4 )
    {
LABEL_47:
      v43 = 6LL;
      goto LABEL_30;
    }
LABEL_65:
    exit();
  }
LABEL_30:
  v44 = (char *)&v18[v43];
  v45 = a2[369];
  if ( a2[370] )
  {
    v46 = 0LL;
    v47 = 0;
    do
    {
      v48 = *v44++;
      v49 = (unsigned __int64)(v48 & 0x7F) << v47;
      v47 += 7;
      v46 |= v49;
    }
    while ( v48 < 0 );
    v50 = &v44[v46];
    if ( v45 != -1 )
    {
      sub_885D0((__int64)a1, v45, (__int64)v44, v64);
      a1[20] = v64[0];
    }
  }
  else
  {
    v50 = v44;
    if ( v45 != -1 )
    {
      v50 = (char *)sub_885D0((__int64)a1, v45, (__int64)v44, v64);
      a1[20] = v64[0];
    }
  }
  sub_892F0(v50, (unsigned __int64)v18 + *v18 + 4, (__int64)a1, a2);
  return 0LL;
}

//----- (000000000008A1D0) ----------------------------------------------------
unsigned __int64 __fastcall sub_8A1D0(__m128i *a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, u32 *a13, u32 a14)
{
  unsigned __int64 result; // rax
  __int64 v16; // [rsp+8h] [rbp-1B0h] BYREF
  char v17[296]; // [rsp+10h] [rbp-1A8h] BYREF
  __int64 v18; // [rsp+138h] [rbp-80h]
  __int64 v19; // [rsp+140h] [rbp-78h]
  int v20; // [rsp+150h] [rbp-68h]
  __int64 retaddr; // [rsp+1B8h] [rbp+0h]

  memset(a1, 0, 0xF0uLL);
  a1[9].m128i_i64[1] = retaddr;
  a1[12].m128i_i64[0] = 0x4000000000000000LL;
  if ( (unsigned int)sub_89B60(a1, v17, a4, a5, a6, a7, a8, a9, a10, a11, a3, 0LL, a13, a14) )
    goto LABEL_9;
  if ( !byte_C1900[0] )
    memset(byte_C1900, 8, 17);
  if ( byte_C1907 != 8 )
LABEL_9:
    exit();
  v16 = a2;
  if ( (a1[12].m128i_i8[7] & 0x40) != 0 )
    a1[13].m128i_i8[15] = 0;
  v20 = 1;
  a1[3].m128i_i64[1] = (__int64)&v16;
  v19 = 7LL;
  v18 = 0LL;
  result = sub_88EB0(a1, (__int64)v17);
  a1[9].m128i_i64[1] = a3;
  return result;
}
// 0: using guessed type __int64 (*dword_0)(void);
// C1907: using guessed type char byte_C1907;

//----- (000000000008A350) ----------------------------------------------------
__int64 __fastcall sub_8A350(_QWORD *a1, __m128i *a2, __int64 *a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v14; // r13
  int v15; // eax
  int v16; // er15
  __int64 result; // rax
  __int64 *v18; // [rsp+8h] [rbp-1C0h]
  char v19[336]; // [rsp+10h] [rbp-1B8h] BYREF
  __int64 (__fastcall *v20)(__int64, _QWORD, _QWORD, _QWORD *, __m128i *); // [rsp+160h] [rbp-68h]
  __int64 v21; // [rsp+178h] [rbp-50h]

  v14 = 1LL;
  v18 = a3;
  while ( 1 )
  {
    v15 = sub_89B60(a2, v19, a7, a8, a9, a10, a11, a12, a13, a14, (__int64)a3, a4, a5, a6);
    v16 = 4 * (a1[3] == a2[9].m128i_i64[0] - ((unsigned __int64)a2[12].m128i_i64[0] >> 63));
    if ( v15 )
      return 2LL;
    if ( v20 )
      break;
LABEL_8:
    if ( v16 )
      goto LABEL_18;
    sub_88EB0(a2, (__int64)v19);
    a3 = (__int64 *)(16 * v21);
    if ( *(_DWORD *)&v19[16 * v21 + 8] == 6 )
    {
      a2[9].m128i_i64[1] = 0LL;
    }
    else
    {
      if ( (int)v21 > 17 )
        goto LABEL_18;
      a3 = (__int64 *)a2->m128i_i64[(int)v21];
      if ( (a2[12].m128i_i8[7] & 0x40) == 0 || !a2[13].m128i_i8[(int)v21 + 8] )
      {
        if ( byte_C1900[(int)v21] != 8 )
LABEL_18:
          exit();
        a3 = (__int64 *)*a3;
      }
      a2[9].m128i_i64[1] = (__int64)a3;
    }
    ++v14;
  }
  result = v20(1LL, v16 | 2u, *a1, a1, a2);
  if ( (_DWORD)result != 7 )
  {
    if ( (_DWORD)result != 8 )
      return 2LL;
    goto LABEL_8;
  }
  *v18 = v14;
  return result;
}
// 8A398: variable 'a11' is possibly undefined
// 8A398: variable 'a12' is possibly undefined
// 8A398: variable 'a4' is possibly undefined
// 8A398: variable 'a5' is possibly undefined
// 8A398: variable 'a6' is possibly undefined

//----- (000000000008A4A0) ----------------------------------------------------
__int64 __fastcall sub_8A4A0(_QWORD *a1, __m128i *a2, __int64 *a3, char *a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v14; // rbp
  __int64 v15; // r14
  unsigned int v16; // eax
  unsigned int v17; // er15
  __int64 v18; // rdx
  unsigned int v19; // eax
  unsigned int (__fastcall *v21)(__int64, __int64, __int64, _QWORD *, __m128i *, __int64); // [rsp+0h] [rbp-1C8h]
  __int64 *v22; // [rsp+8h] [rbp-1C0h]
  char v23[336]; // [rsp+10h] [rbp-1B8h] BYREF
  __int64 (__fastcall *v24)(__int64, __int64, _QWORD, _QWORD *, __m128i *); // [rsp+160h] [rbp-68h]
  __int64 v25; // [rsp+178h] [rbp-50h]

  v14 = 1LL;
  v15 = a1[3];
  v22 = a3;
  v21 = (unsigned int (__fastcall *)(__int64, __int64, __int64, _QWORD *, __m128i *, __int64))a1[2];
  while ( 1 )
  {
    v16 = sub_89B60(a2, v23, a7, a8, a9, a10, a11, a12, a13, a14, (__int64)a3, (__int64)a4, a5, a6);
    v17 = v16;
    if ( v16 && v16 != 5 )
      return 2;
    v18 = *a1;
    if ( v16 == 5 )
      break;
    if ( v21(1LL, 10LL, v18, a1, a2, v15) )
      return 2;
    if ( v24 )
    {
      v19 = v24(1LL, 10LL, *a1, a1, a2);
      v17 = v19;
      if ( v19 == 7 )
        goto LABEL_21;
      if ( v19 != 8 )
        return 2;
    }
    sub_88EB0(a2, (__int64)v23);
    a3 = (__int64 *)(16 * v25);
    if ( *(_DWORD *)&v23[16 * v25 + 8] == 6 )
    {
      a2[9].m128i_i64[1] = 0LL;
    }
    else
    {
      if ( (int)v25 > 17 )
        goto LABEL_22;
      a3 = (__int64 *)a2->m128i_i64[(int)v25];
      if ( (a2[12].m128i_i8[7] & 0x40) == 0 || !a2[13].m128i_i8[(int)v25 + 8] )
      {
        a4 = byte_C1900;
        if ( byte_C1900[(int)v25] != 8 )
LABEL_22:
          exit();
        a3 = (__int64 *)*a3;
      }
      a2[9].m128i_i64[1] = (__int64)a3;
    }
    ++v14;
  }
  if ( v21(1LL, 26LL, v18, a1, a2, v15) )
    return 2;
LABEL_21:
  *v22 = v14;
  return v17;
}
// 8A4ED: variable 'a11' is possibly undefined
// 8A4ED: variable 'a12' is possibly undefined
// 8A4ED: variable 'a4' is possibly undefined
// 8A4ED: variable 'a5' is possibly undefined
// 8A4ED: variable 'a6' is possibly undefined

//----- (000000000008A680) ----------------------------------------------------
__int64 __fastcall sub_8A680(__int64 a1, int a2, __int64 a3)
{
  __int64 result; // rax

  if ( a2 > 17 )
    goto LABEL_7;
  result = (unsigned __int8)byte_C1900[a2];
  if ( (*(_BYTE *)(a1 + 199) & 0x40) == 0 || !*(_BYTE *)(a1 + a2 + 216) )
  {
    if ( (_BYTE)result == 8 )
    {
      **(_QWORD **)(a1 + 8LL * a2) = a3;
      return result;
    }
LABEL_7:
    exit();
  }
  *(_QWORD *)(a1 + 8LL * a2) = a3;
  return result;
}

//----- (000000000008A6F0) ----------------------------------------------------
__int64 __fastcall sub_8A6F0(__int64 a1, _DWORD *a2)
{
  *a2 = (*(__int64 *)(a1 + 192) >> 63) & 1;
  return *(_QWORD *)(a1 + 152);
}

//----- (000000000008A710) ----------------------------------------------------
void __fastcall sub_8A710(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 152) = a2;
}

//----- (000000000008A720) ----------------------------------------------------
__int64 __fastcall sub_8A720(__int64 a1)
{
  return *(_QWORD *)(a1 + 160);
}

//----- (000000000008A730) ----------------------------------------------------
__int64 __fastcall sub_8A730(__int64 a1)
{
  return *(_QWORD *)(a1 + 184);
}

//----- (000000000008A770) ----------------------------------------------------
__int64 __fastcall sub_8A770(__int64 a1)
{
  return *(_QWORD *)(a1 + 176);
}

//----- (000000000008A780) ----------------------------------------------------
__int64 __fastcall sub_8A780(__int64 a1)
{
  return *(_QWORD *)(a1 + 168);
}

//----- (000000000008A8B0) ----------------------------------------------------
void sub_8A8B0()
{
  ;
}

//----- (000000000008A8C0) ----------------------------------------------------
__int64 __fastcall sub_8A8C0(_QWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, u32 *a13, u32 a14, char a15)
{
  __int64 v15; // rax
  _QWORD *v16; // rdx
  __int64 v17; // rcx
  u32 *v18; // r8
  u32 v19; // er9
  __m128i v20; // xmm1
  __m128i v21; // xmm2
  __m128i v22; // xmm3
  __m128i v23; // xmm4
  __m128i v24; // xmm5
  __m128i v25; // xmm6
  __m128i v26; // xmm7
  __m128i v27; // xmm0
  __m128i v28; // xmm1
  __m128i v29; // xmm2
  __m128i v30; // xmm3
  __m128i v31; // xmm4
  __m128i v32; // xmm5
  __m128i v33; // xmm6
  __int64 result; // rax
  int v35; // eax
  __int64 v36; // rcx
  u32 *v37; // r8
  u32 v38; // er9
  __m128i v39; // xmm7
  unsigned __int64 v40; // rdx
  __m128i v41; // xmm0
  __m128i v42; // xmm7
  __m128i v43; // xmm1
  __m128i v44; // xmm2
  __m128i v45; // xmm3
  __m128i v46; // xmm7
  __m128i v47; // xmm4
  __m128i v48; // xmm5
  __m128i v49; // xmm6
  __m128i v50; // xmm7
  __m128i v51; // xmm0
  __m128i v52; // xmm7
  __m128i v53; // xmm7
  __int64 v54; // rsi
  __int64 v55; // rdx
  __m128i v59; // [rsp+0h] [rbp-3A0h] BYREF
  __m128i v60; // [rsp+10h] [rbp-390h] BYREF
  __m128i v61; // [rsp+20h] [rbp-380h] BYREF
  __m128i v62; // [rsp+30h] [rbp-370h] BYREF
  __m128i v63; // [rsp+40h] [rbp-360h] BYREF
  __m128i v64; // [rsp+50h] [rbp-350h] BYREF
  __m128i v65; // [rsp+60h] [rbp-340h] BYREF
  __m128i v66; // [rsp+70h] [rbp-330h] BYREF
  __m128i v67; // [rsp+80h] [rbp-320h] BYREF
  __m128i v68; // [rsp+90h] [rbp-310h] BYREF
  __m128i v69; // [rsp+A0h] [rbp-300h] BYREF
  __m128i v70; // [rsp+B0h] [rbp-2F0h] BYREF
  __m128i v71; // [rsp+C0h] [rbp-2E0h] BYREF
  __m128i v72; // [rsp+D0h] [rbp-2D0h] BYREF
  __m128i v73; // [rsp+E0h] [rbp-2C0h] BYREF
  __m128i v74; // [rsp+F0h] [rbp-2B0h] BYREF
  __m128i v75; // [rsp+100h] [rbp-2A0h]
  __m128i v76; // [rsp+110h] [rbp-290h]
  __m128i v77; // [rsp+120h] [rbp-280h]
  __m128i v78; // [rsp+130h] [rbp-270h]
  __m128i v79; // [rsp+140h] [rbp-260h]
  __m128i v80; // [rsp+150h] [rbp-250h]
  __m128i v81; // [rsp+160h] [rbp-240h]
  __m128i v82; // [rsp+170h] [rbp-230h]
  __m128i v83; // [rsp+180h] [rbp-220h]
  __m128i v84; // [rsp+190h] [rbp-210h]
  __m128i v85; // [rsp+1A0h] [rbp-200h]
  __m128i v86; // [rsp+1B0h] [rbp-1F0h]
  __m128i v87; // [rsp+1C0h] [rbp-1E0h]
  __m128i v88; // [rsp+1D0h] [rbp-1D0h]
  __int64 v89[42]; // [rsp+1E0h] [rbp-1C0h] BYREF
  __int64 (__fastcall *v90)(__int64, __int64, _QWORD, _QWORD *, __m128i *); // [rsp+330h] [rbp-70h]
  __int64 v91; // [rsp+348h] [rbp-58h]
  __int64 v92; // [rsp+368h] [rbp-38h]
  __int64 v93; // [rsp+370h] [rbp-30h]
  __int64 retaddr; // [rsp+3A8h] [rbp+8h]

  v93 = a11;
  v92 = v15;
  sub_8A1D0(&v59, (__int64)&a15, retaddr, a2, a3, a4, a5, a6, a7, a8, a9, a12, a13, a14);
  v20 = _mm_loadu_si128(&v60);
  v21 = _mm_loadu_si128(&v61);
  v22 = _mm_loadu_si128(&v62);
  v23 = _mm_loadu_si128(&v63);
  v24 = _mm_loadu_si128(&v64);
  v74 = _mm_loadu_si128(&v59);
  v25 = _mm_loadu_si128(&v65);
  v26 = _mm_loadu_si128(&v66);
  v75 = v20;
  v27 = _mm_loadu_si128(&v67);
  v28 = _mm_loadu_si128(&v68);
  v76 = v21;
  v77 = v22;
  v29 = _mm_loadu_si128(&v69);
  v30 = _mm_loadu_si128(&v70);
  v78 = v23;
  v31 = _mm_loadu_si128(&v71);
  v79 = v24;
  v32 = _mm_loadu_si128(&v72);
  v80 = v25;
  v33 = _mm_loadu_si128(&v73);
  v81 = v26;
  v82 = v27;
  v83 = v28;
  v84 = v29;
  v85 = v30;
  v86 = v31;
  v87 = v32;
  v88 = v33;
  while ( 1 )
  {
    result = sub_89B60(
               &v74,
               (char *)v89,
               *(double *)v27.m128i_i64,
               *(double *)v28.m128i_i64,
               *(double *)v29.m128i_i64,
               *(double *)v30.m128i_i64,
               *(double *)v31.m128i_i64,
               *(double *)v32.m128i_i64,
               *(double *)v33.m128i_i64,
               *(double *)v26.m128i_i64,
               (__int64)v16,
               v17,
               v18,
               v19);
    if ( (_DWORD)result == 5 )
      return result;
    while ( 1 )
    {
      if ( (_DWORD)result )
        return 3LL;
      if ( v90 )
      {
        v35 = v90(1LL, 1LL, *a1, a1, &v74);
        if ( v35 == 6 )
        {
          v39 = _mm_loadu_si128(&v59);
          v40 = v86.m128i_i64[0];
          a1[2] = 0LL;
          v41 = _mm_loadu_si128(&v64);
          v74 = v39;
          v42 = _mm_loadu_si128(&v60);
          v43 = _mm_loadu_si128(&v65);
          v44 = _mm_loadu_si128(&v66);
          v45 = _mm_loadu_si128(&v67);
          v79 = v41;
          v75 = v42;
          v46 = _mm_loadu_si128(&v61);
          v47 = _mm_loadu_si128(&v68);
          v48 = _mm_loadu_si128(&v69);
          v49 = _mm_loadu_si128(&v70);
          a1[3] = v83.m128i_i64[0] - (v40 >> 63);
          v76 = v46;
          v50 = _mm_loadu_si128(&v62);
          v51 = _mm_loadu_si128(&v72);
          v80 = v43;
          v77 = v50;
          v52 = _mm_loadu_si128(&v63);
          v81 = v44;
          v78 = v52;
          v53 = _mm_loadu_si128(&v71);
          v82 = v45;
          v83 = v47;
          v84 = v48;
          v85 = v49;
          v86 = v53;
          v87 = v51;
          v88 = _mm_loadu_si128(&v73);
          result = sub_8A350(
                     a1,
                     &v74,
                     v89,
                     v36,
                     v37,
                     v38,
                     *(double *)v51.m128i_i64,
                     *(double *)v88.m128i_i64,
                     *(double *)v44.m128i_i64,
                     *(double *)v45.m128i_i64,
                     *(double *)v47.m128i_i64,
                     *(double *)v48.m128i_i64,
                     *(double *)v49.m128i_i64,
                     *(double *)v53.m128i_i64);
          if ( (_DWORD)result == 7 )
          {
            sub_88430((__int64)&v59, (__int64)&v74);
            v54 = v83.m128i_i64[1];
            sub_8A8B0();
            __asm { rdsspq  rax }
            if ( _RAX )
            {
              _RAX = v89[0];
              _RCX = 255LL;
              while ( _RAX > 0xFF )
              {
                __asm { incsspq rcx }
                _RAX -= 255LL;
              }
              __asm { incsspq rax }
            }
            *(__int64 *)((char *)&retaddr + v55) = v54;
            result = v92;
          }
          return result;
        }
        if ( v35 != 8 )
          return 3LL;
      }
      sub_88EB0(&v74, (__int64)v89);
      if ( LODWORD(v89[2 * v91 + 1]) != 6 )
        break;
      v83.m128i_i64[1] = 0LL;
      result = sub_89B60(
                 &v74,
                 (char *)v89,
                 *(double *)v27.m128i_i64,
                 *(double *)v28.m128i_i64,
                 *(double *)v29.m128i_i64,
                 *(double *)v30.m128i_i64,
                 *(double *)v31.m128i_i64,
                 *(double *)v32.m128i_i64,
                 *(double *)v33.m128i_i64,
                 *(double *)v26.m128i_i64,
                 16 * v91,
                 v17,
                 v18,
                 v19);
      if ( (_DWORD)result == 5 )
        return result;
    }
    if ( (int)v91 > 17 )
      goto LABEL_24;
    v16 = (_QWORD *)v74.m128i_i64[(int)v91];
    if ( (v86.m128i_i8[7] & 0x40) == 0 || !v87.m128i_i8[(int)v91 + 8] )
    {
      if ( byte_C1900[(int)v91] == 8 )
      {
        v16 = (_QWORD *)*v16;
        goto LABEL_15;
      }
LABEL_24:
      exit();
    }
LABEL_15:
    v83.m128i_i64[1] = (__int64)v16;
  }
}
// 8A8F8: variable 'v15' is possibly undefined
// 8A9F6: variable 'v31' is possibly undefined
// 8A9F6: variable 'v32' is possibly undefined
// 8A9F6: variable 'v16' is possibly undefined
// 8A9F6: variable 'v17' is possibly undefined
// 8A9F6: variable 'v18' is possibly undefined
// 8A9F6: variable 'v19' is possibly undefined
// 8ABEB: variable 'v36' is possibly undefined
// 8ABEB: variable 'v37' is possibly undefined
// 8ABEB: variable 'v38' is possibly undefined
// 8AC4F: variable 'v55' is possibly undefined

//----- (000000000008AC80) ----------------------------------------------------
__int64 __fastcall sub_8AC80(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, char a15)
{
  __int64 v15; // rax
  __m128i v17; // xmm0
  __m128i v18; // xmm1
  __m128i v19; // xmm2
  __m128i v20; // xmm3
  __m128i v21; // xmm4
  __m128i v22; // xmm5
  __m128i v23; // xmm6
  __m128i v24; // xmm7
  __m128i v25; // xmm0
  __m128i v26; // xmm1
  __m128i v27; // xmm2
  __m128i v28; // xmm3
  __m128i v29; // xmm4
  __m128i v30; // xmm5
  __m128i v31; // xmm6
  char *v32; // rcx
  u32 *v33; // r8
  u32 v34; // er9
  __int64 result; // rax
  __int64 v36; // rsi
  __int64 v37; // rdx
  unsigned __int64 v41; // [rsp+0h] [rbp-228h] BYREF
  __m128i v42; // [rsp+8h] [rbp-220h] BYREF
  __m128i v43; // [rsp+18h] [rbp-210h] BYREF
  __m128i v44; // [rsp+28h] [rbp-200h] BYREF
  __m128i v45; // [rsp+38h] [rbp-1F0h] BYREF
  __m128i v46; // [rsp+48h] [rbp-1E0h] BYREF
  __m128i v47; // [rsp+58h] [rbp-1D0h] BYREF
  __m128i v48; // [rsp+68h] [rbp-1C0h] BYREF
  __m128i v49; // [rsp+78h] [rbp-1B0h] BYREF
  __m128i v50; // [rsp+88h] [rbp-1A0h] BYREF
  __m128i v51; // [rsp+98h] [rbp-190h] BYREF
  __m128i v52; // [rsp+A8h] [rbp-180h] BYREF
  __m128i v53; // [rsp+B8h] [rbp-170h] BYREF
  __m128i v54; // [rsp+C8h] [rbp-160h] BYREF
  __m128i v55; // [rsp+D8h] [rbp-150h] BYREF
  __m128i v56; // [rsp+E8h] [rbp-140h] BYREF
  __m128i v57[9]; // [rsp+F8h] [rbp-130h] BYREF
  __m128i v58; // [rsp+188h] [rbp-A0h]
  __m128i v59; // [rsp+198h] [rbp-90h]
  __m128i v60; // [rsp+1A8h] [rbp-80h]
  __m128i v61; // [rsp+1B8h] [rbp-70h]
  __m128i v62; // [rsp+1C8h] [rbp-60h]
  __m128i v63; // [rsp+1D8h] [rbp-50h]
  __int64 v64; // [rsp+1F0h] [rbp-38h]
  __int64 v65; // [rsp+1F8h] [rbp-30h]
  __int64 retaddr; // [rsp+230h] [rbp+8h]

  v65 = a3;
  v64 = v15;
  sub_8A1D0(&v42, (__int64)&a15, retaddr, a7, a8, a9, a10, a11, a12, a13, a14, a4, a5, a6);
  v17 = _mm_loadu_si128(&v42);
  v18 = _mm_loadu_si128(&v43);
  v19 = _mm_loadu_si128(&v44);
  v20 = _mm_loadu_si128(&v45);
  a1[2] = a2;
  v21 = _mm_loadu_si128(&v46);
  v22 = _mm_loadu_si128(&v47);
  a1[3] = a3;
  v23 = _mm_loadu_si128(&v48);
  v24 = _mm_loadu_si128(&v49);
  v57[0] = v17;
  v25 = _mm_loadu_si128(&v50);
  v57[1] = v18;
  v26 = _mm_loadu_si128(&v51);
  v57[2] = v19;
  v27 = _mm_loadu_si128(&v52);
  v57[3] = v20;
  v28 = _mm_loadu_si128(&v53);
  v57[4] = v21;
  v29 = _mm_loadu_si128(&v54);
  v57[5] = v22;
  v30 = _mm_loadu_si128(&v55);
  v57[6] = v23;
  v31 = _mm_loadu_si128(&v56);
  v57[7] = v24;
  v57[8] = v25;
  v58 = v26;
  v59 = v27;
  v60 = v28;
  v61 = v29;
  v62 = v30;
  v63 = v31;
  result = sub_8A4A0(
             a1,
             v57,
             (__int64 *)&v41,
             v32,
             v33,
             v34,
             *(double *)v25.m128i_i64,
             *(double *)v26.m128i_i64,
             *(double *)v27.m128i_i64,
             *(double *)v28.m128i_i64,
             *(double *)v29.m128i_i64,
             *(double *)v30.m128i_i64,
             *(double *)v31.m128i_i64,
             *(double *)v24.m128i_i64);
  if ( (_DWORD)result == 7 )
  {
    sub_88430((__int64)&v42, (__int64)v57);
    v36 = v58.m128i_i64[1];
    sub_8A8B0();
    __asm { rdsspq  rax }
    if ( _RAX )
    {
      _RAX = v41;
      if ( v41 > 0xFF )
      {
        _RCX = 255LL;
        do
        {
          __asm { incsspq rcx }
          _RAX -= 255LL;
        }
        while ( _RAX > 0xFF );
      }
      __asm { incsspq rax }
    }
    *(__int64 *)((char *)&retaddr + v37) = v36;
    result = v64;
  }
  return result;
}
// 8ACA9: variable 'v15' is possibly undefined
// 8ADAD: variable 'v32' is possibly undefined
// 8ADAD: variable 'v33' is possibly undefined
// 8ADAD: variable 'v34' is possibly undefined
// 8AE29: variable 'v37' is possibly undefined

//----- (000000000008AE60) ----------------------------------------------------
void __fastcall __spoils<rdx,rcx,r8,r9,r10,r11,xmm0,xmm4,xmm5> sub_8AE60(_QWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, u32 *a13, u32 a14, char a15)
{
  char *v15; // rcx
  u32 *v16; // r8
  u32 v17; // er9
  __m128i v18; // xmm1
  __m128i v19; // xmm2
  __m128i v20; // xmm3
  __m128i v21; // xmm4
  __m128i v22; // xmm5
  __m128i v23; // xmm6
  __m128i v24; // xmm7
  __m128i v25; // xmm0
  __m128i v26; // xmm1
  __m128i v27; // xmm2
  __m128i v28; // xmm3
  __m128i v29; // xmm4
  bool v30; // zf
  __m128i v31; // xmm5
  __m128i v32; // xmm6
  int v33; // eax
  __int64 v34; // rsi
  __int64 v35; // rdx
  unsigned __int64 v39; // [rsp+0h] [rbp-228h] BYREF
  __m128i v40; // [rsp+8h] [rbp-220h] BYREF
  __m128i v41; // [rsp+18h] [rbp-210h] BYREF
  __m128i v42; // [rsp+28h] [rbp-200h] BYREF
  __m128i v43; // [rsp+38h] [rbp-1F0h] BYREF
  __m128i v44; // [rsp+48h] [rbp-1E0h] BYREF
  __m128i v45; // [rsp+58h] [rbp-1D0h] BYREF
  __m128i v46; // [rsp+68h] [rbp-1C0h] BYREF
  __m128i v47; // [rsp+78h] [rbp-1B0h] BYREF
  __m128i v48; // [rsp+88h] [rbp-1A0h] BYREF
  __m128i v49; // [rsp+98h] [rbp-190h] BYREF
  __m128i v50; // [rsp+A8h] [rbp-180h] BYREF
  __m128i v51; // [rsp+B8h] [rbp-170h] BYREF
  __m128i v52; // [rsp+C8h] [rbp-160h] BYREF
  __m128i v53; // [rsp+D8h] [rbp-150h] BYREF
  __m128i v54; // [rsp+E8h] [rbp-140h] BYREF
  __m128i v55[9]; // [rsp+F8h] [rbp-130h] BYREF
  __m128i v56; // [rsp+188h] [rbp-A0h]
  __m128i v57; // [rsp+198h] [rbp-90h]
  __m128i v58; // [rsp+1A8h] [rbp-80h]
  __m128i v59; // [rsp+1B8h] [rbp-70h]
  __m128i v60; // [rsp+1C8h] [rbp-60h]
  __m128i v61; // [rsp+1D8h] [rbp-50h]
  __int64 v62; // [rsp+1F8h] [rbp-30h]
  __int64 retaddr; // [rsp+230h] [rbp+8h]

  v62 = a11;
  sub_8A1D0(&v40, (__int64)&a15, retaddr, a2, a3, a4, a5, a6, a7, a8, a9, a12, a13, a14);
  v18 = _mm_loadu_si128(&v41);
  v19 = _mm_loadu_si128(&v42);
  v20 = _mm_loadu_si128(&v43);
  v21 = _mm_loadu_si128(&v44);
  v22 = _mm_loadu_si128(&v45);
  v55[0] = _mm_loadu_si128(&v40);
  v23 = _mm_loadu_si128(&v46);
  v24 = _mm_loadu_si128(&v47);
  v55[1] = v18;
  v25 = _mm_loadu_si128(&v48);
  v26 = _mm_loadu_si128(&v49);
  v55[2] = v19;
  v55[3] = v20;
  v27 = _mm_loadu_si128(&v50);
  v28 = _mm_loadu_si128(&v51);
  v55[4] = v21;
  v29 = _mm_loadu_si128(&v52);
  v30 = a1[2] == 0LL;
  v55[5] = v22;
  v31 = _mm_loadu_si128(&v53);
  v55[6] = v23;
  v32 = _mm_loadu_si128(&v54);
  v55[7] = v24;
  v55[8] = v25;
  v56 = v26;
  v57 = v27;
  v58 = v28;
  v59 = v29;
  v60 = v31;
  v61 = v32;
  if ( v30 )
    v33 = sub_8A350(
            a1,
            v55,
            (__int64 *)&v39,
            (__int64)v15,
            v16,
            v17,
            *(double *)v25.m128i_i64,
            *(double *)v26.m128i_i64,
            *(double *)v27.m128i_i64,
            *(double *)v28.m128i_i64,
            *(double *)v29.m128i_i64,
            *(double *)v31.m128i_i64,
            *(double *)v32.m128i_i64,
            *(double *)v24.m128i_i64);
  else
    v33 = sub_8A4A0(
            a1,
            v55,
            (__int64 *)&v39,
            v15,
            v16,
            v17,
            *(double *)v25.m128i_i64,
            *(double *)v26.m128i_i64,
            *(double *)v27.m128i_i64,
            *(double *)v28.m128i_i64,
            *(double *)v29.m128i_i64,
            *(double *)v31.m128i_i64,
            *(double *)v32.m128i_i64,
            *(double *)v24.m128i_i64);
  if ( v33 != 7 )
    exit();
  sub_88430((__int64)&v40, (__int64)v55);
  v34 = v56.m128i_i64[1];
  sub_8A8B0();
  __asm { rdsspq  rax }
  if ( _RAX )
  {
    _RAX = v39;
    if ( v39 > 0xFF )
    {
      _RCX = 255LL;
      do
      {
        __asm { incsspq rcx }
        _RAX -= 255LL;
      }
      while ( _RAX > 0xFF );
    }
    __asm { incsspq rax }
  }
  *(__int64 *)((char *)&retaddr + v35) = v34;
}
// 8AF89: variable 'v15' is possibly undefined
// 8AF89: variable 'v16' is possibly undefined
// 8AF89: variable 'v17' is possibly undefined
// 8AFFB: variable 'v35' is possibly undefined

//----- (000000000008B040) ----------------------------------------------------
__int64 __fastcall sub_8B040(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, char a15)
{
  __int64 v15; // rax
  u32 *v18; // r8
  u32 v19; // er9
  double v20; // xmm4_8
  double v21; // xmm5_8
  __m128i *v22; // rdi
  __m128i *v23; // rsi
  __int64 i; // rcx
  __int64 v25; // rsi
  __int64 v26; // rdx
  char v30; // [rsp-8h] [rbp-230h]
  unsigned __int64 v31; // [rsp+0h] [rbp-228h] BYREF
  __m128i v32[15]; // [rsp+8h] [rbp-220h] BYREF
  __m128i v33[9]; // [rsp+F8h] [rbp-130h] BYREF
  __int64 v34; // [rsp+190h] [rbp-98h]
  __int64 v35; // [rsp+1F0h] [rbp-38h]
  __int64 v36; // [rsp+1F8h] [rbp-30h]
  __int64 retaddr; // [rsp+230h] [rbp+8h]

  v36 = a3;
  v35 = v15;
  if ( !a1[2] )
    return sub_8A8C0(a1, a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6, v30);
  sub_8A1D0(v32, (__int64)&a15, retaddr, a7, a8, a9, a10, a11, a12, a13, a14, a4, a5, a6);
  v22 = v33;
  v23 = v32;
  for ( i = 60LL; i; --i )
  {
    v22->m128i_i32[0] = v23->m128i_i32[0];
    v23 = (__m128i *)((char *)v23 + 4);
    v22 = (__m128i *)((char *)v22 + 4);
  }
  if ( (unsigned int)sub_8A4A0(a1, v33, (__int64 *)&v31, 0LL, v18, v19, a7, a8, a9, a10, v20, v21, a13, a14) != 7 )
    exit();
  sub_88430((__int64)v32, (__int64)v33);
  v25 = v34;
  sub_8A8B0();
  __asm { rdsspq  rax }
  if ( _RAX )
  {
    _RAX = v31;
    if ( v31 > 0xFF )
    {
      _RCX = 255LL;
      do
      {
        __asm { incsspq rcx }
        _RAX -= 255LL;
      }
      while ( _RAX > 0xFF );
    }
    __asm { incsspq rax }
  }
  *(__int64 *)((char *)&retaddr + v26) = v25;
  return v35;
}
// 8B055: variable 'v15' is possibly undefined
// 8B064: variable 'v30' is possibly undefined
// 8B0BB: variable 'v18' is possibly undefined
// 8B0BB: variable 'v19' is possibly undefined
// 8B0BB: variable 'v20' is possibly undefined
// 8B0BB: variable 'v21' is possibly undefined
// 8B125: variable 'v26' is possibly undefined

//----- (000000000008B190) ----------------------------------------------------
__int64 __fastcall sub_8B190(unsigned int (__fastcall *a1)(__m128i *, __int64), __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14, char a15)
{
  _QWORD *v15; // rdx
  char *v16; // rcx
  u32 *v17; // r8
  u32 v18; // er9
  double v19; // xmm4_8
  double v20; // xmm5_8
  unsigned int v21; // eax
  unsigned int v22; // er15
  __m128i v24; // [rsp+0h] [rbp-2A0h] BYREF
  _QWORD *v25; // [rsp+98h] [rbp-208h]
  char v26; // [rsp+C7h] [rbp-1D9h]
  char v27[24]; // [rsp+D8h] [rbp-1C8h]
  char v28[360]; // [rsp+F0h] [rbp-1B0h] BYREF
  __int64 v29; // [rsp+258h] [rbp-48h]
  __int64 retaddr; // [rsp+2A8h] [rbp+8h]

  sub_8A1D0(&v24, (__int64)&a15, retaddr, a3, a4, a5, a6, a7, a8, a9, a10, a12, a13, a14);
  while ( 1 )
  {
    v21 = sub_89B60(&v24, v28, a3, a4, a5, a6, v19, v20, a9, a10, (__int64)v15, (__int64)v16, v17, v18);
    v22 = v21;
    if ( v21 )
    {
      if ( v21 != 5 )
        return 3;
    }
    if ( a1(&v24, a2) )
      return 3;
    if ( v22 == 5 )
      return v22;
    sub_88EB0(&v24, (__int64)v28);
    v15 = (_QWORD *)(16 * v29);
    if ( *(_DWORD *)&v28[16 * v29 + 8] == 6 )
    {
      v25 = 0LL;
    }
    else
    {
      if ( (int)v29 > 17 )
        goto LABEL_16;
      v15 = (_QWORD *)v24.m128i_i64[(int)v29];
      if ( (v26 & 0x40) == 0 || !v27[(int)v29] )
      {
        v16 = byte_C1900;
        if ( byte_C1900[(int)v29] != 8 )
LABEL_16:
          exit();
        v15 = (_QWORD *)*v15;
      }
      v25 = v15;
    }
  }
}
// 8B1D6: variable 'v19' is possibly undefined
// 8B1D6: variable 'v20' is possibly undefined
// 8B1D6: variable 'v15' is possibly undefined
// 8B1D6: variable 'v16' is possibly undefined
// 8B1D6: variable 'v17' is possibly undefined
// 8B1D6: variable 'v18' is possibly undefined

//----- (000000000008B2A0) ----------------------------------------------------
__int64 __fastcall sub_8B2A0(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // rcx
  __int64 result; // rax

  v3 = *(_QWORD *)(a3 + 8);
  result = 1LL;
  if ( *(_QWORD *)(a2 + 8) <= v3 )
    result = (unsigned int)-(*(_QWORD *)(a2 + 8) < v3);
  return result;
}

//----- (000000000008B2C0) ----------------------------------------------------
void __fastcall sub_8B2C0(__int64 a1, __int64 (__fastcall *a2)(__int64, __int64, __int64), __int64 a3, int a4, int a5)
{
  __int64 v5; // r9
  int v8; // ebx
  int v9; // eax
  __int64 v10; // r8
  int v11; // ebp
  __int64 *v12; // rbx
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 *v15; // r14
  __int64 *v16; // [rsp+10h] [rbp-48h]
  int v17; // [rsp+1Ch] [rbp-3Ch]

  v5 = a4;
  v8 = 2 * a4 + 1;
  if ( v8 < a5 )
  {
    while ( 1 )
    {
      v11 = v8 + 1;
      v14 = 8LL * v8;
      v15 = (__int64 *)(a3 + v14);
      v10 = *(_QWORD *)(a3 + v14);
      if ( v8 + 1 < a5 )
      {
        v17 = v5;
        v16 = (__int64 *)(a3 + v14 + 8);
        v9 = a2(a1, v10, *v16);
        v5 = v17;
        if ( v9 < 0 )
        {
          v10 = *v16;
          v15 = v16;
        }
        else
        {
          v10 = *v15;
          v11 = v8;
        }
      }
      else
      {
        v11 = v8;
      }
      v12 = (__int64 *)(a3 + 8 * v5);
      if ( (int)a2(a1, *v12, v10) >= 0 )
        break;
      v13 = *v12;
      *v12 = *v15;
      v8 = 2 * v11 + 1;
      *v15 = v13;
      if ( a5 <= v8 )
        break;
      v5 = v11;
    }
  }
}

//----- (000000000008B390) ----------------------------------------------------
void __fastcall sub_8B390(__int64 a1, __int64 (__fastcall *a2)(__int64, __int64, __int64), __int64 a3)
{
  __int64 v3; // r14
  int v5; // ebx
  __int64 v7; // rbx
  __int64 v8; // rax
  int v9; // er8
  unsigned __int64 v10; // [rsp+8h] [rbp-40h]

  v3 = a3 + 16;
  v10 = *(_QWORD *)(a3 + 8);
  v5 = (v10 >> 1) - 1;
  if ( v5 >= 0 )
  {
    do
      sub_8B2C0(a1, a2, v3, v5, v10);
    while ( v5-- != 0 );
  }
  v7 = (int)v10 - 1;
  if ( (int)v10 - 1 > 0 )
  {
    do
    {
      v8 = *(_QWORD *)(a3 + 16);
      v9 = v7;
      *(_QWORD *)(a3 + 16) = *(_QWORD *)(a3 + 8 * v7 + 16);
      *(_QWORD *)(a3 + 8 * v7-- + 16) = v8;
      sub_8B2C0(a1, a2, v3, 0, v9);
    }
    while ( (int)v7 > 0 );
  }
}

//----- (000000000008B440) ----------------------------------------------------
_QWORD *__fastcall sub_8B440(char a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  __int64 *v4; // rax
  __int64 v5; // rdx
  _QWORD *result; // rax

  if ( a1 != 80 )
  {
    if ( (a1 & 0xFu) <= 0xC )
      __asm { jmp     rax }
    exit();
  }
  v4 = (__int64 *)((a3 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  v5 = *v4;
  result = v4 + 1;
  *a4 = v5;
  return result;
}

//----- (000000000008B590) ----------------------------------------------------
__int64 __fastcall sub_8B590(_BYTE *a1)
{
  __int64 (__fastcall *v1)(); // rax
  unsigned __int8 v2; // cl
  unsigned __int8 *v3; // rax
  unsigned int v4; // er8
  unsigned __int8 *v6; // rdx
  char *v7; // rbx
  char v8; // dl
  __int64 v9[4]; // [rsp+8h] [rbp-20h] BYREF

  v1 = sub_231C0();
  v2 = a1[8];
  v3 = (unsigned __int8 *)v1 + (_QWORD)(a1 + 9) + 1;
  if ( v2 > 3u )
  {
    v4 = 255;
    if ( *v3 != 8 || v3[1] )
      return v4;
    v3 += 2;
  }
  if ( a1[9] != 122 )
    return 0;
  do
    ++v3;
  while ( (*(v3 - 1) & 0x80u) != 0 );
  do
    v6 = v3++;
  while ( (*(v3 - 1) & 0x80u) != 0 );
  if ( v2 == 1 )
  {
    v3 = v6 + 2;
  }
  else
  {
    do
      ++v3;
    while ( (*(v3 - 1) & 0x80u) != 0 );
  }
  v7 = a1 + 10;
  do
    ++v3;
  while ( (*(v3 - 1) & 0x80u) != 0 );
  v8 = a1[10];
  if ( v8 != 82 )
  {
    while ( 1 )
    {
      while ( v8 == 80 )
      {
        ++v7;
        v3 = (unsigned __int8 *)sub_8B440(*v3 & 0x7F, 0LL, (__int64)(v3 + 1), v9);
        v8 = *v7;
        if ( *v7 == 82 )
          return *v3;
      }
      if ( v8 != 76 && v8 != 66 )
        break;
      v8 = *++v7;
      ++v3;
      if ( v8 == 82 )
        return *v3;
    }
    return 0;
  }
  return *v3;
}

//----- (000000000008B6C0) ----------------------------------------------------
__int64 __fastcall sub_8B6C0(__int64 a1, unsigned int *a2)
{
  unsigned int *v2; // rbx
  __int64 v3; // r14
  int v4; // er15
  char *v5; // rcx
  __int64 v6; // rdx
  __int64 v7; // rax
  unsigned __int8 v8; // bp
  char *v9; // r13
  int v10; // eax
  unsigned __int8 v11; // al
  unsigned __int16 v12; // ax
  unsigned __int8 v13; // al
  __int64 v15; // [rsp+8h] [rbp-50h]
  unsigned __int64 v16[8]; // [rsp+18h] [rbp-40h] BYREF

  if ( !*a2 )
    return 0LL;
  v2 = a2;
  v3 = 0LL;
  LOBYTE(v4) = 0;
  v15 = 0LL;
  v5 = 0LL;
  while ( 1 )
  {
    v7 = (int)v2[1];
    if ( (_DWORD)v7 )
      break;
LABEL_9:
    v2 = (unsigned int *)((char *)v2 + *v2 + 4);
    if ( !*v2 )
      return v15;
  }
  v8 = v4;
  v9 = (char *)v2 - v7 + 4;
  if ( v9 == v5 )
  {
LABEL_21:
    sub_8B440(v4, v3, (__int64)(v2 + 2), v16);
    if ( v8 == 0xFF )
    {
      v6 = 0LL;
    }
    else
    {
      v13 = v8 & 7;
      if ( (v8 & 7) == 2 )
      {
        v6 = 0xFFFFLL;
      }
      else
      {
        if ( v13 <= 2u )
        {
          if ( v13 )
            goto LABEL_38;
        }
        else
        {
          v6 = 0xFFFFFFFFLL;
          if ( v13 == 3 )
            goto LABEL_5;
          if ( v13 != 4 )
            goto LABEL_38;
        }
        v6 = -1LL;
      }
    }
LABEL_5:
    v5 = v9;
    if ( (v6 & v16[0]) != 0 )
    {
      ++v15;
      if ( *(_QWORD *)a1 > v16[0] )
        *(_QWORD *)a1 = v16[0];
      v5 = v9;
    }
    goto LABEL_9;
  }
  v10 = sub_8B590((_BYTE *)v2 - v7 + 4);
  v4 = v10;
  if ( v10 != 255 )
  {
    v8 = v10;
    if ( (_BYTE)v10 != 0xFF )
    {
      v11 = v10 & 0x70;
      if ( v11 == 32 )
      {
        v3 = *(_QWORD *)(a1 + 8);
LABEL_18:
        v12 = *(_WORD *)(a1 + 32);
        if ( (v12 & 0x7F8) == 2040 )
        {
          *(_WORD *)(a1 + 32) = (8 * v8) | v12 & 0xF807;
        }
        else if ( (unsigned __int8)(v12 >> 3) != v4 )
        {
          *(_BYTE *)(a1 + 32) |= 4u;
        }
        goto LABEL_21;
      }
      if ( v11 <= 0x20u )
      {
        if ( (v4 & 0x60) != 0 )
LABEL_38:
          exit();
      }
      else
      {
        if ( v11 == 48 )
        {
          v3 = *(_QWORD *)(a1 + 16);
          goto LABEL_18;
        }
        if ( v11 != 80 )
          goto LABEL_38;
      }
    }
    v3 = 0LL;
    goto LABEL_18;
  }
  return -1LL;
}

//----- (000000000008B8B0) ----------------------------------------------------
__int64 __fastcall sub_8B8B0(__int64 a1, __int64 a2, __int64 a3)
{
  __int16 v4; // ax
  unsigned __int8 v5; // dl
  __int64 v6; // r12
  __int64 result; // rax
  unsigned __int64 v8; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v9[4]; // [rsp+8h] [rbp-20h] BYREF

  v4 = *(_WORD *)(a1 + 32) >> 3;
  if ( (_BYTE)v4 == 0xFF )
    goto LABEL_10;
  v5 = v4 & 0x70;
  if ( (v4 & 0x70) != 32 )
  {
    if ( v5 > 0x20u )
    {
      if ( v5 == 48 )
      {
        v6 = *(_QWORD *)(a1 + 16);
        goto LABEL_6;
      }
      if ( v5 == 80 )
        goto LABEL_10;
LABEL_14:
      exit();
    }
    if ( (v4 & 0x60) != 0 )
      goto LABEL_14;
LABEL_10:
    v6 = 0LL;
    goto LABEL_6;
  }
  v6 = *(_QWORD *)(a1 + 8);
LABEL_6:
  sub_8B440(v4, v6, a2 + 8, &v8);
  sub_8B440(*(_WORD *)(a1 + 32) >> 3, v6, a3 + 8, v9);
  result = 1LL;
  if ( v8 <= v9[0] )
    result = (unsigned int)-(v8 < v9[0]);
  return result;
}

//----- (000000000008B970) ----------------------------------------------------
__int64 __fastcall sub_8B970(__int64 a1, __int64 a2, __int64 a3)
{
  char v4; // al
  __int64 v5; // rdx
  unsigned __int8 v6; // cl
  __int64 v7; // rsi
  char v8; // al
  unsigned __int8 v9; // cl
  __int64 v10; // rsi
  __int64 result; // rax
  unsigned __int64 v12; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v13[4]; // [rsp+8h] [rbp-20h] BYREF

  v4 = sub_8B590((_BYTE *)(a2 + 4 - *(int *)(a2 + 4)));
  v5 = a2 + 8;
  if ( v4 == -1 )
  {
LABEL_17:
    v7 = 0LL;
    goto LABEL_6;
  }
  v6 = v4 & 0x70;
  if ( (v4 & 0x70) != 32 )
  {
    if ( v6 <= 0x20u )
    {
      if ( (v4 & 0x60) != 0 )
        goto LABEL_24;
    }
    else
    {
      if ( v6 == 48 )
      {
        v7 = *(_QWORD *)(a1 + 16);
        goto LABEL_6;
      }
      if ( v6 != 80 )
        goto LABEL_24;
    }
    goto LABEL_17;
  }
  v7 = *(_QWORD *)(a1 + 8);
LABEL_6:
  sub_8B440(v4, v7, v5, &v12);
  v8 = sub_8B590((_BYTE *)(a3 + 4 - *(int *)(a3 + 4)));
  if ( v8 == -1 )
    goto LABEL_15;
  v9 = v8 & 0x70;
  if ( (v8 & 0x70) != 32 )
  {
    if ( v9 > 0x20u )
    {
      if ( v9 == 48 )
      {
        v10 = *(_QWORD *)(a1 + 16);
        goto LABEL_11;
      }
      if ( v9 == 80 )
        goto LABEL_15;
LABEL_24:
      exit();
    }
    if ( (v8 & 0x60) != 0 )
      goto LABEL_24;
LABEL_15:
    v10 = 0LL;
    goto LABEL_11;
  }
  v10 = *(_QWORD *)(a1 + 8);
LABEL_11:
  sub_8B440(v8, v10, a3 + 8, v13);
  result = 1LL;
  if ( v12 <= v13[0] )
    result = (unsigned int)-(v12 < v13[0]);
  return result;
}

//----- (000000000008BAA0) ----------------------------------------------------
__int16 __fastcall sub_8BAA0(__int64 a1, __int64 *a2, unsigned int *a3)
{
  int v4; // eax
  int v5; // ebp
  unsigned __int8 v6; // dl
  __int64 v7; // r13
  unsigned int *v8; // r15
  __int64 v9; // rax
  int v10; // eax
  char v11; // r10
  unsigned __int8 v12; // al
  __int64 v13; // rax
  __int64 v14; // rdx
  char v15; // r10
  char v16; // dl
  bool v17; // cc
  __int64 v18; // rax
  unsigned int *v20; // [rsp+8h] [rbp-50h]
  char v21; // [rsp+8h] [rbp-50h]
  __int64 v22[8]; // [rsp+18h] [rbp-40h] BYREF

  LOWORD(v4) = *(_WORD *)(a1 + 32) >> 3;
  if ( (_BYTE)v4 == 0xFF )
  {
    v7 = 0LL;
    v5 = 255;
  }
  else
  {
    v5 = (unsigned __int8)v4;
    v6 = v4 & 0x70;
    if ( (v4 & 0x70) != 32 )
    {
      if ( v6 <= 0x20u )
      {
        if ( (v4 & 0x60) == 0 )
        {
LABEL_38:
          v7 = 0LL;
          goto LABEL_6;
        }
      }
      else
      {
        if ( v6 == 48 )
        {
          v7 = *(_QWORD *)(a1 + 16);
          goto LABEL_6;
        }
        if ( v6 == 80 )
          goto LABEL_38;
      }
LABEL_47:
      exit();
    }
    v7 = *(_QWORD *)(a1 + 8);
  }
LABEL_6:
  v8 = 0LL;
  while ( *a3 )
  {
    v9 = (int)a3[1];
    if ( !(_DWORD)v9 )
      goto LABEL_18;
    if ( (*(_BYTE *)(a1 + 32) & 4) == 0 || (unsigned int *)((char *)a3 - v9 + 4) == v8 )
    {
      if ( !v5 )
        goto LABEL_15;
      sub_8B440(v5, v7, (__int64)(a3 + 2), v22);
      v15 = v5;
      if ( (_BYTE)v5 == 0xFF )
      {
        v18 = 0LL;
        goto LABEL_25;
      }
    }
    else
    {
      v20 = (unsigned int *)((char *)a3 - v9 + 4);
      v10 = sub_8B590(v20);
      v5 = v10;
      v11 = v10;
      if ( (_BYTE)v10 == 0xFF )
      {
        v7 = 0LL;
        sub_8B440(255, 0LL, (__int64)(a3 + 2), v22);
        v18 = 0LL;
        v8 = v20;
        goto LABEL_25;
      }
      v12 = v10 & 0x70;
      if ( v12 == 32 )
      {
        v7 = *(_QWORD *)(a1 + 8);
        v8 = v20;
        if ( !v5 )
        {
LABEL_15:
          v5 = 0;
          if ( *((_QWORD *)a3 + 1) )
            goto LABEL_16;
          goto LABEL_18;
        }
      }
      else
      {
        if ( v12 <= 0x20u )
        {
          if ( (v11 & 0x60) != 0 )
            goto LABEL_47;
          goto LABEL_32;
        }
        if ( v12 != 48 )
        {
          if ( v12 != 80 )
            goto LABEL_47;
LABEL_32:
          v8 = v20;
          v7 = 0LL;
          if ( !v5 )
            goto LABEL_15;
          sub_8B440(v5, 0LL, (__int64)(a3 + 2), v22);
          v16 = v5 & 7;
          v17 = (v5 & 7u) <= 2;
          if ( (v5 & 7) == 2 )
          {
LABEL_34:
            v18 = 0xFFFFLL;
            goto LABEL_25;
          }
          goto LABEL_23;
        }
        v7 = *(_QWORD *)(a1 + 16);
        v8 = v20;
        if ( !v5 )
          goto LABEL_15;
      }
      v21 = v11;
      sub_8B440(v5, v7, (__int64)(a3 + 2), v22);
      v15 = v21;
    }
    v16 = v15 & 7;
    v17 = (v15 & 7u) <= 2;
    if ( (v15 & 7) == 2 )
      goto LABEL_34;
LABEL_23:
    if ( v17 )
    {
      if ( v16 )
        goto LABEL_47;
    }
    else
    {
      v18 = 0xFFFFFFFFLL;
      if ( v16 == 3 )
        goto LABEL_25;
      if ( v16 != 4 )
        goto LABEL_47;
    }
    v18 = -1LL;
LABEL_25:
    if ( (v22[0] & v18) != 0 )
    {
LABEL_16:
      v13 = *a2;
      if ( *a2 )
      {
        v14 = *(_QWORD *)(v13 + 8);
        *(_QWORD *)(v13 + 8) = v14 + 1;
        *(_QWORD *)(v13 + 8 * v14 + 16) = a3;
      }
    }
LABEL_18:
    a3 = (unsigned int *)((char *)a3 + *a3 + 4);
    v4 = *a3;
  }
  return v4;
}

//----- (000000000008BD50) ----------------------------------------------------
unsigned int *__fastcall sub_8BD50(__int64 a1, unsigned int *a2, __int64 a3)
{
  unsigned int *v4; // rbx
  __int16 v5; // ax
  int v6; // ebp
  unsigned __int8 v7; // dl
  __int64 v8; // r13
  unsigned int *v9; // r15
  int v10; // eax
  char v11; // r10
  unsigned __int8 v12; // al
  __int64 v13; // rax
  unsigned __int64 v14; // rdx
  __int64 v15; // rax
  _QWORD *v16; // rax
  char v17; // r10
  unsigned __int8 v18; // al
  __int64 v19; // rdx
  _QWORD *v21; // rax
  _QWORD *v22; // rax
  unsigned int *v23; // [rsp+8h] [rbp-50h]
  char v24; // [rsp+8h] [rbp-50h]
  __int64 v25; // [rsp+10h] [rbp-48h] BYREF
  __int64 v26[8]; // [rsp+18h] [rbp-40h] BYREF

  v4 = a2;
  v5 = *(_WORD *)(a1 + 32) >> 3;
  if ( (_BYTE)v5 == 0xFF )
  {
    v8 = 0LL;
    v6 = 255;
  }
  else
  {
    v6 = (unsigned __int8)v5;
    v7 = v5 & 0x70;
    if ( (v5 & 0x70) != 32 )
    {
      if ( v7 <= 0x20u )
      {
        if ( (v5 & 0x60) == 0 )
        {
LABEL_37:
          v8 = 0LL;
          goto LABEL_6;
        }
      }
      else
      {
        if ( v7 == 48 )
        {
          v8 = *(_QWORD *)(a1 + 16);
          goto LABEL_6;
        }
        if ( v7 == 80 )
          goto LABEL_37;
      }
LABEL_48:
      exit();
    }
    v8 = *(_QWORD *)(a1 + 8);
  }
LABEL_6:
  v9 = 0LL;
  if ( *a2 )
  {
    do
    {
      v15 = (int)v4[1];
      if ( !(_DWORD)v15 )
        goto LABEL_16;
      if ( (*(_BYTE *)(a1 + 32) & 4) == 0 || (unsigned int *)((char *)v4 - v15 + 4) == v9 )
      {
        if ( v6 )
          goto LABEL_20;
      }
      else
      {
        v23 = (unsigned int *)((char *)v4 - v15 + 4);
        v10 = sub_8B590(v23);
        v6 = v10;
        v11 = v10;
        if ( (_BYTE)v10 == 0xFF )
        {
          v8 = 0LL;
          v22 = sub_8B440(255, 0LL, (__int64)(v4 + 2), &v25);
          sub_8B440(v6 & 0xF, 0LL, (__int64)v22, v26);
          v19 = 0LL;
          v9 = v23;
          goto LABEL_24;
        }
        v12 = v10 & 0x70;
        if ( v12 == 32 )
        {
          v8 = *(_QWORD *)(a1 + 8);
          v9 = v23;
          if ( v6 )
          {
LABEL_43:
            v24 = v11;
            v21 = sub_8B440(v6, v8, (__int64)(v4 + 2), &v25);
            sub_8B440(v6 & 0xF, 0LL, (__int64)v21, v26);
            v17 = v24;
LABEL_21:
            v18 = v17 & 7;
            if ( (v17 & 7) == 2 )
            {
              v19 = 0xFFFFLL;
              goto LABEL_24;
            }
            if ( v18 <= 2u )
            {
              if ( v18 )
                goto LABEL_48;
            }
            else
            {
              v19 = 0xFFFFFFFFLL;
              if ( v18 == 3 )
                goto LABEL_24;
              if ( v18 != 4 )
                goto LABEL_48;
            }
            v19 = -1LL;
            goto LABEL_24;
          }
        }
        else
        {
          if ( v12 <= 0x20u )
          {
            if ( (v11 & 0x60) != 0 )
              goto LABEL_48;
          }
          else
          {
            if ( v12 == 48 )
            {
              v8 = *(_QWORD *)(a1 + 16);
              v9 = v23;
              if ( v6 )
                goto LABEL_43;
              goto LABEL_14;
            }
            if ( v12 != 80 )
              goto LABEL_48;
          }
          v9 = v23;
          v8 = 0LL;
          if ( v6 )
          {
LABEL_20:
            v16 = sub_8B440(v6, v8, (__int64)(v4 + 2), &v25);
            sub_8B440(v6 & 0xF, 0LL, (__int64)v16, v26);
            v17 = v6;
            if ( (_BYTE)v6 != 0xFF )
              goto LABEL_21;
            v19 = 0LL;
LABEL_24:
            if ( (v19 & v25) != 0 && (unsigned __int64)(a3 - v25) < v26[0] )
              return v4;
            goto LABEL_16;
          }
        }
      }
LABEL_14:
      v13 = *((_QWORD *)v4 + 1);
      v14 = *((_QWORD *)v4 + 2);
      v6 = 0;
      v25 = v13;
      v26[0] = v14;
      if ( v13 && a3 - v13 < v14 )
        return v4;
LABEL_16:
      v4 = (unsigned int *)((char *)v4 + *v4 + 4);
    }
    while ( *v4 );
  }
  return 0LL;
}

//----- (000000000008C060) ----------------------------------------------------
__int64 __fastcall sub_8C060(__int64 *a1, unsigned __int64 a2, __int64 a3)
{
  int *v6; // rax
  __int64 v7; // r8
  _QWORD *v8; // r12
  __int64 v9; // rdx
  unsigned __int64 v10; // r13
  __int64 v11; // r14
  __int64 v12; // r10
  int *v13; // r11
  int *v14; // rdx
  int *v15; // rcx
  int v16; // esi
  unsigned __int64 v17; // r9
  unsigned __int64 v18; // rsi
  unsigned __int64 v19; // rbp
  _QWORD *v20; // rax
  __int64 v21; // rdx
  _BYTE *v22; // r8
  _BYTE *v23; // rbp
  __int64 v25; // rsi
  char *v26; // rdx
  __int64 v27; // r10
  unsigned __int64 v28; // r9
  _QWORD *v29; // r11
  unsigned __int64 v30; // rdx
  unsigned __int64 v31; // rsi
  unsigned __int64 *v32; // rdx
  char v33; // di
  __int64 v34; // r8
  unsigned __int8 v35; // dl
  __int64 v36; // rsi
  _QWORD *v37; // rax
  char v38; // dl
  unsigned __int64 v39; // rdx
  __int64 v40; // rax
  __int64 v41; // rax
  unsigned int *v42; // rax
  char v43; // al
  unsigned __int8 v44; // cl
  __int64 v45; // rsi
  unsigned __int8 v46; // cl
  __int64 v47; // rsi
  _QWORD *v48; // rax
  _QWORD *v49; // rcx
  unsigned __int64 v50; // r8
  unsigned __int64 v51; // rsi
  int *v52; // r12
  unsigned __int64 v53; // rax
  _BYTE *v54; // r13
  char v55; // al
  unsigned __int8 v56; // cl
  __int64 v57; // rdx
  _BYTE *v58; // r8
  _QWORD *v59; // rdi
  __int64 v60; // rax
  _QWORD *v61; // [rsp+8h] [rbp-80h]
  unsigned int *v62; // [rsp+10h] [rbp-78h] BYREF
  __int64 v63; // [rsp+18h] [rbp-70h] BYREF
  __int64 v64[13]; // [rsp+20h] [rbp-68h] BYREF

  v6 = (int *)a1[2];
  v7 = *a1;
  if ( *(_DWORD *)(a3 + 40) && a2 > 0x2F )
  {
    v25 = a1[5];
    if ( a1[4] != qword_BFA88 || qword_C1928 != v25 )
    {
      qword_BFA88 = a1[4];
      v26 = (char *)&unk_C1970;
      qword_C1928 = v25;
      do
      {
        *((_QWORD *)v26 - 6) = 0LL;
        *((_QWORD *)v26 - 5) = 0LL;
        *((_QWORD *)v26 - 1) = v26;
        v26 += 48;
      }
      while ( (char *)&unk_C1970 + 384 != v26 );
      v8 = 0LL;
      qword_C1AB8 = 0LL;
      qword_C1930 = (__int64)&unk_C1940;
      *(_DWORD *)(a3 + 40) = 0;
      v61 = 0LL;
      goto LABEL_5;
    }
    v27 = qword_C1930;
    if ( !qword_C1930 )
    {
LABEL_4:
      v61 = 0LL;
      v8 = 0LL;
LABEL_5:
      v9 = *((unsigned __int16 *)a1 + 12);
      if ( !(_WORD)v9 )
        return 0LL;
      v10 = 0LL;
      v11 = 0LL;
      v12 = 0LL;
      v13 = 0LL;
      v14 = &v6[14 * v9];
      v15 = 0LL;
      while ( 1 )
      {
        v16 = *v6;
        if ( *v6 != 1 )
          break;
        v17 = *(_QWORD *)a3;
        v18 = v7 + *((_QWORD *)v6 + 2);
        if ( *(_QWORD *)a3 < v18 )
        {
LABEL_10:
          v6 += 14;
          if ( v14 == v6 )
            goto LABEL_19;
        }
        else
        {
          v19 = v18 + *((_QWORD *)v6 + 5);
          if ( v17 < v19 )
            v10 = v18 + *((_QWORD *)v6 + 5);
          if ( v17 < v19 )
          {
            v11 = v7 + *((_QWORD *)v6 + 2);
            if ( v17 < v19 )
              v12 = 1LL;
          }
          v6 += 14;
          if ( v14 == v6 )
          {
LABEL_19:
            if ( v12 )
            {
              if ( a2 > 0x2F )
              {
                v20 = (_QWORD *)qword_C1930;
                if ( v8 && v61 )
                {
                  v21 = v8[5];
                  qword_C1930 = (__int64)v8;
                  v61[5] = v21;
                  v8[5] = v20;
                  v20 = v8;
                }
                v20[2] = v7;
                v20[3] = v13;
                v20[4] = v15;
                *v20 = v11;
                v20[1] = v10;
              }
              goto LABEL_25;
            }
            return 0LL;
          }
        }
      }
      if ( v16 == 1685382480 )
      {
        v13 = v6;
      }
      else if ( v16 == 2 )
      {
        v15 = v6;
      }
      goto LABEL_10;
    }
    v8 = (_QWORD *)qword_C1930;
    v28 = *(_QWORD *)a3;
    v29 = 0LL;
    v30 = *(_QWORD *)qword_C1930;
    v31 = *(_QWORD *)(qword_C1930 + 8);
    if ( *(_QWORD *)a3 < *(_QWORD *)qword_C1930 )
    {
LABEL_39:
      while ( v31 | v30 )
      {
        v32 = (unsigned __int64 *)v8[5];
        if ( !v32 )
          break;
        v29 = v8;
        v8 = (_QWORD *)v8[5];
        v30 = *v32;
        v31 = v8[1];
        if ( v28 >= v30 )
          goto LABEL_38;
      }
      v61 = v29;
      goto LABEL_5;
    }
LABEL_38:
    if ( v28 >= v31 )
      goto LABEL_39;
    v59 = v29;
    v7 = v8[2];
    v13 = (int *)v8[3];
    if ( (_QWORD *)qword_C1930 != v8 )
    {
      v60 = v8[5];
      qword_C1930 = (__int64)v8;
      v59[5] = v60;
      v8[5] = v27;
    }
LABEL_25:
    if ( !v13 )
      return 0LL;
    v22 = (_BYTE *)(*((_QWORD *)v13 + 2) + v7);
    v23 = v22;
    if ( *v22 != 1 )
      return 1LL;
    v33 = v22[1];
    v34 = (__int64)(v22 + 4);
    if ( v33 != -1 )
    {
      v35 = v33 & 0x70;
      if ( (v33 & 0x70) == 32 )
      {
        v36 = *(_QWORD *)(a3 + 8);
        goto LABEL_48;
      }
      if ( v35 <= 0x20u )
      {
        if ( (v23[1] & 0x60) != 0 )
          goto LABEL_102;
      }
      else
      {
        if ( v35 == 48 )
        {
          v36 = *(_QWORD *)(a3 + 16);
LABEL_48:
          v37 = sub_8B440(v33, v36, v34, &v62);
          v38 = v23[2];
          if ( v38 == -1 || v23[3] != 59 )
          {
            v39 = *(_QWORD *)a3;
            goto LABEL_51;
          }
          v46 = v38 & 0x70;
          if ( (v38 & 0x70) == 32 )
          {
            v47 = *(_QWORD *)(a3 + 8);
          }
          else
          {
            if ( v46 <= 0x20u )
            {
              if ( (v23[2] & 0x60) != 0 )
                goto LABEL_102;
            }
            else
            {
              if ( v46 == 48 )
              {
                v47 = *(_QWORD *)(a3 + 16);
                goto LABEL_72;
              }
              if ( v46 != 80 )
                goto LABEL_102;
            }
            v47 = 0LL;
          }
LABEL_72:
          v48 = sub_8B440(v38, v47, (__int64)v37, &v63);
          v49 = v48;
          if ( !v63 )
            return 1LL;
          v39 = *(_QWORD *)a3;
          v50 = (unsigned __int8)v48 & 3;
          if ( ((unsigned __int8)v48 & 3) != 0 )
          {
LABEL_51:
            v40 = *(_QWORD *)(a3 + 8);
            v64[0] = 0LL;
            v64[4] = 4LL;
            v64[1] = v40;
            v41 = *(_QWORD *)(a3 + 16);
            v64[3] = (__int64)v62;
            v64[2] = v41;
            v42 = sub_8BD50((__int64)v64, v62, v39);
            *(_QWORD *)(a3 + 32) = v42;
            if ( !v42 )
              return 1LL;
            v43 = sub_8B590((_BYTE *)v42 - (int)v42[1] + 4);
            if ( v43 != -1 )
            {
              v44 = v43 & 0x70;
              if ( (v43 & 0x70) == 32 )
              {
                v45 = *(_QWORD *)(a3 + 8);
                goto LABEL_59;
              }
              if ( v44 <= 0x20u )
              {
                if ( (v43 & 0x60) != 0 )
                  goto LABEL_102;
              }
              else
              {
                if ( v44 == 48 )
                {
                  v45 = *(_QWORD *)(a3 + 16);
LABEL_59:
                  sub_8B440(v43, v45, *(_QWORD *)(a3 + 32) + 8LL, &v63);
                  *(_QWORD *)(a3 + 24) = v63;
                  return 1LL;
                }
                if ( v44 != 80 )
LABEL_102:
                  exit();
              }
            }
            v45 = 0LL;
            goto LABEL_59;
          }
          if ( (unsigned __int64)&v23[*(int *)v48] > v39 )
            return 1LL;
          v51 = v63 - 1;
          v52 = (int *)&v48[v63 - 1];
          if ( (unsigned __int64)&v23[*v52] > v39 )
          {
            do
            {
              while ( 1 )
              {
                if ( v50 >= v51 )
                  exit();
                v53 = (v50 + v51) >> 1;
                v52 = (int *)&v49[v53];
                if ( (unsigned __int64)&v23[*v52] <= v39 )
                  break;
                v51 = (v50 + v51) >> 1;
              }
              v50 = v53 + 1;
            }
            while ( (unsigned __int64)&v23[SLODWORD(v49[v53 + 1])] <= v39 );
          }
          v54 = &v23[v52[1]];
          v55 = sub_8B590(&v54[-*((int *)v54 + 1) + 4]);
          if ( v55 == -1 )
          {
            v57 = 8LL;
            goto LABEL_83;
          }
          v56 = v55 & 7;
          if ( (v55 & 7) == 2 )
          {
            v57 = 10LL;
            goto LABEL_83;
          }
          if ( v56 <= 2u )
          {
            if ( v56 )
              goto LABEL_102;
          }
          else
          {
            v57 = 12LL;
            if ( v56 == 3 )
            {
LABEL_83:
              sub_8B440(v55 & 0xF, 0LL, (__int64)&v54[v57], v64);
              v58 = &v23[*v52];
              if ( *(_QWORD *)a3 < (unsigned __int64)&v58[v64[0]] )
                *(_QWORD *)(a3 + 32) = v54;
              *(_QWORD *)(a3 + 24) = v58;
              return 1LL;
            }
            if ( v56 != 4 )
              goto LABEL_102;
          }
          v57 = 16LL;
          goto LABEL_83;
        }
        if ( v35 != 80 )
          goto LABEL_102;
      }
    }
    v36 = 0LL;
    goto LABEL_48;
  }
  if ( a2 > 0x19 )
    goto LABEL_4;
  return 0xFFFFFFFFLL;
}
// BFA88: using guessed type __int64 qword_BFA88;
// C1928: using guessed type __int64 qword_C1928;
// C1930: using guessed type __int64 qword_C1930;
// C1AB8: using guessed type __int64 qword_C1AB8;

//----- (000000000008C610) ----------------------------------------------------
unsigned int *__fastcall sub_8C610(__int64 a1, unsigned int *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, u32 *a13, u32 a14)
{
  unsigned __int64 v14; // r12
  __int64 v15; // rdx
  __int64 v16; // rbx
  unsigned __int16 v17; // ax
  __int16 v18; // ax
  unsigned __int8 v19; // dl
  __int64 v20; // rcx
  unsigned __int64 v21; // rbx
  __int64 v22; // r14
  unsigned __int64 v23; // r12
  __int64 v24; // rbp
  unsigned __int64 v25; // r13
  _QWORD *v26; // rax
  __int64 v27; // r14
  __int64 v29; // rbx
  unsigned int **v30; // rbp
  __int64 v31; // rax
  unsigned __int64 v32; // rdx
  unsigned __int64 v33; // rcx
  unsigned __int64 v34; // rax
  unsigned __int64 v35; // rsi
  unsigned __int64 v36; // r15
  unsigned __int64 v37; // r14
  unsigned __int64 v38; // rbp
  __int64 v39; // r13
  char v40; // al
  char v41; // bl
  char v42; // di
  unsigned __int8 v43; // al
  __int64 v44; // rsi
  _QWORD *v45; // rax
  unsigned int **v46; // rbp
  unsigned int *j; // rsi
  unsigned int *v48; // rax
  _QWORD *v49; // rax
  __int64 v50; // rdx
  __int64 v51; // rcx
  u32 *v52; // r8
  u32 v53; // er9
  double v54; // xmm4_8
  double v55; // xmm5_8
  __int64 v56; // rax
  unsigned int **v57; // r14
  unsigned int *v58; // rdx
  __int64 (__fastcall *v59)(__int64, __int64, __int64); // rbp
  __int64 v60; // r15
  _QWORD *v61; // rbx
  __int64 *v62; // r12
  __int64 *v63; // r14
  __int64 v64; // rax
  __int64 v65; // rsi
  __int64 v66; // rdx
  __int64 i; // rax
  __int64 v68; // rcx
  __int64 v69; // r10
  __int64 v70; // rsi
  __int64 v71; // rdx
  unsigned __int64 v72; // rcx
  u32 *v73; // r8
  __int64 v74; // r9
  double v75; // xmm4_8
  double v76; // xmm5_8
  __int64 v77; // rax
  _QWORD *v78; // r12
  __int64 v79; // r14
  __int64 v80; // r15
  __int64 v81; // rbx
  __int64 v82; // rbp
  _QWORD *v83; // r14
  _QWORD *v84; // rax
  char v85; // [rsp+0h] [rbp-88h]
  __int64 v86; // [rsp+0h] [rbp-88h]
  __int64 v87; // [rsp+0h] [rbp-88h]
  __int64 (__fastcall *v88)(__int64, __int64, __int64); // [rsp+0h] [rbp-88h]
  char v89; // [rsp+8h] [rbp-80h]
  __int64 v91; // [rsp+8h] [rbp-80h]
  __int64 v92; // [rsp+8h] [rbp-80h]
  __int64 v93; // [rsp+10h] [rbp-78h]
  __int64 v94; // [rsp+10h] [rbp-78h]
  __int64 v95; // [rsp+18h] [rbp-70h]
  _QWORD *v96; // [rsp+18h] [rbp-70h]
  unsigned __int64 v97; // [rsp+18h] [rbp-70h]
  unsigned __int64 v98; // [rsp+20h] [rbp-68h]
  _QWORD *v99; // [rsp+20h] [rbp-68h]
  unsigned __int64 v100; // [rsp+28h] [rbp-60h]
  unsigned __int64 v101; // [rsp+38h] [rbp-50h] BYREF
  _QWORD *v102; // [rsp+40h] [rbp-48h] BYREF
  __int64 v103; // [rsp+48h] [rbp-40h]

  v14 = (unsigned __int64)a2;
  v15 = *(unsigned __int8 *)(a1 + 32);
  if ( (v15 & 1) != 0 )
  {
LABEL_2:
    v16 = *(_QWORD *)(a1 + 24);
    if ( (v15 & 4) == 0 )
    {
      v17 = *(_WORD *)(a1 + 32);
      if ( (v17 & 0x7F8) == 0 )
      {
        v32 = *(_QWORD *)(v16 + 8);
        v33 = 0LL;
        while ( v32 > v33 )
        {
          v34 = (v32 + v33) >> 1;
          v27 = *(_QWORD *)(v16 + 8 * v34 + 16);
          v35 = *(_QWORD *)(v27 + 8);
          if ( v14 >= v35 )
          {
            if ( v14 < *(_QWORD *)(v27 + 16) + v35 )
              return (unsigned int *)v27;
            v33 = v34 + 1;
          }
          else
          {
            v32 = (v32 + v33) >> 1;
          }
        }
        return 0LL;
      }
      v18 = v17 >> 3;
      v85 = v18;
      if ( (_BYTE)v18 == 0xFF )
        goto LABEL_59;
      v19 = v18 & 0x70;
      if ( (v18 & 0x70) == 32 )
      {
        v20 = *(_QWORD *)(a1 + 8);
        goto LABEL_9;
      }
      if ( v19 <= 0x20u )
      {
        if ( (v18 & 0x60) == 0 )
          goto LABEL_59;
      }
      else
      {
        if ( v19 == 48 )
        {
          v20 = *(_QWORD *)(a1 + 16);
LABEL_9:
          if ( !*(_QWORD *)(v16 + 8) )
            return 0LL;
          v95 = *(_QWORD *)(a1 + 24);
          v89 = v18 & 0xF;
          v21 = *(_QWORD *)(v16 + 8);
          v22 = v20;
          v98 = v14;
          v23 = 0LL;
          while ( 1 )
          {
            while ( 1 )
            {
              v24 = *(_QWORD *)(v95 + 8 * ((v21 + v23) >> 1) + 16);
              v25 = (v21 + v23) >> 1;
              v26 = sub_8B440(v85, v22, v24 + 8, &v101);
              sub_8B440(v89, 0LL, (__int64)v26, &v102);
              if ( v98 >= v101 )
                break;
              v21 = (v21 + v23) >> 1;
              if ( v23 >= v25 )
                return 0LL;
            }
            if ( v98 < (unsigned __int64)v102 + v101 )
              break;
            v23 = v25 + 1;
            if ( v25 + 1 >= v21 )
              return 0LL;
          }
          return (unsigned int *)v24;
        }
        if ( v19 == 80 )
        {
LABEL_59:
          v20 = 0LL;
          goto LABEL_9;
        }
      }
      goto LABEL_115;
    }
    v36 = *(_QWORD *)(v16 + 8);
    if ( !v36 )
      return 0LL;
    v86 = *(_QWORD *)(a1 + 24);
    v37 = 0LL;
    while ( 1 )
    {
      v38 = (v36 + v37) >> 1;
      v39 = *(_QWORD *)(v86 + 8 * v38 + 16);
      v40 = sub_8B590((_BYTE *)(v39 + 4 - *(int *)(v39 + 4)));
      v41 = v40;
      v42 = v40;
      if ( v40 == -1 )
        goto LABEL_54;
      v43 = v40 & 0x70;
      if ( v43 != 32 )
        break;
      v44 = *(_QWORD *)(a1 + 8);
LABEL_39:
      v45 = sub_8B440(v42, v44, v39 + 8, &v101);
      sub_8B440(v41 & 0xF, 0LL, (__int64)v45, &v102);
      if ( v14 >= v101 )
      {
        if ( v14 < (unsigned __int64)v102 + v101 )
          return (unsigned int *)v39;
        v37 = v38 + 1;
      }
      else
      {
        v36 = (v36 + v37) >> 1;
      }
      if ( v37 >= v36 )
        return 0LL;
    }
    if ( v43 <= 0x20u )
    {
      if ( (v41 & 0x60) != 0 )
        goto LABEL_115;
    }
    else
    {
      if ( v43 == 48 )
      {
        v44 = *(_QWORD *)(a1 + 16);
        goto LABEL_39;
      }
      if ( v43 != 80 )
        goto LABEL_115;
    }
LABEL_54:
    v44 = 0LL;
    goto LABEL_39;
  }
  v29 = *(_DWORD *)(a1 + 32) >> 11;
  v93 = v29;
  if ( !(*(_DWORD *)(a1 + 32) >> 11) )
  {
    v30 = *(unsigned int ***)(a1 + 24);
    if ( (v15 & 2) != 0 )
    {
      a2 = *v30;
      if ( !*v30 )
        goto LABEL_45;
      do
      {
        v31 = sub_8B6C0(a1, a2);
        if ( v31 == -1 )
          goto LABEL_23;
        a2 = v30[1];
        ++v30;
        v29 += v31;
      }
      while ( a2 );
      v93 = v29;
    }
    else
    {
      a2 = *(unsigned int **)(a1 + 24);
      v93 = sub_8B6C0(a1, a2);
      if ( v93 == -1 )
      {
LABEL_23:
        *(_QWORD *)(a1 + 32) = 2040LL;
        *(_QWORD *)(a1 + 24) = &unk_AC630;
        goto LABEL_45;
      }
    }
    if ( (v93 & 0xFFFFFFFFFFE00000LL) != 0 )
    {
      *(_DWORD *)(a1 + 32) &= 0x7FFu;
    }
    else
    {
      v15 = (unsigned int)((_DWORD)v93 << 11);
      *(_DWORD *)(a1 + 32) = v15 | *(_DWORD *)(a1 + 32) & 0x7FF;
    }
    if ( !v93 )
      goto LABEL_45;
  }
  v49 = (_QWORD *)sub_21500((u32 *)(8 * v93 + 16), (__int64)a2, v15, a12, a13, a14, a3, a4, a5, a6, a7, a8, a9, a10);
  v102 = v49;
  if ( !v49 )
    goto LABEL_45;
  v49[1] = 0LL;
  v56 = sub_21500((u32 *)(8 * v93 + 16), (__int64)a2, v50, v51, v52, v53, a3, a4, a5, a6, v54, v55, a9, a10);
  v103 = v56;
  if ( v56 )
    *(_QWORD *)(v56 + 8) = 0LL;
  v57 = *(unsigned int ***)(a1 + 24);
  if ( (*(_BYTE *)(a1 + 32) & 2) != 0 )
  {
    v58 = *v57;
    if ( !*v57 )
      goto LABEL_115;
    do
    {
      ++v57;
      sub_8BAA0(a1, (__int64 *)&v102, v58);
      v58 = *v57;
    }
    while ( *v57 );
  }
  else
  {
    sub_8BAA0(a1, (__int64 *)&v102, *(unsigned int **)(a1 + 24));
  }
  v96 = v102;
  v99 = v102;
  if ( v102 && v102[1] != v93 )
    goto LABEL_115;
  v59 = sub_8B970;
  if ( (*(_BYTE *)(a1 + 32) & 4) == 0 )
  {
    v59 = sub_8B2A0;
    if ( (*(_WORD *)(a1 + 32) & 0x7F8) != 0 )
      v59 = sub_8B8B0;
  }
  v60 = v103;
  if ( !v103 )
  {
    sub_8B390(a1, v59, (__int64)v102);
    goto LABEL_103;
  }
  v91 = v102[1];
  if ( v91 )
  {
    v87 = 0LL;
    v100 = v14;
    v61 = v102 + 2;
    v62 = (__int64 *)&unk_C1920;
    v63 = v102 + 2;
    while ( 1 )
    {
      *(_QWORD *)(v60 + 8 * v87++ + 16) = v62;
      if ( v91 == v87 )
        break;
      if ( v63 == (__int64 *)&unk_C1920 )
      {
LABEL_84:
        v62 = (__int64 *)&unk_C1920;
        ++v63;
      }
      else
      {
        v62 = v63;
        while ( (int)v59(a1, v63[1], *v62) < 0 )
        {
          v64 = v62 - v61 + 2;
          v62 = *(__int64 **)(v60 + 8 * v64);
          *(_QWORD *)(v60 + 8 * v64) = 0LL;
          if ( v62 == (__int64 *)&unk_C1920 )
            goto LABEL_84;
        }
        ++v63;
      }
    }
    v14 = v100;
    v65 = 0LL;
    v66 = 0LL;
    for ( i = 0LL; i != v91; ++i )
    {
      v68 = v96[i + 2];
      if ( *(_QWORD *)(v60 + 8 * i + 16) )
        v96[v66++ + 2] = v68;
      else
        *(_QWORD *)(v60 + 8 * v65++ + 16) = v68;
    }
    v69 = v103;
    v96 = v102;
  }
  else
  {
    v69 = v103;
    v65 = 0LL;
    v66 = 0LL;
  }
  v99[1] = v66;
  *(_QWORD *)(v60 + 8) = v65;
  if ( v96[1] + *(_QWORD *)(v69 + 8) != v93 )
LABEL_115:
    exit();
  v70 = (__int64)v59;
  sub_8B390(a1, v59, v69);
  v94 = v103;
  v77 = *(_QWORD *)(v103 + 8);
  if ( !v77 )
    goto LABEL_102;
  v88 = v59;
  v97 = v14;
  v78 = v102;
  v79 = v102[1];
  while ( 1 )
  {
    v71 = v77 + 1;
    v92 = v77 - 1;
    v72 = v94;
    v80 = *(_QWORD *)(v94 + 8 * (v77 + 1));
    if ( !v79 )
      break;
    v81 = v79 + v77 - 1;
    v82 = v79;
    while ( 1 )
    {
      v79 = v82--;
      v70 = v78[v82 + 2];
      if ( (int)v88(a1, v70, v80) <= 0 )
        break;
      v78[v81-- + 2] = v78[v82 + 2];
      if ( !v82 )
      {
        v81 = v92;
        v79 = 0LL;
        break;
      }
    }
LABEL_98:
    v78[v81 + 2] = v80;
    if ( !v92 )
      goto LABEL_101;
    v77 = v92;
  }
  v78[v71] = v80;
  if ( v77 != 1 )
  {
    v72 = v94;
    v81 = v77 - 2;
    v92 = v77 - 2;
    v80 = *(_QWORD *)(v94 + 8 * v77);
    goto LABEL_98;
  }
LABEL_101:
  v83 = v78;
  v14 = v97;
  v83[1] += *(_QWORD *)(v94 + 8);
  v94 = v103;
LABEL_102:
  sub_21B70(v94, a3, a4, a5, a6, v75, v76, a9, a10, v70, v71, v72, v73, v74);
LABEL_103:
  v84 = v102;
  *v102 = *(_QWORD *)(a1 + 24);
  *(_BYTE *)(a1 + 32) |= 1u;
  *(_QWORD *)(a1 + 24) = v84;
LABEL_45:
  if ( *(_QWORD *)a1 > v14 )
    return 0LL;
  LOBYTE(v15) = *(_BYTE *)(a1 + 32);
  v46 = *(unsigned int ***)(a1 + 24);
  if ( (v15 & 1) != 0 )
    goto LABEL_2;
  if ( (*(_BYTE *)(a1 + 32) & 2) != 0 )
  {
    for ( j = *v46; j; ++v46 )
    {
      v48 = sub_8BD50(a1, j, v14);
      if ( v48 )
        return v48;
      j = v46[1];
    }
    return 0LL;
  }
  return sub_8BD50(a1, *(unsigned int **)(a1 + 24), v14);
}
// 8C9E0: variable 'v15' is possibly undefined
// 8C9E0: variable 'a12' is possibly undefined
// 8C9E0: variable 'a13' is possibly undefined
// 8C9E0: variable 'a14' is possibly undefined
// 8C9E0: variable 'a7' is possibly undefined
// 8C9E0: variable 'a8' is possibly undefined
// 8C9FF: variable 'v50' is possibly undefined
// 8C9FF: variable 'v51' is possibly undefined
// 8C9FF: variable 'v52' is possibly undefined
// 8C9FF: variable 'v53' is possibly undefined
// 8C9FF: variable 'v54' is possibly undefined
// 8C9FF: variable 'v55' is possibly undefined
// 8CCDE: variable 'v75' is possibly undefined
// 8CCDE: variable 'v76' is possibly undefined
// 8CCDE: variable 'v71' is possibly undefined
// 8CCDE: variable 'v72' is possibly undefined
// 8CCDE: variable 'v73' is possibly undefined
// 8CCDE: variable 'v74' is possibly undefined

//----- (000000000008D160) ----------------------------------------------------
__int64 __fastcall sub_8D160(_DWORD *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 *a12, u32 *a13, __int64 a14)
{
  __int64 v15; // rax
  _DWORD *v16; // rdx
  __int64 v17; // r12
  __int64 *v19; // rax
  _QWORD *v20; // rdi
  __int64 v21; // rdx

  if ( !a1 || !*a1 )
    return 0LL;
  v15 = qword_C1AF8;
  if ( qword_C1AF8 )
  {
    a12 = &qword_C1AF8;
    do
    {
      v16 = *(_DWORD **)(v15 + 24);
      v17 = v15;
      v15 = *(_QWORD *)(v15 + 40);
      if ( a1 == v16 )
      {
        *a12 = v15;
        return v17;
      }
      a12 = (__int64 *)(v17 + 40);
    }
    while ( v15 );
  }
  v17 = qword_C1AF0;
  if ( !qword_C1AF0 )
LABEL_17:
    exit();
  v19 = &qword_C1AF0;
  while ( 1 )
  {
    v20 = *(_QWORD **)(v17 + 24);
    if ( (*(_BYTE *)(v17 + 32) & 1) != 0 )
      break;
    if ( a1 == (_DWORD *)v20 )
    {
      *v19 = *(_QWORD *)(v17 + 40);
      return v17;
    }
LABEL_12:
    v19 = (__int64 *)(v17 + 40);
    v17 = *(_QWORD *)(v17 + 40);
    if ( !v17 )
      goto LABEL_17;
  }
  if ( a1 != (_DWORD *)*v20 )
    goto LABEL_12;
  v21 = *(_QWORD *)(v17 + 40);
  *v19 = v21;
  sub_21B70((__int64)v20, a3, a4, a5, a6, a7, a8, a9, a10, a2, v21, (unsigned __int64)a12, a13, a14);
  return v17;
}
// 0: using guessed type __int64 (*dword_0)(void);
// C1AF0: using guessed type __int64 qword_C1AF0;
// C1AF8: using guessed type __int64 qword_C1AF8;

//----- (000000000008D2D0) ----------------------------------------------------
unsigned int *__fastcall sub_8D2D0(unsigned int *a1, _QWORD *a2, __int64 *a3, unsigned __int64 a4, u32 *a5, u32 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  unsigned int *v16; // r15
  __int64 v18; // rbx
  __int16 v19; // di
  char v20; // al
  unsigned __int8 v21; // dl
  __int64 v22; // rsi
  __int64 v23; // rdi
  unsigned int *v24; // rax
  unsigned __int64 *v25; // rax
  unsigned int *v26; // [rsp+0h] [rbp-68h] BYREF
  __int64 v27; // [rsp+8h] [rbp-60h]
  __int64 v28; // [rsp+10h] [rbp-58h]
  __int64 v29; // [rsp+18h] [rbp-50h]
  unsigned int *v30; // [rsp+20h] [rbp-48h]
  int v31; // [rsp+28h] [rbp-40h]

  if ( dword_C1AE8 )
  {
    v18 = qword_C1AF0;
    if ( !qword_C1AF0 )
      goto LABEL_19;
    while ( (unsigned __int64)a1 < *(_QWORD *)v18 )
    {
      v18 = *(_QWORD *)(v18 + 40);
      if ( !v18 )
        goto LABEL_19;
    }
    v16 = sub_8C610(v18, a1, a7, a8, a9, a10, a11, a12, a13, a14, (__int64)a3, a4, a5, a6);
    if ( !v16 )
    {
LABEL_19:
      do
      {
        v18 = qword_C1AF8;
        if ( !qword_C1AF8 )
          goto LABEL_2;
        v23 = qword_C1AF8;
        qword_C1AF8 = *(_QWORD *)(qword_C1AF8 + 40);
        v24 = sub_8C610(v23, a1, a7, a8, a9, a10, a11, a12, a13, a14, (__int64)a3, a4, a5, a6);
        a3 = &qword_C1AF0;
        v16 = v24;
        v25 = (unsigned __int64 *)qword_C1AF0;
        if ( qword_C1AF0 )
        {
          a4 = *(_QWORD *)v18;
          do
          {
            if ( *v25 < a4 )
              break;
            a3 = (__int64 *)(v25 + 5);
            v25 = (unsigned __int64 *)v25[5];
          }
          while ( v25 );
        }
        *(_QWORD *)(v18 + 40) = v25;
        *a3 = v18;
      }
      while ( !v16 );
    }
    *a2 = *(_QWORD *)(v18 + 8);
    a2[1] = *(_QWORD *)(v18 + 16);
    if ( (*(_BYTE *)(v18 + 32) & 4) != 0 )
    {
      v20 = sub_8B590((_BYTE *)v16 - (int)v16[1] + 4);
      LOBYTE(v19) = v20;
    }
    else
    {
      v19 = *(_WORD *)(v18 + 32) >> 3;
      v20 = v19;
    }
    if ( v20 != -1 )
    {
      v21 = v20 & 0x70;
      if ( (v20 & 0x70) == 32 )
      {
        v22 = *(_QWORD *)(v18 + 8);
        goto LABEL_18;
      }
      if ( v21 <= 0x20u )
      {
        if ( (v20 & 0x60) != 0 )
          goto LABEL_34;
      }
      else
      {
        if ( v21 == 48 )
        {
          v22 = *(_QWORD *)(v18 + 16);
LABEL_18:
          sub_8B440(v19, v22, (__int64)(v16 + 2), &v26);
          a2[2] = v26;
          return v16;
        }
        if ( v21 != 80 )
LABEL_34:
          exit();
      }
    }
    v22 = 0LL;
    goto LABEL_18;
  }
LABEL_2:
  v26 = a1;
  v27 = 0LL;
  v28 = 0LL;
  v29 = 0LL;
  v30 = 0LL;
  v31 = 1;
  if ( (int)sub_8DA20((__int64 (__fastcall *)(__int64 *, __int64, __int64))sub_8C060, (__int64)&v26) < 0 )
    return 0LL;
  v16 = v30;
  if ( v30 )
  {
    *a2 = v27;
    a2[1] = v28;
    a2[2] = v29;
  }
  return v16;
}
// 8D481: variable 'a11' is possibly undefined
// 8D481: variable 'a12' is possibly undefined
// 8D481: variable 'a3' is possibly undefined
// 8D481: variable 'a4' is possibly undefined
// 8D481: variable 'a5' is possibly undefined
// 8D481: variable 'a6' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);
// C1AE8: using guessed type int dword_C1AE8;
// C1AF0: using guessed type __int64 qword_C1AF0;
// C1AF8: using guessed type __int64 qword_C1AF8;

//----- (000000000008D540) ----------------------------------------------------
__int64 __fastcall sub_8D540(char a1, __int64 a2)
{
  unsigned __int8 v2; // al

  if ( a1 == -1 )
    return 0LL;
  v2 = a1 & 0x70;
  if ( (a1 & 0x70) != 48 )
  {
    if ( v2 > 0x30u )
    {
      if ( v2 == 64 )
        return sub_8A730(a2);
      if ( v2 == 80 )
        return 0LL;
    }
    else
    {
      if ( v2 == 32 )
        return sub_8A780(a2);
      if ( v2 <= 0x20u && (a1 & 0x60) == 0 )
        return 0LL;
    }
    exit();
  }
  return sub_8A770(a2);
}

//----- (000000000008D5D0) ----------------------------------------------------
_QWORD *__fastcall sub_8D5D0(char a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  __int64 *v4; // rax
  __int64 v5; // rdx
  _QWORD *result; // rax

  if ( a1 != 80 )
  {
    if ( (a1 & 0xFu) <= 0xC )
      __asm { jmp     rax }
    exit();
  }
  v4 = (__int64 *)((a3 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  v5 = *v4;
  result = v4 + 1;
  *a4 = v5;
  return result;
}

//----- (000000000008D720) ----------------------------------------------------
__int64 __fastcall sub_8D720(int a1, char a2, __int64 a3, __int64 a4, __int64 a5)
{
  char *v6; // rbx
  __int64 v7; // rax
  char v8; // dl
  char *v9; // r13
  char v10; // r14
  unsigned __int8 v11; // al
  __int64 v12; // rsi
  char *v13; // rsi
  __int64 v14; // rdi
  int v15; // ecx
  char v16; // dl
  unsigned __int64 v17; // rax
  char *v18; // r12
  __int64 v19; // rdi
  int v20; // ecx
  char v21; // si
  unsigned __int64 v22; // rax
  __int64 v23; // rax
  unsigned __int64 v24; // rbx
  char v25; // bp
  __int64 v26; // rax
  _QWORD *v27; // rax
  char v28; // bp
  __int64 v29; // r12
  __int64 v30; // rax
  _QWORD *v31; // rax
  __int64 v32; // rbp
  __int64 v33; // rax
  __int64 v34; // r13
  int v37; // [rsp+14h] [rbp-84h] BYREF
  __int64 v38; // [rsp+18h] [rbp-80h] BYREF
  __int64 v39; // [rsp+20h] [rbp-78h] BYREF
  __int64 v40; // [rsp+28h] [rbp-70h] BYREF
  __int64 v41; // [rsp+30h] [rbp-68h]
  __int64 v42; // [rsp+38h] [rbp-60h] BYREF
  char *v43; // [rsp+48h] [rbp-50h]
  unsigned __int64 v44; // [rsp+50h] [rbp-48h]
  char v45; // [rsp+58h] [rbp-40h]
  char v46; // [rsp+59h] [rbp-3Fh]

  v37 = 0;
  if ( a1 == 1 )
  {
    if ( (a2 & 2) == 0 )
      return 8LL;
    v6 = (char *)sub_8A720(a5);
    if ( !v6 )
      return 8LL;
    v7 = 0LL;
    if ( a5 )
      v7 = sub_8A730(a5);
    v41 = v7;
    v8 = *v6;
    v9 = v6 + 1;
    if ( *v6 == -1 )
    {
      v42 = v7;
LABEL_19:
      v13 = v9 + 1;
      v45 = *v9;
      if ( v45 == -1 )
      {
        v43 = 0LL;
      }
      else
      {
        v14 = 0LL;
        v15 = 0;
        do
        {
          v16 = *v13++;
          v17 = (unsigned __int64)(v16 & 0x7F) << v15;
          v15 += 7;
          v14 |= v17;
        }
        while ( v16 < 0 );
        v43 = &v13[v14];
      }
      v18 = v13 + 1;
      v19 = 0LL;
      v20 = 0;
      v46 = *v13;
      do
      {
        v21 = *v18++;
        v22 = (unsigned __int64)(v21 & 0x7F) << v20;
        v20 += 7;
        v19 |= v22;
      }
      while ( v21 < 0 );
      v44 = (unsigned __int64)&v18[v19];
      v23 = sub_8A6F0(a5, &v37);
      v24 = v23 - (v37 == 0);
      if ( (unsigned __int64)v18 < v44 )
      {
        while ( 1 )
        {
          v25 = v46;
          v26 = sub_8D540(v46, 0LL);
          v27 = sub_8D5D0(v25, v26, (__int64)v18, &v38);
          v28 = v46;
          v29 = (__int64)v27;
          v30 = sub_8D540(v46, 0LL);
          v31 = sub_8D5D0(v28, v30, v29, &v39);
          LOBYTE(v29) = v46;
          v32 = (__int64)v31;
          v33 = sub_8D540(v46, 0LL);
          v18 = (char *)sub_8D5D0(v29, v33, v32, &v40);
          do
            ++v18;
          while ( *(v18 - 1) < 0 );
          if ( v41 + v38 > v24 )
            break;
          if ( v39 + v41 + v38 > v24 )
          {
            if ( v40 )
            {
              v34 = v42 + v40;
              if ( v42 + v40 )
              {
                sub_8A680(a5, 0, a4);
                sub_8A680(a5, 1, 0LL);
                sub_8A710(a5, v34);
                return 7LL;
              }
            }
            return 8LL;
          }
          if ( v44 <= (unsigned __int64)v18 )
            return 8LL;
        }
      }
      return 8LL;
    }
    v10 = *v6;
    v11 = v8 & 0x70;
    if ( (v8 & 0x70) == 48 )
    {
      v12 = sub_8A770(a5);
      goto LABEL_18;
    }
    if ( v11 > 0x30u )
    {
      if ( v11 == 64 )
      {
        v12 = sub_8A730(a5);
        goto LABEL_18;
      }
      if ( v11 == 80 )
      {
LABEL_17:
        v12 = 0LL;
        goto LABEL_18;
      }
    }
    else
    {
      if ( v11 == 32 )
      {
        v12 = sub_8A780(a5);
LABEL_18:
        v9 = (char *)sub_8D5D0(v10, v12, (__int64)(v6 + 1), &v42);
        goto LABEL_19;
      }
      if ( v11 <= 0x20u && (*v6 & 0x60) == 0 )
        goto LABEL_17;
    }
    exit();
  }
  return 3LL;
}

//----- (000000000008DA20) ----------------------------------------------------
__int64 __fastcall sub_8DA20(__int64 (__fastcall *a1)(__int64 *, __int64, __int64), __int64 a2)
{
  _QWORD *v3; // r15
  __int64 v4; // r12
  unsigned int v5; // er14
  __int64 v6; // rdi
  __int64 v7; // rax
  __int64 v9[3]; // [rsp+0h] [rbp-88h] BYREF
  __int16 v10; // [rsp+18h] [rbp-70h]
  __int64 v11; // [rsp+20h] [rbp-68h]
  __int64 v12; // [rsp+28h] [rbp-60h]
  __int64 v14; // [rsp+38h] [rbp-50h]
  unsigned __int64 v15; // [rsp+48h] [rbp-40h]

  v15 = __readfsqword(0x28u);
  v3 = off_BF0E0;
  v4 = (unsigned int)dword_BF0E8;
  if ( !off_BF0E0 )
    return 0;
  while ( 1 )
  {
    v6 = v3[5];
    v9[0] = *(_QWORD *)v6;
    v7 = *(_QWORD *)(v6 + 8);
    v14 = 0LL;
    v9[1] = v7;
    v9[2] = *(_QWORD *)(v6 + 680);
    v10 = *(_WORD *)(v6 + 696);
    v11 = qword_BF080;
    v12 = qword_BF080 - v4;
    if ( *(_QWORD *)(v6 + 1112) )
      v14 = sub_4D9C0(v6);
    v5 = a1(v9, 64LL, a2);
    if ( v5 )
      break;
    v3 = (_QWORD *)v3[3];
    if ( !v3 )
      return 0;
  }
  return v5;
}
// 9228: using guessed type __int64 __fastcall sub_9228(_QWORD);
// 9248: using guessed type __int64 __fastcall sub_9248(_QWORD);
// BF080: using guessed type __int64 qword_BF080;
// BF0E0: using guessed type void *off_BF0E0;
// BF0E8: using guessed type int dword_BF0E8;

//----- (000000000008DB50) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_8DB50(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14))(_QWORD, _QWORD)
{
  __int64 *i; // rbp
  char *v15; // rdi
  __int64 v16; // rdx
  unsigned __int64 v17; // rcx
  u32 *v18; // r8
  __int64 v19; // r9
  double v20; // xmm4_8
  double v21; // xmm5_8
  __int64 (__fastcall *result)(_QWORD, _QWORD); // rax
  __int64 v23; // rdx
  unsigned __int64 v24; // rcx
  u32 *v25; // r8
  __int64 v26; // r9
  double v27; // xmm4_8
  double v28; // xmm5_8
  _QWORD *v29; // rbp
  __int64 v30; // rdi

  for ( i = (__int64 *)qword_C0BF8; qword_C0BF8; i = (__int64 *)qword_C0BF8 )
  {
    v15 = (char *)i[1];
    qword_C0BF8 = *i;
    if ( v15 != "/usr/share/locale" )
      sub_21B70((__int64)v15, a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14);
    sub_21B70(i[2], a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14);
    sub_21B70((__int64)i, a1, a2, a3, a4, v20, v21, a7, a8, a10, v16, v17, v18, v19);
  }
  if ( off_BE040 != "messages" )
    sub_21B70((__int64)off_BE040, a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14);
  result = sub_4C870((_QWORD *)qword_C0C30, (double (__fastcall *)(_QWORD))sub_21B70, a1, a2, a3, a4, a5, a6, a7, a8);
  v29 = (_QWORD *)qword_C0C28;
  qword_C0C30 = 0LL;
  if ( qword_C0C28 )
  {
    do
    {
      v30 = (__int64)v29;
      v29 = (_QWORD *)*v29;
      qword_C0C28 = (__int64)v29;
      result = sub_21B70(v30, a1, a2, a3, a4, v27, v28, a7, a8, (__int64)sub_21B70, v23, v24, v25, v26);
    }
    while ( v29 );
  }
  return result;
}
// 8DB84: variable 'a5' is possibly undefined
// 8DB84: variable 'a6' is possibly undefined
// 8DB84: variable 'a11' is possibly undefined
// 8DB84: variable 'a12' is possibly undefined
// 8DB84: variable 'a13' is possibly undefined
// 8DB84: variable 'a14' is possibly undefined
// 8DB95: variable 'v20' is possibly undefined
// 8DB95: variable 'v21' is possibly undefined
// 8DB95: variable 'v16' is possibly undefined
// 8DB95: variable 'v17' is possibly undefined
// 8DB95: variable 'v18' is possibly undefined
// 8DB95: variable 'v19' is possibly undefined
// 8DBFE: variable 'v27' is possibly undefined
// 8DBFE: variable 'v28' is possibly undefined
// 8DBFE: variable 'v23' is possibly undefined
// 8DBFE: variable 'v24' is possibly undefined
// 8DBFE: variable 'v25' is possibly undefined
// 8DBFE: variable 'v26' is possibly undefined
// BE040: using guessed type char *off_BE040;
// C0BF8: using guessed type __int64 qword_C0BF8;
// C0C28: using guessed type __int64 qword_C0C28;
// C0C30: using guessed type __int64 qword_C0C30;

//----- (000000000008DC10) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_8DC10(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, size_t a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14))(_QWORD, _QWORD)
{
  __int64 *v14; // rbp
  __int64 v15; // rdi
  __int64 *v16; // rbx
  __int64 v17; // rdx
  unsigned __int64 v18; // rcx
  u32 *v19; // r8
  __int64 v20; // r9
  double v21; // xmm4_8
  double v22; // xmm5_8
  __int64 (__fastcall *result)(_QWORD, _QWORD); // rax

  v14 = (__int64 *)qword_C0CB8;
  if ( qword_C0CB8 )
  {
    while ( 1 )
    {
      v15 = v14[2];
      if ( v15 )
        sub_8DC70(v15, a10, a11, a12, a13, a14, a1, a2, a3, a4, a5, a6, a7, a8);
      v16 = (__int64 *)v14[3];
      sub_21B70(*v14, a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14);
      result = sub_21B70((__int64)v14, a1, a2, a3, a4, v21, v22, a7, a8, a10, v17, v18, v19, v20);
      if ( !v16 )
        break;
      v14 = v16;
    }
  }
  return result;
}
// 8DC3C: variable 'a11' is possibly undefined
// 8DC3C: variable 'a12' is possibly undefined
// 8DC3C: variable 'a13' is possibly undefined
// 8DC3C: variable 'a14' is possibly undefined
// 8DC3C: variable 'a5' is possibly undefined
// 8DC3C: variable 'a6' is possibly undefined
// 8DC51: variable 'v21' is possibly undefined
// 8DC51: variable 'v22' is possibly undefined
// 8DC51: variable 'v17' is possibly undefined
// 8DC51: variable 'v18' is possibly undefined
// 8DC51: variable 'v19' is possibly undefined
// 8DC51: variable 'v20' is possibly undefined
// C0CB8: using guessed type __int64 qword_C0CB8;

//----- (000000000008DC70) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_8DC70(__int64 a1, size_t a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14))(_QWORD, _QWORD)
{
  int *v15; // rdi
  unsigned __int64 v16; // rbx
  __int64 *v17; // rdi
  __int64 v18; // rdx
  __int64 *v19; // rbp
  __int64 v20; // rdi
  __int64 v21; // rdx
  unsigned __int64 v22; // rcx
  u32 *v23; // r8
  __int64 v24; // r9
  double v25; // xmm4_8
  double v26; // xmm5_8
  __int64 v27; // rdx
  unsigned __int64 v28; // rcx
  u32 *v29; // r8
  __int64 v30; // r9
  double v31; // xmm4_8
  double v32; // xmm5_8
  __int64 v33; // rdx
  unsigned __int64 v34; // rcx
  u32 *v35; // r8
  __int64 v36; // r9
  double v37; // xmm4_8
  double v38; // xmm5_8

  v15 = *(int **)(a1 + 184);
  if ( v15 != (int *)&unk_BAD60 )
    sub_10E70(v15);
  if ( *(_QWORD *)(a1 + 120) )
  {
    v16 = 0LL;
    do
    {
      v18 = *(_QWORD *)(a1 + 112);
      v19 = (__int64 *)(v18 + 24 * v16);
      sub_21B70(*v19, a7, a8, a9, a10, a11, a12, a13, a14, a2, v18, a4, a5, a6);
      v20 = v19[2];
      if ( (unsigned __int64)(v20 - 1) <= 0xFFFFFFFFFFFFFFFDLL )
        sub_21B70(v20, a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);
      v17 = (__int64 *)v19[1];
      if ( v17 != (__int64 *)-1LL )
        sub_51590(v17, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
      ++v16;
    }
    while ( *(_QWORD *)(a1 + 120) > v16 );
  }
  sub_21B70(*(_QWORD *)(a1 + 112), a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);
  sub_21B70(*(_QWORD *)(a1 + 32), a7, a8, a9, a10, v25, v26, a13, a14, a2, v21, v22, v23, v24);
  if ( *(_DWORD *)(a1 + 8) )
  {
    a2 = *(_QWORD *)(a1 + 16);
    munmap(*(void **)a1, a2);
  }
  else
  {
    sub_21B70(*(_QWORD *)a1, a7, a8, a9, a10, v31, v32, a13, a14, a2, v27, v28, v29, v30);
  }
  return sub_21B70(a1, a7, a8, a9, a10, v37, v38, a13, a14, a2, v33, v34, v35, v36);
}
// 8DCAA: variable 'a3' is possibly undefined
// 8DCAA: variable 'a4' is possibly undefined
// 8DCAA: variable 'a5' is possibly undefined
// 8DCAA: variable 'a6' is possibly undefined
// 8DCAA: variable 'a11' is possibly undefined
// 8DCAA: variable 'a12' is possibly undefined
// 8DD0E: variable 'v25' is possibly undefined
// 8DD0E: variable 'v26' is possibly undefined
// 8DD0E: variable 'v21' is possibly undefined
// 8DD0E: variable 'v22' is possibly undefined
// 8DD0E: variable 'v23' is possibly undefined
// 8DD0E: variable 'v24' is possibly undefined
// 8DD31: variable 'v37' is possibly undefined
// 8DD31: variable 'v38' is possibly undefined
// 8DD31: variable 'v33' is possibly undefined
// 8DD31: variable 'v34' is possibly undefined
// 8DD31: variable 'v35' is possibly undefined
// 8DD31: variable 'v36' is possibly undefined
// 8DD44: variable 'v31' is possibly undefined
// 8DD44: variable 'v32' is possibly undefined
// 8DD44: variable 'v27' is possibly undefined
// 8DD44: variable 'v28' is possibly undefined
// 8DD44: variable 'v29' is possibly undefined
// 8DD44: variable 'v30' is possibly undefined
// 9260: using guessed type __int64 __fastcall sub_9260(_QWORD);

//----- (000000000008DD60) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_8DD60(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14))(_QWORD, _QWORD)
{
  __int64 v14; // rbx
  __int64 (__fastcall *result)(_QWORD, _QWORD); // rax

  v14 = qword_C11B0;
  for ( byte_C11B8 = 1; v14; qword_C11B0 = v14 )
  {
    result = sub_21B70(*(_QWORD *)(v14 + 176), a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14);
    v14 = *(_QWORD *)(v14 + 168);
  }
  return result;
}
// 8DD87: variable 'a5' is possibly undefined
// 8DD87: variable 'a6' is possibly undefined
// 8DD87: variable 'a11' is possibly undefined
// 8DD87: variable 'a12' is possibly undefined
// 8DD87: variable 'a13' is possibly undefined
// 8DD87: variable 'a14' is possibly undefined
// C11B0: using guessed type __int64 qword_C11B0;
// C11B8: using guessed type char byte_C11B8;

//----- (000000000008DDB0) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_8DDB0(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14))(_QWORD, _QWORD)
{
  __int64 v14; // rdx
  __int64 v15; // rbx
  unsigned __int64 v16; // rbp
  _QWORD *v17; // rax
  void (__fastcall *v18)(__int64); // r12
  unsigned __int64 v19; // rcx
  u32 *v20; // r8
  __int64 v21; // r9
  double v22; // xmm4_8
  double v23; // xmm5_8
  __int64 v24; // rdx
  unsigned __int64 v25; // rcx
  u32 *v26; // r8
  __int64 v27; // r9
  double v28; // xmm4_8
  double v29; // xmm5_8

  v14 = *(_QWORD *)(a1 + 16);
  if ( *(_QWORD *)(a1 + 24) )
  {
    v15 = 0LL;
    v16 = 0LL;
    do
    {
      v17 = (_QWORD *)(v14 + v15);
      a12 = *(unsigned int *)(v14 + v15 + 16);
      if ( (int)a12 > 0 )
      {
        if ( *v17 )
        {
          v18 = (void (__fastcall *)(__int64))(__readfsqword(0x30u) ^ __ROR8__(v17[8], 17));
          if ( v18 )
          {
            sub_4F2B0((__int64)v18);
            v18(v15 + *(_QWORD *)(a1 + 16));
            v14 = *(_QWORD *)(a1 + 16);
          }
        }
      }
      ++v16;
      v15 += 104LL;
    }
    while ( *(_QWORD *)(a1 + 24) > v16 );
  }
  if ( v14 )
  {
    sub_21B70(*(_QWORD *)(v14 + 24), a3, a4, a5, a6, a7, a8, a9, a10, a2, v14, a12, a13, a14);
    sub_21B70(
      *(_QWORD *)(*(_QWORD *)(a1 + 16) + 104LL * *(_QWORD *)(a1 + 24) - 72),
      a3,
      a4,
      a5,
      a6,
      v22,
      v23,
      a9,
      a10,
      a2,
      *(_QWORD *)(a1 + 16),
      v19,
      v20,
      v21);
    sub_21B70(*(_QWORD *)(a1 + 16), a3, a4, a5, a6, v28, v29, a9, a10, a2, v24, v25, v26, v27);
  }
  return sub_21B70(a1, a3, a4, a5, a6, a7, a8, a9, a10, a2, v14, a12, a13, a14);
}
// 8DE24: variable 'a7' is possibly undefined
// 8DE24: variable 'a8' is possibly undefined
// 8DE24: variable 'a12' is possibly undefined
// 8DE24: variable 'a13' is possibly undefined
// 8DE24: variable 'a14' is possibly undefined
// 8DE41: variable 'v22' is possibly undefined
// 8DE41: variable 'v23' is possibly undefined
// 8DE41: variable 'v19' is possibly undefined
// 8DE41: variable 'v20' is possibly undefined
// 8DE41: variable 'v21' is possibly undefined
// 8DE4A: variable 'v28' is possibly undefined
// 8DE4A: variable 'v29' is possibly undefined
// 8DE4A: variable 'v24' is possibly undefined
// 8DE4A: variable 'v25' is possibly undefined
// 8DE4A: variable 'v26' is possibly undefined
// 8DE4A: variable 'v27' is possibly undefined
// 8DE5C: variable 'v14' is possibly undefined

//----- (000000000008DE70) ----------------------------------------------------
_BYTE *__fastcall sub_8DE70(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v14; // rbx
  __int64 v15; // rdi
  _BYTE *result; // rax

  v14 = a1;
  if ( *(_QWORD *)(a1 + 32) )
    sub_8DE70();
  if ( *(_QWORD *)(a1 + 48) )
    sub_8DE70();
  do
  {
    while ( 1 )
    {
      v15 = v14;
      v14 = *(_QWORD *)(v14 + 40);
      result = *(_BYTE **)(v15 + 24);
      if ( *result == 47 )
        break;
      if ( !v14 )
        return result;
    }
    result = sub_21B70(v15, a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);
  }
  while ( v14 );
  return result;
}
// 8DEAD: variable 'a11' is possibly undefined
// 8DEAD: variable 'a12' is possibly undefined
// 8DEAD: variable 'a3' is possibly undefined
// 8DEAD: variable 'a4' is possibly undefined
// 8DEAD: variable 'a5' is possibly undefined
// 8DEAD: variable 'a6' is possibly undefined

//----- (000000000008DEC0) ----------------------------------------------------
_BYTE *__fastcall sub_8DEC0(__int64 a1, __int64 (__fastcall *(__fastcall *a2)(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14))(_QWORD, _QWORD), __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  __int64 v14; // rdx
  unsigned __int64 v15; // rcx
  u32 *v16; // r8
  __int64 v17; // r9
  double v18; // xmm4_8
  double v19; // xmm5_8
  _BYTE *result; // rax
  __int64 v21; // rdx
  unsigned __int64 v22; // rcx
  u32 *v23; // r8
  __int64 v24; // r9
  double v25; // xmm4_8
  double v26; // xmm5_8

  sub_8E0A0(a7, a8, a9, a10, a11, a12, a13, a14, a1, (size_t)a2, a3, a4, a5, a6);
  result = sub_8DC10(a7, a8, a9, a10, v18, v19, a13, a14, a1, (size_t)a2, v14, v15, v16, v17);
  if ( qword_C14F8 )
  {
    a2 = sub_21B70;
    result = sub_4C870(
               (_QWORD *)qword_C14F8,
               (double (__fastcall *)(_QWORD))sub_21B70,
               a7,
               a8,
               a9,
               a10,
               v25,
               v26,
               a13,
               a14);
  }
  if ( qword_C14F0 )
    result = sub_8DE70(qword_C14F0, (__int64)a2, v21, v22, v23, v24, a7, a8, a9, a10, v25, v26, a13, a14);
  if ( qword_C1500 )
    result = sub_4C870(
               (_QWORD *)qword_C1500,
               (double (__fastcall *)(_QWORD))sub_8DDB0,
               a7,
               a8,
               a9,
               a10,
               v25,
               v26,
               a13,
               a14);
  return result;
}
// 8DECD: variable 'v18' is possibly undefined
// 8DECD: variable 'v19' is possibly undefined
// 8DECD: variable 'v14' is possibly undefined
// 8DECD: variable 'v15' is possibly undefined
// 8DECD: variable 'v16' is possibly undefined
// 8DECD: variable 'v17' is possibly undefined
// 8DEE5: variable 'v25' is possibly undefined
// 8DEE5: variable 'v26' is possibly undefined
// 8DEF6: variable 'v21' is possibly undefined
// 8DEF6: variable 'v22' is possibly undefined
// 8DEF6: variable 'v23' is possibly undefined
// 8DEF6: variable 'v24' is possibly undefined
// C14F0: using guessed type __int64 qword_C14F0;
// C14F8: using guessed type __int64 qword_C14F8;
// C1500: using guessed type __int64 qword_C1500;

//----- (000000000008DF30) ----------------------------------------------------
void *__fastcall sub_8DF30(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14)
{
  void *result; // rax

  if ( qword_C1518 )
  {
    result = &unk_94A50;
    if ( (_UNKNOWN *)qword_C1518 != &unk_94A50 )
      result = sub_21B70(qword_C1518, a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14);
  }
  return result;
}
// C1518: using guessed type __int64 qword_C1518;

//----- (000000000008DF60) ----------------------------------------------------
unsigned __int64 __fastcall sub_8DF60(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14)
{
  unsigned __int64 result; // rax

  result = (unsigned int)dword_C1528;
  if ( dword_C1528 )
    return (unsigned __int64)sub_21B70(qword_C1538, a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14);
  if ( qword_C1538 )
    result = munmap((void *)qword_C1538, qword_C1530);
  return result;
}
// C1528: using guessed type int dword_C1528;
// C1530: using guessed type __int64 qword_C1530;
// C1538: using guessed type __int64 qword_C1538;

//----- (000000000008DFA0) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_8DFA0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14))(_QWORD, _QWORD)
{
  __int64 v15; // rdi

  v15 = *(_QWORD *)(a1 + 16);
  if ( v15 )
    sub_79F90(v15, a2, a3, a4, (__int64)a5, a6);
  return sub_21B70(a1, a7, a8, a9, a10, a11, a12, a13, a14, a2, a3, a4, a5, a6);
}
// 8DFBA: variable 'a11' is possibly undefined
// 8DFBA: variable 'a12' is possibly undefined
// 8DFBA: variable 'a3' is possibly undefined
// 8DFBA: variable 'a4' is possibly undefined
// 8DFBA: variable 'a5' is possibly undefined
// 8DFBA: variable 'a6' is possibly undefined

//----- (000000000008DFC0) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_8DFC0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8))(_QWORD, _QWORD)
{
  __int64 (__fastcall *result)(_QWORD, _QWORD); // rax

  result = sub_4C870((_QWORD *)qword_C1540, (double (__fastcall *)(_QWORD))sub_8DFA0, a1, a2, a3, a4, a5, a6, a7, a8);
  qword_C1540 = 0LL;
  return result;
}
// C1540: using guessed type __int64 qword_C1540;

//----- (000000000008DFF0) ----------------------------------------------------
__int64 (*__fastcall sub_8DFF0(int a1, size_t a2, void **a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14))(void)
{
  __int64 (*result)(void); // rax
  __int64 *v16; // rbp
  __int64 v17; // rbx
  char *v18; // rdi
  __int64 v19; // rdi
  __int64 *v20; // rbx
  __int64 v21; // rdx
  unsigned __int64 v22; // rcx
  u32 *v23; // r8
  __int64 v24; // r9
  double v25; // xmm4_8
  double v26; // xmm5_8

  result = (__int64 (*)(void))qword_C15A0;
  v16 = (__int64 *)qword_C15A0[a1];
  if ( a3 != (void **)a2 )
  {
    result = (__int64 (*)(void))qword_BDA00;
    if ( qword_BDA00[a1] )
    {
      off_BF8E0[a1] = a3;
      result = *(&off_BD980 + a1);
      if ( result )
        result = (__int64 (*)(void))result();
    }
    v17 = a1 + 16LL;
    v18 = (char *)off_BF8E0[v17];
    if ( v18 != "C" )
    {
      result = (__int64 (*)(void))sub_21B70(
                                    (__int64)v18,
                                    a7,
                                    a8,
                                    a9,
                                    a10,
                                    a11,
                                    a12,
                                    a13,
                                    a14,
                                    a2,
                                    (__int64)a3,
                                    a4,
                                    a5,
                                    a6);
      off_BF8E0[v17] = (void **)"C";
    }
  }
  if ( v16 )
  {
    while ( 1 )
    {
      v19 = v16[2];
      if ( v19 )
      {
        if ( a3 != (void **)v19 )
          sub_5C7A0(v19, a2, (__int64)a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
      }
      v20 = (__int64 *)v16[3];
      sub_21B70(*v16, a7, a8, a9, a10, a11, a12, a13, a14, a2, (__int64)a3, a4, a5, a6);
      result = (__int64 (*)(void))sub_21B70((__int64)v16, a7, a8, a9, a10, v25, v26, a13, a14, a2, v21, v22, v23, v24);
      if ( !v20 )
        break;
      v16 = v20;
    }
  }
  return result;
}
// 8E04F: variable 'a11' is possibly undefined
// 8E04F: variable 'a12' is possibly undefined
// 8E04F: variable 'a3' is possibly undefined
// 8E04F: variable 'a4' is possibly undefined
// 8E04F: variable 'a5' is possibly undefined
// 8E04F: variable 'a6' is possibly undefined
// 8E086: variable 'v25' is possibly undefined
// 8E086: variable 'v26' is possibly undefined
// 8E086: variable 'v21' is possibly undefined
// 8E086: variable 'v22' is possibly undefined
// 8E086: variable 'v23' is possibly undefined
// 8E086: variable 'v24' is possibly undefined
// BD980: using guessed type __int64 (__fastcall *off_BD980)();
// BF8E0: using guessed type void **off_BF8E0[6];

//----- (000000000008E0A0) ----------------------------------------------------
void __fastcall sub_8E0A0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, size_t a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14)
{
  _QWORD *v14; // r12
  __int64 v15; // rbp
  __int64 v16; // rbx
  __int64 v17; // rdx
  unsigned __int64 v18; // rcx
  u32 *v19; // r8
  __int64 v20; // r9
  double v21; // xmm4_8
  double v22; // xmm5_8
  __int64 v23; // rdi
  void (*v24)(void); // rax
  __int64 v25; // rbx
  size_t v26; // rsi
  void *v27; // rdi
  __int64 v28; // rbx
  __int64 v29; // rbp
  size_t v30; // rsi
  __int64 v31; // rdx
  unsigned __int64 v32; // rcx
  u32 *v33; // r8
  __int64 v34; // r9
  double v35; // xmm4_8
  double v36; // xmm5_8

  if ( &dword_0 != (__int64 (**)(void))-2LL )
  {
    a10 = *(_QWORD *)__readfsqword(0xFFFFFFA0);
    sub_8DFF0(0, a10, &off_BAE20, a12, a13, a14, a1, a2, a3, a4, a5, a6, a7, a8);
  }
  if ( &dword_0 != (__int64 (**)(void))-2LL )
  {
    a10 = *(_QWORD *)__readfsqword(0xFFFFFFB8);
    sub_8DFF0(4, a10, &off_BC3E0, a12, a13, a14, a1, a2, a3, a4, a5, a6, a7, a8);
  }
  if ( &dword_0 != (__int64 (**)(void))-2LL )
  {
    a10 = *(_QWORD *)__readfsqword(0xFFFFFFB0);
    sub_8DFF0(1, a10, &off_BC5A0, a12, a13, a14, a1, a2, a3, a4, a5, a6, a7, a8);
  }
  if ( off_BF990 != "C" )
  {
    sub_21B70((__int64)off_BF990, a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14);
    off_BF990 = "C";
  }
  v14 = (_QWORD *)qword_C1620;
  if ( qword_C1620 )
  {
    do
    {
      v15 = (__int64)v14;
      v16 = 0LL;
      v14 = (_QWORD *)*v14;
      sub_21B70(*(_QWORD *)(v15 + 8), a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14);
      while ( 1 )
      {
        if ( v16 != 6 )
        {
          v23 = *(_QWORD *)(v15 + 8 * v16 + 16);
          if ( v23 )
          {
            v24 = *(void (**)(void))(v23 + 32);
            if ( v24 )
            {
              v24();
              v23 = *(_QWORD *)(v15 + 8 * v16 + 16);
            }
            sub_21B70(v23, a1, a2, a3, a4, v21, v22, a7, a8, a10, v17, v18, v19, v20);
          }
          if ( v16 == 12 )
            break;
        }
        ++v16;
      }
      sub_21B70(v15, a1, a2, a3, a4, v21, v22, a7, a8, a10, v17, v18, v19, v20);
    }
    while ( v14 );
  }
  v25 = qword_C16E8;
  qword_C1620 = 0LL;
  if ( qword_C16E8 )
  {
    if ( (__int64 *)qword_C16E8 != &qword_C16D0 )
      sub_CF00(
        (__int64)"archmapped == &headmap",
        (__int64)"loadarchive.c",
        0x216u,
        "_nl_archive_subfreeres",
        a1,
        a2,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8);
    v26 = *(unsigned int *)(qword_C16E8 + 12);
    v27 = *(void **)qword_C16E8;
    qword_C16E8 = 0LL;
    munmap(v27, v26);
    v28 = *(_QWORD *)(v25 + 16);
    while ( v28 )
    {
      v29 = v28;
      v28 = *(_QWORD *)(v28 + 16);
      v30 = *(unsigned int *)(v29 + 12);
      munmap(*(void **)v29, v30);
      sub_21B70(v29, a1, a2, a3, a4, v35, v36, a7, a8, v30, v31, v32, v33, v34);
    }
  }
}
// 8E118: variable 'a12' is possibly undefined
// 8E118: variable 'a13' is possibly undefined
// 8E118: variable 'a14' is possibly undefined
// 8E118: variable 'a5' is possibly undefined
// 8E118: variable 'a6' is possibly undefined
// 8E2A1: variable 'a11' is possibly undefined
// 8E314: variable 'v21' is possibly undefined
// 8E314: variable 'v22' is possibly undefined
// 8E314: variable 'v17' is possibly undefined
// 8E314: variable 'v18' is possibly undefined
// 8E314: variable 'v19' is possibly undefined
// 8E314: variable 'v20' is possibly undefined
// 8E386: variable 'v35' is possibly undefined
// 8E386: variable 'v36' is possibly undefined
// 8E386: variable 'v31' is possibly undefined
// 8E386: variable 'v32' is possibly undefined
// 8E386: variable 'v33' is possibly undefined
// 8E386: variable 'v34' is possibly undefined
// 0: using guessed type __int64 (*dword_0)(void);
// BAE20: using guessed type void *off_BAE20;
// BC3E0: using guessed type void *off_BC3E0;
// BC5A0: using guessed type void *off_BC5A0;
// BF990: using guessed type void *off_BF990;
// C1620: using guessed type __int64 qword_C1620;
// C16D0: using guessed type __int64 qword_C16D0;
// C16E8: using guessed type __int64 qword_C16E8;

//----- (000000000008E3C0) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_8E3C0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14))(_QWORD, _QWORD)
{
  double v14; // xmm4_8
  double v15; // xmm5_8
  __int64 (__fastcall *result)(_QWORD, _QWORD); // rax

  sub_5DD00(a7, a8, a9, a10, a11, a12, a13, a14, a1, a2, a3, a4, a5, a6);
  result = sub_4C870(
             (_QWORD *)qword_C16F8,
             (double (__fastcall *)(_QWORD))sub_21B70,
             a7,
             a8,
             a9,
             a10,
             v14,
             v15,
             a13,
             a14);
  qword_C16F8 = 0LL;
  return result;
}
// 8E3DB: variable 'v14' is possibly undefined
// 8E3DB: variable 'v15' is possibly undefined
// C16F8: using guessed type __int64 qword_C16F8;

//----- (000000000008E3F0) ----------------------------------------------------
__int64 __fastcall sub_8E3F0(unsigned __int64 **a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  unsigned int v10; // er12
  unsigned __int64 *v12; // rdi
  __int64 v13; // rdx
  u32 *v14; // r8
  __int64 v15; // r9
  double v16; // xmm4_8
  double v17; // xmm5_8
  __int64 v18; // rdi
  unsigned __int64 v19; // rcx
  __int64 v20; // rax

  v10 = 1;
  v12 = *a1;
  if ( !v12 )
    return v10;
  v10 = sub_8E3F0(v12 + 1);
  if ( !(_BYTE)v10 )
    return v10;
  v18 = (__int64)*a1;
  v19 = **a1;
  if ( v19 )
  {
    v20 = 0LL;
    do
    {
      v13 = 16 * v20;
      if ( *(_QWORD *)(v18 + 16 * v20 + 24) )
        return 0;
    }
    while ( ++v20 != v19 );
  }
  sub_21B70(v18, a3, a4, a5, a6, v16, v17, a9, a10, a2, v13, v19, v14, v15);
  *a1 = 0LL;
  return v10;
}
// 8E460: variable 'v16' is possibly undefined
// 8E460: variable 'v17' is possibly undefined
// 8E460: variable 'v13' is possibly undefined
// 8E460: variable 'v14' is possibly undefined
// 8E460: variable 'v15' is possibly undefined

//----- (000000000008E480) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_8E480(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14))(_QWORD, _QWORD)
{
  _QWORD *v14; // rbx
  __int64 v15; // rdi
  _QWORD *v16; // rbp
  __int64 v17; // rax
  __int64 v18; // rbx
  __int64 v19; // rdi
  __int64 v20; // rdi
  __int64 v21; // rdx
  unsigned __int64 v22; // rcx
  u32 *v23; // r8
  __int64 v24; // r9
  double v25; // xmm4_8
  double v26; // xmm5_8
  unsigned __int64 v28; // rcx
  void **v29; // rdx
  __int64 v30; // rdi

  v14 = (_QWORD *)qword_C1320;
  if ( qword_C1320 != qword_C1318 )
  {
    do
    {
      v15 = (__int64)v14;
      v14 = (_QWORD *)*v14;
      sub_21B70(v15, a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14);
    }
    while ( (_QWORD *)qword_C1318 != v14 );
  }
  if ( qword_BF088 )
  {
    v16 = off_BF0E0;
    if ( off_BF0E0 )
    {
      do
      {
        v17 = v16[7];
        v18 = *(_QWORD *)(v17 + 8);
        *(_QWORD *)(v17 + 8) = 0LL;
        while ( v18 )
        {
          while ( 1 )
          {
            v19 = v18;
            v18 = *(_QWORD *)(v18 + 8);
            a11 = *(unsigned int *)(v19 + 16);
            if ( (_DWORD)a11 )
              break;
            sub_21B70(v19, a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14);
            if ( !v18 )
              goto LABEL_9;
          }
        }
LABEL_9:
        if ( (*((_BYTE *)v16 + 798) & 1) != 0 )
          sub_21B70(v16[121], a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14);
        v16[121] = 0LL;
        v16 = (_QWORD *)v16[3];
      }
      while ( v16 );
    }
    if ( dword_BF0F8 )
    {
      v28 = (unsigned int)dword_BF0B8;
      if ( *((_DWORD *)off_BF0F0 + 2) == dword_BF0B8 )
      {
        v29 = off_BF0B0;
        v30 = (__int64)*off_BF0F0;
        *off_BF0F0 = off_BF0B0;
        dword_BF0F8 = 0;
        sub_21B70(v30, a1, a2, a3, a4, a5, a6, a7, a8, a10, (__int64)v29, v28, a13, a14);
      }
    }
  }
  sub_8E3F0((unsigned __int64 **)(qword_C0378 + 8), a10, a1, a2, a3, a4, a5, a6, a7, a8);
  v20 = qword_C12D8;
  qword_C12D8 = 0LL;
  return sub_21B70(v20, a1, a2, a3, a4, v25, v26, a7, a8, a10, v21, v22, v23, v24);
}
// 8E4A6: variable 'a5' is possibly undefined
// 8E4A6: variable 'a6' is possibly undefined
// 8E4A6: variable 'a11' is possibly undefined
// 8E4A6: variable 'a12' is possibly undefined
// 8E4A6: variable 'a13' is possibly undefined
// 8E4A6: variable 'a14' is possibly undefined
// 8E54C: variable 'v25' is possibly undefined
// 8E54C: variable 'v26' is possibly undefined
// 8E54C: variable 'v21' is possibly undefined
// 8E54C: variable 'v22' is possibly undefined
// 8E54C: variable 'v23' is possibly undefined
// 8E54C: variable 'v24' is possibly undefined
// BF088: using guessed type __int64 qword_BF088;
// BF0B0: using guessed type void **off_BF0B0;
// BF0B8: using guessed type int dword_BF0B8;
// BF0E0: using guessed type void *off_BF0E0;
// BF0F0: using guessed type void ***off_BF0F0;
// BF0F8: using guessed type int dword_BF0F8;
// C0378: using guessed type __int64 qword_C0378;
// C12D8: using guessed type __int64 qword_C12D8;
// C1318: using guessed type __int64 qword_C1318;
// C1320: using guessed type __int64 qword_C1320;

//----- (000000000008E5A0) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_8E5A0(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, unsigned __int64 a12, u32 *a13, __int64 a14))(_QWORD, _QWORD)
{
  __int64 v14; // rdi
  __int64 i; // rbp
  _QWORD *v16; // rbx
  __int64 v17; // rdi
  __int64 (__fastcall *result)(_QWORD, _QWORD); // rax

  v14 = qword_C1798;
  if ( qword_C1798 )
  {
    for ( i = 0LL; i != 2040; i += 8LL )
    {
      v16 = *(_QWORD **)(v14 + i);
      if ( v16 )
      {
        do
        {
          v17 = (__int64)v16;
          v16 = (_QWORD *)*v16;
          sub_21B70(v17, a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14);
        }
        while ( v16 );
        v14 = qword_C1798;
      }
    }
    result = sub_21B70(v14, a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14);
  }
  return result;
}
// 8E5D6: variable 'a5' is possibly undefined
// 8E5D6: variable 'a6' is possibly undefined
// 8E5D6: variable 'a11' is possibly undefined
// 8E5D6: variable 'a12' is possibly undefined
// 8E5D6: variable 'a13' is possibly undefined
// 8E5D6: variable 'a14' is possibly undefined
// C1798: using guessed type __int64 qword_C1798;

//----- (000000000008E600) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=857 queued=809 decompiled=809 lumina nreq=0 worse=0 better=0
#error "There were 2 decompilation failure(s) on 809 function(s)"
